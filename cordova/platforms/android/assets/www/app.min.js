var tutao = typeof tutao != 'undefined' ? tutao : {};

tutao.global = this;

/**
 * Adapted from goog.exportPath_
 * 
 * Builds an object structure for the provided namespace path,
 * ensuring that names that already exist are not overwritten. For
 * example:
 * "a.b.c" -> a = {};a.b={};a.b.c={};
 * @param {string} name name of the object that this file defines.
 */
tutao.provide = function(name) {
    var parts = name.split('.');
    var cur = tutao.global;

    // Internet Explorer exhibits strange behavior when throwing errors from
    // methods externed in this manner.  See the testExportSymbolExceptions in
    // base_test.html for an example.
    if (!(parts[0] in cur) && cur.execScript) {
        cur.execScript('var ' + parts[0]);
    }

    // Certain browsers cannot parse code in the form for((a in b); c;);
    // This pattern is produced by the JSCompiler when it collapses the
    // statement above into the conditional loop below. To prevent this from
    // happening, use a for-loop and reserve the init logic as below.

    // Parentheses added to eliminate strict JS warning in Firefox.
    for (var part; parts.length && (part = parts.shift());) {
        if (cur[part]) {
            cur = cur[part];
        } else {
            cur = cur[part] = {};
        }
    }
};

if (!Object.create) {
    Object.create = function(proto, props) {
        if (typeof props !== "undefined") {
            throw "The multiple-argument version of Object.create is not provided by this browser and cannot be shimmed.";
        }
        function F() { }
        F.prototype = proto;
        return new F();
    };
}
/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0
 * LastModified: Dec 25 1999
 * This library is free.  You can redistribute it and/or modify it.
 */

/*
 * Interfaces:
 * b64 = base64encode(data);
 * data = base64decode(b64);
 */

(function() {

    var base64EncodeChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var base64DecodeChars = new Array(
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
        -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
        -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1);

    function base64encode(str) {
        var out, i, len;
        var c1, c2, c3;

        len = str.length;
        i = 0;
        out = "";
        while(i < len) {
            c1 = str.charCodeAt(i++) & 0xff;
            if(i == len)
            {
                out += base64EncodeChars.charAt(c1 >> 2);
                out += base64EncodeChars.charAt((c1 & 0x3) << 4);
                out += "==";
                break;
            }
            c2 = str.charCodeAt(i++);
            if(i == len)
            {
                out += base64EncodeChars.charAt(c1 >> 2);
                out += base64EncodeChars.charAt(((c1 & 0x3)<< 4) | ((c2 & 0xF0) >> 4));
                out += base64EncodeChars.charAt((c2 & 0xF) << 2);
                out += "=";
                break;
            }
            c3 = str.charCodeAt(i++);
            out += base64EncodeChars.charAt(c1 >> 2);
            out += base64EncodeChars.charAt(((c1 & 0x3)<< 4) | ((c2 & 0xF0) >> 4));
            out += base64EncodeChars.charAt(((c2 & 0xF) << 2) | ((c3 & 0xC0) >>6));
            out += base64EncodeChars.charAt(c3 & 0x3F);
        }
        return out;
    }

    function base64decode(str) {
        var c1, c2, c3, c4;
        var i, len, out;

        len = str.length;
        i = 0;
        out = "";
        while(i < len) {
            /* c1 */
            do {
                c1 = base64DecodeChars[str.charCodeAt(i++) & 0xff];
            } while(i < len && c1 == -1);
            if(c1 == -1)
                break;

            /* c2 */
            do {
                c2 = base64DecodeChars[str.charCodeAt(i++) & 0xff];
            } while(i < len && c2 == -1);
            if(c2 == -1)
                break;

            out += String.fromCharCode((c1 << 2) | ((c2 & 0x30) >> 4));

            /* c3 */
            do {
                c3 = str.charCodeAt(i++) & 0xff;
                if(c3 == 61)
                    return out;
                c3 = base64DecodeChars[c3];
            } while(i < len && c3 == -1);
            if(c3 == -1)
                break;

            out += String.fromCharCode(((c2 & 0XF) << 4) | ((c3 & 0x3C) >> 2));

            /* c4 */
            do {
                c4 = str.charCodeAt(i++) & 0xff;
                if(c4 == 61)
                    return out;
                c4 = base64DecodeChars[c4];
            } while(i < len && c4 == -1);
            if(c4 == -1)
                break;
            out += String.fromCharCode(((c3 & 0x03) << 6) | c4);
        }
        return out;
    }

    if (typeof btoa == 'undefined') btoa = base64encode;
    if (typeof atob == 'undefined') atob = base64decode;

})();
// Copyright (c) 2005  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.

// Basic JavaScript BN library - subset useful for RSA encryption.

// Bits per digit
var dbits;

// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary&0xffffff)==0xefcafe);

// (public) Constructor
// tutao: a = bitlength (1024)
//        b = number of miller rabin test * 2
//        c = SecureRandom
function BigInteger(a,b,c) {
  if(a != null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null && "string" != typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}

// return new, unset BigInteger
function nbi() { return new BigInteger(null); }

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i,x,w,j,c,n) {
  while(--n >= 0) {
    var v = x*this[i++]+w[j]+c;
    c = Math.floor(v/0x4000000);
    w[j++] = v&0x3ffffff;
  }
  return c;
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i,x,w,j,c,n) {
  var xl = x&0x7fff, xh = x>>15;
  while(--n >= 0) {
    var l = this[i]&0x7fff;
    var h = this[i++]>>15;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
    w[j++] = l&0x3fffffff;
  }
  return c;
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i,x,w,j,c,n) {
  var xl = x&0x3fff, xh = x>>14;
  while(--n >= 0) {
    var l = this[i]&0x3fff;
    var h = this[i++]>>14;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x3fff)<<14)+w[j]+c;
    c = (l>>28)+(m>>14)+xh*h;
    w[j++] = l&0xfffffff;
  }
  return c;
}
if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
  BigInteger.prototype.am = am2;
  dbits = 30;
}
else if(j_lm && (navigator.appName != "Netscape")) {
  BigInteger.prototype.am = am1;
  dbits = 26;
}
else { // Mozilla/Netscape seems to prefer am3
  BigInteger.prototype.am = am3;
  dbits = 28;
}

BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1<<dbits)-1);
BigInteger.prototype.DV = (1<<dbits);

var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2,BI_FP);
BigInteger.prototype.F1 = BI_FP-dbits;
BigInteger.prototype.F2 = 2*dbits-BI_FP;

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr,vv;
rr = "0".charCodeAt(0);
for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

function int2char(n) { return BI_RM.charAt(n); }
function intAt(s,i) {
  var c = BI_RC[s.charCodeAt(i)];
  return (c==null)?-1:c;
}

// (protected) copy this to r
function bnpCopyTo(r) {
  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
  r.t = this.t;
  r.s = this.s;
}

// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x) {
  this.t = 1;
  this.s = (x<0)?-1:0;
  if(x > 0) this[0] = x;
  else if(x < -1) this[0] = x+DV;
  else this.t = 0;
}

// return bigint initialized to value
function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

// (protected) set from string and radix
function bnpFromString(s,b) {
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 256) k = 8; // byte array
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else { this.fromRadix(s,b); return; }
  this.t = 0;
  this.s = 0;
  var i = s.length, mi = false, sh = 0;
  while(--i >= 0) {
    var x = (k==8)?s[i]&0xff:intAt(s,i);
    if(x < 0) {
      if(s.charAt(i) == "-") mi = true;
      continue;
    }
    mi = false;
    if(sh == 0)
      this[this.t++] = x;
    else if(sh+k > this.DB) {
      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
      this[this.t++] = (x>>(this.DB-sh));
    }
    else
      this[this.t-1] |= x<<sh;
    sh += k;
    if(sh >= this.DB) sh -= this.DB;
  }
  if(k == 8 && (s[0]&0x80) != 0) {
    this.s = -1;
    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
  }
  this.clamp();
  if(mi) BigInteger.ZERO.subTo(this,this);
}

// (protected) clamp off excess high words
function bnpClamp() {
  var c = this.s&this.DM;
  while(this.t > 0 && this[this.t-1] == c) --this.t;
}

// (public) return string representation in given radix
function bnToString(b) {
  if(this.s < 0) return "-"+this.negate().toString(b);
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else return this.toRadix(b);
  var km = (1<<k)-1, d, m = false, r = "", i = this.t;
  var p = this.DB-(i*this.DB)%k;
  if(i-- > 0) {
    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
    while(i >= 0) {
      if(p < k) {
        d = (this[i]&((1<<p)-1))<<(k-p);
        d |= this[--i]>>(p+=this.DB-k);
      }
      else {
        d = (this[i]>>(p-=k))&km;
        if(p <= 0) { p += this.DB; --i; }
      }
      if(d > 0) m = true;
      if(m) r += int2char(d);
    }
  }
  return m?r:"0";
}

// (public) -this
function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

// (public) |this|
function bnAbs() { return (this.s<0)?this.negate():this; }

// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a) {
  var r = this.s-a.s;
  if(r != 0) return r;
  var i = this.t;
  r = i-a.t;
  if(r != 0) return (this.s<0)?-r:r;
  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
  return 0;
}

// returns bit length of the integer x
function nbits(x) {
  var r = 1, t;
  if((t=x>>>16) != 0) { x = t; r += 16; }
  if((t=x>>8) != 0) { x = t; r += 8; }
  if((t=x>>4) != 0) { x = t; r += 4; }
  if((t=x>>2) != 0) { x = t; r += 2; }
  if((t=x>>1) != 0) { x = t; r += 1; }
  return r;
}

// (public) return the number of bits in "this"
function bnBitLength() {
  if(this.t <= 0) return 0;
  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
}

// (protected) r = this << n*DB
function bnpDLShiftTo(n,r) {
  var i;
  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
  for(i = n-1; i >= 0; --i) r[i] = 0;
  r.t = this.t+n;
  r.s = this.s;
}

// (protected) r = this >> n*DB
function bnpDRShiftTo(n,r) {
  for(var i = n; i < this.t; ++i) r[i-n] = this[i];
  r.t = Math.max(this.t-n,0);
  r.s = this.s;
}

// (protected) r = this << n
function bnpLShiftTo(n,r) {
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1<<cbs)-1;
  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
  for(i = this.t-1; i >= 0; --i) {
    r[i+ds+1] = (this[i]>>cbs)|c;
    c = (this[i]&bm)<<bs;
  }
  for(i = ds-1; i >= 0; --i) r[i] = 0;
  r[ds] = c;
  r.t = this.t+ds+1;
  r.s = this.s;
  r.clamp();
}

// (protected) r = this >> n
function bnpRShiftTo(n,r) {
  r.s = this.s;
  var ds = Math.floor(n/this.DB);
  if(ds >= this.t) { r.t = 0; return; }
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1<<bs)-1;
  r[0] = this[ds]>>bs;
  for(var i = ds+1; i < this.t; ++i) {
    r[i-ds-1] |= (this[i]&bm)<<cbs;
    r[i-ds] = this[i]>>bs;
  }
  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
  r.t = this.t-ds;
  r.clamp();
}

// (protected) r = this - a
function bnpSubTo(a,r) {
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i < m) {
    c += this[i]-a[i];
    r[i++] = c&this.DM;
    c >>= this.DB;
  }
  if(a.t < this.t) {
    c -= a.s;
    while(i < this.t) {
      c += this[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c += this.s;
  }
  else {
    c += this.s;
    while(i < a.t) {
      c -= a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c -= a.s;
  }
  r.s = (c<0)?-1:0;
  if(c < -1) r[i++] = this.DV+c;
  else if(c > 0) r[i++] = c;
  r.t = i;
  r.clamp();
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a,r) {
  var x = this.abs(), y = a.abs();
  var i = x.t;
  r.t = i+y.t;
  while(--i >= 0) r[i] = 0;
  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
  r.s = 0;
  r.clamp();
  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
  var x = this.abs();
  var i = r.t = 2*x.t;
  while(--i >= 0) r[i] = 0;
  for(i = 0; i < x.t-1; ++i) {
    var c = x.am(i,x[i],r,2*i,0,1);
    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
      r[i+x.t] -= x.DV;
      r[i+x.t+1] = 1;
    }
  }
  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
  r.s = 0;
  r.clamp();
}

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m,q,r) {
  var pm = m.abs();
  if(pm.t <= 0) return;
  var pt = this.abs();
  if(pt.t < pm.t) {
    if(q != null) q.fromInt(0);
    if(r != null) this.copyTo(r);
    return;
  }
  if(r == null) r = nbi();
  var y = nbi(), ts = this.s, ms = m.s;
  var nsh = this.DB-nbits(pm[pm.t-1]);	// normalize modulus
  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
  else { pm.copyTo(y); pt.copyTo(r); }
  var ys = y.t;
  var y0 = y[ys-1];
  if(y0 == 0) return;
  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
  var i = r.t, j = i-ys, t = (q==null)?nbi():q;
  y.dlShiftTo(j,t);
  if(r.compareTo(t) >= 0) {
    r[r.t++] = 1;
    r.subTo(t,r);
  }
  BigInteger.ONE.dlShiftTo(ys,t);
  t.subTo(y,y);	// "negative" y so we can replace sub with am later
  while(y.t < ys) y[y.t++] = 0;
  while(--j >= 0) {
    // Estimate quotient digit
    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out
      y.dlShiftTo(j,t);
      r.subTo(t,r);
      while(r[i] < --qd) r.subTo(t,r);
    }
  }
  if(q != null) {
    r.drShiftTo(ys,q);
    if(ts != ms) BigInteger.ZERO.subTo(q,q);
  }
  r.t = ys;
  r.clamp();
  if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder
  if(ts < 0) BigInteger.ZERO.subTo(r,r);
}

// (public) this mod a
function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a,null,r);
  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
  return r;
}

// Modular reduction using "classic" algorithm
function Classic(m) { this.m = m; }
function cConvert(x) {
  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
  else return x;
}
function cRevert(x) { return x; }
function cReduce(x) { x.divRemTo(this.m,null,x); }
function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit() {
  if(this.t < 1) return 0;
  var x = this[0];
  if((x&1) == 0) return 0;
  var y = x&3;		// y == 1/x mod 2^2
  y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4
  y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8
  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16
  // last step - calculate inverse mod DV directly;
  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
  y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
  // we really want the negative inverse, and -DV < y < DV
  return (y>0)?this.DV-y:-y;
}

// Montgomery reduction
function Montgomery(m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp&0x7fff;
  this.mph = this.mp>>15;
  this.um = (1<<(m.DB-15))-1;
  this.mt2 = 2*m.t;
}

// xR mod m
function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t,r);
  r.divRemTo(this.m,null,r);
  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
  return r;
}

// x/R mod m
function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
}

// x = x/R mod m (HAC 14.32)
function montReduce(x) {
  while(x.t <= this.mt2)	// pad x so am has enough room later
    x[x.t++] = 0;
  for(var i = 0; i < this.m.t; ++i) {
    // faster way of calculating u0 = x[i]*mp mod DV
    var j = x[i]&0x7fff;
    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
    // use am to combine the multiply-shift-add into one call
    j = i+this.m.t;
    x[j] += this.m.am(0,u0,x,i,0,this.m.t);
    // propagate carry
    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
  }
  x.clamp();
  x.drShiftTo(this.m.t,x);
  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
}

// r = "x^2/R mod m"; x != r
function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

// r = "xy/R mod m"; x,y != r
function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;

// (protected) true iff this is even
function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e,z) {
  if(e > 0xffffffff || e < 1) return BigInteger.ONE;
  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
  g.copyTo(r);
  while(--i >= 0) {
    z.sqrTo(r,r2);
    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
    else { var t = r; r = r2; r2 = t; }
  }
  return z.revert(r);
}

// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e,m) {
  var z;
  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
  return this.exp(e,z);
}

// protected
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;

// public
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;

// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

// Copyright (c) 2005-2009  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.

// Extended JavaScript BN functions, required for RSA private ops.

// Version 1.1: new BigInteger("0", 10) returns "proper" zero
// Version 1.2: square() API, isProbablePrime fix

// (public)
function bnClone() { var r = nbi(); this.copyTo(r); return r; }

// (public) return value as integer
function bnIntValue() {
  if(this.s < 0) {
    if(this.t == 1) return this[0]-this.DV;
    else if(this.t == 0) return -1;
  }
  else if(this.t == 1) return this[0];
  else if(this.t == 0) return 0;
  // assumes 16 < DB < 32
  return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
}

// (public) return value as byte
function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }

// (public) return value as short (assumes DB>=16)
function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }

// (protected) return x s.t. r^x < DV
function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

// (public) 0 if this == 0, 1 if this > 0
function bnSigNum() {
  if(this.s < 0) return -1;
  else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
  else return 1;
}

// (protected) convert to radix string
function bnpToRadix(b) {
  if(b == null) b = 10;
  if(this.signum() == 0 || b < 2 || b > 36) return "0";
  var cs = this.chunkSize(b);
  var a = Math.pow(b,cs);
  var d = nbv(a), y = nbi(), z = nbi(), r = "";
  this.divRemTo(d,y,z);
  while(y.signum() > 0) {
    r = (a+z.intValue()).toString(b).substr(1) + r;
    y.divRemTo(d,y,z);
  }
  return z.intValue().toString(b) + r;
}

// (protected) convert from radix string
function bnpFromRadix(s,b) {
  this.fromInt(0);
  if(b == null) b = 10;
  var cs = this.chunkSize(b);
  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
  for(var i = 0; i < s.length; ++i) {
    var x = intAt(s,i);
    if(x < 0) {
      if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
      continue;
    }
    w = b*w+x;
    if(++j >= cs) {
      this.dMultiply(d);
      this.dAddOffset(w,0);
      j = 0;
      w = 0;
    }
  }
  if(j > 0) {
    this.dMultiply(Math.pow(b,j));
    this.dAddOffset(w,0);
  }
  if(mi) BigInteger.ZERO.subTo(this,this);
}

// (protected) alternate constructor
// tutao: on first invocation:
//        a = bitlength (1024)
//        b = number of miller rabin test * 2
//        c = SecureRandom
//       on second invocation:
//        a = bitlength (1024)
//        b = SecureRandom
//        c == undefined
function bnpFromNumber(a,b,c) {
  if("number" == typeof b) {
    // new BigInteger(int,int,RNG)
    if(a < 2) this.fromInt(1);
    else {
      this.fromNumber(a,c);
      if(!this.testBit(a-1))	// force MSB set
        this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
      if(this.isEven()) this.dAddOffset(1,0); // force odd
      while(!this.isProbablePrime(b)) {
        this.dAddOffset(2,0);
        if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
      }
    }
  }
  else {
    // new BigInteger(int,RNG)
    var x = new Array(), t = a&7;
    x.length = (a>>3)+1;
    b.nextBytes(x);
    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
    this.fromString(x,256);
  }
}

// (public) convert to bigendian byte array
function bnToByteArray() {
  var i = this.t, r = new Array();
  r[0] = this.s;
  var p = this.DB-(i*this.DB)%8, d, k = 0;
  if(i-- > 0) {
    if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
      r[k++] = d|(this.s<<(this.DB-p));
    while(i >= 0) {
      if(p < 8) {
        d = (this[i]&((1<<p)-1))<<(8-p);
        d |= this[--i]>>(p+=this.DB-8);
      }
      else {
        d = (this[i]>>(p-=8))&0xff;
        if(p <= 0) { p += this.DB; --i; }
      }
      if((d&0x80) != 0) d |= -256;
      if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
      if(k > 0 || d != this.s) r[k++] = d;
    }
  }
  return r;
}

function bnEquals(a) { return(this.compareTo(a)==0); }
function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
function bnMax(a) { return(this.compareTo(a)>0)?this:a; }

// (protected) r = this op a (bitwise)
function bnpBitwiseTo(a,op,r) {
  var i, f, m = Math.min(a.t,this.t);
  for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
  if(a.t < this.t) {
    f = a.s&this.DM;
    for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
    r.t = this.t;
  }
  else {
    f = this.s&this.DM;
    for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
    r.t = a.t;
  }
  r.s = op(this.s,a.s);
  r.clamp();
}

// (public) this & a
function op_and(x,y) { return x&y; }
function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

// (public) this | a
function op_or(x,y) { return x|y; }
function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

// (public) this ^ a
function op_xor(x,y) { return x^y; }
function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

// (public) this & ~a
function op_andnot(x,y) { return x&~y; }
function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

// (public) ~this
function bnNot() {
  var r = nbi();
  for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
  r.t = this.t;
  r.s = ~this.s;
  return r;
}

// (public) this << n
function bnShiftLeft(n) {
  var r = nbi();
  if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
  return r;
}

// (public) this >> n
function bnShiftRight(n) {
  var r = nbi();
  if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
  return r;
}

// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
  if(x == 0) return -1;
  var r = 0;
  if((x&0xffff) == 0) { x >>= 16; r += 16; }
  if((x&0xff) == 0) { x >>= 8; r += 8; }
  if((x&0xf) == 0) { x >>= 4; r += 4; }
  if((x&3) == 0) { x >>= 2; r += 2; }
  if((x&1) == 0) ++r;
  return r;
}

// (public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit() {
  for(var i = 0; i < this.t; ++i)
    if(this[i] != 0) return i*this.DB+lbit(this[i]);
  if(this.s < 0) return this.t*this.DB;
  return -1;
}

// return number of 1 bits in x
function cbit(x) {
  var r = 0;
  while(x != 0) { x &= x-1; ++r; }
  return r;
}

// (public) return number of set bits
function bnBitCount() {
  var r = 0, x = this.s&this.DM;
  for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
  return r;
}

// (public) true iff nth bit is set
function bnTestBit(n) {
  var j = Math.floor(n/this.DB);
  if(j >= this.t) return(this.s!=0);
  return((this[j]&(1<<(n%this.DB)))!=0);
}

// (protected) this op (1<<n)
function bnpChangeBit(n,op) {
  var r = BigInteger.ONE.shiftLeft(n);
  this.bitwiseTo(r,op,r);
  return r;
}

// (public) this | (1<<n)
function bnSetBit(n) { return this.changeBit(n,op_or); }

// (public) this & ~(1<<n)
function bnClearBit(n) { return this.changeBit(n,op_andnot); }

// (public) this ^ (1<<n)
function bnFlipBit(n) { return this.changeBit(n,op_xor); }

// (protected) r = this + a
function bnpAddTo(a,r) {
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i < m) {
    c += this[i]+a[i];
    r[i++] = c&this.DM;
    c >>= this.DB;
  }
  if(a.t < this.t) {
    c += a.s;
    while(i < this.t) {
      c += this[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c += this.s;
  }
  else {
    c += this.s;
    while(i < a.t) {
      c += a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    c += a.s;
  }
  r.s = (c<0)?-1:0;
  if(c > 0) r[i++] = c;
  else if(c < -1) r[i++] = this.DV+c;
  r.t = i;
  r.clamp();
}

// (public) this + a
function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

// (public) this - a
function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

// (public) this * a
function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

// (public) this^2
function bnSquare() { var r = nbi(); this.squareTo(r); return r; }

// (public) this / a
function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

// (public) this % a
function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

// (public) [this/a,this%a]
function bnDivideAndRemainder(a) {
  var q = nbi(), r = nbi();
  this.divRemTo(a,q,r);
  return new Array(q,r);
}

// (protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n) {
  this[this.t] = this.am(0,n-1,this,0,0,this.t);
  ++this.t;
  this.clamp();
}

// (protected) this += n << w words, this >= 0
function bnpDAddOffset(n,w) {
  if(n == 0) return;
  while(this.t <= w) this[this.t++] = 0;
  this[w] += n;
  while(this[w] >= this.DV) {
    this[w] -= this.DV;
    if(++w >= this.t) this[this.t++] = 0;
    ++this[w];
  }
}

// A "null" reducer
function NullExp() {}
function nNop(x) { return x; }
function nMulTo(x,y,r) { x.multiplyTo(y,r); }
function nSqrTo(x,r) { x.squareTo(r); }

NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;

// (public) this^e
function bnPow(e) { return this.exp(e,new NullExp()); }

// (protected) r = lower n words of "this * a", a.t <= n
// "this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a,n,r) {
  var i = Math.min(this.t+a.t,n);
  r.s = 0; // assumes a,this >= 0
  r.t = i;
  while(i > 0) r[--i] = 0;
  var j;
  for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
  for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
  r.clamp();
}

// (protected) r = "this * a" without lower n words, n > 0
// "this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a,n,r) {
  --n;
  var i = r.t = this.t+a.t-n;
  r.s = 0; // assumes a,this >= 0
  while(--i >= 0) r[i] = 0;
  for(i = Math.max(n-this.t,0); i < a.t; ++i)
    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
  r.clamp();
  r.drShiftTo(1,r);
}

// Barrett modular reduction
function Barrett(m) {
  // setup Barrett
  this.r2 = nbi();
  this.q3 = nbi();
  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
  this.mu = this.r2.divide(m);
  this.m = m;
}

function barrettConvert(x) {
  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
  else if(x.compareTo(this.m) < 0) return x;
  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
}

function barrettRevert(x) { return x; }

// x = x mod m (HAC 14.42)
function barrettReduce(x) {
  x.drShiftTo(this.m.t-1,this.r2);
  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
  x.subTo(this.r2,x);
  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
}

// r = x^2 mod m; x != r
function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

// r = x*y mod m; x,y != r
function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;

// (public) this^e % m (HAC 14.85)
function bnModPow(e,m) {
	// we switched to leemons bigint lib for modpow, as this is faster on safari browsers (reduced the decryption times: 9s -> 3,4s)
	// TODO introduce switch for other browsers, as they are slower (by factor 0.5) because of the conversion overhead
	var xHex = this.toString(16);
	var eHex = e.toString(16);
	var mHex = m.toString(16);
	var result = powMod(str2bigInt(xHex,16),str2bigInt(eHex,16),str2bigInt(mHex,16));
	return new BigInteger(bigInt2str(result,16),16);
//  var i = e.bitLength(), k, r = nbv(1), z;
//  if(i <= 0) return r;
//  else if(i < 18) k = 1;
//  else if(i < 48) k = 3;
//  else if(i < 144) k = 4;
//  else if(i < 768) k = 5;
//  else k = 6;
//  if(i < 8)
//    z = new Classic(m);
//  else if(m.isEven())
//    z = new Barrett(m);
//  else
//    z = new Montgomery(m);
//
//  // precomputation
//  var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
//  g[1] = z.convert(this);
//  if(k > 1) {
//    var g2 = nbi();
//    z.sqrTo(g[1],g2);
//    while(n <= km) {
//      g[n] = nbi();
//      z.mulTo(g2,g[n-2],g[n]);
//      n += 2;
//    }
//  }
//
//  var j = e.t-1, w, is1 = true, r2 = nbi(), t;
//  i = nbits(e[j])-1;
//  while(j >= 0) {
//    if(i >= k1) w = (e[j]>>(i-k1))&km;
//    else {
//      w = (e[j]&((1<<(i+1))-1))<<(k1-i);
//      if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
//    }
//
//    n = k;
//    while((w&1) == 0) { w >>= 1; --n; }
//    if((i -= n) < 0) { i += this.DB; --j; }
//    if(is1) {	// ret == 1, don't bother squaring or multiplying it
//      g[w].copyTo(r);
//      is1 = false;
//    }
//    else {
//      while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
//      if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
//      z.mulTo(r2,g[w],r);
//    }
//
//    while(j >= 0 && (e[j]&(1<<i)) == 0) {
//      z.sqrTo(r,r2); t = r; r = r2; r2 = t;
//      if(--i < 0) { i = this.DB-1; --j; }
//    }
//  }
//  return z.revert(r);
}

// (public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
  var x = (this.s<0)?this.negate():this.clone();
  var y = (a.s<0)?a.negate():a.clone();
  if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
  var i = x.getLowestSetBit(), g = y.getLowestSetBit();
  if(g < 0) return x;
  if(i < g) g = i;
  if(g > 0) {
    x.rShiftTo(g,x);
    y.rShiftTo(g,y);
  }
  while(x.signum() > 0) {
    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
    if(x.compareTo(y) >= 0) {
      x.subTo(y,x);
      x.rShiftTo(1,x);
    }
    else {
      y.subTo(x,y);
      y.rShiftTo(1,y);
    }
  }
  if(g > 0) y.lShiftTo(g,y);
  return y;
}

// (protected) this % n, n < 2^26
function bnpModInt(n) {
  if(n <= 0) return 0;
  var d = this.DV%n, r = (this.s<0)?n-1:0;
  if(this.t > 0)
    if(d == 0) r = this[0]%n;
    else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
  return r;
}

// (public) 1/this % m (HAC 14.61)
function bnModInverse(m) {
  var ac = m.isEven();
  if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
  var u = m.clone(), v = this.clone();
  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
  while(u.signum() != 0) {
    while(u.isEven()) {
      u.rShiftTo(1,u);
      if(ac) {
        if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
        a.rShiftTo(1,a);
      }
      else if(!b.isEven()) b.subTo(m,b);
      b.rShiftTo(1,b);
    }
    while(v.isEven()) {
      v.rShiftTo(1,v);
      if(ac) {
        if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
        c.rShiftTo(1,c);
      }
      else if(!d.isEven()) d.subTo(m,d);
      d.rShiftTo(1,d);
    }
    if(u.compareTo(v) >= 0) {
      u.subTo(v,u);
      if(ac) a.subTo(c,a);
      b.subTo(d,b);
    }
    else {
      v.subTo(u,v);
      if(ac) c.subTo(a,c);
      d.subTo(b,d);
    }
  }
  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
  if(d.compareTo(m) >= 0) return d.subtract(m);
  if(d.signum() < 0) d.addTo(m,d); else return d;
  if(d.signum() < 0) return d.add(m); else return d;
}

var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
var lplim = (1<<26)/lowprimes[lowprimes.length-1];

// (public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t) {
  var i, x = this.abs();
  if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
    for(i = 0; i < lowprimes.length; ++i)
      if(x[0] == lowprimes[i]) return true;
    return false;
  }
  if(x.isEven()) return false;
  i = 1;
  while(i < lowprimes.length) {
    var m = lowprimes[i], j = i+1;
    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
    m = x.modInt(m);
    while(i < j) if(m%lowprimes[i++] == 0) return false;
  }
  return x.millerRabin(t);
}

// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger.ONE);
  var k = n1.getLowestSetBit();
  if(k <= 0) return false;
  var r = n1.shiftRight(k);
  t = (t+1)>>1;
  if(t > lowprimes.length) t = lowprimes.length;
  var a = nbi();
  for(var i = 0; i < t; ++i) {
    //Pick bases at random, instead of starting at 2
    a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
    var y = a.modPow(r,this);
    if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
      var j = 1;
      while(j++ < k && y.compareTo(n1) != 0) {
        y = y.modPowInt(2,this);
        if(y.compareTo(BigInteger.ONE) == 0) return false;
      }
      if(y.compareTo(n1) != 0) return false;
    }
  }
  return true;
}

// protected
BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;

// public
BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

// JSBN-specific extension
BigInteger.prototype.square = bnSquare;

// BigInteger interfaces not implemented in jsbn:

// BigInteger(int signum, byte[] magnitude)
// double doubleValue()
// float floatValue()
// int hashCode()
// long longValue()
// static BigInteger valueOf(long val)

// Depends on jsbn.js and rng.js

// Version 1.1: support utf-8 encoding in pkcs1pad2

// convert a (hex) string to a bignum object
function parseBigInt(str,r) {
  return new BigInteger(str,r);
}

function linebrk(s,n) {
  var ret = "";
  var i = 0;
  while(i + n < s.length) {
    ret += s.substring(i,i+n) + "\n";
    i += n;
  }
  return ret + s.substring(i,s.length);
}

function byte2Hex(b) {
  if(b < 0x10)
    return "0" + b.toString(16);
  else
    return b.toString(16);
}

// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
function pkcs1pad2(s,n) {
  if(n < s.length + 11) { // TODO: fix for utf-8
    alert("Message too long for RSA");
    return null;
  }
  var ba = new Array();
  var i = s.length - 1;
  while(i >= 0 && n > 0) {
    var c = s.charCodeAt(i--);
    if(c < 128) { // encode using utf-8
      ba[--n] = c;
    }
    else if((c > 127) && (c < 2048)) {
      ba[--n] = (c & 63) | 128;
      ba[--n] = (c >> 6) | 192;
    }
    else {
      ba[--n] = (c & 63) | 128;
      ba[--n] = ((c >> 6) & 63) | 128;
      ba[--n] = (c >> 12) | 224;
    }
  }
  ba[--n] = 0;
  var rng = new SecureRandom();
  var x = new Array();
  while(n > 2) { // random non-zero pad
    x[0] = 0;
    while(x[0] == 0) rng.nextBytes(x);
    ba[--n] = x[0];
  }
  ba[--n] = 2;
  ba[--n] = 0;
  return new BigInteger(ba);
}

// "empty" RSA key constructor
function RSAKey() {
  this.n = null;
  this.e = 0;
  this.d = null;
  this.p = null;
  this.q = null;
  this.dmp1 = null;
  this.dmq1 = null;
  this.coeff = null;
}

// Set the public key fields N and e from hex strings
function RSASetPublic(N,E) {
  if(N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
  }
  else
    alert("Invalid RSA public key");
}

// Perform raw public operation on "x": return x^e (mod n)
function RSADoPublic(x) {
  return x.modPowInt(this.e, this.n);
}

// Return the PKCS#1 RSA encryption of "text" as an even-length hex string
function RSAEncrypt(text) {
  var m = pkcs1pad2(text,(this.n.bitLength()+7)>>3);
  if(m == null) return null;
  var c = this.doPublic(m);
  if(c == null) return null;
  var h = c.toString(16);
  if((h.length & 1) == 0) return h; else return "0" + h;
}

// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
//function RSAEncryptB64(text) {
//  var h = this.encrypt(text);
//  if(h) return hex2b64(h); else return null;
//}

// protected
RSAKey.prototype.doPublic = RSADoPublic;

// public
RSAKey.prototype.setPublic = RSASetPublic;
RSAKey.prototype.encrypt = RSAEncrypt;
//RSAKey.prototype.encrypt_b64 = RSAEncryptB64;

// Depends on rsa.js and jsbn2.js

// Version 1.1: support utf-8 decoding in pkcs1unpad2

// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext
function pkcs1unpad2(d,n) {
  var b = d.toByteArray();
  var i = 0;
  while(i < b.length && b[i] == 0) ++i;
  if(b.length-i != n-1 || b[i] != 2)
    return null;
  ++i;
  while(b[i] != 0)
    if(++i >= b.length) return null;
  var ret = "";
  while(++i < b.length) {
    var c = b[i] & 255;
    if(c < 128) { // utf-8 decode
      ret += String.fromCharCode(c);
    }
    else if((c > 191) && (c < 224)) {
      ret += String.fromCharCode(((c & 31) << 6) | (b[i+1] & 63));
      ++i;
    }
    else {
      ret += String.fromCharCode(((c & 15) << 12) | ((b[i+1] & 63) << 6) | (b[i+2] & 63));
      i += 2;
    }
  }
  return ret;
}

// Set the private key fields N, e, and d from hex strings
function RSASetPrivate(N,E,D) {
  if(N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
    this.d = parseBigInt(D,16);
  }
  else
    alert("Invalid RSA private key");
}

// Set the private key fields N, e, d and CRT params from hex strings
function RSASetPrivateEx(N,E,D,P,Q,DP,DQ,C) {
  if(N != null && E != null && N.length > 0 && E.length > 0) {
    this.n = parseBigInt(N,16);
    this.e = parseInt(E,16);
    this.d = parseBigInt(D,16);
    this.p = parseBigInt(P,16);
    this.q = parseBigInt(Q,16);
    this.dmp1 = parseBigInt(DP,16);
    this.dmq1 = parseBigInt(DQ,16);
    this.coeff = parseBigInt(C,16);
  }
  else
    alert("Invalid RSA private key");
}

// Generate a new random private key B bits long, using public expt E
function RSAGenerate(B,E) {
    var rng = new SecureRandom();
    var qs = B>>1;
    this.e = parseInt(E,16);
    var ee = new BigInteger(E,16);
    for(;;) {
        for(;;) {
            this.p = new BigInteger(B-qs,10,rng); // tutao: changed parameter b from 1 to 10 (=> 5 rounds); according to HAC 4.49, we only need 2 rounds && discussion: https://github.com/digitalbazaar/forge/issues/28
            // tutao: the prime probability is already guaranteed by the BigInteger constructor above; if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;
            if(this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0) break;
        }
        for(;;) {
            // tutao: same changes as above
            this.q = new BigInteger(qs,10,rng);
            if(this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0) break;
        }
        if(this.p.compareTo(this.q) <= 0) {
            var t = this.p;
            this.p = this.q;
            this.q = t;
        }
        var p1 = this.p.subtract(BigInteger.ONE);
        var q1 = this.q.subtract(BigInteger.ONE);
        var phi = p1.multiply(q1);
        if(phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
            this.n = this.p.multiply(this.q);
            this.d = ee.modInverse(phi);
            this.dmp1 = this.d.mod(p1);
            this.dmq1 = this.d.mod(q1);
            this.coeff = this.q.modInverse(this.p);
            break;
        }
    }
}

// Perform raw private operation on "x": return x^d (mod n)
function RSADoPrivate(x) {
  if(this.p == null || this.q == null)
    return x.modPow(this.d, this.n);

  // TODO: re-calculate any missing CRT params
  var xp = x.mod(this.p).modPow(this.dmp1, this.p);
  var xq = x.mod(this.q).modPow(this.dmq1, this.q);

  while(xp.compareTo(xq) < 0)
    xp = xp.add(this.p);
  return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
}

// Return the PKCS#1 RSA decryption of "ctext".
// "ctext" is an even-length hex string and the output is a plain string.
function RSADecrypt(ctext) {
  var c = parseBigInt(ctext, 16);
  var m = this.doPrivate(c);
  if(m == null) return null;
  return pkcs1unpad2(m, (this.n.bitLength()+7)>>3);
}

// Return the PKCS#1 RSA decryption of "ctext".
// "ctext" is a Base64-encoded string and the output is a plain string.
//function RSAB64Decrypt(ctext) {
//  var h = b64tohex(ctext);
//  if(h) return this.decrypt(h); else return null;
//}

// protected
RSAKey.prototype.doPrivate = RSADoPrivate;

// public
RSAKey.prototype.setPrivate = RSASetPrivate;
RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
RSAKey.prototype.generate = RSAGenerate;
RSAKey.prototype.decrypt = RSADecrypt;
//RSAKey.prototype.b64_decrypt = RSAB64Decrypt;

////////////////////////////////////////////////////////////////////////////////////////
// Big Integer Library v. 5.4
// Created 2000, last modified 2009
// Leemon Baird
// www.leemon.com
//
// Version history:
// v 5.4  3 Oct 2009
//   - added "var i" to greaterShift() so i is not global. (Thanks to PŽter Szab— for finding that bug)
//
// v 5.3  21 Sep 2009
//   - added randProbPrime(k) for probable primes
//   - unrolled loop in mont_ (slightly faster)
//   - millerRabin now takes a bigInt parameter rather than an int
//
// v 5.2  15 Sep 2009
//   - fixed capitalization in call to int2bigInt in randBigInt
//     (thanks to Emili Evripidou, Reinhold Behringer, and Samuel Macaleese for finding that bug)
//
// v 5.1  8 Oct 2007 
//   - renamed inverseModInt_ to inverseModInt since it doesn't change its parameters
//   - added functions GCD and randBigInt, which call GCD_ and randBigInt_
//   - fixed a bug found by Rob Visser (see comment with his name below)
//   - improved comments
//
// This file is public domain.   You can use it for any purpose without restriction.
// I do not guarantee that it is correct, so use it at your own risk.  If you use 
// it for something interesting, I'd appreciate hearing about it.  If you find 
// any bugs or make any improvements, I'd appreciate hearing about those too.
// It would also be nice if my name and URL were left in the comments.  But none 
// of that is required.
//
// This code defines a bigInt library for arbitrary-precision integers.
// A bigInt is an array of integers storing the value in chunks of bpe bits, 
// little endian (buff[0] is the least significant word).
// Negative bigInts are stored two's complement.  Almost all the functions treat
// bigInts as nonnegative.  The few that view them as two's complement say so
// in their comments.  Some functions assume their parameters have at least one 
// leading zero element. Functions with an underscore at the end of the name put
// their answer into one of the arrays passed in, and have unpredictable behavior 
// in case of overflow, so the caller must make sure the arrays are big enough to 
// hold the answer.  But the average user should never have to call any of the 
// underscored functions.  Each important underscored function has a wrapper function 
// of the same name without the underscore that takes care of the details for you.  
// For each underscored function where a parameter is modified, that same variable 
// must not be used as another argument too.  So, you cannot square x by doing 
// multMod_(x,x,n).  You must use squareMod_(x,n) instead, or do y=dup(x); multMod_(x,y,n).
// Or simply use the multMod(x,x,n) function without the underscore, where
// such issues never arise, because non-underscored functions never change
// their parameters; they always allocate new memory for the answer that is returned.
//
// These functions are designed to avoid frequent dynamic memory allocation in the inner loop.
// For most functions, if it needs a BigInt as a local variable it will actually use
// a global, and will only allocate to it only when it's not the right size.  This ensures
// that when a function is called repeatedly with same-sized parameters, it only allocates
// memory on the first call.
//
// Note that for cryptographic purposes, the calls to Math.random() must 
// be replaced with calls to a better pseudorandom number generator.
//
// In the following, "bigInt" means a bigInt with at least one leading zero element,
// and "integer" means a nonnegative integer less than radix.  In some cases, integer 
// can be negative.  Negative bigInts are 2s complement.
// 
// The following functions do not modify their inputs.
// Those returning a bigInt, string, or Array will dynamically allocate memory for that value.
// Those returning a boolean will return the integer 0 (false) or 1 (true).
// Those returning boolean or int will not allocate memory except possibly on the first 
// time they're called with a given parameter size.
// 
// bigInt  add(x,y)               //return (x+y) for bigInts x and y.  
// bigInt  addInt(x,n)            //return (x+n) where x is a bigInt and n is an integer.
// string  bigInt2str(x,base)     //return a string form of bigInt x in a given base, with 2 <= base <= 95
// int     bitSize(x)             //return how many bits long the bigInt x is, not counting leading zeros
// bigInt  dup(x)                 //return a copy of bigInt x
// boolean equals(x,y)            //is the bigInt x equal to the bigint y?
// boolean equalsInt(x,y)         //is bigint x equal to integer y?
// bigInt  expand(x,n)            //return a copy of x with at least n elements, adding leading zeros if needed
// Array   findPrimes(n)          //return array of all primes less than integer n
// bigInt  GCD(x,y)               //return greatest common divisor of bigInts x and y (each with same number of elements).
// boolean greater(x,y)           //is x>y?  (x and y are nonnegative bigInts)
// boolean greaterShift(x,y,shift)//is (x <<(shift*bpe)) > y?
// bigInt  int2bigInt(t,n,m)      //return a bigInt equal to integer t, with at least n bits and m array elements
// bigInt  inverseMod(x,n)        //return (x**(-1) mod n) for bigInts x and n.  If no inverse exists, it returns null
// int     inverseModInt(x,n)     //return x**(-1) mod n, for integers x and n.  Return 0 if there is no inverse
// boolean isZero(x)              //is the bigInt x equal to zero?
// boolean millerRabin(x,b)       //does one round of Miller-Rabin base integer b say that bigInt x is possibly prime? (b is bigInt, 1<b<x)
// boolean millerRabinInt(x,b)    //does one round of Miller-Rabin base integer b say that bigInt x is possibly prime? (b is int,    1<b<x)
// bigInt  mod(x,n)               //return a new bigInt equal to (x mod n) for bigInts x and n.
// int     modInt(x,n)            //return x mod n for bigInt x and integer n.
// bigInt  mult(x,y)              //return x*y for bigInts x and y. This is faster when y<x.
// bigInt  multMod(x,y,n)         //return (x*y mod n) for bigInts x,y,n.  For greater speed, let y<x.
// boolean negative(x)            //is bigInt x negative?
// bigInt  powMod(x,y,n)          //return (x**y mod n) where x,y,n are bigInts and ** is exponentiation.  0**0=1. Faster for odd n.
// bigInt  randBigInt(n,s)        //return an n-bit random BigInt (n>=1).  If s=1, then the most significant of those n bits is set to 1.
// bigInt  randTruePrime(k)       //return a new, random, k-bit, true prime bigInt using Maurer's algorithm.
// bigInt  randProbPrime(k)       //return a new, random, k-bit, probable prime bigInt (probability it's composite less than 2^-80).
// bigInt  str2bigInt(s,b,n,m)    //return a bigInt for number represented in string s in base b with at least n bits and m array elements
// bigInt  sub(x,y)               //return (x-y) for bigInts x and y.  Negative answers will be 2s complement
// bigInt  trim(x,k)              //return a copy of x with exactly k leading zero elements
//
//
// The following functions each have a non-underscored version, which most users should call instead.
// These functions each write to a single parameter, and the caller is responsible for ensuring the array 
// passed in is large enough to hold the result. 
//
// void    addInt_(x,n)          //do x=x+n where x is a bigInt and n is an integer
// void    add_(x,y)             //do x=x+y for bigInts x and y
// void    copy_(x,y)            //do x=y on bigInts x and y
// void    copyInt_(x,n)         //do x=n on bigInt x and integer n
// void    GCD_(x,y)             //set x to the greatest common divisor of bigInts x and y, (y is destroyed).  (This never overflows its array).
// boolean inverseMod_(x,n)      //do x=x**(-1) mod n, for bigInts x and n. Returns 1 (0) if inverse does (doesn't) exist
// void    mod_(x,n)             //do x=x mod n for bigInts x and n. (This never overflows its array).
// void    mult_(x,y)            //do x=x*y for bigInts x and y.
// void    multMod_(x,y,n)       //do x=x*y  mod n for bigInts x,y,n.
// void    powMod_(x,y,n)        //do x=x**y mod n, where x,y,n are bigInts (n is odd) and ** is exponentiation.  0**0=1.
// void    randBigInt_(b,n,s)    //do b = an n-bit random BigInt. if s=1, then nth bit (most significant bit) is set to 1. n>=1.
// void    randTruePrime_(ans,k) //do ans = a random k-bit true random prime (not just probable prime) with 1 in the msb.
// void    sub_(x,y)             //do x=x-y for bigInts x and y. Negative answers will be 2s complement.
//
// The following functions do NOT have a non-underscored version. 
// They each write a bigInt result to one or more parameters.  The caller is responsible for
// ensuring the arrays passed in are large enough to hold the results. 
//
// void addShift_(x,y,ys)       //do x=x+(y<<(ys*bpe))
// void carry_(x)               //do carries and borrows so each element of the bigInt x fits in bpe bits.
// void divide_(x,y,q,r)        //divide x by y giving quotient q and remainder r
// int  divInt_(x,n)            //do x=floor(x/n) for bigInt x and integer n, and return the remainder. (This never overflows its array).
// int  eGCD_(x,y,d,a,b)        //sets a,b,d to positive bigInts such that d = GCD_(x,y) = a*x-b*y
// void halve_(x)               //do x=floor(|x|/2)*sgn(x) for bigInt x in 2's complement.  (This never overflows its array).
// void leftShift_(x,n)         //left shift bigInt x by n bits.  n<bpe.
// void linComb_(x,y,a,b)       //do x=a*x+b*y for bigInts x and y and integers a and b
// void linCombShift_(x,y,b,ys) //do x=x+b*(y<<(ys*bpe)) for bigInts x and y, and integers b and ys
// void mont_(x,y,n,np)         //Montgomery multiplication (see comments where the function is defined)
// void multInt_(x,n)           //do x=x*n where x is a bigInt and n is an integer.
// void rightShift_(x,n)        //right shift bigInt x by n bits.  0 <= n < bpe. (This never overflows its array).
// void squareMod_(x,n)         //do x=x*x  mod n for bigInts x,n
// void subShift_(x,y,ys)       //do x=x-(y<<(ys*bpe)). Negative answers will be 2s complement.
//
// The following functions are based on algorithms from the _Handbook of Applied Cryptography_
//    powMod_()           = algorithm 14.94, Montgomery exponentiation
//    eGCD_,inverseMod_() = algorithm 14.61, Binary extended GCD_
//    GCD_()              = algorothm 14.57, Lehmer's algorithm
//    mont_()             = algorithm 14.36, Montgomery multiplication
//    divide_()           = algorithm 14.20  Multiple-precision division
//    squareMod_()        = algorithm 14.16  Multiple-precision squaring
//    randTruePrime_()    = algorithm  4.62, Maurer's algorithm
//    millerRabin()       = algorithm  4.24, Miller-Rabin algorithm
//
// Profiling shows:
//     randTruePrime_() spends:
//         10% of its time in calls to powMod_()
//         85% of its time in calls to millerRabin()
//     millerRabin() spends:
//         99% of its time in calls to powMod_()   (always with a base of 2)
//     powMod_() spends:
//         94% of its time in calls to mont_()  (almost always with x==y)
//
// This suggests there are several ways to speed up this library slightly:
//     - convert powMod_ to use a Montgomery form of k-ary window (or maybe a Montgomery form of sliding window)
//         -- this should especially focus on being fast when raising 2 to a power mod n
//     - convert randTruePrime_() to use a minimum r of 1/3 instead of 1/2 with the appropriate change to the test
//     - tune the parameters in randTruePrime_(), including c, m, and recLimit
//     - speed up the single loop in mont_() that takes 95% of the runtime, perhaps by reducing checking
//       within the loop when all the parameters are the same length.
//
// There are several ideas that look like they wouldn't help much at all:
//     - replacing trial division in randTruePrime_() with a sieve (that speeds up something taking almost no time anyway)
//     - increase bpe from 15 to 30 (that would help if we had a 32*32->64 multiplier, but not with JavaScript's 32*32->32)
//     - speeding up mont_(x,y,n,np) when x==y by doing a non-modular, non-Montgomery square
//       followed by a Montgomery reduction.  The intermediate answer will be twice as long as x, so that
//       method would be slower.  This is unfortunate because the code currently spends almost all of its time
//       doing mont_(x,x,...), both for randTruePrime_() and powMod_().  A faster method for Montgomery squaring
//       would have a large impact on the speed of randTruePrime_() and powMod_().  HAC has a couple of poorly-worded
//       sentences that seem to imply it's faster to do a non-modular square followed by a single
//       Montgomery reduction, but that's obviously wrong.
////////////////////////////////////////////////////////////////////////////////////////

//globals
bpe=0;         //bits stored per array element
mask=0;        //AND this with an array element to chop it down to bpe bits
radix=mask+1;  //equals 2^bpe.  A single 1 bit to the left of the last bit of mask.

//the digits for converting to different bases
digitsStr='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_=!@#$%^&*()[]{}|;:,.<>/?`~ \\\'\"+-';

//initialize the global variables
for (bpe=0; (1<<(bpe+1)) > (1<<bpe); bpe++);  //bpe=number of bits in the mantissa on this platform
bpe>>=1;                   //bpe=number of bits in one element of the array representing the bigInt
mask=(1<<bpe)-1;           //AND the mask with an integer to get its bpe least significant bits
radix=mask+1;              //2^bpe.  a single 1 bit to the left of the first bit of mask
one=int2bigInt(1,1,1);     //constant used in powMod_()

//the following global variables are scratchpad memory to 
//reduce dynamic memory allocation in the inner loop
t=new Array(0);
ss=t;       //used in mult_()
s0=t;       //used in multMod_(), squareMod_() 
s1=t;       //used in powMod_(), multMod_(), squareMod_() 
s2=t;       //used in powMod_(), multMod_()
s3=t;       //used in powMod_()
s4=t; s5=t; //used in mod_()
s6=t;       //used in bigInt2str()
s7=t;       //used in powMod_()
T=t;        //used in GCD_()
sa=t;       //used in mont_()
mr_x1=t; mr_r=t; mr_a=t;                                      //used in millerRabin()
eg_v=t; eg_u=t; eg_A=t; eg_B=t; eg_C=t; eg_D=t;               //used in eGCD_(), inverseMod_()
md_q1=t; md_q2=t; md_q3=t; md_r=t; md_r1=t; md_r2=t; md_tt=t; //used in mod_()

primes=t; pows=t; s_i=t; s_i2=t; s_R=t; s_rm=t; s_q=t; s_n1=t; 
  s_a=t; s_r2=t; s_n=t; s_b=t; s_d=t; s_x1=t; s_x2=t, s_aa=t; //used in randTruePrime_()
  
rpprb=t; //used in randProbPrimeRounds() (which also uses "primes")

////////////////////////////////////////////////////////////////////////////////////////


//return array of all primes less than integer n
function findPrimes(n) {
  var i,s,p,ans;
  s=new Array(n);
  for (i=0;i<n;i++)
    s[i]=0;
  s[0]=2;
  p=0;    //first p elements of s are primes, the rest are a sieve
  for(;s[p]<n;) {                  //s[p] is the pth prime
    for(i=s[p]*s[p]; i<n; i+=s[p]) //mark multiples of s[p]
      s[i]=1;
    p++;
    s[p]=s[p-1]+1;
    for(; s[p]<n && s[s[p]]; s[p]++); //find next prime (where s[p]==0)
  }
  ans=new Array(p);
  for(i=0;i<p;i++)
    ans[i]=s[i];
  return ans;
}


//does a single round of Miller-Rabin base b consider x to be a possible prime?
//x is a bigInt, and b is an integer, with b<x
function millerRabinInt(x,b) {
  if (mr_x1.length!=x.length) {
    mr_x1=dup(x);
    mr_r=dup(x);
    mr_a=dup(x);
  }

  copyInt_(mr_a,b);
  return millerRabin(x,mr_a);
}

//does a single round of Miller-Rabin base b consider x to be a possible prime?
//x and b are bigInts with b<x
function millerRabin(x,b) {
  var i,j,k,s;

  if (mr_x1.length!=x.length) {
    mr_x1=dup(x);
    mr_r=dup(x);
    mr_a=dup(x);
  }

  copy_(mr_a,b);
  copy_(mr_r,x);
  copy_(mr_x1,x);

  addInt_(mr_r,-1);
  addInt_(mr_x1,-1);

  //s=the highest power of two that divides mr_r
  k=0;
  for (i=0;i<mr_r.length;i++)
    for (j=1;j<mask;j<<=1)
      if (x[i] & j) {
        s=(k<mr_r.length+bpe ? k : 0); 
         i=mr_r.length;
         j=mask;
      } else
        k++;

  if (s)                
    rightShift_(mr_r,s);

  powMod_(mr_a,mr_r,x);

  if (!equalsInt(mr_a,1) && !equals(mr_a,mr_x1)) {
    j=1;
    while (j<=s-1 && !equals(mr_a,mr_x1)) {
      squareMod_(mr_a,x);
      if (equalsInt(mr_a,1)) {
        return 0;
      }
      j++;
    }
    if (!equals(mr_a,mr_x1)) {
      return 0;
    }
  }
  return 1;  
}

//returns how many bits long the bigInt is, not counting leading zeros.
function bitSize(x) {
  var j,z,w;
  for (j=x.length-1; (x[j]==0) && (j>0); j--);
  for (z=0,w=x[j]; w; (w>>=1),z++);
  z+=bpe*j;
  return z;
}

//return a copy of x with at least n elements, adding leading zeros if needed
function expand(x,n) {
  var ans=int2bigInt(0,(x.length>n ? x.length : n)*bpe,0);
  copy_(ans,x);
  return ans;
}

//return a k-bit true random prime using Maurer's algorithm.
function randTruePrime(k) {
  var ans=int2bigInt(0,k,0);
  randTruePrime_(ans,k);
  return trim(ans,1);
}

//return a k-bit random probable prime with probability of error < 2^-80
function randProbPrime(k) {
  if (k>=600) return randProbPrimeRounds(k,2); //numbers from HAC table 4.3
  if (k>=550) return randProbPrimeRounds(k,4);
  if (k>=500) return randProbPrimeRounds(k,5);
  if (k>=400) return randProbPrimeRounds(k,6);
  if (k>=350) return randProbPrimeRounds(k,7);
  if (k>=300) return randProbPrimeRounds(k,9);
  if (k>=250) return randProbPrimeRounds(k,12); //numbers from HAC table 4.4
  if (k>=200) return randProbPrimeRounds(k,15);
  if (k>=150) return randProbPrimeRounds(k,18);
  if (k>=100) return randProbPrimeRounds(k,27);
              return randProbPrimeRounds(k,40); //number from HAC remark 4.26 (only an estimate)
}

//return a k-bit probable random prime using n rounds of Miller Rabin (after trial division with small primes)	
function randProbPrimeRounds(k,n) {
  var ans, i, divisible, B; 
  B=30000;  //B is largest prime to use in trial division
  ans=int2bigInt(0,k,0);
  
  //optimization: try larger and smaller B to find the best limit.
  
  if (primes.length==0)
    primes=findPrimes(30000);  //check for divisibility by primes <=30000

  if (rpprb.length!=ans.length)
    rpprb=dup(ans);

  for (;;) { //keep trying random values for ans until one appears to be prime
    //optimization: pick a random number times L=2*3*5*...*p, plus a 
    //   random element of the list of all numbers in [0,L) not divisible by any prime up to p.
    //   This can reduce the amount of random number generation.
    
    randBigInt_(ans,k,0); //ans = a random odd number to check
    ans[0] |= 1; 
    divisible=0;
  
    //check ans for divisibility by small primes up to B
    for (i=0; (i<primes.length) && (primes[i]<=B); i++)
      if (modInt(ans,primes[i])==0 && !equalsInt(ans,primes[i])) {
        divisible=1;
        break;
      }      
    
    //optimization: change millerRabin so the base can be bigger than the number being checked, then eliminate the while here.
    
    //do n rounds of Miller Rabin, with random bases less than ans
    for (i=0; i<n && !divisible; i++) {
      randBigInt_(rpprb,k,0);
      while(!greater(ans,rpprb)) //pick a random rpprb that's < ans
        randBigInt_(rpprb,k,0);
      if (!millerRabin(ans,rpprb))
        divisible=1;
    }
    
    if(!divisible)
      return ans;
  }  
}

//return a new bigInt equal to (x mod n) for bigInts x and n.
function mod(x,n) {
  var ans=dup(x);
  mod_(ans,n);
  return trim(ans,1);
}

//return (x+n) where x is a bigInt and n is an integer.
function addInt(x,n) {
  var ans=expand(x,x.length+1);
  addInt_(ans,n);
  return trim(ans,1);
}

//return x*y for bigInts x and y. This is faster when y<x.
function mult(x,y) {
  var ans=expand(x,x.length+y.length);
  mult_(ans,y);
  return trim(ans,1);
}

//return (x**y mod n) where x,y,n are bigInts and ** is exponentiation.  0**0=1. Faster for odd n.
function powMod(x,y,n) {
  var ans=expand(x,n.length);  
  powMod_(ans,trim(y,2),trim(n,2),0);  //this should work without the trim, but doesn't
  return trim(ans,1);
}

//return (x-y) for bigInts x and y.  Negative answers will be 2s complement
function sub(x,y) {
  var ans=expand(x,(x.length>y.length ? x.length+1 : y.length+1)); 
  sub_(ans,y);
  return trim(ans,1);
}

//return (x+y) for bigInts x and y.  
function add(x,y) {
  var ans=expand(x,(x.length>y.length ? x.length+1 : y.length+1)); 
  add_(ans,y);
  return trim(ans,1);
}

//return (x**(-1) mod n) for bigInts x and n.  If no inverse exists, it returns null
function inverseMod(x,n) {
  var ans=expand(x,n.length); 
  var s;
  s=inverseMod_(ans,n);
  return s ? trim(ans,1) : null;
}

//return (x*y mod n) for bigInts x,y,n.  For greater speed, let y<x.
function multMod(x,y,n) {
  var ans=expand(x,n.length);
  multMod_(ans,y,n);
  return trim(ans,1);
}

//generate a k-bit true random prime using Maurer's algorithm,
//and put it into ans.  The bigInt ans must be large enough to hold it.
function randTruePrime_(ans,k) {
  var c,m,pm,dd,j,r,B,divisible,z,zz,recSize;

  if (primes.length==0)
    primes=findPrimes(30000);  //check for divisibility by primes <=30000

  if (pows.length==0) {
    pows=new Array(512);
    for (j=0;j<512;j++) {
      pows[j]=Math.pow(2,j/511.-1.);
    }
  }

  //c and m should be tuned for a particular machine and value of k, to maximize speed
  c=0.1;  //c=0.1 in HAC
  m=20;   //generate this k-bit number by first recursively generating a number that has between k/2 and k-m bits
  recLimit=20; //stop recursion when k <=recLimit.  Must have recLimit >= 2

  if (s_i2.length!=ans.length) {
    s_i2=dup(ans);
    s_R =dup(ans);
    s_n1=dup(ans);
    s_r2=dup(ans);
    s_d =dup(ans);
    s_x1=dup(ans);
    s_x2=dup(ans);
    s_b =dup(ans);
    s_n =dup(ans);
    s_i =dup(ans);
    s_rm=dup(ans);
    s_q =dup(ans);
    s_a =dup(ans);
    s_aa=dup(ans);
  }

  if (k <= recLimit) {  //generate small random primes by trial division up to its square root
    pm=(1<<((k+2)>>1))-1; //pm is binary number with all ones, just over sqrt(2^k)
    copyInt_(ans,0);
    for (dd=1;dd;) {
      dd=0;
      ans[0]= 1 | (1<<(k-1)) | Math.floor(Math.random()*(1<<k));  //random, k-bit, odd integer, with msb 1
      for (j=1;(j<primes.length) && ((primes[j]&pm)==primes[j]);j++) { //trial division by all primes 3...sqrt(2^k)
        if (0==(ans[0]%primes[j])) {
          dd=1;
          break;
        }
      }
    }
    carry_(ans);
    return;
  }

  B=c*k*k;    //try small primes up to B (or all the primes[] array if the largest is less than B).
  if (k>2*m)  //generate this k-bit number by first recursively generating a number that has between k/2 and k-m bits
    for (r=1; k-k*r<=m; )
      r=pows[Math.floor(Math.random()*512)];   //r=Math.pow(2,Math.random()-1);
  else
    r=.5;

  //simulation suggests the more complex algorithm using r=.333 is only slightly faster.

  recSize=Math.floor(r*k)+1;

  randTruePrime_(s_q,recSize);
  copyInt_(s_i2,0);
  s_i2[Math.floor((k-2)/bpe)] |= (1<<((k-2)%bpe));   //s_i2=2^(k-2)
  divide_(s_i2,s_q,s_i,s_rm);                        //s_i=floor((2^(k-1))/(2q))

  z=bitSize(s_i);

  for (;;) {
    for (;;) {  //generate z-bit numbers until one falls in the range [0,s_i-1]
      randBigInt_(s_R,z,0);
      if (greater(s_i,s_R))
        break;
    }                //now s_R is in the range [0,s_i-1]
    addInt_(s_R,1);  //now s_R is in the range [1,s_i]
    add_(s_R,s_i);   //now s_R is in the range [s_i+1,2*s_i]

    copy_(s_n,s_q);
    mult_(s_n,s_R); 
    multInt_(s_n,2);
    addInt_(s_n,1);    //s_n=2*s_R*s_q+1
    
    copy_(s_r2,s_R);
    multInt_(s_r2,2);  //s_r2=2*s_R

    //check s_n for divisibility by small primes up to B
    for (divisible=0,j=0; (j<primes.length) && (primes[j]<B); j++)
      if (modInt(s_n,primes[j])==0 && !equalsInt(s_n,primes[j])) {
        divisible=1;
        break;
      }      

    if (!divisible)    //if it passes small primes check, then try a single Miller-Rabin base 2
      if (!millerRabinInt(s_n,2)) //this line represents 75% of the total runtime for randTruePrime_ 
        divisible=1;

    if (!divisible) {  //if it passes that test, continue checking s_n
      addInt_(s_n,-3);
      for (j=s_n.length-1;(s_n[j]==0) && (j>0); j--);  //strip leading zeros
      for (zz=0,w=s_n[j]; w; (w>>=1),zz++);
      zz+=bpe*j;                             //zz=number of bits in s_n, ignoring leading zeros
      for (;;) {  //generate z-bit numbers until one falls in the range [0,s_n-1]
        randBigInt_(s_a,zz,0);
        if (greater(s_n,s_a))
          break;
      }                //now s_a is in the range [0,s_n-1]
      addInt_(s_n,3);  //now s_a is in the range [0,s_n-4]
      addInt_(s_a,2);  //now s_a is in the range [2,s_n-2]
      copy_(s_b,s_a);
      copy_(s_n1,s_n);
      addInt_(s_n1,-1);
      powMod_(s_b,s_n1,s_n);   //s_b=s_a^(s_n-1) modulo s_n
      addInt_(s_b,-1);
      if (isZero(s_b)) {
        copy_(s_b,s_a);
        powMod_(s_b,s_r2,s_n);
        addInt_(s_b,-1);
        copy_(s_aa,s_n);
        copy_(s_d,s_b);
        GCD_(s_d,s_n);  //if s_b and s_n are relatively prime, then s_n is a prime
        if (equalsInt(s_d,1)) {
          copy_(ans,s_aa);
          return;     //if we've made it this far, then s_n is absolutely guaranteed to be prime
        }
      }
    }
  }
}

//Return an n-bit random BigInt (n>=1).  If s=1, then the most significant of those n bits is set to 1.
function randBigInt(n,s) {
  var a,b;
  a=Math.floor((n-1)/bpe)+2; //# array elements to hold the BigInt with a leading 0 element
  b=int2bigInt(0,0,a);
  randBigInt_(b,n,s);
  return b;
}

//Set b to an n-bit random BigInt.  If s=1, then the most significant of those n bits is set to 1.
//Array b must be big enough to hold the result. Must have n>=1
function randBigInt_(b,n,s) {
  var i,a;
  for (i=0;i<b.length;i++)
    b[i]=0;
  a=Math.floor((n-1)/bpe)+1; //# array elements to hold the BigInt
  for (i=0;i<a;i++) {
    b[i]=Math.floor(Math.random()*(1<<(bpe-1)));
  }
  b[a-1] &= (2<<((n-1)%bpe))-1;
  if (s==1)
    b[a-1] |= (1<<((n-1)%bpe));
}

//Return the greatest common divisor of bigInts x and y (each with same number of elements).
function GCD(x,y) {
  var xc,yc;
  xc=dup(x);
  yc=dup(y);
  GCD_(xc,yc);
  return xc;
}

//set x to the greatest common divisor of bigInts x and y (each with same number of elements).
//y is destroyed.
function GCD_(x,y) {
  var i,xp,yp,A,B,C,D,q,sing;
  if (T.length!=x.length)
    T=dup(x);

  sing=1;
  while (sing) { //while y has nonzero elements other than y[0]
    sing=0;
    for (i=1;i<y.length;i++) //check if y has nonzero elements other than 0
      if (y[i]) {
        sing=1;
        break;
      }
    if (!sing) break; //quit when y all zero elements except possibly y[0]

    for (i=x.length;!x[i] && i>=0;i--);  //find most significant element of x
    xp=x[i];
    yp=y[i];
    A=1; B=0; C=0; D=1;
    while ((yp+C) && (yp+D)) {
      q =Math.floor((xp+A)/(yp+C));
      qp=Math.floor((xp+B)/(yp+D));
      if (q!=qp)
        break;
      t= A-q*C;   A=C;   C=t;    //  do (A,B,xp, C,D,yp) = (C,D,yp, A,B,xp) - q*(0,0,0, C,D,yp)      
      t= B-q*D;   B=D;   D=t;
      t=xp-q*yp; xp=yp; yp=t;
    }
    if (B) {
      copy_(T,x);
      linComb_(x,y,A,B); //x=A*x+B*y
      linComb_(y,T,D,C); //y=D*y+C*T
    } else {
      mod_(x,y);
      copy_(T,x);
      copy_(x,y);
      copy_(y,T);
    } 
  }
  if (y[0]==0)
    return;
  t=modInt(x,y[0]);
  copyInt_(x,y[0]);
  y[0]=t;
  while (y[0]) {
    x[0]%=y[0];
    t=x[0]; x[0]=y[0]; y[0]=t;
  }
}

//do x=x**(-1) mod n, for bigInts x and n.
//If no inverse exists, it sets x to zero and returns 0, else it returns 1.
//The x array must be at least as large as the n array.
function inverseMod_(x,n) {
  var k=1+2*Math.max(x.length,n.length);

  if(!(x[0]&1)  && !(n[0]&1)) {  //if both inputs are even, then inverse doesn't exist
    copyInt_(x,0);
    return 0;
  }

  if (eg_u.length!=k) {
    eg_u=new Array(k);
    eg_v=new Array(k);
    eg_A=new Array(k);
    eg_B=new Array(k);
    eg_C=new Array(k);
    eg_D=new Array(k);
  }

  copy_(eg_u,x);
  copy_(eg_v,n);
  copyInt_(eg_A,1);
  copyInt_(eg_B,0);
  copyInt_(eg_C,0);
  copyInt_(eg_D,1);
  for (;;) {
    while(!(eg_u[0]&1)) {  //while eg_u is even
      halve_(eg_u);
      if (!(eg_A[0]&1) && !(eg_B[0]&1)) { //if eg_A==eg_B==0 mod 2
        halve_(eg_A);
        halve_(eg_B);      
      } else {
        add_(eg_A,n);  halve_(eg_A);
        sub_(eg_B,x);  halve_(eg_B);
      }
    }

    while (!(eg_v[0]&1)) {  //while eg_v is even
      halve_(eg_v);
      if (!(eg_C[0]&1) && !(eg_D[0]&1)) { //if eg_C==eg_D==0 mod 2
        halve_(eg_C);
        halve_(eg_D);      
      } else {
        add_(eg_C,n);  halve_(eg_C);
        sub_(eg_D,x);  halve_(eg_D);
      }
    }

    if (!greater(eg_v,eg_u)) { //eg_v <= eg_u
      sub_(eg_u,eg_v);
      sub_(eg_A,eg_C);
      sub_(eg_B,eg_D);
    } else {                   //eg_v > eg_u
      sub_(eg_v,eg_u);
      sub_(eg_C,eg_A);
      sub_(eg_D,eg_B);
    }
  
    if (equalsInt(eg_u,0)) {
      if (negative(eg_C)) //make sure answer is nonnegative
        add_(eg_C,n);
      copy_(x,eg_C);

      if (!equalsInt(eg_v,1)) { //if GCD_(x,n)!=1, then there is no inverse
        copyInt_(x,0);
        return 0;
      }
      return 1;
    }
  }
}

//return x**(-1) mod n, for integers x and n.  Return 0 if there is no inverse
function inverseModInt(x,n) {
  var a=1,b=0,t;
  for (;;) {
    if (x==1) return a;
    if (x==0) return 0;
    b-=a*Math.floor(n/x);
    n%=x;

    if (n==1) return b; //to avoid negatives, change this b to n-b, and each -= to +=
    if (n==0) return 0;
    a-=b*Math.floor(x/n);
    x%=n;
  }
}

//this deprecated function is for backward compatibility only. 
function inverseModInt_(x,n) {
   return inverseModInt(x,n);
}


//Given positive bigInts x and y, change the bigints v, a, and b to positive bigInts such that:
//     v = GCD_(x,y) = a*x-b*y
//The bigInts v, a, b, must have exactly as many elements as the larger of x and y.
function eGCD_(x,y,v,a,b) {
  var g=0;
  var k=Math.max(x.length,y.length);
  if (eg_u.length!=k) {
    eg_u=new Array(k);
    eg_A=new Array(k);
    eg_B=new Array(k);
    eg_C=new Array(k);
    eg_D=new Array(k);
  }
  while(!(x[0]&1)  && !(y[0]&1)) {  //while x and y both even
    halve_(x);
    halve_(y);
    g++;
  }
  copy_(eg_u,x);
  copy_(v,y);
  copyInt_(eg_A,1);
  copyInt_(eg_B,0);
  copyInt_(eg_C,0);
  copyInt_(eg_D,1);
  for (;;) {
    while(!(eg_u[0]&1)) {  //while u is even
      halve_(eg_u);
      if (!(eg_A[0]&1) && !(eg_B[0]&1)) { //if A==B==0 mod 2
        halve_(eg_A);
        halve_(eg_B);      
      } else {
        add_(eg_A,y);  halve_(eg_A);
        sub_(eg_B,x);  halve_(eg_B);
      }
    }

    while (!(v[0]&1)) {  //while v is even
      halve_(v);
      if (!(eg_C[0]&1) && !(eg_D[0]&1)) { //if C==D==0 mod 2
        halve_(eg_C);
        halve_(eg_D);      
      } else {
        add_(eg_C,y);  halve_(eg_C);
        sub_(eg_D,x);  halve_(eg_D);
      }
    }

    if (!greater(v,eg_u)) { //v<=u
      sub_(eg_u,v);
      sub_(eg_A,eg_C);
      sub_(eg_B,eg_D);
    } else {                //v>u
      sub_(v,eg_u);
      sub_(eg_C,eg_A);
      sub_(eg_D,eg_B);
    }
    if (equalsInt(eg_u,0)) {
      if (negative(eg_C)) {   //make sure a (C)is nonnegative
        add_(eg_C,y);
        sub_(eg_D,x);
      }
      multInt_(eg_D,-1);  ///make sure b (D) is nonnegative
      copy_(a,eg_C);
      copy_(b,eg_D);
      leftShift_(v,g);
      return;
    }
  }
}


//is bigInt x negative?
function negative(x) {
  return ((x[x.length-1]>>(bpe-1))&1);
}


//is (x << (shift*bpe)) > y?
//x and y are nonnegative bigInts
//shift is a nonnegative integer
function greaterShift(x,y,shift) {
  var i, kx=x.length, ky=y.length;
  k=((kx+shift)<ky) ? (kx+shift) : ky;
  for (i=ky-1-shift; i<kx && i>=0; i++) 
    if (x[i]>0)
      return 1; //if there are nonzeros in x to the left of the first column of y, then x is bigger
  for (i=kx-1+shift; i<ky; i++)
    if (y[i]>0)
      return 0; //if there are nonzeros in y to the left of the first column of x, then x is not bigger
  for (i=k-1; i>=shift; i--)
    if      (x[i-shift]>y[i]) return 1;
    else if (x[i-shift]<y[i]) return 0;
  return 0;
}

//is x > y? (x and y both nonnegative)
function greater(x,y) {
  var i;
  var k=(x.length<y.length) ? x.length : y.length;

  for (i=x.length;i<y.length;i++)
    if (y[i])
      return 0;  //y has more digits

  for (i=y.length;i<x.length;i++)
    if (x[i])
      return 1;  //x has more digits

  for (i=k-1;i>=0;i--)
    if (x[i]>y[i])
      return 1;
    else if (x[i]<y[i])
      return 0;
  return 0;
}

//divide x by y giving quotient q and remainder r.  (q=floor(x/y),  r=x mod y).  All 4 are bigints.
//x must have at least one leading zero element.
//y must be nonzero.
//q and r must be arrays that are exactly the same length as x. (Or q can have more).
//Must have x.length >= y.length >= 2.
function divide_(x,y,q,r) {
  var kx, ky;
  var i,j,y1,y2,c,a,b;
  copy_(r,x);
  for (ky=y.length;y[ky-1]==0;ky--); //ky is number of elements in y, not including leading zeros

  //normalize: ensure the most significant element of y has its highest bit set  
  b=y[ky-1];
  for (a=0; b; a++)
    b>>=1;  
  a=bpe-a;  //a is how many bits to shift so that the high order bit of y is leftmost in its array element
  leftShift_(y,a);  //multiply both by 1<<a now, then divide both by that at the end
  leftShift_(r,a);

  //Rob Visser discovered a bug: the following line was originally just before the normalization.
  for (kx=r.length;r[kx-1]==0 && kx>ky;kx--); //kx is number of elements in normalized x, not including leading zeros

  copyInt_(q,0);                      // q=0
  while (!greaterShift(y,r,kx-ky)) {  // while (leftShift_(y,kx-ky) <= r) {
    subShift_(r,y,kx-ky);             //   r=r-leftShift_(y,kx-ky)
    q[kx-ky]++;                       //   q[kx-ky]++;
  }                                   // }

  for (i=kx-1; i>=ky; i--) {
    if (r[i]==y[ky-1])
      q[i-ky]=mask;
    else
      q[i-ky]=Math.floor((r[i]*radix+r[i-1])/y[ky-1]);	

    //The following for(;;) loop is equivalent to the commented while loop, 
    //except that the uncommented version avoids overflow.
    //The commented loop comes from HAC, which assumes r[-1]==y[-1]==0
    //  while (q[i-ky]*(y[ky-1]*radix+y[ky-2]) > r[i]*radix*radix+r[i-1]*radix+r[i-2])
    //    q[i-ky]--;    
    for (;;) {
      y2=(ky>1 ? y[ky-2] : 0)*q[i-ky];
      c=y2>>bpe;
      y2=y2 & mask;
      y1=c+q[i-ky]*y[ky-1];
      c=y1>>bpe;
      y1=y1 & mask;

      if (c==r[i] ? y1==r[i-1] ? y2>(i>1 ? r[i-2] : 0) : y1>r[i-1] : c>r[i]) 
        q[i-ky]--;
      else
        break;
    }

    linCombShift_(r,y,-q[i-ky],i-ky);    //r=r-q[i-ky]*leftShift_(y,i-ky)
    if (negative(r)) {
      addShift_(r,y,i-ky);         //r=r+leftShift_(y,i-ky)
      q[i-ky]--;
    }
  }

  rightShift_(y,a);  //undo the normalization step
  rightShift_(r,a);  //undo the normalization step
}

//do carries and borrows so each element of the bigInt x fits in bpe bits.
function carry_(x) {
  var i,k,c,b;
  k=x.length;
  c=0;
  for (i=0;i<k;i++) {
    c+=x[i];
    b=0;
    if (c<0) {
      b=-(c>>bpe);
      c+=b*radix;
    }
    x[i]=c & mask;
    c=(c>>bpe)-b;
  }
}

//return x mod n for bigInt x and integer n.
function modInt(x,n) {
  var i,c=0;
  for (i=x.length-1; i>=0; i--)
    c=(c*radix+x[i])%n;
  return c;
}

//convert the integer t into a bigInt with at least the given number of bits.
//the returned array stores the bigInt in bpe-bit chunks, little endian (buff[0] is least significant word)
//Pad the array with leading zeros so that it has at least minSize elements.
//There will always be at least one leading 0 element.
function int2bigInt(t,bits,minSize) {   
  var i,k;
  k=Math.ceil(bits/bpe)+1;
  k=minSize>k ? minSize : k;
  buff=new Array(k);
  copyInt_(buff,t);
  return buff;
}

//return the bigInt given a string representation in a given base.  
//Pad the array with leading zeros so that it has at least minSize elements.
//If base=-1, then it reads in a space-separated list of array elements in decimal.
//The array will always have at least one leading zero, unless base=-1.
function str2bigInt(s,base,minSize) {
  var d, i, j, x, y, kk;
  var k=s.length;
  if (base==-1) { //comma-separated list of array elements in decimal
    x=new Array(0);
    for (;;) {
      y=new Array(x.length+1);
      for (i=0;i<x.length;i++)
        y[i+1]=x[i];
      y[0]=parseInt(s,10);
      x=y;
      d=s.indexOf(',',0);
      if (d<1) 
        break;
      s=s.substring(d+1);
      if (s.length==0)
        break;
    }
    if (x.length<minSize) {
      y=new Array(minSize);
      copy_(y,x);
      return y;
    }
    return x;
  }

  x=int2bigInt(0,base*k,0);
  for (i=0;i<k;i++) {
    d=digitsStr.indexOf(s.substring(i,i+1),0);
    if (base<=36 && d>=36)  //convert lowercase to uppercase if base<=36
      d-=26;
    if (d>=base || d<0) {   //stop at first illegal character
      break;
    }
    multInt_(x,base);
    addInt_(x,d);
  }

  for (k=x.length;k>0 && !x[k-1];k--); //strip off leading zeros
  k=minSize>k+1 ? minSize : k+1;
  y=new Array(k);
  kk=k<x.length ? k : x.length;
  for (i=0;i<kk;i++)
    y[i]=x[i];
  for (;i<k;i++)
    y[i]=0;
  return y;
}

//is bigint x equal to integer y?
//y must have less than bpe bits
function equalsInt(x,y) {
  var i;
  if (x[0]!=y)
    return 0;
  for (i=1;i<x.length;i++)
    if (x[i])
      return 0;
  return 1;
}

//are bigints x and y equal?
//this works even if x and y are different lengths and have arbitrarily many leading zeros
function equals(x,y) {
  var i;
  var k=x.length<y.length ? x.length : y.length;
  for (i=0;i<k;i++)
    if (x[i]!=y[i])
      return 0;
  if (x.length>y.length) {
    for (;i<x.length;i++)
      if (x[i])
        return 0;
  } else {
    for (;i<y.length;i++)
      if (y[i])
        return 0;
  }
  return 1;
}

//is the bigInt x equal to zero?
function isZero(x) {
  var i;
  for (i=0;i<x.length;i++)
    if (x[i])
      return 0;
  return 1;
}

//convert a bigInt into a string in a given base, from base 2 up to base 95.
//Base -1 prints the contents of the array representing the number.
function bigInt2str(x,base) {
  var i,t,s="";

  if (s6.length!=x.length) 
    s6=dup(x);
  else
    copy_(s6,x);

  if (base==-1) { //return the list of array contents
    for (i=x.length-1;i>0;i--)
      s+=x[i]+',';
    s+=x[0];
  }
  else { //return it in the given base
    while (!isZero(s6)) {
      t=divInt_(s6,base);  //t=s6 % base; s6=floor(s6/base);
      s=digitsStr.substring(t,t+1)+s;
    }
  }
  if (s.length==0)
    s="0";
  return s;
}

//returns a duplicate of bigInt x
function dup(x) {
  var i;
  buff=new Array(x.length);
  copy_(buff,x);
  return buff;
}

//do x=y on bigInts x and y.  x must be an array at least as big as y (not counting the leading zeros in y).
function copy_(x,y) {
  var i;
  var k=x.length<y.length ? x.length : y.length;
  for (i=0;i<k;i++)
    x[i]=y[i];
  for (i=k;i<x.length;i++)
    x[i]=0;
}

//do x=y on bigInt x and integer y.  
function copyInt_(x,n) {
  var i,c;
  for (c=n,i=0;i<x.length;i++) {
    x[i]=c & mask;
    c>>=bpe;
  }
}

//do x=x+n where x is a bigInt and n is an integer.
//x must be large enough to hold the result.
function addInt_(x,n) {
  var i,k,c,b;
  x[0]+=n;
  k=x.length;
  c=0;
  for (i=0;i<k;i++) {
    c+=x[i];
    b=0;
    if (c<0) {
      b=-(c>>bpe);
      c+=b*radix;
    }
    x[i]=c & mask;
    c=(c>>bpe)-b;
    if (!c) return; //stop carrying as soon as the carry is zero
  }
}

//right shift bigInt x by n bits.  0 <= n < bpe.
function rightShift_(x,n) {
  var i;
  var k=Math.floor(n/bpe);
  if (k) {
    for (i=0;i<x.length-k;i++) //right shift x by k elements
      x[i]=x[i+k];
    for (;i<x.length;i++)
      x[i]=0;
    n%=bpe;
  }
  for (i=0;i<x.length-1;i++) {
    x[i]=mask & ((x[i+1]<<(bpe-n)) | (x[i]>>n));
  }
  x[i]>>=n;
}

//do x=floor(|x|/2)*sgn(x) for bigInt x in 2's complement
function halve_(x) {
  var i;
  for (i=0;i<x.length-1;i++) {
    x[i]=mask & ((x[i+1]<<(bpe-1)) | (x[i]>>1));
  }
  x[i]=(x[i]>>1) | (x[i] & (radix>>1));  //most significant bit stays the same
}

//left shift bigInt x by n bits.
function leftShift_(x,n) {
  var i;
  var k=Math.floor(n/bpe);
  if (k) {
    for (i=x.length; i>=k; i--) //left shift x by k elements
      x[i]=x[i-k];
    for (;i>=0;i--)
      x[i]=0;  
    n%=bpe;
  }
  if (!n)
    return;
  for (i=x.length-1;i>0;i--) {
    x[i]=mask & ((x[i]<<n) | (x[i-1]>>(bpe-n)));
  }
  x[i]=mask & (x[i]<<n);
}

//do x=x*n where x is a bigInt and n is an integer.
//x must be large enough to hold the result.
function multInt_(x,n) {
  var i,k,c,b;
  if (!n)
    return;
  k=x.length;
  c=0;
  for (i=0;i<k;i++) {
    c+=x[i]*n;
    b=0;
    if (c<0) {
      b=-(c>>bpe);
      c+=b*radix;
    }
    x[i]=c & mask;
    c=(c>>bpe)-b;
  }
}

//do x=floor(x/n) for bigInt x and integer n, and return the remainder
function divInt_(x,n) {
  var i,r=0,s;
  for (i=x.length-1;i>=0;i--) {
    s=r*radix+x[i];
    x[i]=Math.floor(s/n);
    r=s%n;
  }
  return r;
}

//do the linear combination x=a*x+b*y for bigInts x and y, and integers a and b.
//x must be large enough to hold the answer.
function linComb_(x,y,a,b) {
  var i,c,k,kk;
  k=x.length<y.length ? x.length : y.length;
  kk=x.length;
  for (c=0,i=0;i<k;i++) {
    c+=a*x[i]+b*y[i];
    x[i]=c & mask;
    c>>=bpe;
  }
  for (i=k;i<kk;i++) {
    c+=a*x[i];
    x[i]=c & mask;
    c>>=bpe;
  }
}

//do the linear combination x=a*x+b*(y<<(ys*bpe)) for bigInts x and y, and integers a, b and ys.
//x must be large enough to hold the answer.
function linCombShift_(x,y,b,ys) {
  var i,c,k,kk;
  k=x.length<ys+y.length ? x.length : ys+y.length;
  kk=x.length;
  for (c=0,i=ys;i<k;i++) {
    c+=x[i]+b*y[i-ys];
    x[i]=c & mask;
    c>>=bpe;
  }
  for (i=k;c && i<kk;i++) {
    c+=x[i];
    x[i]=c & mask;
    c>>=bpe;
  }
}

//do x=x+(y<<(ys*bpe)) for bigInts x and y, and integers a,b and ys.
//x must be large enough to hold the answer.
function addShift_(x,y,ys) {
  var i,c,k,kk;
  k=x.length<ys+y.length ? x.length : ys+y.length;
  kk=x.length;
  for (c=0,i=ys;i<k;i++) {
    c+=x[i]+y[i-ys];
    x[i]=c & mask;
    c>>=bpe;
  }
  for (i=k;c && i<kk;i++) {
    c+=x[i];
    x[i]=c & mask;
    c>>=bpe;
  }
}

//do x=x-(y<<(ys*bpe)) for bigInts x and y, and integers a,b and ys.
//x must be large enough to hold the answer.
function subShift_(x,y,ys) {
  var i,c,k,kk;
  k=x.length<ys+y.length ? x.length : ys+y.length;
  kk=x.length;
  for (c=0,i=ys;i<k;i++) {
    c+=x[i]-y[i-ys];
    x[i]=c & mask;
    c>>=bpe;
  }
  for (i=k;c && i<kk;i++) {
    c+=x[i];
    x[i]=c & mask;
    c>>=bpe;
  }
}

//do x=x-y for bigInts x and y.
//x must be large enough to hold the answer.
//negative answers will be 2s complement
function sub_(x,y) {
  var i,c,k,kk;
  k=x.length<y.length ? x.length : y.length;
  for (c=0,i=0;i<k;i++) {
    c+=x[i]-y[i];
    x[i]=c & mask;
    c>>=bpe;
  }
  for (i=k;c && i<x.length;i++) {
    c+=x[i];
    x[i]=c & mask;
    c>>=bpe;
  }
}

//do x=x+y for bigInts x and y.
//x must be large enough to hold the answer.
function add_(x,y) {
  var i,c,k,kk;
  k=x.length<y.length ? x.length : y.length;
  for (c=0,i=0;i<k;i++) {
    c+=x[i]+y[i];
    x[i]=c & mask;
    c>>=bpe;
  }
  for (i=k;c && i<x.length;i++) {
    c+=x[i];
    x[i]=c & mask;
    c>>=bpe;
  }
}

//do x=x*y for bigInts x and y.  This is faster when y<x.
function mult_(x,y) {
  var i;
  if (ss.length!=2*x.length)
    ss=new Array(2*x.length);
  copyInt_(ss,0);
  for (i=0;i<y.length;i++)
    if (y[i])
      linCombShift_(ss,x,y[i],i);   //ss=1*ss+y[i]*(x<<(i*bpe))
  copy_(x,ss);
}

//do x=x mod n for bigInts x and n.
function mod_(x,n) {
  if (s4.length!=x.length)
    s4=dup(x);
  else
    copy_(s4,x);
  if (s5.length!=x.length)
    s5=dup(x);  
  divide_(s4,n,s5,x);  //x = remainder of s4 / n
}

//do x=x*y mod n for bigInts x,y,n.
//for greater speed, let y<x.
function multMod_(x,y,n) {
  var i;
  if (s0.length!=2*x.length)
    s0=new Array(2*x.length);
  copyInt_(s0,0);
  for (i=0;i<y.length;i++)
    if (y[i])
      linCombShift_(s0,x,y[i],i);   //s0=1*s0+y[i]*(x<<(i*bpe))
  mod_(s0,n);
  copy_(x,s0);
}

//do x=x*x mod n for bigInts x,n.
function squareMod_(x,n) {
  var i,j,d,c,kx,kn,k;
  for (kx=x.length; kx>0 && !x[kx-1]; kx--);  //ignore leading zeros in x
  k=kx>n.length ? 2*kx : 2*n.length; //k=# elements in the product, which is twice the elements in the larger of x and n
  if (s0.length!=k) 
    s0=new Array(k);
  copyInt_(s0,0);
  for (i=0;i<kx;i++) {
    c=s0[2*i]+x[i]*x[i];
    s0[2*i]=c & mask;
    c>>=bpe;
    for (j=i+1;j<kx;j++) {
      c=s0[i+j]+2*x[i]*x[j]+c;
      s0[i+j]=(c & mask);
      c>>=bpe;
    }
    s0[i+kx]=c;
  }
  mod_(s0,n);
  copy_(x,s0);
}

//return x with exactly k leading zero elements
function trim(x,k) {
  var i,y;
  for (i=x.length; i>0 && !x[i-1]; i--);
  y=new Array(i+k);
  copy_(y,x);
  return y;
}

//do x=x**y mod n, where x,y,n are bigInts and ** is exponentiation.  0**0=1.
//this is faster when n is odd.  x usually needs to have as many elements as n.
function powMod_(x,y,n) {
  var k1,k2,kn,np;
  if(s7.length!=n.length)
    s7=dup(n);

  //for even modulus, use a simple square-and-multiply algorithm,
  //rather than using the more complex Montgomery algorithm.
  if ((n[0]&1)==0) {
    copy_(s7,x);
    copyInt_(x,1);
    while(!equalsInt(y,0)) {
      if (y[0]&1)
        multMod_(x,s7,n);
      divInt_(y,2);
      squareMod_(s7,n); 
    }
    return;
  }

  //calculate np from n for the Montgomery multiplications
  copyInt_(s7,0);
  for (kn=n.length;kn>0 && !n[kn-1];kn--);
  np=radix-inverseModInt(modInt(n,radix),radix);
  s7[kn]=1;
  multMod_(x ,s7,n);   // x = x * 2**(kn*bp) mod n

  if (s3.length!=x.length)
    s3=dup(x);
  else
    copy_(s3,x);

  for (k1=y.length-1;k1>0 & !y[k1]; k1--);  //k1=first nonzero element of y
  if (y[k1]==0) {  //anything to the 0th power is 1
    copyInt_(x,1);
    return;
  }
  for (k2=1<<(bpe-1);k2 && !(y[k1] & k2); k2>>=1);  //k2=position of first 1 bit in y[k1]
  for (;;) {
    if (!(k2>>=1)) {  //look at next bit of y
      k1--;
      if (k1<0) {
        mont_(x,one,n,np);
        return;
      }
      k2=1<<(bpe-1);
    }    
    mont_(x,x,n,np);

    if (k2 & y[k1]) //if next bit is a 1
      mont_(x,s3,n,np);
  }
}


//do x=x*y*Ri mod n for bigInts x,y,n, 
//  where Ri = 2**(-kn*bpe) mod n, and kn is the 
//  number of elements in the n array, not 
//  counting leading zeros.  
//x array must have at least as many elemnts as the n array
//It's OK if x and y are the same variable.
//must have:
//  x,y < n
//  n is odd
//  np = -(n^(-1)) mod radix
function mont_(x,y,n,np) {
  var i,j,c,ui,t,ks;
  var kn=n.length;
  var ky=y.length;

  if (sa.length!=kn)
    sa=new Array(kn);
    
  copyInt_(sa,0);

  for (;kn>0 && n[kn-1]==0;kn--); //ignore leading zeros of n
  for (;ky>0 && y[ky-1]==0;ky--); //ignore leading zeros of y
  ks=sa.length-1; //sa will never have more than this many nonzero elements.  

  //the following loop consumes 95% of the runtime for randTruePrime_() and powMod_() for large numbers
  for (i=0; i<kn; i++) {
    t=sa[0]+x[i]*y[0];
    ui=((t & mask) * np) & mask;  //the inner "& mask" was needed on Safari (but not MSIE) at one time
    c=(t+ui*n[0]) >> bpe;
    t=x[i];
    
    //do sa=(sa+x[i]*y+ui*n)/b   where b=2**bpe.  Loop is unrolled 5-fold for speed
    j=1;
    for (;j<ky-4;) { c+=sa[j]+ui*n[j]+t*y[j];   sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j]+t*y[j];   sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j]+t*y[j];   sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j]+t*y[j];   sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j]+t*y[j];   sa[j-1]=c & mask;   c>>=bpe;   j++; }    
    for (;j<ky;)   { c+=sa[j]+ui*n[j]+t*y[j];   sa[j-1]=c & mask;   c>>=bpe;   j++; }
    for (;j<kn-4;) { c+=sa[j]+ui*n[j];          sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j];          sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j];          sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j];          sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j];          sa[j-1]=c & mask;   c>>=bpe;   j++; }  
    for (;j<kn;)   { c+=sa[j]+ui*n[j];          sa[j-1]=c & mask;   c>>=bpe;   j++; }   
    for (;j<ks;)   { c+=sa[j];                  sa[j-1]=c & mask;   c>>=bpe;   j++; }  
    sa[j-1]=c & mask;
  }

  if (!greater(n,sa))
    sub_(sa,n);
  copy_(x,sa);
}



/** @fileOverview Javascript cryptography implementation.
 *
 * Crush to remove comments, shorten variable names and
 * generally reduce transmission size.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

"use strict";
/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */
/*global document, window, escape, unescape */

/** @namespace The Stanford Javascript Crypto Library, top-level namespace. */
var sjcl = {
  /** @namespace Symmetric ciphers. */
  cipher: {},

  /** @namespace Hash functions.  Right now only SHA256 is implemented. */
  hash: {},

  /** @namespace Key exchange functions.  Right now only SRP is implemented. */
  keyexchange: {},
  
  /** @namespace Block cipher modes of operation. */
  mode: {},

  /** @namespace Miscellaneous.  HMAC and PBKDF2. */
  misc: {},
  
  /**
   * @namespace Bit array encoders and decoders.
   *
   * @description
   * The members of this namespace are functions which translate between
   * SJCL's bitArrays and other objects (usually strings).  Because it
   * isn't always clear which direction is encoding and which is decoding,
   * the method names are "fromBits" and "toBits".
   */
  codec: {},
  
  /** @namespace Exceptions. */
  exception: {
    /** @class Ciphertext is corrupt. */
    corrupt: function(message) {
      this.toString = function() { return "CORRUPT: "+this.message; };
      this.message = message;
    },
    
    /** @class Invalid parameter. */
    invalid: function(message) {
      this.toString = function() { return "INVALID: "+this.message; };
      this.message = message;
    },
    
    /** @class Bug or missing feature in SJCL. */
    bug: function(message) {
      this.toString = function() { return "BUG: "+this.message; };
      this.message = message;
    },

    /** @class Something isn't ready. */
    notReady: function(message) {
      this.toString = function() { return "NOT READY: "+this.message; };
      this.message = message;
    }
  }
};

if(typeof module != 'undefined' && module.exports){
  module.exports = sjcl;
}

/** @fileOverview Arrays of bits, encoded as arrays of Numbers.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** @namespace Arrays of bits, encoded as arrays of Numbers.
 *
 * @description
 * <p>
 * These objects are the currency accepted by SJCL's crypto functions.
 * </p>
 *
 * <p>
 * Most of our crypto primitives operate on arrays of 4-byte words internally,
 * but many of them can take arguments that are not a multiple of 4 bytes.
 * This library encodes arrays of bits (whose size need not be a multiple of 8
 * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an
 * array of words, 32 bits at a time.  Since the words are double-precision
 * floating point numbers, they fit some extra data.  We use this (in a private,
 * possibly-changing manner) to encode the number of bits actually  present
 * in the last word of the array.
 * </p>
 *
 * <p>
 * Because bitwise ops clear this out-of-band data, these arrays can be passed
 * to ciphers like AES which want arrays of words.
 * </p>
 */
sjcl.bitArray = {
  /**
   * Array slices in units of bits.
   * @param {bitArray} a The array to slice.
   * @param {Number} bstart The offset to the start of the slice, in bits.
   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,
   * slice until the end of the array.
   * @return {bitArray} The requested slice.
   */
  bitSlice: function (a, bstart, bend) {
    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);
    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);
  },

  /**
   * Extract a number packed into a bit array.
   * @param {bitArray} a The array to slice.
   * @param {Number} bstart The offset to the start of the slice, in bits.
   * @param {Number} length The length of the number to extract.
   * @return {Number} The requested slice.
   */
  extract: function(a, bstart, blength) {
    // FIXME: this Math.floor is not necessary at all, but for some reason
    // seems to suppress a bug in the Chromium JIT.
    var x, sh = Math.floor((-bstart-blength) & 31);
    if ((bstart + blength - 1 ^ bstart) & -32) {
      // it crosses a boundary
      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);
    } else {
      // within a single word
      x = a[bstart/32|0] >>> sh;
    }
    return x & ((1<<blength) - 1);
  },

  /**
   * Concatenate two bit arrays.
   * @param {bitArray} a1 The first array.
   * @param {bitArray} a2 The second array.
   * @return {bitArray} The concatenation of a1 and a2.
   */
  concat: function (a1, a2) {
    if (a1.length === 0 || a2.length === 0) {
      return a1.concat(a2);
    }
    
    var out, i, last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);
    if (shift === 32) {
      return a1.concat(a2);
    } else {
      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));
    }
  },

  /**
   * Find the length of an array of bits.
   * @param {bitArray} a The array.
   * @return {Number} The length of a, in bits.
   */
  bitLength: function (a) {
    var l = a.length, x;
    if (l === 0) { return 0; }
    x = a[l - 1];
    return (l-1) * 32 + sjcl.bitArray.getPartial(x);
  },

  /**
   * Truncate an array.
   * @param {bitArray} a The array.
   * @param {Number} len The length to truncate to, in bits.
   * @return {bitArray} A new array, truncated to len bits.
   */
  clamp: function (a, len) {
    if (a.length * 32 < len) { return a; }
    a = a.slice(0, Math.ceil(len / 32));
    var l = a.length;
    len = len & 31;
    if (l > 0 && len) {
      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);
    }
    return a;
  },

  /**
   * Make a partial word for a bit array.
   * @param {Number} len The number of bits in the word.
   * @param {Number} x The bits.
   * @param {Number} [0] _end Pass 1 if x has already been shifted to the high side.
   * @return {Number} The partial word.
   */
  partial: function (len, x, _end) {
    if (len === 32) { return x; }
    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;
  },

  /**
   * Get the number of bits used by a partial word.
   * @param {Number} x The partial word.
   * @return {Number} The number of bits used by the partial word.
   */
  getPartial: function (x) {
    return Math.round(x/0x10000000000) || 32;
  },

  /**
   * Compare two arrays for equality in a predictable amount of time.
   * @param {bitArray} a The first array.
   * @param {bitArray} b The second array.
   * @return {boolean} true if a == b; false otherwise.
   */
  equal: function (a, b) {
    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {
      return false;
    }
    var x = 0, i;
    for (i=0; i<a.length; i++) {
      x |= a[i]^b[i];
    }
    return (x === 0);
  },

  /** Shift an array right.
   * @param {bitArray} a The array to shift.
   * @param {Number} shift The number of bits to shift.
   * @param {Number} [carry=0] A byte to carry in
   * @param {bitArray} [out=[]] An array to prepend to the output.
   * @private
   */
  _shiftRight: function (a, shift, carry, out) {
    var i, last2=0, shift2;
    if (out === undefined) { out = []; }
    
    for (; shift >= 32; shift -= 32) {
      out.push(carry);
      carry = 0;
    }
    if (shift === 0) {
      return out.concat(a);
    }
    
    for (i=0; i<a.length; i++) {
      out.push(carry | a[i]>>>shift);
      carry = a[i] << (32-shift);
    }
    last2 = a.length ? a[a.length-1] : 0;
    shift2 = sjcl.bitArray.getPartial(last2);
    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));
    return out;
  },
  
  /** xor a block of 4 words together.
   * @private
   */
  _xor4: function(x,y) {
    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];
  }
};

// CHANGED (tutao.arm)
// - removed alert call
// - removed build breaking function around sjcl.mode.cbc
// - added option to not use padding in encrypt/decrypt

/** @fileOverview CBC mode implementation
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** @namespace
 * Dangerous: CBC mode with PKCS#5 padding.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */
if (sjcl.beware === undefined) {
  sjcl.beware = {};
}

  sjcl.mode.cbc = {
    /** The name of the mode.
     * @constant
     */
    name: "cbc",
    
    /** Encrypt in CBC mode with PKCS#5 padding.
     * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.
     * @param {bitArray} plaintext The plaintext data.
     * @param {bitArray} iv The initialization value.
     * @param {bitArray} [adata=[]] The authenticated data.  Must be empty.
     * @param {boolean} usePadding True if padding shall be used, false otherwise.
     * @return The encrypted data, an array of bytes.
     * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits, or if any adata is specified.
     */
    encrypt: function(prp, plaintext, iv, adata, usePadding) {
      if (adata && adata.length) {
        throw new sjcl.exception.invalid("cbc can't authenticate data");
      }
      if (sjcl.bitArray.bitLength(iv) !== 128) {
        throw new sjcl.exception.invalid("cbc iv must be 128 bits");
      }
      var i,
          w = sjcl.bitArray,
          xor = w._xor4,
          bl = w.bitLength(plaintext),
          bp = 0,
          output = [];

      if (bl&7) {
        throw new sjcl.exception.invalid("pkcs#5 padding only works for multiples of a byte");
      }
    
      for (i=0; bp+128 <= bl; i+=4, bp+=128) {
        /* Encrypt a non-final block */
        iv = prp.encrypt(xor(iv, plaintext.slice(i,i+4)));
        output.splice(i,0,iv[0],iv[1],iv[2],iv[3]);
      }
      
      if (usePadding) {
        /* Construct the pad. */
        bl = (16 - ((bl >> 3) & 15)) * 0x1010101;

        /* Pad and encrypt. */
        iv = prp.encrypt(xor(iv,w.concat(plaintext,[bl,bl,bl,bl]).slice(i,i+4)));
        output.splice(i,0,iv[0],iv[1],iv[2],iv[3]);
      }
      return output;
    },
    
    /** Decrypt in CBC mode.
     * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.
     * @param {bitArray} ciphertext The ciphertext data.
     * @param {bitArray} iv The initialization value.
     * @param {bitArray} [adata=[]] The authenticated data.  It must be empty.
     * @param {boolean} usePadding True if padding shall be used, false otherwise.
     * @return The decrypted data, an array of bytes.
     * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits, or if any adata is specified.
     * @throws {sjcl.exception.corrupt} if if the message is corrupt.
     */
    decrypt: function(prp, ciphertext, iv, adata, usePadding) {
      if (adata && adata.length) {
        throw new sjcl.exception.invalid("cbc can't authenticate data");
      }
      if (sjcl.bitArray.bitLength(iv) !== 128) {
        throw new sjcl.exception.invalid("cbc iv must be 128 bits");
      }
      if ((sjcl.bitArray.bitLength(ciphertext) & 127) || !ciphertext.length) {
        throw new sjcl.exception.corrupt("cbc ciphertext must be a positive multiple of the block size");
      }
      var i,
          w = sjcl.bitArray,
          xor = w._xor4,
          bi, bo,
          output = [];
          
      adata = adata || [];
    
      for (i=0; i<ciphertext.length; i+=4) {
        bi = ciphertext.slice(i,i+4);
        bo = xor(iv,prp.decrypt(bi));
        output.splice(i,0,bo[0],bo[1],bo[2],bo[3]);
        iv = bi;
      }

      if (usePadding) {
        /* check and remove the pad */
        bi = output[i-1] & 255;
        if (bi == 0 || bi > 16) {
          throw new sjcl.exception.corrupt("pkcs#5 padding corrupt");
        }
        bo = bi * 0x1010101;
        if (!w.equal(w.bitSlice([bo,bo,bo,bo], 0, bi*8),
                     w.bitSlice(output, output.length*32 - bi*8, output.length*32))) {
          throw new sjcl.exception.corrupt("pkcs#5 padding corrupt");
        }
        return w.bitSlice(output, 0, output.length*32 - bi*8);
      } else {
        return output;
      }
    }
  };

/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** @namespace Base64 encoding/decoding */
sjcl.codec.base64 = {
  /** The base64 alphabet.
   * @private
   */
  _chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  
  /** Convert from a bitArray to a base64 string. */
  fromBits: function (arr, _noEquals, _url) {
    var out = "", i, bits=0, c = sjcl.codec.base64._chars, ta=0, bl = sjcl.bitArray.bitLength(arr);
    if (_url) c = c.substr(0,62) + '-_';
    for (i=0; out.length * 6 < bl; ) {
      out += c.charAt((ta ^ arr[i]>>>bits) >>> 26);
      if (bits < 6) {
        ta = arr[i] << (6-bits);
        bits += 26;
        i++;
      } else {
        ta <<= 6;
        bits -= 6;
      }
    }
    while ((out.length & 3) && !_noEquals) { out += "="; }
    return out;
  },
  
  /** Convert from a base64 string to a bitArray */
  toBits: function(str, _url) {
    str = str.replace(/\s|=/g,'');
    var out = [], i, bits=0, c = sjcl.codec.base64._chars, ta=0, x;
    if (_url) c = c.substr(0,62) + '-_';
    for (i=0; i<str.length; i++) {
      x = c.indexOf(str.charAt(i));
      if (x < 0) {
        throw new sjcl.exception.invalid("this isn't base64!");
      }
      if (bits > 26) {
        bits -= 26;
        out.push(ta ^ x>>>bits);
        ta  = x << (32-bits);
      } else {
        bits += 6;
        ta ^= x << (32-bits);
      }
    }
    if (bits&56) {
      out.push(sjcl.bitArray.partial(bits&56, ta, 1));
    }
    return out;
  }
};

sjcl.codec.base64url = {
  fromBits: function (arr) { return sjcl.codec.base64.fromBits(arr,1,1); },
  toBits: function (str) { return sjcl.codec.base64.toBits(str,1); }
};

/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** @namespace Arrays of bytes */
sjcl.codec.bytes = {
  /** Convert from a bitArray to an array of bytes. */
  fromBits: function (arr) {
    var out = [], bl = sjcl.bitArray.bitLength(arr), i, tmp;
    for (i=0; i<bl/8; i++) {
      if ((i&3) === 0) {
        tmp = arr[i/4];
      }
      out.push(tmp >>> 24);
      tmp <<= 8;
    }
    return out;
  },
  /** Convert from an array of bytes to a bitArray. */
  toBits: function (bytes) {
    var out = [], i, tmp=0;
    for (i=0; i<bytes.length; i++) {
      tmp = tmp << 8 | bytes[i];
      if ((i&3) === 3) {
        out.push(tmp);
        tmp = 0;
      }
    }
    if (i&3) {
      out.push(sjcl.bitArray.partial(8*(i&3), tmp));
    }
    return out;
  }
};

/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** @namespace Hexadecimal */
sjcl.codec.hex = {
  /** Convert from a bitArray to a hex string. */
  fromBits: function (arr) {
    var out = "", i, x;
    for (i=0; i<arr.length; i++) {
      out += ((arr[i]|0)+0xF00000000000).toString(16).substr(4);
    }
    return out.substr(0, sjcl.bitArray.bitLength(arr)/4);//.replace(/(.{8})/g, "$1 ");
  },
  /** Convert from a hex string to a bitArray. */
  toBits: function (str) {
    var i, out=[], len;
    str = str.replace(/\s|0x/g, "");
    len = str.length;
    str = str + "00000000";
    for (i=0; i<str.length; i+=8) {
      out.push(parseInt(str.substr(i,8),16)^0);
    }
    return sjcl.bitArray.clamp(out, len*4);
  }
};


/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */
 
/** @namespace UTF-8 strings */
sjcl.codec.utf8String = {
  /** Convert from a bitArray to a UTF-8 string. */
  fromBits: function (arr) {
    var out = "", bl = sjcl.bitArray.bitLength(arr), i, tmp;
    for (i=0; i<bl/8; i++) {
      if ((i&3) === 0) {
        tmp = arr[i/4];
      }
      out += String.fromCharCode(tmp >>> 24);
      tmp <<= 8;
    }
    return decodeURIComponent(escape(out));
  },
  
  /** Convert from a UTF-8 string to a bitArray. */
  toBits: function (str) {
    str = unescape(encodeURIComponent(str));
    var out = [], i, tmp=0;
    for (i=0; i<str.length; i++) {
      tmp = tmp << 8 | str.charCodeAt(i);
      if ((i&3) === 3) {
        out.push(tmp);
        tmp = 0;
      }
    }
    if (i&3) {
      out.push(sjcl.bitArray.partial(8*(i&3), tmp));
    }
    return out;
  }
};

/** @fileOverview HMAC implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** HMAC with the specified hash function.
 * @constructor
 * @param {bitArray} key the key for HMAC.
 * @param {Object} [hash=sjcl.hash.sha256] The hash function to use.
 */
sjcl.misc.hmac = function (key, Hash) {
  this._hash = Hash = Hash || sjcl.hash.sha256;
  var exKey = [[],[]], i,
      bs = Hash.prototype.blockSize / 32;
  this._baseHash = [new Hash(), new Hash()];

  if (key.length > bs) {
    key = Hash.hash(key);
  }
  
  for (i=0; i<bs; i++) {
    exKey[0][i] = key[i]^0x36363636;
    exKey[1][i] = key[i]^0x5C5C5C5C;
  }
  
  this._baseHash[0].update(exKey[0]);
  this._baseHash[1].update(exKey[1]);
};

/** HMAC with the specified hash function.  Also called encrypt since it's a prf.
 * @param {bitArray|String} data The data to mac.
 * @param {Codec} [encoding] the encoding function to use.
 */
sjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data, encoding) {
  var w = new (this._hash)(this._baseHash[0]).update(data, encoding).finalize();
  return new (this._hash)(this._baseHash[1]).update(w).finalize();
};


/** @fileOverview Password-based key-derivation function, version 2.0.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** Password-Based Key-Derivation Function, version 2.0.
 *
 * Generate keys from passwords using PBKDF2-HMAC-SHA256.
 *
 * This is the method specified by RSA's PKCS #5 standard.
 *
 * @param {bitArray|String} password  The password.
 * @param {bitArray} salt The salt.  Should have lots of entropy.
 * @param {Number} [count=1000] The number of iterations.  Higher numbers make the function slower but more secure.
 * @param {Number} [length] The length of the derived key.  Defaults to the
                            output size of the hash function.
 * @param {Object} [Prff=sjcl.misc.hmac] The pseudorandom function family.
 * @return {bitArray} the derived key.
 */
sjcl.misc.pbkdf2 = function (password, salt, count, length, Prff) {
  count = count || 1000;
  
  if (length < 0 || count < 0) {
    throw sjcl.exception.invalid("invalid params to pbkdf2");
  }
  
  if (typeof password === "string") {
    password = sjcl.codec.utf8String.toBits(password);
  }
  
  Prff = Prff || sjcl.misc.hmac;
  
  var prf = new Prff(password),
      u, ui, i, j, k, out = [], b = sjcl.bitArray;

  for (k = 1; 32 * out.length < (length || 1); k++) {
    u = ui = prf.encrypt(b.concat(salt,[k]));
    
    for (i=1; i<count; i++) {
      ui = prf.encrypt(ui);
      for (j=0; j<ui.length; j++) {
        u[j] ^= ui[j];
      }
    }
    
    out = out.concat(u);
  }

  if (length) { out = b.clamp(out, length); }

  return out;
};

/** @fileOverview Low-level AES implementation.
 *
 * This file contains a low-level implementation of AES, optimized for
 * size and for efficiency on several browsers.  It is based on
 * OpenSSL's aes_core.c, a public-domain implementation by Vincent
 * Rijmen, Antoon Bosselaers and Paulo Barreto.
 *
 * An older version of this implementation is available in the public
 * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
 * Stanford University 2008-2010 and BSD-licensed for liability
 * reasons.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Schedule out an AES key for both encryption and decryption.  This
 * is a low-level class.  Use a cipher mode to do bulk encryption.
 *
 * @constructor
 * @param {Array} key The key as an array of 4, 6 or 8 words.
 *
 * @class Advanced Encryption Standard (low-level interface)
 */
sjcl.cipher.aes = function (key) {
  if (!this._tables[0][0][0]) {
    this._precompute();
  }
  
  var i, j, tmp,
    encKey, decKey,
    sbox = this._tables[0][4], decTable = this._tables[1],
    keyLen = key.length, rcon = 1;
  
  if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
    throw new sjcl.exception.invalid("invalid aes key size");
  }
  
  this._key = [encKey = key.slice(0), decKey = []];
  
  // schedule encryption keys
  for (i = keyLen; i < 4 * keyLen + 28; i++) {
    tmp = encKey[i-1];
    
    // apply sbox
    if (i%keyLen === 0 || (keyLen === 8 && i%keyLen === 4)) {
      tmp = sbox[tmp>>>24]<<24 ^ sbox[tmp>>16&255]<<16 ^ sbox[tmp>>8&255]<<8 ^ sbox[tmp&255];
      
      // shift rows and add rcon
      if (i%keyLen === 0) {
        tmp = tmp<<8 ^ tmp>>>24 ^ rcon<<24;
        rcon = rcon<<1 ^ (rcon>>7)*283;
      }
    }
    
    encKey[i] = encKey[i-keyLen] ^ tmp;
  }
  
  // schedule decryption keys
  for (j = 0; i; j++, i--) {
    tmp = encKey[j&3 ? i : i - 4];
    if (i<=4 || j<4) {
      decKey[j] = tmp;
    } else {
      decKey[j] = decTable[0][sbox[tmp>>>24      ]] ^
                  decTable[1][sbox[tmp>>16  & 255]] ^
                  decTable[2][sbox[tmp>>8   & 255]] ^
                  decTable[3][sbox[tmp      & 255]];
    }
  }
};

sjcl.cipher.aes.prototype = {
  // public
  /* Something like this might appear here eventually
  name: "AES",
  blockSize: 4,
  keySizes: [4,6,8],
  */
  
  /**
   * Encrypt an array of 4 big-endian words.
   * @param {Array} data The plaintext.
   * @return {Array} The ciphertext.
   */
  encrypt:function (data) { return this._crypt(data,0); },
  
  /**
   * Decrypt an array of 4 big-endian words.
   * @param {Array} data The ciphertext.
   * @return {Array} The plaintext.
   */
  decrypt:function (data) { return this._crypt(data,1); },
  
  /**
   * The expanded S-box and inverse S-box tables.  These will be computed
   * on the client so that we don't have to send them down the wire.
   *
   * There are two tables, _tables[0] is for encryption and
   * _tables[1] is for decryption.
   *
   * The first 4 sub-tables are the expanded S-box with MixColumns.  The
   * last (_tables[01][4]) is the S-box itself.
   *
   * @private
   */
  _tables: [[[],[],[],[],[]],[[],[],[],[],[]]],

  /**
   * Expand the S-box tables.
   *
   * @private
   */
  _precompute: function () {
   var encTable = this._tables[0], decTable = this._tables[1],
       sbox = encTable[4], sboxInv = decTable[4],
       i, x, xInv, d=[], th=[], x2, x4, x8, s, tEnc, tDec;

    // Compute double and third tables
   for (i = 0; i < 256; i++) {
     th[( d[i] = i<<1 ^ (i>>7)*283 )^i]=i;
   }
   
   for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
     // Compute sbox
     s = xInv ^ xInv<<1 ^ xInv<<2 ^ xInv<<3 ^ xInv<<4;
     s = s>>8 ^ s&255 ^ 99;
     sbox[x] = s;
     sboxInv[s] = x;
     
     // Compute MixColumns
     x8 = d[x4 = d[x2 = d[x]]];
     tDec = x8*0x1010101 ^ x4*0x10001 ^ x2*0x101 ^ x*0x1010100;
     tEnc = d[s]*0x101 ^ s*0x1010100;
     
     for (i = 0; i < 4; i++) {
       encTable[i][x] = tEnc = tEnc<<24 ^ tEnc>>>8;
       decTable[i][s] = tDec = tDec<<24 ^ tDec>>>8;
     }
   }
   
   // Compactify.  Considerable speedup on Firefox.
   for (i = 0; i < 5; i++) {
     encTable[i] = encTable[i].slice(0);
     decTable[i] = decTable[i].slice(0);
   }
  },
  
  /**
   * Encryption and decryption core.
   * @param {Array} input Four words to be encrypted or decrypted.
   * @param dir The direction, 0 for encrypt and 1 for decrypt.
   * @return {Array} The four encrypted or decrypted words.
   * @private
   */
  _crypt:function (input, dir) {
    if (input.length !== 4) {
      throw new sjcl.exception.invalid("invalid aes block size");
    }
    
    var key = this._key[dir],
        // state variables a,b,c,d are loaded with pre-whitened data
        a = input[0]           ^ key[0],
        b = input[dir ? 3 : 1] ^ key[1],
        c = input[2]           ^ key[2],
        d = input[dir ? 1 : 3] ^ key[3],
        a2, b2, c2,
        
        nInnerRounds = key.length/4 - 2,
        i,
        kIndex = 4,
        out = [0,0,0,0],
        table = this._tables[dir],
        
        // load up the tables
        t0    = table[0],
        t1    = table[1],
        t2    = table[2],
        t3    = table[3],
        sbox  = table[4];
 
    // Inner rounds.  Cribbed from OpenSSL.
    for (i = 0; i < nInnerRounds; i++) {
      a2 = t0[a>>>24] ^ t1[b>>16 & 255] ^ t2[c>>8 & 255] ^ t3[d & 255] ^ key[kIndex];
      b2 = t0[b>>>24] ^ t1[c>>16 & 255] ^ t2[d>>8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
      c2 = t0[c>>>24] ^ t1[d>>16 & 255] ^ t2[a>>8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
      d  = t0[d>>>24] ^ t1[a>>16 & 255] ^ t2[b>>8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
      kIndex += 4;
      a=a2; b=b2; c=c2;
    }
        
    // Last round.
    for (i = 0; i < 4; i++) {
      out[dir ? 3&-i : i] =
        sbox[a>>>24      ]<<24 ^ 
        sbox[b>>16  & 255]<<16 ^
        sbox[c>>8   & 255]<<8  ^
        sbox[d      & 255]     ^
        key[kIndex++];
      a2=a; a=b; b=c; c=d; d=a2;
    }
    
    return out;
  }
};


/** @fileOverview Javascript SHA-256 implementation.
 *
 * An older version of this implementation is available in the public
 * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
 * Stanford University 2008-2010 and BSD-licensed for liability
 * reasons.
 *
 * Special thanks to Aldo Cortesi for pointing out several bugs in
 * this code.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Context for a SHA-256 operation in progress.
 * @constructor
 * @class Secure Hash Algorithm, 256 bits.
 */
sjcl.hash.sha256 = function (hash) {
  if (!this._key[0]) { this._precompute(); }
  if (hash) {
    this._h = hash._h.slice(0);
    this._buffer = hash._buffer.slice(0);
    this._length = hash._length;
  } else {
    this.reset();
  }
};

/**
 * Hash a string or an array of words.
 * @static
 * @param {bitArray|String} data the data to hash.
 * @return {bitArray} The hash value, an array of 16 big-endian words.
 */
sjcl.hash.sha256.hash = function (data) {
  return (new sjcl.hash.sha256()).update(data).finalize();
};

sjcl.hash.sha256.prototype = {
  /**
   * The hash's block size, in bits.
   * @constant
   */
  blockSize: 512,
   
  /**
   * Reset the hash state.
   * @return this
   */
  reset:function () {
    this._h = this._init.slice(0);
    this._buffer = [];
    this._length = 0;
    return this;
  },
  
  /**
   * Input several words to the hash.
   * @param {bitArray|String} data the data to hash.
   * @return this
   */
  update: function (data) {
    if (typeof data === "string") {
      data = sjcl.codec.utf8String.toBits(data);
    }
    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),
        ol = this._length,
        nl = this._length = ol + sjcl.bitArray.bitLength(data);
    for (i = 512+ol & -512; i <= nl; i+= 512) {
      this._block(b.splice(0,16));
    }
    return this;
  },
  
  /**
   * Complete hashing and output the hash value.
   * @return {bitArray} The hash value, an array of 16 big-endian words.
   */
  finalize:function () {
    var i, b = this._buffer, h = this._h;

    // Round out and push the buffer
    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);
    
    // Round out the buffer to a multiple of 16 words, less the 2 length words.
    for (i = b.length + 2; i & 15; i++) {
      b.push(0);
    }
    
    // append the length
    b.push(Math.floor(this._length / 0x100000000));
    b.push(this._length | 0);

    while (b.length) {
      this._block(b.splice(0,16));
    }

    this.reset();
    return h;
  },

  /**
   * The SHA-256 initialization vector, to be precomputed.
   * @private
   */
  _init:[],
  /*
  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],
  */
  
  /**
   * The SHA-256 hash key, to be precomputed.
   * @private
   */
  _key:[],
  /*
  _key:
    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],
  */


  /**
   * Function to precompute _init and _key.
   * @private
   */
  _precompute: function () {
    var i = 0, prime = 2, factor;

    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }

    outer: for (; i<64; prime++) {
      for (factor=2; factor*factor <= prime; factor++) {
        if (prime % factor === 0) {
          // not a prime
          continue outer;
        }
      }
      
      if (i<8) {
        this._init[i] = frac(Math.pow(prime, 1/2));
      }
      this._key[i] = frac(Math.pow(prime, 1/3));
      i++;
    }
  },
  
  /**
   * Perform one cycle of SHA-256.
   * @param {bitArray} words one block of words.
   * @private
   */
  _block:function (words) {  
    var i, tmp, a, b,
      w = words.slice(0),
      h = this._h,
      k = this._key,
      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],
      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];

    /* Rationale for placement of |0 :
     * If a value can overflow is original 32 bits by a factor of more than a few
     * million (2^23 ish), there is a possibility that it might overflow the
     * 53-bit mantissa and lose precision.
     *
     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that
     * propagates around the loop, and on the hash state h[].  I don't believe
     * that the clamps on h4 and on h0 are strictly necessary, but it's close
     * (for h4 anyway), and better safe than sorry.
     *
     * The clamps on h[] are necessary for the output to be correct even in the
     * common case and for short inputs.
     */
    for (i=0; i<64; i++) {
      // load up the input word for this round
      if (i<16) {
        tmp = w[i];
      } else {
        a   = w[(i+1 ) & 15];
        b   = w[(i+14) & 15];
        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + 
                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +
                         w[i&15] + w[(i+9) & 15]) | 0;
      }
      
      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;
      
      // shift register
      h7 = h6; h6 = h5; h5 = h4;
      h4 = h3 + tmp | 0;
      h3 = h2; h2 = h1; h1 = h0;

      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;
    }

    h[0] = h[0]+h0 | 0;
    h[1] = h[1]+h1 | 0;
    h[2] = h[2]+h2 | 0;
    h[3] = h[3]+h3 | 0;
    h[4] = h[4]+h4 | 0;
    h[5] = h[5]+h5 | 0;
    h[6] = h[6]+h6 | 0;
    h[7] = h[7]+h7 | 0;
  }
};



/** @fileOverview Random number generator.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** @namespace Random number generator
 *
 * @description
 * <p>
 * This random number generator is a derivative of Ferguson and Schneier's
 * generator Fortuna.  It collects entropy from various events into several
 * pools, implemented by streaming SHA-256 instances.  It differs from
 * ordinary Fortuna in a few ways, though.
 * </p>
 *
 * <p>
 * Most importantly, it has an entropy estimator.  This is present because
 * there is a strong conflict here between making the generator available
 * as soon as possible, and making sure that it doesn't "run on empty".
 * In Fortuna, there is a saved state file, and the system is likely to have
 * time to warm up.
 * </p>
 *
 * <p>
 * Second, because users are unlikely to stay on the page for very long,
 * and to speed startup time, the number of pools increases logarithmically:
 * a new pool is created when the previous one is actually used for a reseed.
 * This gives the same asymptotic guarantees as Fortuna, but gives more
 * entropy to early reseeds.
 * </p>
 *
 * <p>
 * The entire mechanism here feels pretty klunky.  Furthermore, there are
 * several improvements that should be made, including support for
 * dedicated cryptographic functions that may be present in some browsers;
 * state files in local storage; cookies containing randomness; etc.  So
 * look for improvements in future versions.
 * </p>
 */
sjcl.random = function() {
  /** Generate several random words, and return them in an array
   * @param {Number} nwords The number of words to generate.
   */
  this.randomWords = function (nwords, paranoia) {
    var out = [], i, readiness = this.isReady(paranoia), g;
  
    if (readiness === this._NOT_READY) {
      throw new sjcl.exception.notReady("generator isn't seeded");
    } else if (readiness & this._REQUIRES_RESEED) {
      this._reseedFromPools(!(readiness & this._READY));
    }
  
    for (i=0; i<nwords; i+= 4) {
      if ((i+1) % this._MAX_WORDS_PER_BURST === 0) {
        this._gate();
      }
   
      g = this._gen4words();
      out.push(g[0],g[1],g[2],g[3]);
    }
    this._gate();
  
    return out.slice(0,nwords);
  };
  
  this.setDefaultParanoia = function (paranoia) {
    this._defaultParanoia = paranoia;
  };
  
  /**
   * Add entropy to the pools.
   * @param data The entropic value.  Should be a 32-bit integer, array of 32-bit integers, or string
   * @param {Number} estimatedEntropy The estimated entropy of data, in bits
   * @param {String} source The source of the entropy, eg "mouse"
   */
  this.addEntropy = function (data, estimatedEntropy, source) {
    source = source || "user";
  
    var id,
      i, tmp,
      t = (new Date()).valueOf(),
      robin = this._robins[source],
      oldReady = this.isReady(), err = 0;
      
    id = this._collectorIds[source];
    if (id === undefined) { id = this._collectorIds[source] = this._collectorIdNext ++; }
      
    if (robin === undefined) { robin = this._robins[source] = 0; }
    this._robins[source] = ( this._robins[source] + 1 ) % this._pools.length;
  
    switch(typeof(data)) {
      
    case "number":
      if (estimatedEntropy === undefined) {
        estimatedEntropy = 1;
      }
      this._pools[robin].update([id,this._eventId++,1,estimatedEntropy,t,1,data|0]);
      break;
      
    case "object":
      var objName = Object.prototype.toString.call(data);
      if (objName === "[object Uint32Array]") {
        tmp = [];
        for (i = 0; i < data.length; i++) {
          tmp.push(data[i]);
        }
        data = tmp;
      } else {
        if (objName !== "[object Array]") {
          err = 1;
        }
        for (i=0; i<data.length && !err; i++) {
          if (typeof(data[i]) != "number") {
            err = 1;
          }
        }
      }
      if (!err) {
        if (estimatedEntropy === undefined) {
          /* horrible entropy estimator */
          estimatedEntropy = 0;
          for (i=0; i<data.length; i++) {
            tmp= data[i];
            while (tmp>0) {
              estimatedEntropy++;
              tmp = tmp >>> 1;
            }
          }
        }
        this._pools[robin].update([id,this._eventId++,2,estimatedEntropy,t,data.length].concat(data));
      }
      break;
      
    case "string":
      if (estimatedEntropy === undefined) {
       /* English text has just over 1 bit per character of entropy.
        * But this might be HTML or something, and have far less
        * entropy than English...  Oh well, let's just say one bit.
        */
       estimatedEntropy = data.length;
      }
      this._pools[robin].update([id,this._eventId++,3,estimatedEntropy,t,data.length]);
      this._pools[robin].update(data);
      break;
      
    default:
      err=1;
    }
    if (err) {
      throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");
    }
  
    /* record the new strength */
    this._poolEntropy[robin] += estimatedEntropy;
    this._poolStrength += estimatedEntropy;
  
    /* fire off events */
    if (oldReady === this._NOT_READY) {
      if (this.isReady() !== this._NOT_READY) {
        this._fireEvent("seeded", Math.max(this._strength, this._poolStrength));
      }
      this._fireEvent("progress", this.getProgress());
    }
  };
  
  /** Is the generator ready? */
  this.isReady = function (paranoia) {
    var entropyRequired = this._PARANOIA_LEVELS[ (paranoia !== undefined) ? paranoia : this._defaultParanoia ];
  
    if (this._strength && this._strength >= entropyRequired) {
      return (this._poolEntropy[0] > this._BITS_PER_RESEED && (new Date()).valueOf() > this._nextReseed) ?
        this._REQUIRES_RESEED | this._READY :
        this._READY;
    } else {
      return (this._poolStrength >= entropyRequired) ?
        this._REQUIRES_RESEED | this._NOT_READY :
        this._NOT_READY;
    }
  };
  
  /** Get the generator's progress toward readiness, as a fraction */
  this.getProgress = function (paranoia) {
    var entropyRequired = this._PARANOIA_LEVELS[ paranoia ? paranoia : this._defaultParanoia ];
  
    if (this._strength >= entropyRequired) {
      return 1.0;
    } else {
      return (this._poolStrength > entropyRequired) ?
        1.0 :
        this._poolStrength / entropyRequired;
    }
  };
  
  /** start the built-in entropy collectors */
  this.startCollectors = function () {
    if (this._collectorsStarted) { return; }
  
    if (window.addEventListener) {
      window.addEventListener("load", this._loadTimeCollector, false);
      window.addEventListener("mousemove", this._mouseCollector, false);
    } else if (document.attachEvent) {
      document.attachEvent("onload", this._loadTimeCollector);
      document.attachEvent("onmousemove", this._mouseCollector);
    }
    else {
      throw new sjcl.exception.bug("can't attach event");
    }
  
    this._collectorsStarted = true;
  };
  
  /** stop the built-in entropy collectors */
  this.stopCollectors = function () {
    if (!this._collectorsStarted) { return; }
  
    if (window.removeEventListener) {
      window.removeEventListener("load", this._loadTimeCollector, false);
      window.removeEventListener("mousemove", this._mouseCollector, false);
    } else if (window.detachEvent) {
      window.detachEvent("onload", this._loadTimeCollector);
      window.detachEvent("onmousemove", this._mouseCollector);
    }
    this._collectorsStarted = false;
  };
  
  /* use a cookie to store entropy.
  useCookie: function (all_cookies) {
      throw new sjcl.exception.bug("random: useCookie is unimplemented");
  },*/
  
  /** add an event listener for progress or seeded-ness. */
  this.addEventListener = function (name, callback) {
    this._callbacks[name][this._callbackI++] = callback;
  };
  
  /** remove an event listener for progress or seeded-ness */
  this.removeEventListener = function (name, cb) {
    var i, j, cbs=this._callbacks[name], jsTemp=[];
  
    /* I'm not sure if this is necessary; in C++, iterating over a
     * collection and modifying it at the same time is a no-no.
     */
  
    for (j in cbs) {
	if (cbs.hasOwnProperty(j) && cbs[j] === cb) {
        jsTemp.push(j);
      }
    }
  
    for (i=0; i<jsTemp.length; i++) {
      j = jsTemp[i];
      delete cbs[j];
    }
  };
  
  /* private */
  this._pools                   = [new sjcl.hash.sha256()];
  this._poolEntropy             = [0];
  this._reseedCount             = 0;
  this._robins                  = {};
  this._eventId                 = 0;
  
  this._collectorIds            = {};
  this._collectorIdNext         = 0;
  
  this._strength                = 0;
  this._poolStrength            = 0;
  this._nextReseed              = 0;
  this._key                     = [0,0,0,0,0,0,0,0];
  this._counter                 = [0,0,0,0];
  this._cipher                  = undefined;
  this._defaultParanoia         = 6;
  
  /* event listener stuff */
  this._collectorsStarted       = false;
  this._callbacks               = {progress: {}, seeded: {}};
  this._callbackI               = 0;
  
  /* constants */
  this._NOT_READY               = 0;
  this._READY                   = 1;
  this._REQUIRES_RESEED         = 2;

  this._MAX_WORDS_PER_BURST     = 65536;
  this._PARANOIA_LEVELS         = [0,48,64,96,128,192,256,384,512,768,1024];
  this._MILLISECONDS_PER_RESEED = 30000;
  this._BITS_PER_RESEED         = 80;
  
  /** Generate 4 random words, no reseed, no gate.
   * @private
   */
  this._gen4words = function () {
    for (var i=0; i<4; i++) {
      this._counter[i] = this._counter[i]+1 | 0;
      if (this._counter[i]) { break; }
    }
    return this._cipher.encrypt(this._counter);
  };
  
  /* Rekey the AES instance with itself after a request, or every _MAX_WORDS_PER_BURST words.
   * @private
   */
  this._gate = function () {
    this._key = this._gen4words().concat(this._gen4words());
    this._cipher = new sjcl.cipher.aes(this._key);
  };
  
  /** Reseed the generator with the given words
   * @private
   */
  this._reseed = function (seedWords) {
    this._key = sjcl.hash.sha256.hash(this._key.concat(seedWords));
    this._cipher = new sjcl.cipher.aes(this._key);
    for (var i=0; i<4; i++) {
      this._counter[i] = this._counter[i]+1 | 0;
      if (this._counter[i]) { break; }
    }
  };
  
  /** reseed the data from the entropy pools
   * @param full If set, use all the entropy pools in the reseed.
   */
  this._reseedFromPools = function (full) {
    var reseedData = [], strength = 0, i;
  
    this._nextReseed = reseedData[0] =
      (new Date()).valueOf() + this._MILLISECONDS_PER_RESEED;
    
    for (i=0; i<16; i++) {
      /* On some browsers, this is cryptographically random.  So we might
       * as well toss it in the pot and stir...
       */
      reseedData.push(Math.random()*0x100000000|0);
    }
    
    for (i=0; i<this._pools.length; i++) {
     reseedData = reseedData.concat(this._pools[i].finalize());
     strength += this._poolEntropy[i];
     this._poolEntropy[i] = 0;
   
     if (!full && (this._reseedCount & (1<<i))) { break; }
    }
  
    /* if we used the last pool, push a new one onto the stack */
    if (this._reseedCount >= 1 << this._pools.length) {
     this._pools.push(new sjcl.hash.sha256());
     this._poolEntropy.push(0);
    }
  
    /* how strong was this reseed? */
    this._poolStrength -= strength;
    if (strength > this._strength) {
      this._strength = strength;
    }
  
    this._reseedCount ++;
    this._reseed(reseedData);
  };
  
  this._mouseCollector = function (ev) {
    var x = ev.x || ev.clientX || ev.offsetX || 0, y = ev.y || ev.clientY || ev.offsetY || 0;
    this.addEntropy([x,y], 2, "mouse");
  };
  
  this._loadTimeCollector = function (ev) {
    this.addEntropy((new Date()).valueOf(), 2, "loadtime");
  };
  
  this._fireEvent = function (name, arg) {
    var j, cbs=this._callbacks[name], cbsTemp=[];
    /* TODO: there is a race condition between removing collectors and firing them */ 

    /* I'm not sure if this is necessary; in C++, iterating over a
     * collection and modifying it at the same time is a no-no.
     */
  
    for (j in cbs) {
     if (cbs.hasOwnProperty(j)) {
        cbsTemp.push(cbs[j]);
     }
    }
  
    for (j=0; j<cbsTemp.length; j++) {
     cbsTemp[j](arg);
    }
  };
};

//(function(){
//  try {
//    // get cryptographically strong entropy in Webkit
//    var ab = new Uint32Array(32);
//    crypto.getRandomValues(ab);
//    this.addEntropy(ab, 1024, "crypto.getRandomValues");
//  } catch (e) {
//    // no getRandomValues :-(
//  }
//})();


if (typeof importScripts !== 'function') {
// v2.2

function bCrypt() {
	this.GENSALT_DEFAULT_LOG2_ROUNDS = 10;
	this.BCRYPT_SALT_LEN = 16;
	this.BLOWFISH_NUM_ROUNDS = 16;
	// commented next line because it is not used
//	this.PRNG = Clipperz.Crypto.PRNG.defaultRandomGenerator();
	this.MAX_EXECUTION_TIME = 100;
	this.P_orig = [0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822,
			0x299f31d0, 0x082efa98, 0xec4e6c89, 0x452821e6, 0x38d01377,
			0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5,
			0xb5470917, 0x9216d5d9, 0x8979fb1b];
	this.S_orig = [0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed,
			0x6a267e96, 0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7,
			0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3,
			0xf4933d7e, 0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee,
			0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013, 0xc5d1b023,
			0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e,
			0x6c9e0e8b, 0xb01e8a3e, 0xd71577c1, 0xbd314b27, 0x78af2fda,
			0x55605c60, 0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
			0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af,
			0x7c72e993, 0xb3ee1411, 0x636fbc2a, 0x2ba9c55d, 0x741831f6,
			0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c, 0x7a325381,
			0x28958677, 0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,
			0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032, 0xef845d5d,
			0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5,
			0x0f6d6ff3, 0x83f44239, 0x2e0b4482, 0xa4842004, 0x69c8f04a,
			0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
			0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c,
			0x137a3be4, 0xba3bf050, 0x7efb2a98, 0xa1f1651d, 0x39af0176,
			0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3,
			0x3b8b5ebe, 0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6,
			0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d, 0x37d0d724,
			0xd00a1248, 0xdb0fead3, 0x49f1c09b, 0x075372c9, 0x80991b7b,
			0x25d479d8, 0xf6e8def7, 0xe3fe501a, 0xb6794c3b, 0x976ce0bd,
			0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
			0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f,
			0x9b30952c, 0xcc814544, 0xaf5ebd09, 0xbee3d004, 0xde334afd,
			0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39,
			0xb9d3fbdb, 0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279,
			0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8, 0x3c7516df,
			0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760,
			0x53317b48, 0x3e00df82, 0x9e5c57bb, 0xca6f8ca0, 0x1a87562e,
			0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,
			0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0, 0x10fa3d98,
			0xfd2183b8, 0x4afcb56c, 0x2dd1d35b, 0x9a53e479, 0xb6f84565,
			0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341,
			0xcee4c6e8, 0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,
			0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0, 0xd08ed1d0,
			0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64,
			0x8888b812, 0x900df01c, 0x4fad5ea0, 0x688fc31c, 0xd1cff191,
			0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
			0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0,
			0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9, 0x165fa266, 0x80957705,
			0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5,
			0xfb9d35cf, 0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49,
			0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af, 0x2464369b,
			0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f,
			0x207d5ba2, 0x02e5b9c5, 0x83260376, 0x6295cfa9, 0x11c81968,
			0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
			0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5,
			0x571be91f, 0xf296ec6b, 0x2a0dd915, 0xb6636521, 0xe7b9f9b6,
			0xff34052e, 0xc5855664, 0x53b02d5d, 0xa99f8fa1, 0x08ba4799,
			0x6e85076a, 0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623,
			0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266, 0xecaa8c71,
			0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29,
			0xa0591340, 0xe4183a3e, 0x3f54989a, 0x5b429d65, 0x6b8fe4d6,
			0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
			0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f,
			0x3ebaefc9, 0x3c971814, 0x6b6a70a1, 0x687f3584, 0x52a0e286,
			0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c, 0x8e7d44ec,
			0x5716f2b8, 0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,
			0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd, 0xd19113f9,
			0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc,
			0xc8b57634, 0x9af3dda7, 0xa9446146, 0x0fd0030e, 0xecc8c73e,
			0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,
			0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290,
			0x24977c79, 0x5679b072, 0xbcaf89af, 0xde9a771f, 0xd9930810,
			0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6,
			0x9f84cd87, 0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,
			0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 0xef1c1847,
			0x3215d908, 0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451,
			0x50940002, 0x133ae4dd, 0x71dff89e, 0x10314e55, 0x81ac77d6,
			0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,
			0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570,
			0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 0x771fe71c, 0x4e3d06fa,
			0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978,
			0x9c10b36a, 0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4,
			0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960, 0x5223a708,
			0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883,
			0xb17f37d1, 0x018cff28, 0xc332ddef, 0xbe6c5aa5, 0x65582185,
			0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
			0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830,
			0xeb61bd96, 0x0334fe1e, 0xaa0363cf, 0xb5735c90, 0x4c70a239,
			0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab,
			0xb2f3846e, 0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,
			0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7, 0x9b540b19,
			0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77,
			0x11ed935f, 0x16681281, 0x0e358829, 0xc7e61fd6, 0x96dedfa1,
			0x7858ba99, 0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
			0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef,
			0x34c6ffea, 0xfe28ed61, 0xee7c3c73, 0x5d4a14d9, 0xe864b7e3,
			0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15,
			0xfacb4fd0, 0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,
			0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250, 0xcf62a1f2,
			0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492,
			0x47848a0b, 0x5692b285, 0x095bbf00, 0xad19489d, 0x1462b174,
			0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
			0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759,
			0xcbee7460, 0x4085f2a7, 0xce77326e, 0xa6078084, 0x19f8509e,
			0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc,
			0x800bcadc, 0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9,
			0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340, 0xc5c43465,
			0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a,
			0xe6e39f2b, 0xdb83adf7, 0xe93d5a68, 0x948140f7, 0xf64c261c,
			0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
			0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e,
			0x97244546, 0x14214f74, 0xbf8b8840, 0x4d95fc1d, 0x96b591af,
			0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0,
			0x31cb8504, 0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,
			0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb, 0x68dc1462,
			0xd7486900, 0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c,
			0xb58ce006, 0x7af4d6b6, 0xaace1e7c, 0xd3375fec, 0xce78a399,
			0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
			0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74,
			0xdd5b4332, 0x6841e7f7, 0xca7820fb, 0xfb0af54e, 0xd8feb397,
			0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7,
			0xd096954b, 0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33,
			0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c, 0xfdf8e802,
			0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22,
			0x48c1133f, 0xc70f86dc, 0x07f9c9ee, 0x41041f0f, 0x404779a4,
			0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
			0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2,
			0x02e1329e, 0xaf664fd1, 0xcad18115, 0x6b2395e0, 0x333e92e1,
			0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c,
			0x2da2f728, 0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,
			0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e, 0x0a476341,
			0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8,
			0x991be14c, 0xdb6e6b0d, 0xc67b5510, 0x6d672c37, 0x2765d43b,
			0xdcd0e804, 0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
			0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88,
			0x515bad24, 0x7b9479bf, 0x763bd6eb, 0x37392eb3, 0xcc115979,
			0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc,
			0x782ef11c, 0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,
			0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9, 0x44421659,
			0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f,
			0xbebfe988, 0x64e4c3fe, 0x9dbc8057, 0xf0f7c086, 0x60787bf8,
			0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
			0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be,
			0xbde8ae24, 0x55464299, 0xbf582e61, 0x4e58f48f, 0xf2ddfda2,
			0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255,
			0x46fcd9b9, 0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2,
			0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c, 0xb90bace1,
			0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09,
			0x662d09a1, 0xc4324633, 0xe85a1f02, 0x09f0be8c, 0x4a99a025,
			0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,
			0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01,
			0xa70683fa, 0xa002b5c4, 0x0de6d027, 0x9af88c27, 0x773f8641,
			0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa,
			0x30dc7d62, 0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,
			0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76, 0x6f05e409,
			0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9,
			0x1ac15bb4, 0xd39eb8fc, 0xed545578, 0x08fca5b5, 0xd83d7cd3,
			0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
			0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837, 0xd79a3234,
			0x92638212, 0x670efa8e, 0x406000e0, 0x3a39ce37, 0xd3faf5cf,
			0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740,
			0x99bc9bbe, 0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,
			0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4, 0x5748ab2f,
			0xbc946e79, 0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d,
			0xd5730a1d, 0x4cd04dc6, 0x2939bbdb, 0xa9ba4650, 0xac9526e8,
			0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
			0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4, 0x83c061ba,
			0x9be96a4d, 0x8fe51550, 0xba645bd6, 0x2826a2f9, 0xa73a3ae1,
			0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69,
			0x77fa0a59, 0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593,
			0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51, 0x96d5ac3a,
			0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b,
			0x5ad6b472, 0x5a88f54c, 0xe029ac71, 0xe019a5e6, 0x47b0acfd,
			0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
			0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4,
			0x88f46dba, 0x03a16125, 0x0564f0bd, 0xc3eb9e15, 0x3c9057a2,
			0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb,
			0x26dcf319, 0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb,
			0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f, 0x4de81751,
			0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce,
			0x5121ce64, 0x774fbe32, 0xa8b6e37e, 0xc3293d46, 0x48de5369,
			0x6413e680, 0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,
			0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd,
			0x1b588d40, 0xccd2017f, 0x6bb4e3bb, 0xdda26a7e, 0x3a59ff45,
			0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb, 0x8d6612ae,
			0xbf3c6f47, 0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,
			0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 0x4040cb08,
			0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d,
			0x06b89fb4, 0xce6ea048, 0x6f3f3b82, 0x3520ab82, 0x011a1d4b,
			0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,
			0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e,
			0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 0x1a908749, 0xd44fbd9a,
			0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c,
			0xe0b12b4f, 0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c,
			0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525, 0xfae59361,
			0xceb69ceb, 0xc2a86459, 0x12baa8d1, 0xb6c1075e, 0xe3056a0c,
			0x10d25065, 0xcb03a442, 0xe0ec6e0e, 0x1698db3b, 0x4c98a0be,
			0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
			0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d,
			0x9b992f2e, 0xe60b6f47, 0x0fe3f11d, 0xe54cda54, 0x1edad891,
			0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5,
			0xf6fb2299, 0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02,
			0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc, 0xde966292,
			0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a,
			0x45e1d006, 0xc3f27b9a, 0xc9aa53fd, 0x62a80f00, 0xbb25bfe2,
			0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,
			0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0, 0xba38209c,
			0xf746ce76, 0x77afa1c5, 0x20756060, 0x85cbfe4e, 0x8ae88dd8,
			0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4,
			0xd6ebe1f9, 0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,
			0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6];
	this.bf_crypt_ciphertext = [0x4f727068, 0x65616e42, 0x65686f6c, 0x64657253];
	this.base64_code = ['.', '/', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',
			'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',
			'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',
			'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
			'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8',
			'9'];
	this.index_64 = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1,
			54, 55, 56, 57, 58, 59, 60, 61, 62, 63, -1, -1, -1, -1, -1, -1, -1,
			2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
			21, 22, 23, 24, 25, 26, 27, -1, -1, -1, -1, -1, -1, 28, 29, 30, 31,
			32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
			49, 50, 51, 52, 53, -1, -1, -1, -1, -1];
	this.P;
	this.S;
	this.lr;
	this.offp;
}
bCrypt.prototype.getByte = function(c) {
	var ret = 0;
	try {
		var b = c.charCodeAt(0);
	} catch (err) {
		b = c;
	}
	if (b > 127) {
		return -128 + (b % 128);
	} else {
		return b;
	}
};
bCrypt.prototype.encode_base64 = function(d, len) {
	var off = 0;
	var rs = [];
	var c1;
	var c2;
	if (len <= 0 || len > d.length)
		throw "Invalid len";
	while (off < len) {
		c1 = d[off++] & 0xff;
		rs.push(this.base64_code[(c1 >> 2) & 0x3f]);
		c1 = (c1 & 0x03) << 4;
		if (off >= len) {
			rs.push(this.base64_code[c1 & 0x3f]);
			break;
		}
		c2 = d[off++] & 0xff;
		c1 |= (c2 >> 4) & 0x0f;
		rs.push(this.base64_code[c1 & 0x3f]);
		c1 = (c2 & 0x0f) << 2;
		if (off >= len) {
			rs.push(this.base64_code[c1 & 0x3f]);
			break;
		}
		c2 = d[off++] & 0xff;
		c1 |= (c2 >> 6) & 0x03;
		rs.push(this.base64_code[c1 & 0x3f]);
		rs.push(this.base64_code[c2 & 0x3f]);
	}
	return rs.join('');
};
bCrypt.prototype.char64 = function(x) {
	var code = x.charCodeAt(0);
	if (code < 0 || code > this.index_64.length) {
		return -1;
	}
	return this.index_64[code];
};
bCrypt.prototype.decode_base64 = function(s, maxolen) {
	var off = 0;
	var slen = s.length;
	var olen = 0;
	var rs = [];
	var c1, c2, c3, c4, o;
	if (maxolen <= 0)
		throw "Invalid maxolen";
	while (off < slen - 1 && olen < maxolen) {
		c1 = this.char64(s.charAt(off++));
		c2 = this.char64(s.charAt(off++));
		if (c1 == -1 || c2 == -1) {
			break;
		}
		o = this.getByte(c1 << 2);
		o |= (c2 & 0x30) >> 4;
		rs.push(String.fromCharCode(o));
		if (++olen >= maxolen || off >= slen) {
			break;
		}
		c3 = this.char64(s.charAt(off++));
		if (c3 == -1) {
			break;
		}
		o = this.getByte((c2 & 0x0f) << 4);
		o |= (c3 & 0x3c) >> 2;
		rs.push(String.fromCharCode(o));
		if (++olen >= maxolen || off >= slen) {
			break;
		}
		c4 = this.char64(s.charAt(off++));
		o = this.getByte((c3 & 0x03) << 6);
		o |= c4;
		rs.push(String.fromCharCode(o));
		++olen;
	}
	var ret = [];
	for (off = 0; off < olen; off++) {
		ret.push(this.getByte(rs[off]));
	}
	return ret;
};
bCrypt.prototype.encipher = function(lr, off) {
	var i;
	var n;
	var l = lr[off];
	var r = lr[off + 1];

	l ^= this.P[0];
	for (i = 0; i <= this.BLOWFISH_NUM_ROUNDS - 2;) {
		// Feistel substitution on left word
		n = this.S[(l >> 24) & 0xff];
		n += this.S[0x100 | ((l >> 16) & 0xff)];
		n ^= this.S[0x200 | ((l >> 8) & 0xff)];
		n += this.S[0x300 | (l & 0xff)];
		r ^= n ^ this.P[++i];

		// Feistel substitution on right word
		n = this.S[(r >> 24) & 0xff];
		n += this.S[0x100 | ((r >> 16) & 0xff)];
		n ^= this.S[0x200 | ((r >> 8) & 0xff)];
		n += this.S[0x300 | (r & 0xff)];
		l ^= n ^ this.P[++i];
	}
	lr[off] = r ^ this.P[this.BLOWFISH_NUM_ROUNDS + 1];
	lr[off + 1] = l;
};
bCrypt.prototype.streamtoword = function(data, offp) {
	var i;
	var word = 0;
	var off = offp;
	for (i = 0; i < 4; i++) {
		word = (word << 8) | (data[off] & 0xff);
		off = (off + 1) % data.length;
	}
	this.offp = off;
	return word;
};
bCrypt.prototype.init_key = function() {
	this.P = this.P_orig.slice();
	this.S = this.S_orig.slice();
};
bCrypt.prototype.key = function(key) {
	var i;
	this.offp = 0;
	var lr = new Array(0x00000000, 0x00000000);
	var plen = this.P.length;
	var slen = this.S.length;

	for (i = 0; i < plen; i++) {
		this.P[i] = this.P[i] ^ this.streamtoword(key, this.offp);
	}
	for (i = 0; i < plen; i += 2) {
		this.encipher(lr, 0);
		this.P[i] = lr[0];
		this.P[i + 1] = lr[1];
	}

	for (i = 0; i < slen; i += 2) {
		this.encipher(lr, 0);
		this.S[i] = lr[0];
		this.S[i + 1] = lr[1];
	}
};
bCrypt.prototype.ekskey = function(data, key) {
	var i;
	this.offp = 0;
	var lr = new Array(0x00000000, 0x00000000);
	var plen = this.P.length;
	var slen = this.S.length;

	for (i = 0; i < plen; i++)
		this.P[i] = this.P[i] ^ this.streamtoword(key, this.offp);
	this.offp = 0;
	for (i = 0; i < plen; i += 2) {
		lr[0] ^= this.streamtoword(data, this.offp);
		lr[1] ^= this.streamtoword(data, this.offp);
		this.encipher(lr, 0);
		this.P[i] = lr[0];
		this.P[i + 1] = lr[1];
	}
	for (i = 0; i < slen; i += 2) {
		lr[0] ^= this.streamtoword(data, this.offp);
		lr[1] ^= this.streamtoword(data, this.offp);
		this.encipher(lr, 0);
		this.S[i] = lr[0];
		this.S[i + 1] = lr[1];
	}
};

// removed arguments.callee from original version because it is not allowed in strict mode
bCrypt.prototype.crypt_raw = function(password, salt, log_rounds, callback, progress) {
	var rounds;
	var j;
	var cdata = this.bf_crypt_ciphertext.slice();
	var clen = cdata.length;
	var one_percent;

	if (log_rounds < 4 || log_rounds > 31)
		throw "Bad number of rounds";
	if (salt.length != this.BCRYPT_SALT_LEN)
		throw "Bad salt length";

	rounds = 1 << log_rounds;
	one_percent = Math.floor(rounds / 100) + 1;
	this.init_key();
	this.ekskey(salt, password);

	var obj = this;
	var i = 0;

	var roundFunction = null;
	roundFunction = function() {
		if (i < rounds) {
			var start = new Date();
			for (; i < rounds;) {
				i = i + 1;
				obj.key(password);
				obj.key(salt);
                if (i % one_percent == 0) {
                	progress();
        		}
                if ((new Date() - start) > obj.MAX_EXECUTION_TIME) {
            		break;
                }
            }
		    setTimeout(roundFunction, 0);
        } else {
        	for (i = 0; i < 64; i++) {
        		for (j = 0; j < (clen >> 1); j++) {
           			obj.encipher(cdata, j << 1);
        		}
    		}
			var ret = [];
	        for (i = 0; i < clen; i++) {
        		ret.push(obj.getByte((cdata[i] >> 24) & 0xff));
        		ret.push(obj.getByte((cdata[i] >> 16) & 0xff));
        		ret.push(obj.getByte((cdata[i] >> 8) & 0xff));
        		ret.push(obj.getByte(cdata[i] & 0xff));
    		}
    		callback(ret);
    	}
	};
	setTimeout(roundFunction, 0);
};
/*
 * callback: a function that will be passed the hash when it is complete
 * progress: optional - this function will be called every time 1% of hashing
 *      is complete.
 */
bCrypt.prototype.hashpw = function(password, salt, callback, progress) {
	var real_salt;
	var passwordb = [];
	var saltb = [];
	var hashed = [];
	var minor = String.fromCharCode(0);
	var rounds = 0;
	var off = 0;

	if (!progress) {
	        var progress = function() {};
	}

	if (salt.charAt(0) != '$' || salt.charAt(1) != '2')
		throw "Invalid salt version";
	if (salt.charAt(2) == '$')
		off = 3;
	else {
		minor = salt.charAt(2);
		if (minor != 'a' || salt.charAt(3) != '$')
			throw "Invalid salt revision";
		off = 4;
	}

	// Extract number of rounds
	if (salt.charAt(off + 2) > '$')
		throw "Missing salt rounds";
	var r1 = parseInt(salt.substring(off, off + 1)) * 10;
	var r2 = parseInt(salt.substring(off + 1, off + 2));
	rounds = r1 + r2;
	real_salt = salt.substring(off + 3, off + 25);
	password = password + (minor >= 'a' ? "\000" : "");
	for (var r = 0; r < password.length; r++) {
		passwordb.push(this.getByte(password.charAt(r)));
	}
	saltb = this.decode_base64(real_salt, this.BCRYPT_SALT_LEN);
	var obj = this;
	this.crypt_raw(passwordb, saltb, rounds, function(hashed) {
		var rs = [];
	        rs.push("$2");
	        if (minor >= 'a')
			rs.push(minor);
		rs.push("$");
        	if (rounds < 10)
			rs.push("0");
        	rs.push(rounds.toString());
	        rs.push("$");
	        rs.push(obj.encode_base64(saltb, saltb.length));
	        rs.push(obj.encode_base64(hashed, obj.bf_crypt_ciphertext.length * 4 - 1));
	        callback(rs.join(''));
	}, progress);
};

bCrypt.prototype.gensalt = function(rounds) {
	if (typeof(this.PRNG) == 'undefined')
		throw "PRNG not defined";
	if (!this.PRNG.isReadyToGenerateRandomValues())
		throw "PRNG is not ready to generate values, please wait";
	var iteration_count = rounds;
	if (iteration_count < 4 || iteration_count > 31) {
		iteration_count = this.GENSALT_DEFAULT_LOG2_ROUNDS;
	}
	var output = [];
	output.push("$2a$");
	if (iteration_count < 10)
		output.push("0");
	output.push(iteration_count.toString());
	output.push('$');
	output.push(this.encode_base64(this.PRNG.getRandomBytes(this.BCRYPT_SALT_LEN).arrayValues(), this.BCRYPT_SALT_LEN));
	return output.join('');
};

bCrypt.prototype.ready = function() {
	if (typeof(this.PRNG) == 'undefined' || !this.PRNG.isReadyToGenerateRandomValues()) {
		return false;
	}
	return true;
};

/**
 * bluebird build version 2.2.2
 * Features enabled: core, map, reduce, each
 * Features disabled: race, call_get, generators, nodeify, promisify, props, settle, some, progress, cancel, using, filter, any, timers
*/
/**
 * @preserve Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
var schedule = _dereq_("./schedule.js");
var Queue = _dereq_("./queue.js");
var errorObj = _dereq_("./util.js").errorObj;
var tryCatch1 = _dereq_("./util.js").tryCatch1;
var _process = typeof process !== "undefined" ? process : void 0;

function Async() {
    this._isTickUsed = false;
    this._schedule = schedule;
    this._length = 0;
    this._lateBuffer = new Queue(16);
    this._functionBuffer = new Queue(65536);
    var self = this;
    this.consumeFunctionBuffer = function Async$consumeFunctionBuffer() {
        self._consumeFunctionBuffer();
    };
}

Async.prototype.haveItemsQueued = function Async$haveItemsQueued() {
    return this._length > 0;
};

Async.prototype.invokeLater = function Async$invokeLater(fn, receiver, arg) {
    if (_process !== void 0 &&
        _process.domain != null &&
        !fn.domain) {
        fn = _process.domain.bind(fn);
    }
    this._lateBuffer.push(fn, receiver, arg);
    this._queueTick();
};

Async.prototype.invoke = function Async$invoke(fn, receiver, arg) {
    if (_process !== void 0 &&
        _process.domain != null &&
        !fn.domain) {
        fn = _process.domain.bind(fn);
    }
    var functionBuffer = this._functionBuffer;
    functionBuffer.push(fn, receiver, arg);
    this._length = functionBuffer.length();
    this._queueTick();
};

Async.prototype._consumeFunctionBuffer =
function Async$_consumeFunctionBuffer() {
    var functionBuffer = this._functionBuffer;
    while (functionBuffer.length() > 0) {
        var fn = functionBuffer.shift();
        var receiver = functionBuffer.shift();
        var arg = functionBuffer.shift();
        fn.call(receiver, arg);
    }
    this._reset();
    this._consumeLateBuffer();
};

Async.prototype._consumeLateBuffer = function Async$_consumeLateBuffer() {
    var buffer = this._lateBuffer;
    while(buffer.length() > 0) {
        var fn = buffer.shift();
        var receiver = buffer.shift();
        var arg = buffer.shift();
        var res = tryCatch1(fn, receiver, arg);
        if (res === errorObj) {
            this._queueTick();
            if (fn.domain != null) {
                fn.domain.emit("error", res.e);
            } else {
                throw res.e;
            }
        }
    }
};

Async.prototype._queueTick = function Async$_queue() {
    if (!this._isTickUsed) {
        this._schedule(this.consumeFunctionBuffer);
        this._isTickUsed = true;
    }
};

Async.prototype._reset = function Async$_reset() {
    this._isTickUsed = false;
    this._length = 0;
};

module.exports = new Async();

},{"./queue.js":16,"./schedule.js":18,"./util.js":21}],2:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
var Promise = _dereq_("./promise.js")();
module.exports = Promise;
},{"./promise.js":13}],3:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
module.exports = function() {
var inherits = _dereq_("./util.js").inherits;
var defineProperty = _dereq_("./es5.js").defineProperty;

var rignore = new RegExp(
    "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|" +
    "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|" +
    "\\w*PromiseArray\\.\\w*PromiseArray|" +
    "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|" +
    "process._tickCallback|nextTick|Async\\$\\w+)\\b"
);

var rtraceline = null;
var formatStack = null;

function formatNonError(obj) {
    var str;
    if (typeof obj === "function") {
        str = "[function " +
            (obj.name || "anonymous") +
            "]";
    } else {
        str = obj.toString();
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
            try {
                var newStr = JSON.stringify(obj);
                str = newStr;
            }
            catch(e) {

            }
        }
        if (str.length === 0) {
            str = "(empty array)";
        }
    }
    return ("(<" + snip(str) + ">, no stack trace)");
}

function snip(str) {
    var maxChars = 41;
    if (str.length < maxChars) {
        return str;
    }
    return str.substr(0, maxChars - 3) + "...";
}

function CapturedTrace(ignoreUntil, isTopLevel) {
    this.captureStackTrace(CapturedTrace, isTopLevel);

}
inherits(CapturedTrace, Error);

CapturedTrace.prototype.captureStackTrace =
function CapturedTrace$captureStackTrace(ignoreUntil, isTopLevel) {
    captureStackTrace(this, ignoreUntil, isTopLevel);
};

CapturedTrace.possiblyUnhandledRejection =
function CapturedTrace$PossiblyUnhandledRejection(reason) {
    if (typeof console === "object") {
        var message;
        if (typeof reason === "object" || typeof reason === "function") {
            var stack = reason.stack;
            message = "Possibly unhandled " + formatStack(stack, reason);
        } else {
            message = "Possibly unhandled " + String(reason);
        }
        if (typeof console.error === "function" ||
            typeof console.error === "object") {
            console.error(message);
        } else if (typeof console.log === "function" ||
            typeof console.log === "object") {
            console.log(message);
        }
    }
};

CapturedTrace.combine = function CapturedTrace$Combine(current, prev) {
    var curLast = current.length - 1;
    for (var i = prev.length - 1; i >= 0; --i) {
        var line = prev[i];
        if (current[curLast] === line) {
            current.pop();
            curLast--;
        } else {
            break;
        }
    }

    current.push("From previous event:");
    var lines = current.concat(prev);

    var ret = [];

    for (var i = 0, len = lines.length; i < len; ++i) {

        if ((rignore.test(lines[i]) ||
            (i > 0 && !rtraceline.test(lines[i])) &&
            lines[i] !== "From previous event:")
       ) {
            continue;
        }
        ret.push(lines[i]);
    }
    return ret;
};

CapturedTrace.protectErrorMessageNewlines = function(stack) {
    for (var i = 0; i < stack.length; ++i) {
        if (rtraceline.test(stack[i])) {
            break;
        }
    }

    if (i <= 1) return;

    var errorMessageLines = [];
    for (var j = 0; j < i; ++j) {
        errorMessageLines.push(stack.shift());
    }
    stack.unshift(errorMessageLines.join("\u0002\u0000\u0001"));
};

CapturedTrace.isSupported = function CapturedTrace$IsSupported() {
    return typeof captureStackTrace === "function";
};

var captureStackTrace = (function stackDetection() {
    if (typeof Error.stackTraceLimit === "number" &&
        typeof Error.captureStackTrace === "function") {
        rtraceline = /^\s*at\s*/;
        formatStack = function(stack, error) {
            if (typeof stack === "string") return stack;

            if (error.name !== void 0 &&
                error.message !== void 0) {
                return error.name + ". " + error.message;
            }
            return formatNonError(error);


        };
        var captureStackTrace = Error.captureStackTrace;
        return function CapturedTrace$_captureStackTrace(
            receiver, ignoreUntil) {
            captureStackTrace(receiver, ignoreUntil);
        };
    }
    var err = new Error();

    if (typeof err.stack === "string" &&
        typeof "".startsWith === "function" &&
        (err.stack.startsWith("stackDetection@")) &&
        stackDetection.name === "stackDetection") {

        defineProperty(Error, "stackTraceLimit", {
            writable: true,
            enumerable: false,
            configurable: false,
            value: 25
        });
        rtraceline = /@/;
        var rline = /[@\n]/;

        formatStack = function(stack, error) {
            if (typeof stack === "string") {
                return (error.name + ". " + error.message + "\n" + stack);
            }

            if (error.name !== void 0 &&
                error.message !== void 0) {
                return error.name + ". " + error.message;
            }
            return formatNonError(error);
        };

        return function captureStackTrace(o) {
            var stack = new Error().stack;
            var split = stack.split(rline);
            var len = split.length;
            var ret = "";
            for (var i = 0; i < len; i += 2) {
                ret += split[i];
                ret += "@";
                ret += split[i + 1];
                ret += "\n";
            }
            o.stack = ret;
        };
    } else {
        formatStack = function(stack, error) {
            if (typeof stack === "string") return stack;

            if ((typeof error === "object" ||
                typeof error === "function") &&
                error.name !== void 0 &&
                error.message !== void 0) {
                return error.name + ". " + error.message;
            }
            return formatNonError(error);
        };

        return null;
    }
})();

return CapturedTrace;
};

},{"./es5.js":9,"./util.js":21}],4:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
module.exports = function(NEXT_FILTER) {
var util = _dereq_("./util.js");
var errors = _dereq_("./errors.js");
var tryCatch1 = util.tryCatch1;
var errorObj = util.errorObj;
var keys = _dereq_("./es5.js").keys;
var TypeError = errors.TypeError;

function CatchFilter(instances, callback, promise) {
    this._instances = instances;
    this._callback = callback;
    this._promise = promise;
}

function CatchFilter$_safePredicate(predicate, e) {
    var safeObject = {};
    var retfilter = tryCatch1(predicate, safeObject, e);

    if (retfilter === errorObj) return retfilter;

    var safeKeys = keys(safeObject);
    if (safeKeys.length) {
        errorObj.e = new TypeError(
            "Catch filter must inherit from Error "
          + "or be a simple predicate function");
        return errorObj;
    }
    return retfilter;
}

CatchFilter.prototype.doFilter = function CatchFilter$_doFilter(e) {
    var cb = this._callback;
    var promise = this._promise;
    var boundTo = promise._boundTo;
    for (var i = 0, len = this._instances.length; i < len; ++i) {
        var item = this._instances[i];
        var itemIsErrorType = item === Error ||
            (item != null && item.prototype instanceof Error);

        if (itemIsErrorType && e instanceof item) {
            var ret = tryCatch1(cb, boundTo, e);
            if (ret === errorObj) {
                NEXT_FILTER.e = ret.e;
                return NEXT_FILTER;
            }
            return ret;
        } else if (typeof item === "function" && !itemIsErrorType) {
            var shouldHandle = CatchFilter$_safePredicate(item, e);
            if (shouldHandle === errorObj) {
                var trace = errors.canAttach(errorObj.e)
                    ? errorObj.e
                    : new Error(errorObj.e + "");
                this._promise._attachExtraTrace(trace);
                e = errorObj.e;
                break;
            } else if (shouldHandle) {
                var ret = tryCatch1(cb, boundTo, e);
                if (ret === errorObj) {
                    NEXT_FILTER.e = ret.e;
                    return NEXT_FILTER;
                }
                return ret;
            }
        }
    }
    NEXT_FILTER.e = e;
    return NEXT_FILTER;
};

return CatchFilter;
};

},{"./errors.js":7,"./es5.js":9,"./util.js":21}],5:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
var util = _dereq_("./util.js");
var isPrimitive = util.isPrimitive;
var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;

module.exports = function(Promise) {
var returner = function Promise$_returner() {
    return this;
};
var thrower = function Promise$_thrower() {
    throw this;
};

var wrapper = function Promise$_wrapper(value, action) {
    if (action === 1) {
        return function Promise$_thrower() {
            throw value;
        };
    } else if (action === 2) {
        return function Promise$_returner() {
            return value;
        };
    }
};


Promise.prototype["return"] =
Promise.prototype.thenReturn =
function Promise$thenReturn(value) {
    if (wrapsPrimitiveReceiver && isPrimitive(value)) {
        return this._then(
            wrapper(value, 2),
            void 0,
            void 0,
            void 0,
            void 0
       );
    }
    return this._then(returner, void 0, void 0, value, void 0);
};

Promise.prototype["throw"] =
Promise.prototype.thenThrow =
function Promise$thenThrow(reason) {
    if (wrapsPrimitiveReceiver && isPrimitive(reason)) {
        return this._then(
            wrapper(reason, 1),
            void 0,
            void 0,
            void 0,
            void 0
       );
    }
    return this._then(thrower, void 0, void 0, reason, void 0);
};
};

},{"./util.js":21}],6:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
module.exports = function(Promise, INTERNAL) {
var PromiseReduce = Promise.reduce;

Promise.prototype.each = function Promise$each(fn) {
    return PromiseReduce(this, fn, null, INTERNAL);
};

Promise.each = function Promise$Each(promises, fn) {
    return PromiseReduce(promises, fn, null, INTERNAL);
};
};

},{}],7:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
var Objectfreeze = _dereq_("./es5.js").freeze;
var util = _dereq_("./util.js");
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, "isOperational", true);
    }
    catch(ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return ((e instanceof OperationalError) ||
        e["isOperational"] === true);
}

function isError(obj) {
    return obj instanceof Error;
}

function canAttach(obj) {
    return isError(obj);
}

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        this.message = typeof message === "string" ? message : defaultMessage;
        this.name = nameProperty;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch(e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}

var methods = ("join pop push shift unshift slice filter forEach some " +
    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

AggregateError.prototype.length = 0;
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};

function OperationalError(message) {
    this.name = "OperationalError";
    this.message = message;
    this.cause = message;
    this["isOperational"] = true;

    if (message instanceof Error) {
        this.message = message.message;
        this.stack = message.stack;
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }

}
inherits(OperationalError, Error);

var key = "__BluebirdErrorTypes__";
var errorTypes = Error[key];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    notEnumerableProp(Error, key, errorTypes);
}

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    canAttach: canAttach
};

},{"./es5.js":9,"./util.js":21}],8:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
module.exports = function(Promise) {
var TypeError = _dereq_('./errors.js').TypeError;

function apiRejection(msg) {
    var error = new TypeError(msg);
    var ret = Promise.rejected(error);
    var parent = ret._peekContext();
    if (parent != null) {
        parent._attachExtraTrace(error);
    }
    return ret;
}

return apiRejection;
};

},{"./errors.js":7}],9:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
var isES5 = (function(){
    "use strict";
    return this === void 0;
})();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        keys: Object.keys,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function ObjectKeys(o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    }

    var ObjectDefineProperty = function ObjectDefineProperty(o, key, desc) {
        o[key] = desc.value;
        return o;
    }

    var ObjectFreeze = function ObjectFreeze(obj) {
        return obj;
    }

    var ObjectGetPrototypeOf = function ObjectGetPrototypeOf(obj) {
        try {
            return Object(obj).constructor.prototype;
        }
        catch (e) {
            return proto;
        }
    }

    var ArrayIsArray = function ArrayIsArray(obj) {
        try {
            return str.call(obj) === "[object Array]";
        }
        catch(e) {
            return false;
        }
    }

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5
    };
}

},{}],10:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
module.exports = function(Promise, NEXT_FILTER, cast) {
var util = _dereq_("./util.js");
var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
var isPrimitive = util.isPrimitive;
var thrower = util.thrower;

function returnThis() {
    return this;
}
function throwThis() {
    throw this;
}
function return$(r) {
    return function Promise$_returner() {
        return r;
    };
}
function throw$(r) {
    return function Promise$_thrower() {
        throw r;
    };
}
function promisedFinally(ret, reasonOrValue, isFulfilled) {
    var then;
    if (wrapsPrimitiveReceiver && isPrimitive(reasonOrValue)) {
        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
    } else {
        then = isFulfilled ? returnThis : throwThis;
    }
    return ret._then(then, thrower, void 0, reasonOrValue, void 0);
}

function finallyHandler(reasonOrValue) {
    var promise = this.promise;
    var handler = this.handler;

    var ret = promise._isBound()
                    ? handler.call(promise._boundTo)
                    : handler();

    if (ret !== void 0) {
        var maybePromise = cast(ret, void 0);
        if (maybePromise instanceof Promise) {
            return promisedFinally(maybePromise, reasonOrValue,
                                    promise.isFulfilled());
        }
    }

    if (promise.isRejected()) {
        NEXT_FILTER.e = reasonOrValue;
        return NEXT_FILTER;
    } else {
        return reasonOrValue;
    }
}

function tapHandler(value) {
    var promise = this.promise;
    var handler = this.handler;

    var ret = promise._isBound()
                    ? handler.call(promise._boundTo, value)
                    : handler(value);

    if (ret !== void 0) {
        var maybePromise = cast(ret, void 0);
        if (maybePromise instanceof Promise) {
            return promisedFinally(maybePromise, value, true);
        }
    }
    return value;
}

Promise.prototype._passThroughHandler =
function Promise$_passThroughHandler(handler, isFinally) {
    if (typeof handler !== "function") return this.then();

    var promiseAndHandler = {
        promise: this,
        handler: handler
    };

    return this._then(
            isFinally ? finallyHandler : tapHandler,
            isFinally ? finallyHandler : void 0, void 0,
            promiseAndHandler, void 0);
};

Promise.prototype.lastly =
Promise.prototype["finally"] = function Promise$finally(handler) {
    return this._passThroughHandler(handler, true);
};

Promise.prototype.tap = function Promise$tap(handler) {
    return this._passThroughHandler(handler, false);
};
};

},{"./util.js":21}],11:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
module.exports =
function(Promise, PromiseArray, cast, INTERNAL) {
var util = _dereq_("./util.js");
var canEvaluate = util.canEvaluate;
var tryCatch1 = util.tryCatch1;
var errorObj = util.errorObj;


if (canEvaluate) {
    var thenCallback = function(i) {
        return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
    };

    var caller = function(count) {
        var values = [];
        for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
        return new Function("holder", "                                      \n\
            'use strict';                                                    \n\
            var callback = holder.fn;                                        \n\
            return callback(values);                                         \n\
            ".replace(/values/g, values.join(", ")));
    };
    var thenCallbacks = [];
    var callers = [void 0];
    for (var i = 1; i <= 5; ++i) {
        thenCallbacks.push(thenCallback(i));
        callers.push(caller(i));
    }

    var Holder = function(total, fn) {
        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
        this.fn = fn;
        this.total = total;
        this.now = 0;
    };

    Holder.prototype.callers = callers;
    Holder.prototype.checkFulfillment = function(promise) {
        var now = this.now;
        now++;
        var total = this.total;
        if (now >= total) {
            var handler = this.callers[total];
            var ret = tryCatch1(handler, void 0, this);
            if (ret === errorObj) {
                promise._rejectUnchecked(ret.e);
            } else if (!promise._tryFollow(ret)) {
                promise._fulfillUnchecked(ret);
            }
        } else {
            this.now = now;
        }
    };
}




Promise.join = function Promise$Join() {
    var last = arguments.length - 1;
    var fn;
    if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (last < 6 && canEvaluate) {
            var ret = new Promise(INTERNAL);
            ret._setTrace(void 0);
            var holder = new Holder(last, fn);
            var reject = ret._reject;
            var callbacks = thenCallbacks;
            for (var i = 0; i < last; ++i) {
                var maybePromise = cast(arguments[i], void 0);
                if (maybePromise instanceof Promise) {
                    if (maybePromise.isPending()) {
                        maybePromise._then(callbacks[i], reject,
                                           void 0, ret, holder);
                    } else if (maybePromise.isFulfilled()) {
                        callbacks[i].call(ret,
                                          maybePromise._settledValue, holder);
                    } else {
                        ret._reject(maybePromise._settledValue);
                        maybePromise._unsetRejectionIsUnhandled();
                    }
                } else {
                    callbacks[i].call(ret, maybePromise, holder);
                }
            }
            return ret;
        }
    }
    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
    var ret = new PromiseArray(args).promise();
    return fn !== void 0 ? ret.spread(fn) : ret;
};

};

},{"./util.js":21}],12:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
module.exports = function(Promise, PromiseArray, apiRejection, cast, INTERNAL) {
var util = _dereq_("./util.js");
var tryCatch3 = util.tryCatch3;
var errorObj = util.errorObj;
var PENDING = {};
var EMPTY_ARRAY = [];

function MappingPromiseArray(promises, fn, limit, _filter) {
    this.constructor$(promises);
    this._callback = fn;
    this._preservedValues = _filter === INTERNAL
        ? new Array(this.length())
        : null;
    this._limit = limit;
    this._inFlight = 0;
    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
    this._init$(void 0, -2);
}
util.inherits(MappingPromiseArray, PromiseArray);

MappingPromiseArray.prototype._init = function MappingPromiseArray$_init() {};

MappingPromiseArray.prototype._promiseFulfilled =
function MappingPromiseArray$_promiseFulfilled(value, index) {
    var values = this._values;
    if (values === null) return;

    var length = this.length();
    var preservedValues = this._preservedValues;
    var limit = this._limit;
    if (values[index] === PENDING) {
        values[index] = value;
        if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved()) return;
        }
    } else {
        if (limit >= 1 && this._inFlight >= limit) {
            values[index] = value;
            this._queue.push(index);
            return;
        }
        if (preservedValues !== null) preservedValues[index] = value;

        var callback = this._callback;
        var receiver = this._promise._boundTo;
        var ret = tryCatch3(callback, receiver, value, index, length);
        if (ret === errorObj) return this._reject(ret.e);

        var maybePromise = cast(ret, void 0);
        if (maybePromise instanceof Promise) {
            if (maybePromise.isPending()) {
                if (limit >= 1) this._inFlight++;
                values[index] = PENDING;
                return maybePromise._proxyPromiseArray(this, index);
            } else if (maybePromise.isFulfilled()) {
                ret = maybePromise.value();
            } else {
                maybePromise._unsetRejectionIsUnhandled();
                return this._reject(maybePromise.reason());
            }
        }
        values[index] = ret;
    }
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= length) {
        if (preservedValues !== null) {
            this._filter(values, preservedValues);
        } else {
            this._resolve(values);
        }

    }
};

MappingPromiseArray.prototype._drainQueue =
function MappingPromiseArray$_drainQueue() {
    var queue = this._queue;
    var limit = this._limit;
    var values = this._values;
    while (queue.length > 0 && this._inFlight < limit) {
        var index = queue.pop();
        this._promiseFulfilled(values[index], index);
    }
};

MappingPromiseArray.prototype._filter =
function MappingPromiseArray$_filter(booleans, values) {
    var len = values.length;
    var ret = new Array(len);
    var j = 0;
    for (var i = 0; i < len; ++i) {
        if (booleans[i]) ret[j++] = values[i];
    }
    ret.length = j;
    this._resolve(ret);
};

MappingPromiseArray.prototype.preservedValues =
function MappingPromiseArray$preserveValues() {
    return this._preservedValues;
};

function map(promises, fn, options, _filter) {
    var limit = typeof options === "object" && options !== null
        ? options.concurrency
        : 0;
    limit = typeof limit === "number" &&
        isFinite(limit) && limit >= 1 ? limit : 0;
    return new MappingPromiseArray(promises, fn, limit, _filter);
}

Promise.prototype.map = function Promise$map(fn, options) {
    if (typeof fn !== "function") return apiRejection("fn must be a function");

    return map(this, fn, options, null).promise();
};

Promise.map = function Promise$Map(promises, fn, options, _filter) {
    if (typeof fn !== "function") return apiRejection("fn must be a function");
    return map(promises, fn, options, _filter).promise();
};


};

},{"./util.js":21}],13:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
var old;
if (typeof Promise !== "undefined") old = Promise;
function noConflict(bluebird) {
    try { if (Promise === bluebird) Promise = old; }
    catch (e) {}
    return bluebird;
}
module.exports = function() {
var util = _dereq_("./util.js");
var async = _dereq_("./async.js");
var errors = _dereq_("./errors.js");

var INTERNAL = function(){};
var APPLY = {};
var NEXT_FILTER = {e: null};

var cast = _dereq_("./thenables.js")(Promise, INTERNAL);
var PromiseArray = _dereq_("./promise_array.js")(Promise, INTERNAL, cast);
var CapturedTrace = _dereq_("./captured_trace.js")();
var CatchFilter = _dereq_("./catch_filter.js")(NEXT_FILTER);
var PromiseResolver = _dereq_("./promise_resolver.js");

var isArray = util.isArray;

var errorObj = util.errorObj;
var tryCatch1 = util.tryCatch1;
var tryCatch2 = util.tryCatch2;
var tryCatchApply = util.tryCatchApply;
var RangeError = errors.RangeError;
var TypeError = errors.TypeError;
var CancellationError = errors.CancellationError;
var TimeoutError = errors.TimeoutError;
var OperationalError = errors.OperationalError;
var originatesFromRejection = errors.originatesFromRejection;
var markAsOriginatingFromRejection = errors.markAsOriginatingFromRejection;
var canAttach = errors.canAttach;
var thrower = util.thrower;
var apiRejection = _dereq_("./errors_api_rejection")(Promise);


var makeSelfResolutionError = function Promise$_makeSelfResolutionError() {
    return new TypeError("circular promise resolution chain");
};

function Promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("the promise constructor requires a resolver function");
    }
    if (this.constructor !== Promise) {
        throw new TypeError("the promise constructor cannot be invoked directly");
    }
    this._bitField = 0;
    this._fulfillmentHandler0 = void 0;
    this._rejectionHandler0 = void 0;
    this._promise0 = void 0;
    this._receiver0 = void 0;
    this._settledValue = void 0;
    this._boundTo = void 0;
    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
}

Promise.prototype.bind = function Promise$bind(thisArg) {
    var ret = new Promise(INTERNAL);
    ret._follow(this);
    ret._propagateFrom(this, 2 | 1);
    ret._setBoundTo(thisArg);
    return ret;
};

Promise.prototype.toString = function Promise$toString() {
    return "[object Promise]";
};

Promise.prototype.caught = Promise.prototype["catch"] =
function Promise$catch(fn) {
    var len = arguments.length;
    if (len > 1) {
        var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (typeof item === "function") {
                catchInstances[j++] = item;
            } else {
                var catchFilterTypeError =
                    new TypeError(
                        "A catch filter must be an error constructor "
                        + "or a filter function");

                this._attachExtraTrace(catchFilterTypeError);
                async.invoke(this._reject, this, catchFilterTypeError);
                return;
            }
        }
        catchInstances.length = j;
        fn = arguments[i];

        this._resetTrace();
        var catchFilter = new CatchFilter(catchInstances, fn, this);
        return this._then(void 0, catchFilter.doFilter, void 0,
            catchFilter, void 0);
    }
    return this._then(void 0, fn, void 0, void 0, void 0);
};

Promise.prototype.then =
function Promise$then(didFulfill, didReject, didProgress) {
    return this._then(didFulfill, didReject, didProgress,
        void 0, void 0);
};


Promise.prototype.done =
function Promise$done(didFulfill, didReject, didProgress) {
    var promise = this._then(didFulfill, didReject, didProgress,
        void 0, void 0);
    promise._setIsFinal();
};

Promise.prototype.spread = function Promise$spread(didFulfill, didReject) {
    return this._then(didFulfill, didReject, void 0,
        APPLY, void 0);
};

Promise.prototype.isCancellable = function Promise$isCancellable() {
    return !this.isResolved() &&
        this._cancellable();
};

Promise.prototype.toJSON = function Promise$toJSON() {
    var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: void 0,
        rejectionReason: void 0
    };
    if (this.isFulfilled()) {
        ret.fulfillmentValue = this._settledValue;
        ret.isFulfilled = true;
    } else if (this.isRejected()) {
        ret.rejectionReason = this._settledValue;
        ret.isRejected = true;
    }
    return ret;
};

Promise.prototype.all = function Promise$all() {
    return new PromiseArray(this).promise();
};


Promise.is = function Promise$Is(val) {
    return val instanceof Promise;
};

Promise.all = function Promise$All(promises) {
    return new PromiseArray(promises).promise();
};

Promise.prototype.error = function Promise$_error(fn) {
    return this.caught(originatesFromRejection, fn);
};

Promise.prototype._resolveFromSyncValue =
function Promise$_resolveFromSyncValue(value) {
    if (value === errorObj) {
        this._cleanValues();
        this._setRejected();
        this._settledValue = value.e;
        this._ensurePossibleRejectionHandled();
    } else {
        var maybePromise = cast(value, void 0);
        if (maybePromise instanceof Promise) {
            this._follow(maybePromise);
        } else {
            this._cleanValues();
            this._setFulfilled();
            this._settledValue = value;
        }
    }
};

Promise.method = function Promise$_Method(fn) {
    if (typeof fn !== "function") {
        throw new TypeError("fn must be a function");
    }
    return function Promise$_method() {
        var value;
        switch(arguments.length) {
        case 0: value = tryCatch1(fn, this, void 0); break;
        case 1: value = tryCatch1(fn, this, arguments[0]); break;
        case 2: value = tryCatch2(fn, this, arguments[0], arguments[1]); break;
        default:
            var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
            value = tryCatchApply(fn, args, this); break;
        }
        var ret = new Promise(INTERNAL);
        ret._setTrace(void 0);
        ret._resolveFromSyncValue(value);
        return ret;
    };
};

Promise.attempt = Promise["try"] = function Promise$_Try(fn, args, ctx) {
    if (typeof fn !== "function") {
        return apiRejection("fn must be a function");
    }
    var value = isArray(args)
        ? tryCatchApply(fn, args, ctx)
        : tryCatch1(fn, ctx, args);

    var ret = new Promise(INTERNAL);
    ret._setTrace(void 0);
    ret._resolveFromSyncValue(value);
    return ret;
};

Promise.defer = Promise.pending = function Promise$Defer() {
    var promise = new Promise(INTERNAL);
    promise._setTrace(void 0);
    return new PromiseResolver(promise);
};

Promise.bind = function Promise$Bind(thisArg) {
    var ret = new Promise(INTERNAL);
    ret._setTrace(void 0);
    ret._setFulfilled();
    ret._setBoundTo(thisArg);
    return ret;
};

Promise.cast = function Promise$_Cast(obj) {
    var ret = cast(obj, void 0);
    if (!(ret instanceof Promise)) {
        var val = ret;
        ret = new Promise(INTERNAL);
        ret._setTrace(void 0);
        ret._setFulfilled();
        ret._cleanValues();
        ret._settledValue = val;
    }
    return ret;
};

Promise.resolve = Promise.fulfilled = Promise.cast;

Promise.reject = Promise.rejected = function Promise$Reject(reason) {
    var ret = new Promise(INTERNAL);
    ret._setTrace(void 0);
    markAsOriginatingFromRejection(reason);
    ret._cleanValues();
    ret._setRejected();
    ret._settledValue = reason;
    if (!canAttach(reason)) {
        var trace = new Error(reason + "");
        ret._setCarriedStackTrace(trace);
    }
    ret._ensurePossibleRejectionHandled();
    return ret;
};

Promise.onPossiblyUnhandledRejection =
function Promise$OnPossiblyUnhandledRejection(fn) {
        CapturedTrace.possiblyUnhandledRejection = typeof fn === "function"
                                                    ? fn : void 0;
};

var unhandledRejectionHandled;
Promise.onUnhandledRejectionHandled =
function Promise$onUnhandledRejectionHandled(fn) {
    unhandledRejectionHandled = typeof fn === "function" ? fn : void 0;
};

var debugging = false || !!(
    typeof process !== "undefined" &&
    typeof process.execPath === "string" &&
    typeof process.env === "object" &&
    (process.env["BLUEBIRD_DEBUG"] ||
        process.env["NODE_ENV"] === "development")
);


Promise.longStackTraces = function Promise$LongStackTraces() {
    if (async.haveItemsQueued() &&
        debugging === false
   ) {
        throw new Error("cannot enable long stack traces after promises have been created");
    }
    debugging = CapturedTrace.isSupported();
};

Promise.hasLongStackTraces = function Promise$HasLongStackTraces() {
    return debugging && CapturedTrace.isSupported();
};

Promise.prototype._then =
function Promise$_then(
    didFulfill,
    didReject,
    didProgress,
    receiver,
    internalData
) {
    var haveInternalData = internalData !== void 0;
    var ret = haveInternalData ? internalData : new Promise(INTERNAL);

    if (!haveInternalData) {
        if (debugging) {
            var haveSameContext = this._peekContext() === this._traceParent;
            ret._traceParent = haveSameContext ? this._traceParent : this;
        }
        ret._propagateFrom(this, 7);
    }

    var callbackIndex =
        this._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);

    if (this.isResolved()) {
        async.invoke(this._queueSettleAt, this, callbackIndex);
    }

    return ret;
};

Promise.prototype._length = function Promise$_length() {
    return this._bitField & 262143;
};

Promise.prototype._isFollowingOrFulfilledOrRejected =
function Promise$_isFollowingOrFulfilledOrRejected() {
    return (this._bitField & 939524096) > 0;
};

Promise.prototype._isFollowing = function Promise$_isFollowing() {
    return (this._bitField & 536870912) === 536870912;
};

Promise.prototype._setLength = function Promise$_setLength(len) {
    this._bitField = (this._bitField & -262144) |
        (len & 262143);
};

Promise.prototype._setFulfilled = function Promise$_setFulfilled() {
    this._bitField = this._bitField | 268435456;
};

Promise.prototype._setRejected = function Promise$_setRejected() {
    this._bitField = this._bitField | 134217728;
};

Promise.prototype._setFollowing = function Promise$_setFollowing() {
    this._bitField = this._bitField | 536870912;
};

Promise.prototype._setIsFinal = function Promise$_setIsFinal() {
    this._bitField = this._bitField | 33554432;
};

Promise.prototype._isFinal = function Promise$_isFinal() {
    return (this._bitField & 33554432) > 0;
};

Promise.prototype._cancellable = function Promise$_cancellable() {
    return (this._bitField & 67108864) > 0;
};

Promise.prototype._setCancellable = function Promise$_setCancellable() {
    this._bitField = this._bitField | 67108864;
};

Promise.prototype._unsetCancellable = function Promise$_unsetCancellable() {
    this._bitField = this._bitField & (~67108864);
};

Promise.prototype._setRejectionIsUnhandled =
function Promise$_setRejectionIsUnhandled() {
    this._bitField = this._bitField | 2097152;
};

Promise.prototype._unsetRejectionIsUnhandled =
function Promise$_unsetRejectionIsUnhandled() {
    this._bitField = this._bitField & (~2097152);
    if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
    }
};

Promise.prototype._isRejectionUnhandled =
function Promise$_isRejectionUnhandled() {
    return (this._bitField & 2097152) > 0;
};

Promise.prototype._setUnhandledRejectionIsNotified =
function Promise$_setUnhandledRejectionIsNotified() {
    this._bitField = this._bitField | 524288;
};

Promise.prototype._unsetUnhandledRejectionIsNotified =
function Promise$_unsetUnhandledRejectionIsNotified() {
    this._bitField = this._bitField & (~524288);
};

Promise.prototype._isUnhandledRejectionNotified =
function Promise$_isUnhandledRejectionNotified() {
    return (this._bitField & 524288) > 0;
};

Promise.prototype._setCarriedStackTrace =
function Promise$_setCarriedStackTrace(capturedTrace) {
    this._bitField = this._bitField | 1048576;
    this._fulfillmentHandler0 = capturedTrace;
};

Promise.prototype._unsetCarriedStackTrace =
function Promise$_unsetCarriedStackTrace() {
    this._bitField = this._bitField & (~1048576);
    this._fulfillmentHandler0 = void 0;
};

Promise.prototype._isCarryingStackTrace =
function Promise$_isCarryingStackTrace() {
    return (this._bitField & 1048576) > 0;
};

Promise.prototype._getCarriedStackTrace =
function Promise$_getCarriedStackTrace() {
    return this._isCarryingStackTrace()
        ? this._fulfillmentHandler0
        : void 0;
};

Promise.prototype._receiverAt = function Promise$_receiverAt(index) {
    var ret = index === 0
        ? this._receiver0
        : this[(index << 2) + index - 5 + 4];
    if (this._isBound() && ret === void 0) {
        return this._boundTo;
    }
    return ret;
};

Promise.prototype._promiseAt = function Promise$_promiseAt(index) {
    return index === 0
        ? this._promise0
        : this[(index << 2) + index - 5 + 3];
};

Promise.prototype._fulfillmentHandlerAt =
function Promise$_fulfillmentHandlerAt(index) {
    return index === 0
        ? this._fulfillmentHandler0
        : this[(index << 2) + index - 5 + 0];
};

Promise.prototype._rejectionHandlerAt =
function Promise$_rejectionHandlerAt(index) {
    return index === 0
        ? this._rejectionHandler0
        : this[(index << 2) + index - 5 + 1];
};

Promise.prototype._addCallbacks = function Promise$_addCallbacks(
    fulfill,
    reject,
    progress,
    promise,
    receiver
) {
    var index = this._length();

    if (index >= 262143 - 5) {
        index = 0;
        this._setLength(0);
    }

    if (index === 0) {
        this._promise0 = promise;
        if (receiver !== void 0) this._receiver0 = receiver;
        if (typeof fulfill === "function" && !this._isCarryingStackTrace())
            this._fulfillmentHandler0 = fulfill;
        if (typeof reject === "function") this._rejectionHandler0 = reject;
        if (typeof progress === "function") this._progressHandler0 = progress;
    } else {
        var base = (index << 2) + index - 5;
        this[base + 3] = promise;
        this[base + 4] = receiver;
        this[base + 0] = typeof fulfill === "function"
                                            ? fulfill : void 0;
        this[base + 1] = typeof reject === "function"
                                            ? reject : void 0;
        this[base + 2] = typeof progress === "function"
                                            ? progress : void 0;
    }
    this._setLength(index + 1);
    return index;
};

Promise.prototype._setProxyHandlers =
function Promise$_setProxyHandlers(receiver, promiseSlotValue) {
    var index = this._length();

    if (index >= 262143 - 5) {
        index = 0;
        this._setLength(0);
    }
    if (index === 0) {
        this._promise0 = promiseSlotValue;
        this._receiver0 = receiver;
    } else {
        var base = (index << 2) + index - 5;
        this[base + 3] = promiseSlotValue;
        this[base + 4] = receiver;
        this[base + 0] =
        this[base + 1] =
        this[base + 2] = void 0;
    }
    this._setLength(index + 1);
};

Promise.prototype._proxyPromiseArray =
function Promise$_proxyPromiseArray(promiseArray, index) {
    this._setProxyHandlers(promiseArray, index);
};

Promise.prototype._proxyPromise = function Promise$_proxyPromise(promise) {
    promise._setProxied();
    this._setProxyHandlers(promise, -1);
};

Promise.prototype._setBoundTo = function Promise$_setBoundTo(obj) {
    if (obj !== void 0) {
        this._bitField = this._bitField | 8388608;
        this._boundTo = obj;
    } else {
        this._bitField = this._bitField & (~8388608);
    }
};

Promise.prototype._isBound = function Promise$_isBound() {
    return (this._bitField & 8388608) === 8388608;
};

Promise.prototype._resolveFromResolver =
function Promise$_resolveFromResolver(resolver) {
    var promise = this;
    this._setTrace(void 0);
    this._pushContext();

    function Promise$_resolver(val) {
        if (promise._tryFollow(val)) {
            return;
        }
        promise._fulfill(val);
    }
    function Promise$_rejecter(val) {
        var trace = canAttach(val) ? val : new Error(val + "");
        promise._attachExtraTrace(trace);
        markAsOriginatingFromRejection(val);
        promise._reject(val, trace === val ? void 0 : trace);
    }
    var r = tryCatch2(resolver, void 0, Promise$_resolver, Promise$_rejecter);
    this._popContext();

    if (r !== void 0 && r === errorObj) {
        var e = r.e;
        var trace = canAttach(e) ? e : new Error(e + "");
        promise._reject(e, trace);
    }
};

Promise.prototype._spreadSlowCase =
function Promise$_spreadSlowCase(targetFn, promise, values, boundTo) {
    var promiseForAll = new PromiseArray(values).promise();
    var promise2 = promiseForAll._then(function() {
        return targetFn.apply(boundTo, arguments);
    }, void 0, void 0, APPLY, void 0);
    promise._follow(promise2);
};

Promise.prototype._callSpread =
function Promise$_callSpread(handler, promise, value) {
    var boundTo = this._boundTo;
    if (isArray(value)) {
        for (var i = 0, len = value.length; i < len; ++i) {
            if (cast(value[i], void 0) instanceof Promise) {
                this._spreadSlowCase(handler, promise, value, boundTo);
                return;
            }
        }
    }
    promise._pushContext();
    return tryCatchApply(handler, value, boundTo);
};

Promise.prototype._callHandler =
function Promise$_callHandler(
    handler, receiver, promise, value) {
    var x;
    if (receiver === APPLY && !this.isRejected()) {
        x = this._callSpread(handler, promise, value);
    } else {
        promise._pushContext();
        x = tryCatch1(handler, receiver, value);
    }
    promise._popContext();
    return x;
};

Promise.prototype._settlePromiseFromHandler =
function Promise$_settlePromiseFromHandler(
    handler, receiver, value, promise
) {
    if (!(promise instanceof Promise)) {
        handler.call(receiver, value, promise);
        return;
    }
    var x = this._callHandler(handler, receiver, promise, value);
    if (promise._isFollowing()) return;

    if (x === errorObj || x === promise || x === NEXT_FILTER) {
        var err = x === promise
                    ? makeSelfResolutionError()
                    : x.e;
        var trace = canAttach(err) ? err : new Error(err + "");
        if (x !== NEXT_FILTER) promise._attachExtraTrace(trace);
        promise._rejectUnchecked(err, trace);
    } else {
        var castValue = cast(x, promise);
        if (castValue instanceof Promise) {
            if (castValue.isRejected() &&
                !castValue._isCarryingStackTrace() &&
                !canAttach(castValue._settledValue)) {
                var trace = new Error(castValue._settledValue + "");
                promise._attachExtraTrace(trace);
                castValue._setCarriedStackTrace(trace);
            }
            promise._follow(castValue);
            promise._propagateFrom(castValue, 1);
        } else {
            promise._fulfillUnchecked(x);
        }
    }
};

Promise.prototype._follow =
function Promise$_follow(promise) {
    this._setFollowing();

    if (promise.isPending()) {
        this._propagateFrom(promise, 1);
        promise._proxyPromise(this);
    } else if (promise.isFulfilled()) {
        this._fulfillUnchecked(promise._settledValue);
    } else {
        this._rejectUnchecked(promise._settledValue,
            promise._getCarriedStackTrace());
    }

    if (promise._isRejectionUnhandled()) promise._unsetRejectionIsUnhandled();

    if (debugging &&
        promise._traceParent == null) {
        promise._traceParent = this;
    }
};

Promise.prototype._tryFollow =
function Promise$_tryFollow(value) {
    if (this._isFollowingOrFulfilledOrRejected() ||
        value === this) {
        return false;
    }
    var maybePromise = cast(value, void 0);
    if (!(maybePromise instanceof Promise)) {
        return false;
    }
    this._follow(maybePromise);
    return true;
};

Promise.prototype._resetTrace = function Promise$_resetTrace() {
    if (debugging) {
        this._trace = new CapturedTrace(this._peekContext() === void 0);
    }
};

Promise.prototype._setTrace = function Promise$_setTrace(parent) {
    if (debugging) {
        var context = this._peekContext();
        this._traceParent = context;
        var isTopLevel = context === void 0;
        if (parent !== void 0 &&
            parent._traceParent === context) {
            this._trace = parent._trace;
        } else {
            this._trace = new CapturedTrace(isTopLevel);
        }
    }
    return this;
};

Promise.prototype._attachExtraTrace =
function Promise$_attachExtraTrace(error) {
    if (debugging) {
        var promise = this;
        var stack = error.stack;
        stack = typeof stack === "string" ? stack.split("\n") : [];
        CapturedTrace.protectErrorMessageNewlines(stack);
        var headerLineCount = 1;
        var combinedTraces = 1;
        while(promise != null &&
            promise._trace != null) {
            stack = CapturedTrace.combine(
                stack,
                promise._trace.stack.split("\n")
            );
            promise = promise._traceParent;
            combinedTraces++;
        }

        var stackTraceLimit = Error.stackTraceLimit || 10;
        var max = (stackTraceLimit + headerLineCount) * combinedTraces;
        var len = stack.length;
        if (len > max) {
            stack.length = max;
        }

        if (len > 0)
            stack[0] = stack[0].split("\u0002\u0000\u0001").join("\n");

        if (stack.length <= headerLineCount) {
            error.stack = "(No stack trace)";
        } else {
            error.stack = stack.join("\n");
        }
    }
};

Promise.prototype._cleanValues = function Promise$_cleanValues() {
    if (this._cancellable()) {
        this._cancellationParent = void 0;
    }
};

Promise.prototype._propagateFrom =
function Promise$_propagateFrom(parent, flags) {
    if ((flags & 1) > 0 && parent._cancellable()) {
        this._setCancellable();
        this._cancellationParent = parent;
    }
    if ((flags & 4) > 0) {
        this._setBoundTo(parent._boundTo);
    }
    if ((flags & 2) > 0) {
        this._setTrace(parent);
    }
};

Promise.prototype._fulfill = function Promise$_fulfill(value) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    this._fulfillUnchecked(value);
};

Promise.prototype._reject =
function Promise$_reject(reason, carriedStackTrace) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    this._rejectUnchecked(reason, carriedStackTrace);
};

Promise.prototype._settlePromiseAt = function Promise$_settlePromiseAt(index) {
    var handler = this.isFulfilled()
        ? this._fulfillmentHandlerAt(index)
        : this._rejectionHandlerAt(index);

    var value = this._settledValue;
    var receiver = this._receiverAt(index);
    var promise = this._promiseAt(index);

    if (typeof handler === "function") {
        this._settlePromiseFromHandler(handler, receiver, value, promise);
    } else {
        var done = false;
        var isFulfilled = this.isFulfilled();
        if (receiver !== void 0) {
            if (receiver instanceof Promise &&
                receiver._isProxied()) {
                receiver._unsetProxied();

                if (isFulfilled) receiver._fulfillUnchecked(value);
                else receiver._rejectUnchecked(value,
                    this._getCarriedStackTrace());
                done = true;
            } else if (receiver instanceof PromiseArray) {
                if (isFulfilled) receiver._promiseFulfilled(value, promise);
                else receiver._promiseRejected(value, promise);
                done = true;
            }
        }

        if (!done) {
            if (isFulfilled) promise._fulfill(value);
            else promise._reject(value, this._getCarriedStackTrace());
        }
    }

    if (index >= 256) {
        this._queueGC();
    }
};

Promise.prototype._isProxied = function Promise$_isProxied() {
    return (this._bitField & 4194304) === 4194304;
};

Promise.prototype._setProxied = function Promise$_setProxied() {
    this._bitField = this._bitField | 4194304;
};

Promise.prototype._unsetProxied = function Promise$_unsetProxied() {
    this._bitField = this._bitField & (~4194304);
};

Promise.prototype._isGcQueued = function Promise$_isGcQueued() {
    return (this._bitField & -1073741824) === -1073741824;
};

Promise.prototype._setGcQueued = function Promise$_setGcQueued() {
    this._bitField = this._bitField | -1073741824;
};

Promise.prototype._unsetGcQueued = function Promise$_unsetGcQueued() {
    this._bitField = this._bitField & (~-1073741824);
};

Promise.prototype._queueGC = function Promise$_queueGC() {
    if (this._isGcQueued()) return;
    this._setGcQueued();
    async.invokeLater(this._gc, this, void 0);
};

Promise.prototype._gc = function Promise$gc() {
    var len = this._length() * 5;
    for (var i = 0; i < len; i++) {
        delete this[i];
    }
    this._setLength(0);
    this._unsetGcQueued();
};

Promise.prototype._queueSettleAt = function Promise$_queueSettleAt(index) {
    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
    async.invoke(this._settlePromiseAt, this, index);
};

Promise.prototype._fulfillUnchecked =
function Promise$_fulfillUnchecked(value) {
    if (!this.isPending()) return;
    if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._rejectUnchecked(err, void 0);
    }
    this._cleanValues();
    this._setFulfilled();
    this._settledValue = value;
    var len = this._length();

    if (len > 0) {
        async.invoke(this._settlePromises, this, len);
    }
};

Promise.prototype._rejectUncheckedCheckError =
function Promise$_rejectUncheckedCheckError(reason) {
    var trace = canAttach(reason) ? reason : new Error(reason + "");
    this._rejectUnchecked(reason, trace === reason ? void 0 : trace);
};

Promise.prototype._rejectUnchecked =
function Promise$_rejectUnchecked(reason, trace) {
    if (!this.isPending()) return;
    if (reason === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._rejectUnchecked(err);
    }
    this._cleanValues();
    this._setRejected();
    this._settledValue = reason;

    if (this._isFinal()) {
        async.invokeLater(thrower, void 0, trace === void 0 ? reason : trace);
        return;
    }
    var len = this._length();

    if (trace !== void 0) this._setCarriedStackTrace(trace);

    if (len > 0) {
        async.invoke(this._rejectPromises, this, null);
    } else {
        this._ensurePossibleRejectionHandled();
    }
};

Promise.prototype._rejectPromises = function Promise$_rejectPromises() {
    this._settlePromises();
    this._unsetCarriedStackTrace();
};

Promise.prototype._settlePromises = function Promise$_settlePromises() {
    var len = this._length();
    for (var i = 0; i < len; i++) {
        this._settlePromiseAt(i);
    }
};

Promise.prototype._ensurePossibleRejectionHandled =
function Promise$_ensurePossibleRejectionHandled() {
    this._setRejectionIsUnhandled();
    if (CapturedTrace.possiblyUnhandledRejection !== void 0) {
        async.invokeLater(this._notifyUnhandledRejection, this, void 0);
    }
};

Promise.prototype._notifyUnhandledRejectionIsHandled =
function Promise$_notifyUnhandledRejectionIsHandled() {
    if (typeof unhandledRejectionHandled === "function") {
        async.invokeLater(unhandledRejectionHandled, void 0, this);
    }
};

Promise.prototype._notifyUnhandledRejection =
function Promise$_notifyUnhandledRejection() {
    if (this._isRejectionUnhandled()) {
        var reason = this._settledValue;
        var trace = this._getCarriedStackTrace();

        this._setUnhandledRejectionIsNotified();

        if (trace !== void 0) {
            this._unsetCarriedStackTrace();
            reason = trace;
        }
        if (typeof CapturedTrace.possiblyUnhandledRejection === "function") {
            CapturedTrace.possiblyUnhandledRejection(reason, this);
        }
    }
};

var contextStack = [];
Promise.prototype._peekContext = function Promise$_peekContext() {
    var lastIndex = contextStack.length - 1;
    if (lastIndex >= 0) {
        return contextStack[lastIndex];
    }
    return void 0;

};

Promise.prototype._pushContext = function Promise$_pushContext() {
    if (!debugging) return;
    contextStack.push(this);
};

Promise.prototype._popContext = function Promise$_popContext() {
    if (!debugging) return;
    contextStack.pop();
};

Promise.noConflict = function Promise$NoConflict() {
    return noConflict(Promise);
};

Promise.setScheduler = function(fn) {
    if (typeof fn !== "function") throw new TypeError("fn must be a function");
    async._schedule = fn;
};

if (!CapturedTrace.isSupported()) {
    Promise.longStackTraces = function(){};
    debugging = false;
}

Promise._makeSelfResolutionError = makeSelfResolutionError;
_dereq_("./finally.js")(Promise, NEXT_FILTER, cast);
_dereq_("./direct_resolve.js")(Promise);
_dereq_("./synchronous_inspection.js")(Promise);
_dereq_("./join.js")(Promise, PromiseArray, cast, INTERNAL);
Promise.RangeError = RangeError;
Promise.CancellationError = CancellationError;
Promise.TimeoutError = TimeoutError;
Promise.TypeError = TypeError;
Promise.OperationalError = OperationalError;
Promise.RejectionError = OperationalError;
Promise.AggregateError = errors.AggregateError;

util.toFastProperties(Promise);
util.toFastProperties(Promise.prototype);
Promise.Promise = Promise;
_dereq_('./reduce.js')(Promise,PromiseArray,apiRejection,cast,INTERNAL);
_dereq_('./map.js')(Promise,PromiseArray,apiRejection,cast,INTERNAL);
_dereq_('./each.js')(Promise,INTERNAL);

Promise.prototype = Promise.prototype;
return Promise;

};

},{"./async.js":1,"./captured_trace.js":3,"./catch_filter.js":4,"./direct_resolve.js":5,"./each.js":6,"./errors.js":7,"./errors_api_rejection":8,"./finally.js":10,"./join.js":11,"./map.js":12,"./promise_array.js":14,"./promise_resolver.js":15,"./reduce.js":17,"./synchronous_inspection.js":19,"./thenables.js":20,"./util.js":21}],14:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
module.exports = function(Promise, INTERNAL, cast) {
var canAttach = _dereq_("./errors.js").canAttach;
var util = _dereq_("./util.js");
var isArray = util.isArray;

function toResolutionValue(val) {
    switch(val) {
    case -1: return void 0;
    case -2: return [];
    case -3: return {};
    }
}

function PromiseArray(values) {
    var promise = this._promise = new Promise(INTERNAL);
    var parent = void 0;
    if (values instanceof Promise) {
        parent = values;
        promise._propagateFrom(parent, 1 | 4);
    }
    promise._setTrace(parent);
    this._values = values;
    this._length = 0;
    this._totalResolved = 0;
    this._init(void 0, -2);
}
PromiseArray.prototype.length = function PromiseArray$length() {
    return this._length;
};

PromiseArray.prototype.promise = function PromiseArray$promise() {
    return this._promise;
};

PromiseArray.prototype._init =
function PromiseArray$_init(_, resolveValueIfEmpty) {
    var values = cast(this._values, void 0);
    if (values instanceof Promise) {
        this._values = values;
        values._setBoundTo(this._promise._boundTo);
        if (values.isFulfilled()) {
            values = values._settledValue;
            if (!isArray(values)) {
                var err = new Promise.TypeError("expecting an array, a promise or a thenable");
                this.__hardReject__(err);
                return;
            }
        } else if (values.isPending()) {
            values._then(
                PromiseArray$_init,
                this._reject,
                void 0,
                this,
                resolveValueIfEmpty
           );
            return;
        } else {
            values._unsetRejectionIsUnhandled();
            this._reject(values._settledValue);
            return;
        }
    } else if (!isArray(values)) {
        var err = new Promise.TypeError("expecting an array, a promise or a thenable");
        this.__hardReject__(err);
        return;
    }

    if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
        }
        else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
    }
    var len = this.getActualLength(values.length);
    var newLen = len;
    var newValues = this.shouldCopyValues() ? new Array(len) : this._values;
    var isDirectScanNeeded = false;
    for (var i = 0; i < len; ++i) {
        var maybePromise = cast(values[i], void 0);
        if (maybePromise instanceof Promise) {
            if (maybePromise.isPending()) {
                maybePromise._proxyPromiseArray(this, i);
            } else {
                maybePromise._unsetRejectionIsUnhandled();
                isDirectScanNeeded = true;
            }
        } else {
            isDirectScanNeeded = true;
        }
        newValues[i] = maybePromise;
    }
    this._values = newValues;
    this._length = newLen;
    if (isDirectScanNeeded) {
        this._scanDirectValues(len);
    }
};

PromiseArray.prototype._settlePromiseAt =
function PromiseArray$_settlePromiseAt(index) {
    var value = this._values[index];
    if (!(value instanceof Promise)) {
        this._promiseFulfilled(value, index);
    } else if (value.isFulfilled()) {
        this._promiseFulfilled(value._settledValue, index);
    } else if (value.isRejected()) {
        this._promiseRejected(value._settledValue, index);
    }
};

PromiseArray.prototype._scanDirectValues =
function PromiseArray$_scanDirectValues(len) {
    for (var i = 0; i < len; ++i) {
        if (this._isResolved()) {
            break;
        }
        this._settlePromiseAt(i);
    }
};

PromiseArray.prototype._isResolved = function PromiseArray$_isResolved() {
    return this._values === null;
};

PromiseArray.prototype._resolve = function PromiseArray$_resolve(value) {
    this._values = null;
    this._promise._fulfill(value);
};

PromiseArray.prototype.__hardReject__ =
PromiseArray.prototype._reject = function PromiseArray$_reject(reason) {
    this._values = null;
    var trace = canAttach(reason) ? reason : new Error(reason + "");
    this._promise._attachExtraTrace(trace);
    this._promise._reject(reason, trace);
};

PromiseArray.prototype._promiseProgressed =
function PromiseArray$_promiseProgressed(progressValue, index) {
    if (this._isResolved()) return;
    this._promise._progress({
        index: index,
        value: progressValue
    });
};


PromiseArray.prototype._promiseFulfilled =
function PromiseArray$_promiseFulfilled(value, index) {
    if (this._isResolved()) return;
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
    }
};

PromiseArray.prototype._promiseRejected =
function PromiseArray$_promiseRejected(reason, index) {
    if (this._isResolved()) return;
    this._totalResolved++;
    this._reject(reason);
};

PromiseArray.prototype.shouldCopyValues =
function PromiseArray$_shouldCopyValues() {
    return true;
};

PromiseArray.prototype.getActualLength =
function PromiseArray$getActualLength(len) {
    return len;
};

return PromiseArray;
};

},{"./errors.js":7,"./util.js":21}],15:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
var util = _dereq_("./util.js");
var maybeWrapAsError = util.maybeWrapAsError;
var errors = _dereq_("./errors.js");
var TimeoutError = errors.TimeoutError;
var OperationalError = errors.OperationalError;
var async = _dereq_("./async.js");
var haveGetters = util.haveGetters;
var es5 = _dereq_("./es5.js");

function isUntypedError(obj) {
    return obj instanceof Error &&
        es5.getPrototypeOf(obj) === Error.prototype;
}

function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
    } else {
        ret = obj;
    }
    errors.markAsOriginatingFromRejection(ret);
    return ret;
}

function nodebackForPromise(promise) {
    function PromiseResolver$_callback(err, value) {
        if (promise === null) return;

        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (arguments.length > 2) {
            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
            promise._fulfill(args);
        } else {
            promise._fulfill(value);
        }

        promise = null;
    }
    return PromiseResolver$_callback;
}


var PromiseResolver;
if (!haveGetters) {
    PromiseResolver = function PromiseResolver(promise) {
        this.promise = promise;
        this.asCallback = nodebackForPromise(promise);
        this.callback = this.asCallback;
    };
}
else {
    PromiseResolver = function PromiseResolver(promise) {
        this.promise = promise;
    };
}
if (haveGetters) {
    var prop = {
        get: function() {
            return nodebackForPromise(this.promise);
        }
    };
    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
}

PromiseResolver._nodebackForPromise = nodebackForPromise;

PromiseResolver.prototype.toString = function PromiseResolver$toString() {
    return "[object PromiseResolver]";
};

PromiseResolver.prototype.resolve =
PromiseResolver.prototype.fulfill = function PromiseResolver$resolve(value) {
    if (!(this instanceof PromiseResolver)) {
        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.");
    }

    var promise = this.promise;
    if (promise._tryFollow(value)) {
        return;
    }
    async.invoke(promise._fulfill, promise, value);
};

PromiseResolver.prototype.reject = function PromiseResolver$reject(reason) {
    if (!(this instanceof PromiseResolver)) {
        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.");
    }

    var promise = this.promise;
    errors.markAsOriginatingFromRejection(reason);
    var trace = errors.canAttach(reason) ? reason : new Error(reason + "");
    promise._attachExtraTrace(trace);
    async.invoke(promise._reject, promise, reason);
    if (trace !== reason) {
        async.invoke(this._setCarriedStackTrace, this, trace);
    }
};

PromiseResolver.prototype.progress =
function PromiseResolver$progress(value) {
    if (!(this instanceof PromiseResolver)) {
        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.");
    }
    async.invoke(this.promise._progress, this.promise, value);
};

PromiseResolver.prototype.cancel = function PromiseResolver$cancel() {
    async.invoke(this.promise.cancel, this.promise, void 0);
};

PromiseResolver.prototype.timeout = function PromiseResolver$timeout() {
    this.reject(new TimeoutError("timeout"));
};

PromiseResolver.prototype.isResolved = function PromiseResolver$isResolved() {
    return this.promise.isResolved();
};

PromiseResolver.prototype.toJSON = function PromiseResolver$toJSON() {
    return this.promise.toJSON();
};

PromiseResolver.prototype._setCarriedStackTrace =
function PromiseResolver$_setCarriedStackTrace(trace) {
    if (this.promise.isRejected()) {
        this.promise._setCarriedStackTrace(trace);
    }
};

module.exports = PromiseResolver;

},{"./async.js":1,"./errors.js":7,"./es5.js":9,"./util.js":21}],16:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
function arrayCopy(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
    this._makeCapacity();
}

Queue.prototype._willBeOverCapacity =
function Queue$_willBeOverCapacity(size) {
    return this._capacity < size;
};

Queue.prototype._pushOne = function Queue$_pushOne(arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype.push = function Queue$push(fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[(j + 0) & wrapMask] = fn;
    this[(j + 1) & wrapMask] = receiver;
    this[(j + 2) & wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function Queue$shift() {
    var front = this._front,
        ret = this[front];

    this[front] = void 0;
    this._front = (front + 1) & (this._capacity - 1);
    this._length--;
    return ret;
};

Queue.prototype.length = function Queue$length() {
    return this._length;
};

Queue.prototype._makeCapacity = function Queue$_makeCapacity() {
    var len = this._capacity;
    for (var i = 0; i < len; ++i) {
        this[i] = void 0;
    }
};

Queue.prototype._checkCapacity = function Queue$_checkCapacity(size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 3);
    }
};

Queue.prototype._resizeTo = function Queue$_resizeTo(capacity) {
    var oldFront = this._front;
    var oldCapacity = this._capacity;
    var oldQueue = new Array(oldCapacity);
    var length = this.length();

    arrayCopy(this, 0, oldQueue, 0, oldCapacity);
    this._capacity = capacity;
    this._makeCapacity();
    this._front = 0;
    if (oldFront + length <= oldCapacity) {
        arrayCopy(oldQueue, oldFront, this, 0, length);
    } else {        var lengthBeforeWrapping =
            length - ((oldFront + length) & (oldCapacity - 1));

        arrayCopy(oldQueue, oldFront, this, 0, lengthBeforeWrapping);
        arrayCopy(oldQueue, 0, this, lengthBeforeWrapping,
                    length - lengthBeforeWrapping);
    }
};

module.exports = Queue;

},{}],17:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
module.exports = function(Promise, PromiseArray, apiRejection, cast, INTERNAL) {
var util = _dereq_("./util.js");
var tryCatch4 = util.tryCatch4;
var tryCatch3 = util.tryCatch3;
var errorObj = util.errorObj;
function ReductionPromiseArray(promises, fn, accum, _each) {
    this.constructor$(promises);
    this._preservedValues = _each === INTERNAL ? [] : null;
    this._zerothIsAccum = (accum === void 0);
    this._gotAccum = false;
    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
    this._valuesPhase = undefined;

    var maybePromise = cast(accum, void 0);
    var rejected = false;
    var isPromise = maybePromise instanceof Promise;
    if (isPromise) {
        if (maybePromise.isPending()) {
            maybePromise._proxyPromiseArray(this, -1);
        } else if (maybePromise.isFulfilled()) {
            accum = maybePromise.value();
            this._gotAccum = true;
        } else {
            maybePromise._unsetRejectionIsUnhandled();
            this._reject(maybePromise.reason());
            rejected = true;
        }
    }
    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
    this._callback = fn;
    this._accum = accum;
    if (!rejected) this._init$(void 0, -5);
}
util.inherits(ReductionPromiseArray, PromiseArray);

ReductionPromiseArray.prototype._init =
function ReductionPromiseArray$_init() {};

ReductionPromiseArray.prototype._resolveEmptyArray =
function ReductionPromiseArray$_resolveEmptyArray() {
    if (this._gotAccum || this._zerothIsAccum) {
        this._resolve(this._preservedValues !== null
                        ? [] : this._accum);
    }
};

ReductionPromiseArray.prototype._promiseFulfilled =
function ReductionPromiseArray$_promiseFulfilled(value, index) {
    var values = this._values;
    if (values === null) return;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var isEach = preservedValues !== null;
    var gotAccum = this._gotAccum;
    var valuesPhase = this._valuesPhase;
    var valuesPhaseIndex;
    if (!valuesPhase) {
        valuesPhase = this._valuesPhase = Array(length);
        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
            valuesPhase[valuesPhaseIndex] = 0;
        }
    }
    valuesPhaseIndex = valuesPhase[index];

    if (index === 0 && this._zerothIsAccum) {
        if (!gotAccum) {
            this._accum = value;
            this._gotAccum = gotAccum = true;
        }
        valuesPhase[index] = ((valuesPhaseIndex === 0)
            ? 1 : 2);
    } else if (index === -1) {
        if (!gotAccum) {
            this._accum = value;
            this._gotAccum = gotAccum = true;
        }
    } else {
        if (valuesPhaseIndex === 0) {
            valuesPhase[index] = 1;
        }
        else {
            valuesPhase[index] = 2;
            if (gotAccum) {
                this._accum = value;
            }
        }
    }
    if (!gotAccum) return;

    var callback = this._callback;
    var receiver = this._promise._boundTo;
    var ret;

    for (var i = this._reducingIndex; i < length; ++i) {
        valuesPhaseIndex = valuesPhase[i];
        if (valuesPhaseIndex === 2) {
            this._reducingIndex = i + 1;
            continue;
        }
        if (valuesPhaseIndex !== 1) return;

        value = values[i];
        if (value instanceof Promise) {
            if (value.isFulfilled()) {
                value = value._settledValue;
            } else if (value.isPending()) {
                return;
            } else {
                value._unsetRejectionIsUnhandled();
                return this._reject(value.reason());
            }
        }

        if (isEach) {
            preservedValues.push(value);
            ret = tryCatch3(callback, receiver, value, i, length);
        }
        else {
            ret = tryCatch4(callback, receiver, this._accum, value, i, length);
        }

        if (ret === errorObj) return this._reject(ret.e);

        var maybePromise = cast(ret, void 0);
        if (maybePromise instanceof Promise) {
            if (maybePromise.isPending()) {
                valuesPhase[i] = 4;
                return maybePromise._proxyPromiseArray(this, i);
            } else if (maybePromise.isFulfilled()) {
                ret = maybePromise.value();
            } else {
                maybePromise._unsetRejectionIsUnhandled();
                return this._reject(maybePromise.reason());
            }
        }

        this._reducingIndex = i + 1;
        this._accum = ret;
    }

    if (this._reducingIndex < length) return;
    this._resolve(isEach ? preservedValues : this._accum);
};

function reduce(promises, fn, initialValue, _each) {
    if (typeof fn !== "function") return apiRejection("fn must be a function");
    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
    return array.promise();
}

Promise.prototype.reduce = function Promise$reduce(fn, initialValue) {
    return reduce(this, fn, initialValue, null);
};

Promise.reduce = function Promise$Reduce(promises, fn, initialValue, _each) {
    return reduce(promises, fn, initialValue, _each);
};
};

},{"./util.js":21}],18:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
var schedule;
var _MutationObserver;
if (typeof process === "object" && typeof process.version === "string") {
    schedule = function Promise$_Scheduler(fn) {
        process.nextTick(fn);
    };
}
else if ((typeof MutationObserver !== "undefined" &&
         (_MutationObserver = MutationObserver)) ||
         (typeof WebKitMutationObserver !== "undefined" &&
         (_MutationObserver = WebKitMutationObserver))) {
    schedule = (function() {
        var div = document.createElement("div");
        var queuedFn = void 0;
        var observer = new _MutationObserver(
            function Promise$_Scheduler() {
                var fn = queuedFn;
                queuedFn = void 0;
                fn();
            }
       );
        observer.observe(div, {
            attributes: true
        });
        return function Promise$_Scheduler(fn) {
            queuedFn = fn;
            div.setAttribute("class", "foo");
        };

    })();
}
else if (typeof setTimeout !== "undefined") {
    schedule = function Promise$_Scheduler(fn) {
        setTimeout(fn, 0);
    };
}
else throw new Error("no async scheduler available");
module.exports = schedule;

},{}],19:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
module.exports = function(Promise) {
function PromiseInspection(promise) {
    if (promise !== void 0) {
        this._bitField = promise._bitField;
        this._settledValue = promise.isResolved()
            ? promise._settledValue
            : void 0;
    }
    else {
        this._bitField = 0;
        this._settledValue = void 0;
    }
}

PromiseInspection.prototype.isFulfilled =
Promise.prototype.isFulfilled = function Promise$isFulfilled() {
    return (this._bitField & 268435456) > 0;
};

PromiseInspection.prototype.isRejected =
Promise.prototype.isRejected = function Promise$isRejected() {
    return (this._bitField & 134217728) > 0;
};

PromiseInspection.prototype.isPending =
Promise.prototype.isPending = function Promise$isPending() {
    return (this._bitField & 402653184) === 0;
};

PromiseInspection.prototype.value =
Promise.prototype.value = function Promise$value() {
    if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise");
    }
    return this._settledValue;
};

PromiseInspection.prototype.error =
PromiseInspection.prototype.reason =
Promise.prototype.reason = function Promise$reason() {
    if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise");
    }
    return this._settledValue;
};

PromiseInspection.prototype.isResolved =
Promise.prototype.isResolved = function Promise$isResolved() {
    return (this._bitField & 402653184) > 0;
};

Promise.PromiseInspection = PromiseInspection;
};

},{}],20:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
module.exports = function(Promise, INTERNAL) {
var util = _dereq_("./util.js");
var canAttach = _dereq_("./errors.js").canAttach;
var errorObj = util.errorObj;
var isObject = util.isObject;

function getThen(obj) {
    try {
        return obj.then;
    }
    catch(e) {
        errorObj.e = e;
        return errorObj;
    }
}

function Promise$_Cast(obj, originalPromise) {
    if (isObject(obj)) {
        if (obj instanceof Promise) {
            return obj;
        }
        else if (isAnyBluebirdPromise(obj)) {
            var ret = new Promise(INTERNAL);
            ret._setTrace(void 0);
            obj._then(
                ret._fulfillUnchecked,
                ret._rejectUncheckedCheckError,
                ret._progressUnchecked,
                ret,
                null
            );
            ret._setFollowing();
            return ret;
        }
        var then = getThen(obj);
        if (then === errorObj) {
            if (originalPromise !== void 0 && canAttach(then.e)) {
                originalPromise._attachExtraTrace(then.e);
            }
            return Promise.reject(then.e);
        } else if (typeof then === "function") {
            return Promise$_doThenable(obj, then, originalPromise);
        }
    }
    return obj;
}

var hasProp = {}.hasOwnProperty;
function isAnyBluebirdPromise(obj) {
    return hasProp.call(obj, "_promise0");
}

function Promise$_doThenable(x, then, originalPromise) {
    var resolver = Promise.defer();
    var called = false;
    try {
        then.call(
            x,
            Promise$_resolveFromThenable,
            Promise$_rejectFromThenable,
            Promise$_progressFromThenable
        );
    } catch(e) {
        if (!called) {
            called = true;
            var trace = canAttach(e) ? e : new Error(e + "");
            if (originalPromise !== void 0) {
                originalPromise._attachExtraTrace(trace);
            }
            resolver.promise._reject(e, trace);
        }
    }
    return resolver.promise;

    function Promise$_resolveFromThenable(y) {
        if (called) return;
        called = true;

        if (x === y) {
            var e = Promise._makeSelfResolutionError();
            if (originalPromise !== void 0) {
                originalPromise._attachExtraTrace(e);
            }
            resolver.promise._reject(e, void 0);
            return;
        }
        resolver.resolve(y);
    }

    function Promise$_rejectFromThenable(r) {
        if (called) return;
        called = true;
        var trace = canAttach(r) ? r : new Error(r + "");
        if (originalPromise !== void 0) {
            originalPromise._attachExtraTrace(trace);
        }
        resolver.promise._reject(r, trace);
    }

    function Promise$_progressFromThenable(v) {
        if (called) return;
        var promise = resolver.promise;
        if (typeof promise._progress === "function") {
            promise._progress(v);
        }
    }
}

return Promise$_Cast;
};

},{"./errors.js":7,"./util.js":21}],21:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
"use strict";
var es5 = _dereq_("./es5.js");
var haveGetters = (function(){
    try {
        var o = {};
        es5.defineProperty(o, "f", {
            get: function () {
                return 3;
            }
        });
        return o.f === 3;
    }
    catch (e) {
        return false;
    }

})();
var canEvaluate = typeof navigator == "undefined";
var errorObj = {e: {}};
function tryCatch1(fn, receiver, arg) {
    try { return fn.call(receiver, arg); }
    catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

function tryCatch2(fn, receiver, arg, arg2) {
    try { return fn.call(receiver, arg, arg2); }
    catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

function tryCatch3(fn, receiver, arg, arg2, arg3) {
    try { return fn.call(receiver, arg, arg2, arg3); }
    catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

function tryCatch4(fn, receiver, arg, arg2, arg3, arg4) {
    try { return fn.call(receiver, arg, arg2, arg3, arg4); }
    catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

function tryCatchApply(fn, args, receiver) {
    try { return fn.apply(receiver, args); }
    catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) &&
                propertyName.charAt(propertyName.length-1) !== "$"
           ) {
                this[propertyName + "$"] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};

function asString(val) {
    return typeof val === "string" ? val : ("" + val);
}

function isPrimitive(val) {
    return val == null || val === true || val === false ||
        typeof val === "string" || typeof val === "number";

}

function isObject(value) {
    return !isPrimitive(value);
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(asString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc != null) {
            return desc.get == null && desc.set == null
                    ? desc.value
                    : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : void 0;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}


var wrapsPrimitiveReceiver = (function() {
    return this !== "string";
}).call("string");

function thrower(r) {
    throw r;
}

var inheritedDataKeys = (function() {
    if (es5.isES5) {
        return function(obj, opts) {
            var ret = [];
            var visitedKeys = Object.create(null);
            var getKeys = Object(opts).includeHidden
                ? Object.getOwnPropertyNames
                : Object.keys;
            while (obj != null) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        return function(obj) {
            var ret = [];
            /*jshint forin:false */
            for (var key in obj) {
                ret.push(key);
            }
            return ret;
        };
    }

})();

function isClass(fn) {
    try {
        if (typeof fn === "function") {
            var keys = es5.keys(fn.prototype);
            return keys.length > 0 &&
                   !(keys.length === 1 && keys[0] === "constructor");
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027*/
    function f() {}
    f.prototype = obj;
    return f;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for(var i = 0; i < count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    haveGetters: haveGetters,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch1: tryCatch1,
    tryCatch2: tryCatch2,
    tryCatch3: tryCatch3,
    tryCatch4: tryCatch4,
    tryCatchApply: tryCatchApply,
    inherits: inherits,
    withAppended: withAppended,
    asString: asString,
    maybeWrapAsError: maybeWrapAsError,
    wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,
    toFastProperties: toFastProperties,
    filledRange: filledRange
};

module.exports = ret;

},{"./es5.js":9}]},{},[2])
(2)
});
(function() {
  /**
   * From: http://code.this.com/mobile/articles/fast_buttons.html
   * Also see: http://stackoverflow.com/questions/6300136/trying-to-implement-googles-fast-button
   */

  /** For IE8 and earlier compatibility: https://developer.mozilla.org/en/DOM/element.addEventListener */
  function addListener(el, type, listener, useCapture) {
    if (el.addEventListener) {
      el.addEventListener(type, listener, useCapture);
      return {
        destroy: function() { el.removeEventListener(type, listener, useCapture); }
      };
    } else {
      // see: http://stackoverflow.com/questions/5198845/javascript-this-losing-context-in-ie
      var handler = function(e) { listener.handleEvent(window.event, listener); }
      el.attachEvent('on' + type, handler);

      return {
        destroy: function() { el.detachEvent('on' + type, handler); }
      };
    }
  }

  var isTouch = "ontouchstart" in window;

  /* Construct the FastButton with a reference to the element and click handler. */
  this.FastButton = function(element, handler, useCapture) {
    // collect functions to call to cleanup events
    this.events = [];
    this.touchEvents = [];
    this.element = element;
    this.handler = handler;
    this.useCapture = useCapture;
    if (isTouch)
      this.events.push(addListener(element, 'touchstart', this, this.useCapture));
    this.events.push(addListener(element, 'click', this, this.useCapture));
  };

  /* Remove event handling when no longer needed for this button */
  this.FastButton.prototype.destroy = function() {
    for (i = this.events.length - 1; i >= 0; i -= 1)
      this.events[i].destroy();
    this.events = this.touchEvents = this.element = this.handler = this.fastButton = null;
  };

  /* acts as an event dispatcher */
  this.FastButton.prototype.handleEvent = function(event) {
    switch (event.type) {
      case 'touchstart': this.onTouchStart(event); break;
      case 'touchmove': this.onTouchMove(event); break;
      case 'touchend': this.onClick(event); break;
      case 'click': this.onClick(event); break;
    }
  };

  /* Save a reference to the touchstart coordinate and start listening to touchmove and
   touchend events. Calling stopPropagation guarantees that other behaviors don’t get a
   chance to handle the same click event. This is executed at the beginning of touch. */
  this.FastButton.prototype.onTouchStart = function(event) {
    event.stopPropagation ? event.stopPropagation() : (event.cancelBubble=true);
    this.touchEvents.push(addListener(this.element, 'touchend', this, this.useCapture));
    this.touchEvents.push(addListener(document.body, 'touchmove', this, this.useCapture));
    this.startX = event.touches[0].clientX;
    this.startY = event.touches[0].clientY;
  };

  /* When /if touchmove event is invoked, check if the user has dragged past the threshold of 10px. */
  this.FastButton.prototype.onTouchMove = function(event) {
    if (Math.abs(event.touches[0].clientX - this.startX) > 10 || Math.abs(event.touches[0].clientY - this.startY) > 10) {
      this.reset(); //if he did, then cancel the touch event
    }
  };

  /* Invoke the actual click handler and prevent ghost clicks if this was a touchend event. */
  this.FastButton.prototype.onClick = function(event) {
    event.stopPropagation ? event.stopPropagation() : (event.cancelBubble=true);
    this.reset();
    // Use .call to call the method so that we have the correct "this": https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call
    var result = this.handler.call(this.element, event);
    if (event.type == 'touchend')
      clickbuster.preventGhostClick(this.startX, this.startY);
    return result;
  };

  this.FastButton.prototype.reset = function() {
    for (i = this.touchEvents.length - 1; i >= 0; i -= 1)
      this.touchEvents[i].destroy();
    this.touchEvents = [];
  };

  this.clickbuster = function() {}

  /* Call preventGhostClick to bust all click events that happen within 25px of
   the provided x, y coordinates in the next 2.5s. */
  this.clickbuster.preventGhostClick = function(x, y) {
    clickbuster.coordinates.push(x, y);
    window.setTimeout(clickbuster.pop, 2500);
  };

  this.clickbuster.pop = function() {
    clickbuster.coordinates.splice(0, 2);
  };

  /* If we catch a click event inside the given radius and time threshold then we call
   stopPropagation and preventDefault. Calling preventDefault will stop links
   from being activated. */
  this.clickbuster.onClick = function(event) {
    for (var i = 0; i < clickbuster.coordinates.length; i += 2) {
      var x = clickbuster.coordinates[i];
      var y = clickbuster.coordinates[i + 1];
      if (Math.abs(event.clientX - x) < 25 && Math.abs(event.clientY - y) < 25) {
        event.stopPropagation ? event.stopPropagation() : (event.cancelBubble=true);
        event.preventDefault ? event.preventDefault() : (event.returnValue=false);
      }
    }
  };

  if (isTouch) {
    // Don't need to use our custom addListener function since we only bust clicks on touch devices
    document.addEventListener('click', clickbuster.onClick, true);
    clickbuster.coordinates = [];
  }
})(this);

/* when updating, apply the fix as described here:
 * * https://code.google.com/p/google-caja/issues/detail?id=1700&sort=-id&colspec=ID%20Type%20Status%20Priority%20Owner%20Summary
 * * Kunagi issue 316
 */
{var CSS_PROP_BIT_QUANTITY=1,CSS_PROP_BIT_HASH_VALUE=2,CSS_PROP_BIT_NEGATIVE_QUANTITY=4,CSS_PROP_BIT_QSTRING_CONTENT=8,CSS_PROP_BIT_QSTRING_URL=16,CSS_PROP_BIT_HISTORY_INSENSITIVE=32,CSS_PROP_BIT_Z_INDEX=64,CSS_PROP_BIT_ALLOWED_IN_LINK=128,cssSchema=(function(){var
s=['rgb(?:\\(\\s*(?:\\d+|0|\\d+(?:\\.\\d+)?%)\\s*,\\s*(?:\\d+|0|\\d+(?:\\.\\d+)?%)\\s*,\\s*(?:\\d+|0|\\d+(?:\\.\\d+)?%)|a\\(\\s*(?:\\d+|0|\\d+(?:\\.\\d+)?%)\\s*,\\s*(?:\\d+|0|\\d+(?:\\.\\d+)?%)\\s*,\\s*(?:\\d+|0|\\d+(?:\\.\\d+)?%)\\s*,\\s*(?:\\d+|0(?:\\.\\d+)?|\\.\\d+|1(?:\\.0+)?|0|\\d+(?:\\.\\d+)?%)) *\\)'],c=[/^ *$/i,RegExp('^ *\\s*'+s[0]+' *$','i'),RegExp('^ *(?:\\s*'+s[0]+'|(?:\\s*'+s[0]+')?)+ *$','i')],L=[['aliceblue','antiquewhite','aqua','aquamarine','azure','beige','bisque','black','blanchedalmond','blue','blueviolet','brown','burlywood','cadetblue','chartreuse','chocolate','coral','cornflowerblue','cornsilk','crimson','cyan','darkblue','darkcyan','darkgoldenrod','darkgray','darkgreen','darkkhaki','darkmagenta','darkolivegreen','darkorange','darkorchid','darkred','darksalmon','darkseagreen','darkslateblue','darkslategray','darkturquoise','darkviolet','deeppink','deepskyblue','dimgray','dodgerblue','firebrick','floralwhite','forestgreen','fuchsia','gainsboro','ghostwhite','gold','goldenrod','gray','green','greenyellow','honeydew','hotpink','indianred','indigo','ivory','khaki','lavender','lavenderblush','lawngreen','lemonchiffon','lightblue','lightcoral','lightcyan','lightgoldenrodyellow','lightgreen','lightgrey','lightpink','lightsalmon','lightseagreen','lightskyblue','lightslategray','lightsteelblue','lightyellow','lime','limegreen','linen','magenta','maroon','mediumaquamarine','mediumblue','mediumorchid','mediumpurple','mediumseagreen','mediumslateblue','mediumspringgreen','mediumturquoise','mediumvioletred','midnightblue','mintcream','mistyrose','moccasin','navajowhite','navy','oldlace','olive','olivedrab','orange','orangered','orchid','palegoldenrod','palegreen','paleturquoise','palevioletred','papayawhip','peachpuff','peru','pink','plum','powderblue','purple','red','rosybrown','royalblue','saddlebrown','salmon','sandybrown','seagreen','seashell','sienna','silver','skyblue','slateblue','slategray','snow','springgreen','steelblue','tan','teal','thistle','tomato','turquoise','violet','wheat','white','whitesmoke','yellow','yellowgreen'],['all-scroll','col-resize','crosshair','default','e-resize','hand','help','move','n-resize','ne-resize','no-drop','not-allowed','nw-resize','pointer','progress','row-resize','s-resize','se-resize','sw-resize','text','vertical-text','w-resize','wait'],['-moz-inline-box','-moz-inline-stack','block','inline','inline-block','inline-table','list-item','run-in','table','table-caption','table-cell','table-column','table-column-group','table-footer-group','table-header-group','table-row','table-row-group'],['armenian','circle','decimal','decimal-leading-zero','disc','georgian','lower-alpha','lower-greek','lower-latin','lower-roman','square','upper-alpha','upper-latin','upper-roman'],['100','200','300','400','500','600','700','800','900','bold','bolder','lighter'],['condensed','expanded','extra-condensed','extra-expanded','narrower','semi-condensed','semi-expanded','ultra-condensed','ultra-expanded','wider'],['behind','center-left','center-right','far-left','far-right','left-side','leftwards','right-side','rightwards'],['large','larger','small','smaller','x-large','x-small','xx-large','xx-small'],['-moz-pre-wrap','-o-pre-wrap','-pre-wrap','nowrap','pre','pre-line','pre-wrap'],['dashed','dotted','double','groove','outset','ridge','solid'],['baseline','middle','sub','super','text-bottom','text-top'],['caption','icon','menu','message-box','small-caption','status-bar'],['fast','faster','slow','slower','x-fast','x-slow'],['above','below','higher','level','lower'],['border-box','contain','content-box','cover','padding-box'],['cursive','fantasy','monospace','sans-serif','serif'],['loud','silent','soft','x-loud','x-soft'],['no-repeat','repeat-x','repeat-y','round','space'],['blink','line-through','overline','underline'],['high','low','x-high','x-low'],['absolute','relative','static'],['capitalize','lowercase','uppercase'],['child','female','male'],['bidi-override','embed'],['bottom','top'],['clip','ellipsis'],['continuous','digits'],['hide','show'],['inside','outside'],['italic','oblique'],['left','right'],['ltr','rtl'],['no-content','no-display'],['suppress','unrestricted'],['thick','thin'],[','],['/'],['always'],['auto'],['avoid'],['both'],['break-word'],['center'],['code'],['collapse'],['fixed'],['hidden'],['inherit'],['inset'],['invert'],['justify'],['local'],['medium'],['mix'],['none'],['normal'],['once'],['repeat'],['scroll'],['separate'],['small-caps'],['spell-out'],['transparent'],['visible']];return{'-moz-border-radius':{'cssExtra':c[0],'cssPropBits':5,'cssLitGroup':[L[36]]},'-moz-border-radius-bottomleft':{'cssExtra':c[0],'cssPropBits':5},'-moz-border-radius-bottomright':{'cssExtra':c[0],'cssPropBits':5},'-moz-border-radius-topleft':{'cssExtra':c[0],'cssPropBits':5},'-moz-border-radius-topright':{'cssExtra':c[0],'cssPropBits':5},'-moz-box-shadow':{'cssExtra':c[2],'cssAlternates':['boxShadow'],'cssPropBits':7,'cssLitGroup':[L[0],L[35],L[48],L[54]]},'-moz-opacity':{'cssPropBits':1,'cssLitGroup':[L[47]]},'-moz-outline':{'cssExtra':c[1],'cssPropBits':7,'cssLitGroup':[L[0],L[9],L[34],L[46],L[47],L[48],L[49],L[52],L[54]]},'-moz-outline-color':{'cssExtra':c[1],'cssPropBits':2,'cssLitGroup':[L[0],L[47],L[49]]},'-moz-outline-style':{'cssPropBits':0,'cssLitGroup':[L[9],L[46],L[47],L[48],L[54]]},'-moz-outline-width':{'cssPropBits':5,'cssLitGroup':[L[34],L[47],L[52]]},'-o-text-overflow':{'cssPropBits':0,'cssLitGroup':[L[25]]},'-webkit-border-bottom-left-radius':{'cssExtra':c[0],'cssPropBits':5},'-webkit-border-bottom-right-radius':{'cssExtra':c[0],'cssPropBits':5},'-webkit-border-radius':{'cssExtra':c[0],'cssPropBits':5,'cssLitGroup':[L[36]]},'-webkit-border-radius-bottom-left':{'cssExtra':c[0],'cssPropBits':5},'-webkit-border-radius-bottom-right':{'cssExtra':c[0],'cssPropBits':5},'-webkit-border-radius-top-left':{'cssExtra':c[0],'cssPropBits':5},'-webkit-border-radius-top-right':{'cssExtra':c[0],'cssPropBits':5},'-webkit-border-top-left-radius':{'cssExtra':c[0],'cssPropBits':5},'-webkit-border-top-right-radius':{'cssExtra':c[0],'cssPropBits':5},'-webkit-box-shadow':{'cssExtra':c[2],'cssAlternates':['boxShadow'],'cssPropBits':7,'cssLitGroup':[L[0],L[35],L[48],L[54]]},'azimuth':{'cssPropBits':5,'cssLitGroup':[L[6],L[30],L[42],L[47]]},'background':{'cssExtra':RegExp('^ *(?:\\s*'+s[0]+'){0,2} *$','i'),'cssPropBits':23,'cssLitGroup':[L[0],L[14],L[17],L[24],L[30],L[35],L[36],L[38],L[42],L[45],L[47],L[51],L[54],L[57],L[58],L[62]]},'background-attachment':{'cssExtra':c[0],'cssPropBits':0,'cssLitGroup':[L[35],L[45],L[51],L[58]]},'background-color':{'cssExtra':c[1],'cssPropBits':130,'cssLitGroup':[L[0],L[47],L[62]]},'background-image':{'cssExtra':c[0],'cssPropBits':16,'cssLitGroup':[L[35],L[54]]},'background-position':{'cssExtra':c[0],'cssPropBits':5,'cssLitGroup':[L[24],L[30],L[35],L[42]]},'background-repeat':{'cssExtra':c[0],'cssPropBits':0,'cssLitGroup':[L[17],L[35],L[57]]},'border':{'cssExtra':c[1],'cssPropBits':7,'cssLitGroup':[L[0],L[9],L[34],L[46],L[47],L[48],L[52],L[54],L[62]]},'border-bottom':{'cssExtra':c[1],'cssPropBits':7,'cssLitGroup':[L[0],L[9],L[34],L[46],L[47],L[48],L[52],L[54],L[62]]},'border-bottom-color':{'cssExtra':c[1],'cssPropBits':2,'cssLitGroup':[L[0],L[47],L[62]]},'border-bottom-left-radius':{'cssExtra':c[0],'cssPropBits':5},'border-bottom-right-radius':{'cssExtra':c[0],'cssPropBits':5},'border-bottom-style':{'cssPropBits':0,'cssLitGroup':[L[9],L[46],L[47],L[48],L[54]]},'border-bottom-width':{'cssPropBits':5,'cssLitGroup':[L[34],L[47],L[52]]},'border-collapse':{'cssPropBits':0,'cssLitGroup':[L[44],L[47],L[59]]},'border-color':{'cssExtra':RegExp('^ *(?:\\s*'+s[0]+'){1,4} *$','i'),'cssPropBits':2,'cssLitGroup':[L[0],L[47],L[62]]},'border-left':{'cssExtra':c[1],'cssPropBits':7,'cssLitGroup':[L[0],L[9],L[34],L[46],L[47],L[48],L[52],L[54],L[62]]},'border-left-color':{'cssExtra':c[1],'cssPropBits':2,'cssLitGroup':[L[0],L[47],L[62]]},'border-left-style':{'cssPropBits':0,'cssLitGroup':[L[9],L[46],L[47],L[48],L[54]]},'border-left-width':{'cssPropBits':5,'cssLitGroup':[L[34],L[47],L[52]]},'border-radius':{'cssExtra':c[0],'cssPropBits':5,'cssLitGroup':[L[36]]},'border-right':{'cssExtra':c[1],'cssPropBits':7,'cssLitGroup':[L[0],L[9],L[34],L[46],L[47],L[48],L[52],L[54],L[62]]},'border-right-color':{'cssExtra':c[1],'cssPropBits':2,'cssLitGroup':[L[0],L[47],L[62]]},'border-right-style':{'cssPropBits':0,'cssLitGroup':[L[9],L[46],L[47],L[48],L[54]]},'border-right-width':{'cssPropBits':5,'cssLitGroup':[L[34],L[47],L[52]]},'border-spacing':{'cssExtra':c[0],'cssPropBits':5,'cssLitGroup':[L[47]]},'border-style':{'cssPropBits':0,'cssLitGroup':[L[9],L[46],L[47],L[48],L[54]]},'border-top':{'cssExtra':c[1],'cssPropBits':7,'cssLitGroup':[L[0],L[9],L[34],L[46],L[47],L[48],L[52],L[54],L[62]]},'border-top-color':{'cssExtra':c[1],'cssPropBits':2,'cssLitGroup':[L[0],L[47],L[62]]},'border-top-left-radius':{'cssExtra':c[0],'cssPropBits':5},'border-top-right-radius':{'cssExtra':c[0],'cssPropBits':5},'border-top-style':{'cssPropBits':0,'cssLitGroup':[L[9],L[46],L[47],L[48],L[54]]},'border-top-width':{'cssPropBits':5,'cssLitGroup':[L[34],L[47],L[52]]},'border-width':{'cssPropBits':5,'cssLitGroup':[L[34],L[47],L[52]]},'bottom':{'cssPropBits':5,'cssLitGroup':[L[38],L[47]]},'box-shadow':{'cssExtra':c[2],'cssPropBits':7,'cssLitGroup':[L[0],L[35],L[48],L[54]]},'caption-side':{'cssPropBits':0,'cssLitGroup':[L[24],L[47]]},'clear':{'cssPropBits':0,'cssLitGroup':[L[30],L[40],L[47],L[54]]},'clip':{'cssExtra':/^ *\s*rect\(\s*(?:0|[+\-]?\d+(?:\.\d+)?(?:[cem]m|ex|in|p[ctx])|auto)\s*,\s*(?:0|[+\-]?\d+(?:\.\d+)?(?:[cem]m|ex|in|p[ctx])|auto)\s*,\s*(?:0|[+\-]?\d+(?:\.\d+)?(?:[cem]m|ex|in|p[ctx])|auto)\s*,\s*(?:0|[+\-]?\d+(?:\.\d+)?(?:[cem]m|ex|in|p[ctx])|auto) *\) *$/i,'cssPropBits':0,'cssLitGroup':[L[38],L[47]]},'color':{'cssExtra':c[1],'cssPropBits':130,'cssLitGroup':[L[0],L[47]]},'content':{'cssPropBits':8,'cssLitGroup':[L[54],L[55]]},'counter-increment':{'cssExtra':c[0],'cssPropBits':5,'cssLitGroup':[L[47],L[54]]},'counter-reset':{'cssExtra':c[0],'cssPropBits':5,'cssLitGroup':[L[47],L[54]]},'cue':{'cssPropBits':16,'cssLitGroup':[L[47],L[54]]},'cue-after':{'cssPropBits':16,'cssLitGroup':[L[47],L[54]]},'cue-before':{'cssPropBits':16,'cssLitGroup':[L[47],L[54]]},'cursor':{'cssExtra':c[0],'cssPropBits':144,'cssLitGroup':[L[1],L[35],L[38],L[47]]},'direction':{'cssPropBits':0,'cssLitGroup':[L[31],L[47]]},'display':{'cssPropBits':32,'cssLitGroup':[L[2],L[47],L[54]]},'elevation':{'cssPropBits':5,'cssLitGroup':[L[13],L[47]]},'empty-cells':{'cssPropBits':0,'cssLitGroup':[L[27],L[47]]},'filter':{'cssExtra':/^ *(?:\s*alpha\(\s*opacity\s*=\s*(?:0|\d+(?:\.\d+)?%|[+\-]?\d+(?:\.\d+)?) *\))+ *$/i,'cssPropBits':32},'float':{'cssAlternates':['cssFloat','styleFloat'],'cssPropBits':32,'cssLitGroup':[L[30],L[47],L[54]]},'font':{'cssExtra':c[0],'cssPropBits':9,'cssLitGroup':[L[4],L[7],L[11],L[15],L[29],L[35],L[36],L[47],L[52],L[55],L[60]]},'font-family':{'cssExtra':c[0],'cssPropBits':8,'cssLitGroup':[L[15],L[35],L[47]]},'font-size':{'cssPropBits':1,'cssLitGroup':[L[7],L[47],L[52]]},'font-stretch':{'cssPropBits':0,'cssLitGroup':[L[5],L[55]]},'font-style':{'cssPropBits':0,'cssLitGroup':[L[29],L[47],L[55]]},'font-variant':{'cssPropBits':0,'cssLitGroup':[L[47],L[55],L[60]]},'font-weight':{'cssPropBits':0,'cssLitGroup':[L[4],L[47],L[55]]},'height':{'cssPropBits':37,'cssLitGroup':[L[38],L[47]]},'left':{'cssPropBits':37,'cssLitGroup':[L[38],L[47]]},'letter-spacing':{'cssPropBits':5,'cssLitGroup':[L[47],L[55]]},'line-height':{'cssPropBits':1,'cssLitGroup':[L[47],L[55]]},'list-style':{'cssPropBits':16,'cssLitGroup':[L[3],L[28],L[47],L[54]]},'list-style-image':{'cssPropBits':16,'cssLitGroup':[L[47],L[54]]},'list-style-position':{'cssPropBits':0,'cssLitGroup':[L[28],L[47]]},'list-style-type':{'cssPropBits':0,'cssLitGroup':[L[3],L[47],L[54]]},'margin':{'cssPropBits':5,'cssLitGroup':[L[38],L[47]]},'margin-bottom':{'cssPropBits':5,'cssLitGroup':[L[38],L[47]]},'margin-left':{'cssPropBits':5,'cssLitGroup':[L[38],L[47]]},'margin-right':{'cssPropBits':5,'cssLitGroup':[L[38],L[47]]},'margin-top':{'cssPropBits':5,'cssLitGroup':[L[38],L[47]]},'max-height':{'cssPropBits':1,'cssLitGroup':[L[38],L[47],L[54]]},'max-width':{'cssPropBits':1,'cssLitGroup':[L[38],L[47],L[54]]},'min-height':{'cssPropBits':1,'cssLitGroup':[L[38],L[47]]},'min-width':{'cssPropBits':1,'cssLitGroup':[L[38],L[47]]},'opacity':{'cssPropBits':33,'cssLitGroup':[L[47]]},'outline':{'cssExtra':c[1],'cssPropBits':7,'cssLitGroup':[L[0],L[9],L[34],L[46],L[47],L[48],L[49],L[52],L[54]]},'outline-color':{'cssExtra':c[1],'cssPropBits':2,'cssLitGroup':[L[0],L[47],L[49]]},'outline-style':{'cssPropBits':0,'cssLitGroup':[L[9],L[46],L[47],L[48],L[54]]},'outline-width':{'cssPropBits':5,'cssLitGroup':[L[34],L[47],L[52]]},'overflow':{'cssPropBits':32,'cssLitGroup':[L[38],L[46],L[47],L[58],L[63]]},'overflow-x':{'cssPropBits':0,'cssLitGroup':[L[32],L[38],L[46],L[58],L[63]]},'overflow-y':{'cssPropBits':0,'cssLitGroup':[L[32],L[38],L[46],L[58],L[63]]},'padding':{'cssPropBits':1,'cssLitGroup':[L[47]]},'padding-bottom':{'cssPropBits':33,'cssLitGroup':[L[47]]},'padding-left':{'cssPropBits':33,'cssLitGroup':[L[47]]},'padding-right':{'cssPropBits':33,'cssLitGroup':[L[47]]},'padding-top':{'cssPropBits':33,'cssLitGroup':[L[47]]},'page-break-after':{'cssPropBits':0,'cssLitGroup':[L[30],L[37],L[38],L[39],L[47]]},'page-break-before':{'cssPropBits':0,'cssLitGroup':[L[30],L[37],L[38],L[39],L[47]]},'page-break-inside':{'cssPropBits':0,'cssLitGroup':[L[38],L[39],L[47]]},'pause':{'cssPropBits':5,'cssLitGroup':[L[47]]},'pause-after':{'cssPropBits':5,'cssLitGroup':[L[47]]},'pause-before':{'cssPropBits':5,'cssLitGroup':[L[47]]},'pitch':{'cssPropBits':5,'cssLitGroup':[L[19],L[47],L[52]]},'pitch-range':{'cssPropBits':5,'cssLitGroup':[L[47]]},'play-during':{'cssExtra':c[0],'cssPropBits':16,'cssLitGroup':[L[38],L[47],L[53],L[54],L[57]]},'position':{'cssPropBits':32,'cssLitGroup':[L[20],L[47]]},'quotes':{'cssExtra':c[0],'cssPropBits':8,'cssLitGroup':[L[47],L[54]]},'richness':{'cssPropBits':5,'cssLitGroup':[L[47]]},'right':{'cssPropBits':37,'cssLitGroup':[L[38],L[47]]},'speak':{'cssPropBits':0,'cssLitGroup':[L[47],L[54],L[55],L[61]]},'speak-header':{'cssPropBits':0,'cssLitGroup':[L[37],L[47],L[56]]},'speak-numeral':{'cssPropBits':0,'cssLitGroup':[L[26],L[47]]},'speak-punctuation':{'cssPropBits':0,'cssLitGroup':[L[43],L[47],L[54]]},'speech-rate':{'cssPropBits':5,'cssLitGroup':[L[12],L[47],L[52]]},'stress':{'cssPropBits':5,'cssLitGroup':[L[47]]},'table-layout':{'cssPropBits':0,'cssLitGroup':[L[38],L[45],L[47]]},'text-align':{'cssPropBits':0,'cssLitGroup':[L[30],L[42],L[47],L[50]]},'text-decoration':{'cssPropBits':0,'cssLitGroup':[L[18],L[47],L[54]]},'text-indent':{'cssPropBits':5,'cssLitGroup':[L[47]]},'text-overflow':{'cssPropBits':0,'cssLitGroup':[L[25]]},'text-shadow':{'cssExtra':c[2],'cssPropBits':7,'cssLitGroup':[L[0],L[35],L[48],L[54]]},'text-transform':{'cssPropBits':0,'cssLitGroup':[L[21],L[47],L[54]]},'text-wrap':{'cssPropBits':0,'cssLitGroup':[L[33],L[54],L[55]]},'top':{'cssPropBits':37,'cssLitGroup':[L[38],L[47]]},'unicode-bidi':{'cssPropBits':0,'cssLitGroup':[L[23],L[47],L[55]]},'vertical-align':{'cssPropBits':5,'cssLitGroup':[L[10],L[24],L[47]]},'visibility':{'cssPropBits':32,'cssLitGroup':[L[44],L[46],L[47],L[63]]},'voice-family':{'cssExtra':c[0],'cssPropBits':8,'cssLitGroup':[L[22],L[35],L[47]]},'volume':{'cssPropBits':1,'cssLitGroup':[L[16],L[47],L[52]]},'white-space':{'cssPropBits':0,'cssLitGroup':[L[8],L[47],L[55]]},'width':{'cssPropBits':33,'cssLitGroup':[L[38],L[47]]},'word-spacing':{'cssPropBits':5,'cssLitGroup':[L[47],L[55]]},'word-wrap':{'cssPropBits':0,'cssLitGroup':[L[41],L[55]]},'z-index':{'cssPropBits':69,'cssLitGroup':[L[38],L[47]]},'zoom':{'cssPropBits':1,'cssLitGroup':[L[55]]}}})(),URI,decodeCss,html,html4,html_sanitize,lexCss,parseCssDeclarations,parseCssStylesheet,sanitizeCssProperty,sanitizeStylesheet;typeof
window!=='undefined'&&(window['cssSchema']=cssSchema),(function(){var ATKEYWORD,BOM,CDC,CDO,CHAR,CMP_OPS,COMMENT,CSS_TOKEN,DASHMATCH,DIMENSION,ESCAPE,ESCAPE_TAIL,FUNCTION,HASH,IDENT,INCLUDES,NAME,NL,NMCHAR,NMSTART,NONASCII,NUM,NUMBER,NUMERIC_VALUE,PERCENTAGE,PREFIXMATCH,S,STRING,STRINGCHAR,SUBSTRINGMATCH,SUFFIXMATCH,SURROGATE_PAIR,UNICODE,UNICODE_RANGE,UNICODE_TAIL,URI,URLCHAR,W,WC,WORD_TERM,cssStrChars,cssUrlChars;function
decodeCssEscape(s){var i=parseInt(s.substring(1),16);return i>65535?(i-=65536,String.fromCharCode(55296+(i>>10),56320+(i&1023))):i==i?String.fromCharCode(i):s[1]<' '?'':s[1]}function
escapeCssString(s,replacer){return'\"'+s.replace(/[\u0000-\u001f\\\"\x3c\x3e]/g,replacer)+'\"'}function
escapeCssStrChar(ch){return cssStrChars[ch]||(cssStrChars[ch]='\\'+ch.charCodeAt(0).toString(16)+' ')}function
escapeCssUrlChar(ch){return cssUrlChars[ch]||(cssUrlChars[ch]=(ch<'\x10'?'%0':'%')+ch.charCodeAt(0).toString(16))}cssStrChars={'\\':'\\\\'},cssUrlChars={'\\':'%5c'},WC='[\\t\\n\\f ]',W=WC+'*',NL='[\\n\\f]',SURROGATE_PAIR='[\\ud800-\\udbff][\\udc00-\\udfff]',NONASCII='[\\u0080-\\ud7ff\\ue000-\\ufffd]|'+SURROGATE_PAIR,UNICODE_TAIL='[0-9a-fA-F]{1,6}'+WC+'?',UNICODE='\\\\'+UNICODE_TAIL,ESCAPE_TAIL='(?:'+UNICODE_TAIL+'|[\\u0020-\\u007e\\u0080-\\ud7ff\\ue000\\ufffd]|'+SURROGATE_PAIR+')',ESCAPE='\\\\'+ESCAPE_TAIL,URLCHAR='(?:[\\t\\x21\\x23-\\x26\\x28-\\x5b\\x5d-\\x7e]|'+NONASCII+'|'+ESCAPE+')',STRINGCHAR='[^\'\"\\n\\f\\\\]|\\\\[\\s\\S]',STRING='\"(?:\'|'+STRINGCHAR+')*\"'+'|\'(?:\"|'+STRINGCHAR+')*\'',NUM='[-+]?(?:[0-9]+(?:[.][0-9]+)?|[.][0-9]+)',NMSTART='(?:[a-zA-Z_]|'+NONASCII+'|'+ESCAPE+')',NMCHAR='(?:[a-zA-Z0-9_-]|'+NONASCII+'|'+ESCAPE+')',NAME=NMCHAR+'+',IDENT='-?'+NMSTART+NMCHAR+'*',ATKEYWORD='@'+IDENT,HASH='#'+NAME,NUMBER=NUM,WORD_TERM='(?:@?-?'+NMSTART+'|#)'+NMCHAR+'*',PERCENTAGE=NUM+'%',DIMENSION=NUM+IDENT,NUMERIC_VALUE=NUM+'(?:%|'+IDENT+')?',URI='url[(]'+W+'(?:'+STRING+'|'+URLCHAR+'*)'+W+'[)]',UNICODE_RANGE='U[+][0-9A-F?]{1,6}(?:-[0-9A-F]{1,6})?',CDO='\x3c!--',CDC='--\x3e',S=WC+'+',COMMENT='/(?:[*][^*]*[*]+(?:[^/][^*]*[*]+)*/|/[^\\n\\f]*)',FUNCTION='(?!url[(])'+IDENT+'[(]',INCLUDES='~=',DASHMATCH='[|]=',PREFIXMATCH='[^]=',SUFFIXMATCH='[$]=',SUBSTRINGMATCH='[*]=',CMP_OPS='[~|^$*]=',CHAR='[^\"\'\\\\/]|/(?![/*])',BOM='\\uFEFF',CSS_TOKEN=new
RegExp(([BOM,UNICODE_RANGE,URI,FUNCTION,WORD_TERM,STRING,NUMERIC_VALUE,CDO,CDC,S,COMMENT,CMP_OPS,CHAR].join('|')),'gi'),decodeCss=function(css){return css.replace(new
RegExp(('\\\\(?:'+ESCAPE_TAIL+'|'+NL+')'),'g'),decodeCssEscape)},lexCss=function(cssText){var
cc,i,j,last,len,n,tok,tokens;cssText=''+cssText,tokens=cssText.replace(/\r\n?/g,'\n').match(CSS_TOKEN)||[],j=0,last=' ';for(i=0,n=tokens.length;i<n;++i)tok=decodeCss(tokens[i]),len=tok.length,cc=tok.charCodeAt(0),tok=cc=='\"'.charCodeAt(0)||cc=='\''.charCodeAt(0)?escapeCssString(tok.substring(1,len-1),escapeCssStrChar):cc=='/'.charCodeAt(0)&&len>1||tok=='\\'||tok==CDC||tok==CDO||tok=='\ufeff'||cc<=' '.charCodeAt(0)?' ':/url\(/i.test(tok)?'url('+escapeCssString(tok.replace(new
RegExp(('^url\\('+W+'[\"\']?|[\"\']?'+W+'\\)$'),'gi'),''),escapeCssUrlChar)+')':tok,(last!=tok||tok!=' ')&&(tokens[j++]=last=tok);return tokens.length=j,tokens}})(),typeof
window!=='undefined'&&(window['lexCss']=lexCss,window['decodeCss']=decodeCss),URI=(function(){var
EXTRA_PARENT_PATHS_RE,PARENT_DIRECTORY_HANDLER,PARENT_DIRECTORY_HANDLER_RE,URI_DISALLOWED_IN_PATH_,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_,URI_RE_;function
parse(uriStr){var m=(''+uriStr).match(URI_RE_);return m?new URI((nullIfAbsent(m[1])),(nullIfAbsent(m[2])),(nullIfAbsent(m[3])),(nullIfAbsent(m[4])),(nullIfAbsent(m[5])),(nullIfAbsent(m[6])),(nullIfAbsent(m[7]))):null}function
create(scheme,credentials,domain,port,path,query,fragment){var uri=new URI((encodeIfExists2(scheme,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_)),(encodeIfExists2(credentials,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_)),(encodeIfExists(domain)),(port>0?port.toString():null),(encodeIfExists2(path,URI_DISALLOWED_IN_PATH_)),null,(encodeIfExists(fragment)));return query&&('string'===typeof
query?uri.setRawQuery(query.replace(/[^?\x26=0-9A-Za-z_\-~.%]/g,encodeOne)):uri.setAllParameters(query)),uri}function
encodeIfExists(unescapedPart){return'string'==typeof unescapedPart?encodeURIComponent(unescapedPart):null}function
encodeIfExists2(unescapedPart,extra){return'string'==typeof unescapedPart?encodeURI(unescapedPart).replace(extra,encodeOne):null}function
encodeOne(ch){var n=ch.charCodeAt(0);return'%'+'0123456789ABCDEF'.charAt(n>>4&15)+'0123456789ABCDEF'.charAt(n&15)}function
normPath(path){return path.replace(/(^|\/)\.(?:\/|$)/g,'$1').replace(/\/{2,}/g,'/')}PARENT_DIRECTORY_HANDLER=new
RegExp('(/|^)(?:[^./][^/]*|\\.{2,}(?:[^./][^/]*)|\\.{3,}[^/]*)/\\.\\.(?:/|$)'),PARENT_DIRECTORY_HANDLER_RE=new
RegExp(PARENT_DIRECTORY_HANDLER),EXTRA_PARENT_PATHS_RE=/^(?:\.\.\/)*(?:\.\.$)?/;function
collapse_dots(path){var p,q,r;if(path===null)return null;p=normPath(path),r=PARENT_DIRECTORY_HANDLER_RE;for(;(q=p.replace(r,'$1'))!=p;p=q);return p}function
resolve(baseUri,relativeUri){var absoluteUri=baseUri.clone(),overridden=relativeUri.hasScheme(),absRawPath,rawPath,simplifiedPath,slash;return overridden?absoluteUri.setRawScheme(relativeUri.getRawScheme()):(overridden=relativeUri.hasCredentials()),overridden?absoluteUri.setRawCredentials(relativeUri.getRawCredentials()):(overridden=relativeUri.hasDomain()),overridden?absoluteUri.setRawDomain(relativeUri.getRawDomain()):(overridden=relativeUri.hasPort()),rawPath=relativeUri.getRawPath(),simplifiedPath=collapse_dots(rawPath),overridden?(absoluteUri.setPort(relativeUri.getPort()),simplifiedPath=simplifiedPath&&simplifiedPath.replace(EXTRA_PARENT_PATHS_RE,'')):(overridden=!!rawPath,overridden?simplifiedPath.charCodeAt(0)!==47&&(absRawPath=collapse_dots(absoluteUri.getRawPath()||'').replace(EXTRA_PARENT_PATHS_RE,''),slash=absRawPath.lastIndexOf('/')+1,simplifiedPath=collapse_dots((slash?absRawPath.substring(0,slash):'')+collapse_dots(rawPath)).replace(EXTRA_PARENT_PATHS_RE,'')):(simplifiedPath=simplifiedPath&&simplifiedPath.replace(EXTRA_PARENT_PATHS_RE,''),simplifiedPath!==rawPath&&absoluteUri.setRawPath(simplifiedPath))),overridden?absoluteUri.setRawPath(simplifiedPath):(overridden=relativeUri.hasQuery()),overridden?absoluteUri.setRawQuery(relativeUri.getRawQuery()):(overridden=relativeUri.hasFragment()),overridden&&absoluteUri.setRawFragment(relativeUri.getRawFragment()),absoluteUri}function
URI(rawScheme,rawCredentials,rawDomain,port,rawPath,rawQuery,rawFragment){this.scheme_=rawScheme,this.credentials_=rawCredentials,this.domain_=rawDomain,this.port_=port,this.path_=rawPath,this.query_=rawQuery,this.fragment_=rawFragment,this.paramCache_=null}URI.prototype.toString=function(){var
out=[];return null!==this.scheme_&&out.push(this.scheme_,':'),null!==this.domain_&&(out.push('//'),null!==this.credentials_&&out.push(this.credentials_,'@'),out.push(this.domain_),null!==this.port_&&out.push(':',this.port_.toString())),null!==this.path_&&out.push(this.path_),null!==this.query_&&out.push('?',this.query_),null!==this.fragment_&&out.push('#',this.fragment_),out.join('')},URI.prototype.clone=function(){return new
URI(this.scheme_,this.credentials_,this.domain_,this.port_,this.path_,this.query_,this.fragment_)},URI.prototype.getScheme=function(){return this.scheme_&&decodeURIComponent(this.scheme_).toLowerCase()},URI.prototype.getRawScheme=function(){return this.scheme_},URI.prototype.setScheme=function(newScheme){return this.scheme_=encodeIfExists2(newScheme,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_),this},URI.prototype.setRawScheme=function(newScheme){return this.scheme_=newScheme?newScheme:null,this},URI.prototype.hasScheme=function(){return null!==this.scheme_},URI.prototype.getCredentials=function(){return this.credentials_&&decodeURIComponent(this.credentials_)},URI.prototype.getRawCredentials=function(){return this.credentials_},URI.prototype.setCredentials=function(newCredentials){return this.credentials_=encodeIfExists2(newCredentials,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_),this},URI.prototype.setRawCredentials=function(newCredentials){return this.credentials_=newCredentials?newCredentials:null,this},URI.prototype.hasCredentials=function(){return null!==this.credentials_},URI.prototype.getDomain=function(){return this.domain_&&decodeURIComponent(this.domain_)},URI.prototype.getRawDomain=function(){return this.domain_},URI.prototype.setDomain=function(newDomain){return this.setRawDomain(newDomain&&encodeURIComponent(newDomain))},URI.prototype.setRawDomain=function(newDomain){return this.domain_=newDomain?newDomain:null,this.setRawPath(this.path_)},URI.prototype.hasDomain=function(){return null!==this.domain_},URI.prototype.getPort=function(){return this.port_&&decodeURIComponent(this.port_)},URI.prototype.setPort=function(newPort){if(newPort){newPort=Number(newPort);if(newPort!==(newPort&65535))throw new
Error(('Bad port number '+newPort));this.port_=''+newPort}else this.port_=null;return this},URI.prototype.hasPort=function(){return null!==this.port_},URI.prototype.getPath=function(){return this.path_&&decodeURIComponent(this.path_)},URI.prototype.getRawPath=function(){return this.path_},URI.prototype.setPath=function(newPath){return this.setRawPath(encodeIfExists2(newPath,URI_DISALLOWED_IN_PATH_))},URI.prototype.setRawPath=function(newPath){return newPath?(newPath=String(newPath),this.path_=!this.domain_||/^\//.test(newPath)?newPath:'/'+newPath):(this.path_=null),this},URI.prototype.hasPath=function(){return null!==this.path_},URI.prototype.getQuery=function(){return this.query_&&decodeURIComponent(this.query_).replace(/\+/g,' ')},URI.prototype.getRawQuery=function(){return this.query_},URI.prototype.setQuery=function(newQuery){return this.paramCache_=null,this.query_=encodeIfExists(newQuery),this},URI.prototype.setRawQuery=function(newQuery){return this.paramCache_=null,this.query_=newQuery?newQuery:null,this},URI.prototype.hasQuery=function(){return null!==this.query_},URI.prototype.setAllParameters=function(params){var
i,j,k,newParams,queryBuf,separator,v;if(typeof params==='object'){if(!(params instanceof
Array)&&(params instanceof Object||Object.prototype.toString.call(params)!=='[object Array]')){newParams=[],i=-1;for(k
in params)v=params[k],'string'===typeof v&&(newParams[++i]=k,newParams[++i]=v);params=newParams}}this.paramCache_=null,queryBuf=[],separator='';for(j=0;j<params.length;)k=params[j++],v=params[j++],queryBuf.push(separator,encodeURIComponent(k.toString())),separator='\x26',v&&queryBuf.push('=',encodeURIComponent(v.toString()));return this.query_=queryBuf.join(''),this},URI.prototype.checkParameterCache_=function(){var
cgiParams,i,k,m,out,q;if(!this.paramCache_){q=this.query_;if(!q)this.paramCache_=[];else{cgiParams=q.split(/[\x26\?]/),out=[],k=-1;for(i=0;i<cgiParams.length;++i)m=cgiParams[i].match(/^([^=]*)(?:=(.*))?$/),out[++k]=decodeURIComponent(m[1]).replace(/\+/g,' '),out[++k]=decodeURIComponent(m[2]||'').replace(/\+/g,' ');this.paramCache_=out}}},URI.prototype.setParameterValues=function(key,values){var
i,k,newValueIndex,params,pc;typeof values==='string'&&(values=[values]),this.checkParameterCache_(),newValueIndex=0,pc=this.paramCache_,params=[];for(i=0,k=0;i<pc.length;i+=2)key===pc[i]?newValueIndex<values.length&&params.push(key,values[newValueIndex++]):params.push(pc[i],pc[i+1]);while(newValueIndex<values.length)params.push(key,values[newValueIndex++]);return this.setAllParameters(params),this},URI.prototype.removeParameter=function(key){return this.setParameterValues(key,[])},URI.prototype.getAllParameters=function(){return this.checkParameterCache_(),this.paramCache_.slice(0,this.paramCache_.length)},URI.prototype.getParameterValues=function(paramNameUnescaped){var
i,values;this.checkParameterCache_(),values=[];for(i=0;i<this.paramCache_.length;i+=2)paramNameUnescaped===this.paramCache_[i]&&values.push(this.paramCache_[i+1]);return values},URI.prototype.getParameterMap=function(paramNameUnescaped){var
i,key,paramMap,value;this.checkParameterCache_(),paramMap={};for(i=0;i<this.paramCache_.length;i+=2)key=this.paramCache_[i++],value=this.paramCache_[i++],key
in paramMap?paramMap[key].push(value):(paramMap[key]=[value]);return paramMap},URI.prototype.getParameterValue=function(paramNameUnescaped){var
i;this.checkParameterCache_();for(i=0;i<this.paramCache_.length;i+=2)if(paramNameUnescaped===this.paramCache_[i])return this.paramCache_[i+1];return null},URI.prototype.getFragment=function(){return this.fragment_&&decodeURIComponent(this.fragment_)},URI.prototype.getRawFragment=function(){return this.fragment_},URI.prototype.setFragment=function(newFragment){return this.fragment_=newFragment?encodeURIComponent(newFragment):null,this},URI.prototype.setRawFragment=function(newFragment){return this.fragment_=newFragment?newFragment:null,this},URI.prototype.hasFragment=function(){return null!==this.fragment_};function
nullIfAbsent(matchPart){return'string'==typeof matchPart&&matchPart.length>0?matchPart:null}return URI_RE_=new
RegExp('^(?:([^:/?#]+):)?(?://(?:([^/?#]*)@)?([^/?#:@]*)(?::([0-9]+))?)?([^?#]+)?(?:\\?([^#]*))?(?:#(.*))?$'),URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_=/[#\/\?@]/g,URI_DISALLOWED_IN_PATH_=/[\#\?]/g,URI.parse=parse,URI.create=create,URI.resolve=resolve,URI.collapse_dots=collapse_dots,URI.utils={'mimeTypeOf':function(uri){var
uriObj=parse(uri);return/\.html$/.test(uriObj.getPath())?'text/html':'application/javascript'},'resolve':function(base,uri){return base?resolve(parse(base),parse(uri)).toString():''+uri}},URI})(),typeof
window!=='undefined'&&(window['URI']=URI),sanitizeCssProperty=(function(){var NOEFFECT_URL='url(\"about:blank\")',NORM_URL_REGEXP=/[\n\f\r\"\'()*\x3c\x3e]/g,NORM_URL_REPLACEMENTS={'\n':'%0a','\f':'%0c','\r':'%0d','\"':'%22','\'':'%27','(':'%28',')':'%29','*':'%2a','\x3c':'%3c','\x3e':'%3e'},ALLOWED_LITERAL,ALLOWED_URI_SCHEMES,URI_SCHEME_RE;function
normalizeUrl(s){return'string'===typeof s?'url(\"'+s.replace(NORM_URL_REGEXP,normalizeUrlChar)+'\")':NOEFFECT_URL}function
normalizeUrlChar(ch){return NORM_URL_REPLACEMENTS[ch]}URI_SCHEME_RE=new RegExp('^(?:([^:/?# ]+):)?'),ALLOWED_URI_SCHEMES=/^(?:https?|mailto)$/i;function
resolveUri(baseUri,uri){return baseUri?URI.utils.resolve(baseUri,uri):uri}function
safeUri(uri,prop,naiveUriRewriter){var parsed;return naiveUriRewriter?(parsed=(''+uri).match(URI_SCHEME_RE),parsed&&(!parsed[1]||ALLOWED_URI_SCHEMES.test(parsed[1]))?naiveUriRewriter(uri,prop):null):null}function
unionArrays(arrs){var map={},arr,i,j;for(i=arrs.length;--i>=0;){arr=arrs[i];for(j=arr.length;--j>=0;)map[arr[j]]=ALLOWED_LITERAL}return map}function
normalizeFunctionCall(tokens,start){var parenDepth=1,end=start+1,n=tokens.length,token;while(end<n&&parenDepth)token=tokens[end++],parenDepth+=token==='('?1:token===')'?-1:0;return end}return ALLOWED_LITERAL={},function(property,propertySchema,tokens,opt_naiveUriRewriter,opt_baseUri){var
propBits=propertySchema.cssPropBits,qstringBits=propBits&(CSS_PROP_BIT_QSTRING_CONTENT|CSS_PROP_BIT_QSTRING_URL),lastQuoted=NaN,i=0,k=0,cc,cc1,cc2,end,isnum1,isnum2,litGroup,litMap,token;for(;i<tokens.length;++i)token=tokens[i].toLowerCase(),cc=token.charCodeAt(0),token=cc===' '.charCodeAt(0)?'':cc==='\"'.charCodeAt(0)?qstringBits===CSS_PROP_BIT_QSTRING_URL&&opt_naiveUriRewriter?normalizeUrl(safeUri(resolveUri(opt_baseUri,decodeCss(tokens[i].substring(1,token.length-1))),property,opt_naiveUriRewriter)):qstringBits===CSS_PROP_BIT_QSTRING_CONTENT?token:'':cc==='#'.charCodeAt(0)&&/^#(?:[0-9a-f]{3}){1,2}$/.test(token)?propBits&CSS_PROP_BIT_HASH_VALUE?token:'':'0'.charCodeAt(0)<=cc&&cc<='9'.charCodeAt(0)?propBits&CSS_PROP_BIT_QUANTITY?propBits&CSS_PROP_BIT_Z_INDEX?token.match(/^\d{1,7}$/)?token:'':token:'':(cc1=token.charCodeAt(1),cc2=token.charCodeAt(2),isnum1='0'.charCodeAt(0)<=cc1&&cc1<='9'.charCodeAt(0),isnum2='0'.charCodeAt(0)<=cc2&&cc2<='9'.charCodeAt(0),cc==='+'.charCodeAt(0)&&(isnum1||cc1==='.'.charCodeAt(0)&&isnum2))?propBits&CSS_PROP_BIT_QUANTITY?propBits&CSS_PROP_BIT_Z_INDEX?token.match(/^\+\d{1,7}$/)?token:'':(isnum1?'':'0')+token.substring(1):'':cc==='-'.charCodeAt(0)&&(isnum1||cc1==='.'.charCodeAt(0)&&isnum2)?propBits&CSS_PROP_BIT_NEGATIVE_QUANTITY?propBits&CSS_PROP_BIT_Z_INDEX?token.match(/^\-\d{1,7}$/)?token:'':(isnum1?'-':'-0')+token.substring(1):propBits&CSS_PROP_BIT_QUANTITY?'0':'':cc==='.'.charCodeAt(0)&&isnum1?propBits&CSS_PROP_BIT_QUANTITY?'0'+token:'':'url('===token.substring(0,4)?opt_naiveUriRewriter&&qstringBits&CSS_PROP_BIT_QSTRING_URL?normalizeUrl(safeUri(resolveUri(opt_baseUri,tokens[i].substring(5,token.length-2)),property,opt_naiveUriRewriter)):'':(token.charAt(token.length-1)==='('&&(end=normalizeFunctionCall(tokens,i),tokens.splice(i,end-i,token=tokens.slice(i,end).join(' '))),litGroup=propertySchema.cssLitGroup,litMap=litGroup?propertySchema.cssLitMap||(propertySchema.cssLitMap=unionArrays(litGroup)):ALLOWED_LITERAL,litMap[token]===ALLOWED_LITERAL||propertySchema.cssExtra&&propertySchema.cssExtra.test(token))?token:/^\w+$/.test(token)&&qstringBits===CSS_PROP_BIT_QSTRING_CONTENT?lastQuoted+1===k?(tokens[lastQuoted]=tokens[lastQuoted].substring(0,tokens[lastQuoted].length-1)+' '+token+'\"',token=''):(lastQuoted=k,'\"'+token+'\"'):'',token&&(tokens[k++]=token);k===1&&tokens[0]===NOEFFECT_URL&&(k=0),tokens.length=k}})();function
sanitizeCssSelectors(selectors,suffix,tagPolicy){var historySensitiveSelectors=[],historyInsensitiveSelectors=[],HISTORY_NON_SENSITIVE_PSEUDO_SELECTOR_WHITELIST=/^(active|after|before|first-child|first-letter|focus|hover)$/,HISTORY_SENSITIVE_PSEUDO_SELECTOR_WHITELIST=/^(link|visited)$/,k=0,inBrackets=0,i,n,start,tok;for(i=0;i<selectors.length;++i)tok=selectors[i],(tok=='('||tok=='['?(++inBrackets,true):tok==')'||tok==']'?(inBrackets&&--inBrackets,true):!(selectors[i]==' '&&(inBrackets||selectors[i-1]=='\x3e'||selectors[i+1]=='\x3e')))&&(selectors[k++]=selectors[i]);selectors.length=k,n=selectors.length,start=0;for(i=0;i<n;++i)selectors[i]===','&&(processSelector(start,i),start=i+1);processSelector(start,n);function
processSelector(start,end){var historySensitive=false,elSelector,i,isChild,lastOperator,out,safeSelector,tok;selectors[start]===' '&&++start,end-1!==start&&selectors[end]===' '&&--end,out=[],lastOperator=start,elSelector='';for(i=start;i<end;++i){tok=selectors[i],isChild=tok==='\x3e';if(isChild||tok===' '){elSelector=processElementSelector(lastOperator,i,false);if(!elSelector||isChild&&/^html/i.test(elSelector))return;lastOperator=i+1,out.push(elSelector,isChild?' \x3e ':' ')}}elSelector=processElementSelector(lastOperator,end,true);if(!elSelector)return;out.push(elSelector);function
processElementSelector(start,end,last){var element='',attr,attrs,atype,classId,decision,op,pseudoSelector,tok,value;start<end&&(tok=selectors[start],tok==='*'?(++start,element=tok):/^[a-zA-Z]/.test(tok)&&(decision=tagPolicy(tok.toLowerCase(),[]),decision&&('tagName'in
decision&&(tok=decision['tagName']),++start,element=tok))),classId='';while(start<end){tok=selectors[start];if(tok.charAt(0)==='#'){if(/^#_|__$|[^#0-9A-Za-z:_\-]/.test(tok))return null;classId+=tok+'-'+suffix}else
if(tok==='.')if(++start<end&&/^[0-9A-Za-z:_\-]+$/.test(tok=selectors[start])&&!/^_|__$/.test(tok))classId+='.'+tok;else
return null;else break;++start}attrs='';while(start<end&&selectors[start]==='['){++start,attr=selectors[start++],atype=html4.ATTRIBS[element+'::'+attr],atype!==+atype&&(atype=html4.ATTRIBS['*::'+attr]);if(atype!==+atype)return null;op='',value='',/^[~^$*|]?=$/.test(selectors[start])&&(op=selectors[start++],value=selectors[start++]);if(selectors[start++]!==']')return null;switch(atype){case
html4.atype['NONE']:case html4.atype['URI']:case html4.atype['URI_FRAGMENT']:case
html4.atype['ID']:case html4.atype['IDREF']:case html4.atype['IDREFS']:case html4.atype['GLOBAL_NAME']:case
html4.atype['LOCAL_NAME']:case html4.atype['CLASSES']:if(op&&atype!==html4.atype['NONE'])return null;attrs+='['+attr+op+value+']'}}pseudoSelector='';if(start<end&&selectors[start]===':'){tok=selectors[++start];if(HISTORY_SENSITIVE_PSEUDO_SELECTOR_WHITELIST.test(tok)){if(!/^[a*]?$/.test(element))return null;historySensitive=true,pseudoSelector=':'+tok,++start,element='a'}else
if(HISTORY_NON_SENSITIVE_PSEUDO_SELECTOR_WHITELIST.test(tok))historySensitive=false,pseudoSelector=':'+tok,++start}return start===end?(element+classId).replace(/[^ .*#\w-]/g,'\\$\x26')+attrs+pseudoSelector:null}safeSelector=out.join(''),safeSelector='.'+suffix+' '+safeSelector,(historySensitive?historySensitiveSelectors:historyInsensitiveSelectors).push(safeSelector)}return[historyInsensitiveSelectors,historySensitiveSelectors]}sanitizeStylesheet=(function(){var
allowed={},cssMediaTypeWhitelist={'braille':allowed,'embossed':allowed,'handheld':allowed,'print':allowed,'projection':allowed,'screen':allowed,'speech':allowed,'tty':allowed,'tv':allowed};function
sanitizeHistorySensitive(blockOfProperties){var elide=false,i,n,token;for(i=0,n=blockOfProperties.length;i<n-1;++i)token=blockOfProperties[i],':'===blockOfProperties[i+1]&&(elide=!(cssSchema[token].cssPropBits&CSS_PROP_BIT_ALLOWED_IN_LINK)),elide&&(blockOfProperties[i]=''),';'===token&&(elide=false);return blockOfProperties.join('')}return function(baseUri,cssText,suffix,naiveUriRewriter,tagPolicy){var
safeCss=void 0,blockStack=[],elide=false;parseCssStylesheet(cssText,{'startStylesheet':function(){safeCss=[]},'endStylesheet':function(){},'startAtrule':function(atIdent,headerArray){elide?(atIdent=null):atIdent==='@media'?(headerArray=headerArray.filter(function(mediaType){return cssMediaTypeWhitelist[mediaType]==allowed}),headerArray.length?safeCss.push(atIdent,headerArray.join(','),'{'):(atIdent=null)):(atIdent==='@import'&&(window.console&&window.console.log('@import '+headerArray.join(' ')+' elided')),atIdent=null),elide=!atIdent,blockStack.push(atIdent)},'endAtrule':function(){var
atIdent=blockStack.pop();elide||safeCss.push(';'),checkElide()},'startBlock':function(){elide||safeCss.push('{')},'endBlock':function(){elide||(safeCss.push('}'),elide=true)},'startRuleset':function(selectorArray){var
historySensitiveSelectors=void 0,removeHistoryInsensitiveSelectors=false,historyInsensitiveSelectors,selector,selectors;elide||(selectors=sanitizeCssSelectors(selectorArray,suffix,tagPolicy),historyInsensitiveSelectors=selectors[0],historySensitiveSelectors=selectors[1],!historyInsensitiveSelectors.length&&!historySensitiveSelectors.length?(elide=true):(selector=historyInsensitiveSelectors.join(', '),selector||(selector='head \x3e html',removeHistoryInsensitiveSelectors=true),safeCss.push(selector,'{'))),blockStack.push(elide?null:{'historySensitiveSelectors':historySensitiveSelectors,'endOfSelectors':safeCss.length-1,'removeHistoryInsensitiveSelectors':removeHistoryInsensitiveSelectors})},'endRuleset':function(){var
rules=blockStack.pop(),propertiesEnd=safeCss.length,extraSelectors,propertyGroupTokens;elide||(safeCss.push('}'),rules&&(extraSelectors=rules.historySensitiveSelectors,extraSelectors.length&&(propertyGroupTokens=safeCss.slice(rules.endOfSelectors),safeCss.push(extraSelectors.join(', '),sanitizeHistorySensitive(propertyGroupTokens))))),rules&&rules.removeHistoryInsensitiveSelectors&&safeCss.splice(rules.endOfSelectors-1,propertiesEnd+1),checkElide()},'declaration':function(property,valueArray){var
schema;elide||(schema=cssSchema[property],schema&&(sanitizeCssProperty(property,schema,valueArray,naiveUriRewriter,baseUri),valueArray.length&&safeCss.push(property,':',valueArray.join(' '),';')))}});function
checkElide(){elide=blockStack.length!==0&&blockStack[blockStack.length-1]!==null}return safeCss.join('')}})(),typeof
window!=='undefined'&&(window['sanitizeCssProperty']=sanitizeCssProperty,window['sanitizeCssSelectors']=sanitizeCssSelectors,window['sanitizeStylesheet']=sanitizeStylesheet);if('I'.toLowerCase()!=='i')throw'I/i problem';(function(){var
ident;parseCssStylesheet=function(cssText,handler){var toks=lexCss(cssText),i,n;handler.startStylesheet&&handler.startStylesheet();for(i=0,n=toks.length;i<n;)i=toks[i]===' '?i+1:statement(toks,i,n,handler);handler.endStylesheet&&handler.endStylesheet()};function
statement(toks,i,n,handler){var tok;return i<n?(tok=toks[i],tok.charAt(0)==='@'?atrule(toks,i,n,handler,true):ruleset(toks,i,n,handler)):i}function
atrule(toks,i,n,handler,blockok){var start=i++,e,s;while(i<n&&toks[i]!=='{'&&toks[i]!==';')++i;return i<n&&(blockok||toks[i]===';')&&(s=start+1,e=i,s<n&&toks[s]===' '&&++s,e>s&&toks[e-1]===' '&&--e,handler.startAtrule&&handler.startAtrule(toks[start].toLowerCase(),toks.slice(s,e)),i=toks[i]==='{'?block(toks,i,n,handler):i+1,handler.endAtrule&&handler.endAtrule()),i}function
block(toks,i,n,handler){var ch;++i,handler.startBlock&&handler.startBlock();while(i<n){ch=toks[i].charAt(0);if(ch=='}'){++i;break}ch===' '||ch===';'?(i=i+1):ch==='@'?(i=atrule(toks,i,n,handler,false)):ch==='{'?(i=block(toks,i,n,handler)):(i=ruleset(toks,i,n,handler))}return handler.endBlock&&handler.endBlock(),i}function
ruleset(toks,i,n,handler){var s=i,e=selector(toks,i,n,true),tok;if(e<0)return e=~e,i===e?e+1:e;i=e,e>s&&toks[e-1]===' '&&--e,tok=toks[i],++i;if(tok!=='{')return i;handler.startRuleset&&handler.startRuleset(toks.slice(s,e));while(i<n){tok=toks[i];if(tok==='}'){++i;break}tok===' '?(i=i+1):(i=declaration(toks,i,n,handler))}return handler.endRuleset&&handler.endRuleset(),i<n?i+1:i}function
selector(toks,i,n,allowSemi){var s=i,brackets=[],stackLast=-1,tok;for(;i<n;++i){tok=toks[i].charAt(0);if(tok==='['||tok==='(')brackets[++stackLast]=tok;else
if(tok===']'&&brackets[stackLast]==='['||tok===')'&&brackets[stackLast]==='(')--stackLast;else
if(tok==='{'||tok==='}'||tok===';'||tok==='@'||tok===':'&&!allowSemi)break}return stackLast>=0&&(i=~(i+1)),i}ident=/^-?[a-z]/i;function
declaration(toks,i,n,handler){var property=toks[i++],e,j,s,tok,value,valuelen;if(!ident.test(property))return i+1;i<n&&toks[i]===' '&&++i;if(i==n||toks[i]!==':'){while(i<n&&(tok=toks[i])!==';'&&tok!=='}')++i;return i}++i,i<n&&toks[i]===' '&&++i,s=i,e=selector(toks,i,n,false);if(e<0)e=~e;else{value=[],valuelen=0;for(j=s;j<e;++j)tok=toks[j],tok!==' '&&(value[valuelen++]=tok);if(e<n){do{tok=toks[e];if(tok===';'||tok==='}')break;valuelen=0}while(++e<n);tok===';'&&++e}valuelen&&handler.declaration&&handler.declaration(property.toLowerCase(),value)}return e}parseCssDeclarations=function(cssText,handler){var
toks=lexCss(cssText),i,n;for(i=0,n=toks.length;i<n;)i=toks[i]!==' '?declaration(toks,i,n,handler):i+1}})(),typeof
window!=='undefined'&&(window['parseCssStylesheet']=parseCssStylesheet,window['parseCssDeclarations']=parseCssDeclarations),html4={},html4.atype={'NONE':0,'URI':1,'URI_FRAGMENT':11,'SCRIPT':2,'STYLE':3,'HTML':12,'ID':4,'IDREF':5,'IDREFS':6,'GLOBAL_NAME':7,'LOCAL_NAME':8,'CLASSES':9,'FRAME_TARGET':10,'MEDIA_QUERY':13},html4['atype']=html4.atype,html4.ATTRIBS={'*::class':9,'*::dir':0,'*::draggable':0,'*::hidden':0,'*::id':4,'*::inert':0,'*::itemprop':0,'*::itemref':6,'*::itemscope':0,'*::lang':0,'*::onblur':2,'*::onchange':2,'*::onclick':2,'*::ondblclick':2,'*::onfocus':2,'*::onkeydown':2,'*::onkeypress':2,'*::onkeyup':2,'*::onload':2,'*::onmousedown':2,'*::onmousemove':2,'*::onmouseout':2,'*::onmouseover':2,'*::onmouseup':2,'*::onreset':2,'*::onscroll':2,'*::onselect':2,'*::onsubmit':2,'*::onunload':2,'*::spellcheck':0,'*::style':3,'*::title':0,'*::translate':0,'a::accesskey':0,'a::coords':0,'a::href':1,'a::hreflang':0,'a::name':7,'a::onblur':2,'a::onfocus':2,'a::shape':0,'a::tabindex':0,'a::target':10,'a::type':0,'area::accesskey':0,'area::alt':0,'area::coords':0,'area::href':1,'area::nohref':0,'area::onblur':2,'area::onfocus':2,'area::shape':0,'area::tabindex':0,'area::target':10,'audio::controls':0,'audio::loop':0,'audio::mediagroup':5,'audio::muted':0,'audio::preload':0,'bdo::dir':0,'blockquote::cite':1,'br::clear':0,'button::accesskey':0,'button::disabled':0,'button::name':8,'button::onblur':2,'button::onfocus':2,'button::tabindex':0,'button::type':0,'button::value':0,'canvas::height':0,'canvas::width':0,'caption::align':0,'col::align':0,'col::char':0,'col::charoff':0,'col::span':0,'col::valign':0,'col::width':0,'colgroup::align':0,'colgroup::char':0,'colgroup::charoff':0,'colgroup::span':0,'colgroup::valign':0,'colgroup::width':0,'command::checked':0,'command::command':5,'command::disabled':0,'command::icon':1,'command::label':0,'command::radiogroup':0,'command::type':0,'data::value':0,'del::cite':1,'del::datetime':0,'details::open':0,'dir::compact':0,'div::align':0,'dl::compact':0,'fieldset::disabled':0,'font::color':0,'font::face':0,'font::size':0,'form::accept':0,'form::action':1,'form::autocomplete':0,'form::enctype':0,'form::method':0,'form::name':7,'form::novalidate':0,'form::onreset':2,'form::onsubmit':2,'form::target':10,'h1::align':0,'h2::align':0,'h3::align':0,'h4::align':0,'h5::align':0,'h6::align':0,'hr::align':0,'hr::noshade':0,'hr::size':0,'hr::width':0,'iframe::align':0,'iframe::frameborder':0,'iframe::height':0,'iframe::marginheight':0,'iframe::marginwidth':0,'iframe::width':0,'img::align':0,'img::alt':0,'img::border':0,'img::height':0,'img::hspace':0,'img::ismap':0,'img::name':7,'img::src':1,'img::usemap':11,'img::vspace':0,'img::width':0,'input::accept':0,'input::accesskey':0,'input::align':0,'input::alt':0,'input::autocomplete':0,'input::checked':0,'input::disabled':0,'input::inputmode':0,'input::ismap':0,'input::list':5,'input::max':0,'input::maxlength':0,'input::min':0,'input::multiple':0,'input::name':8,'input::onblur':2,'input::onchange':2,'input::onfocus':2,'input::onselect':2,'input::placeholder':0,'input::readonly':0,'input::required':0,'input::size':0,'input::src':1,'input::step':0,'input::tabindex':0,'input::type':0,'input::usemap':11,'input::value':0,'ins::cite':1,'ins::datetime':0,'label::accesskey':0,'label::for':5,'label::onblur':2,'label::onfocus':2,'legend::accesskey':0,'legend::align':0,'li::type':0,'li::value':0,'map::name':7,'menu::compact':0,'menu::label':0,'menu::type':0,'meter::high':0,'meter::low':0,'meter::max':0,'meter::min':0,'meter::value':0,'ol::compact':0,'ol::reversed':0,'ol::start':0,'ol::type':0,'optgroup::disabled':0,'optgroup::label':0,'option::disabled':0,'option::label':0,'option::selected':0,'option::value':0,'output::for':6,'output::name':8,'p::align':0,'pre::width':0,'progress::max':0,'progress::min':0,'progress::value':0,'q::cite':1,'select::autocomplete':0,'select::disabled':0,'select::multiple':0,'select::name':8,'select::onblur':2,'select::onchange':2,'select::onfocus':2,'select::required':0,'select::size':0,'select::tabindex':0,'source::type':0,'table::align':0,'table::bgcolor':0,'table::border':0,'table::cellpadding':0,'table::cellspacing':0,'table::frame':0,'table::rules':0,'table::summary':0,'table::width':0,'tbody::align':0,'tbody::char':0,'tbody::charoff':0,'tbody::valign':0,'td::abbr':0,'td::align':0,'td::axis':0,'td::bgcolor':0,'td::char':0,'td::charoff':0,'td::colspan':0,'td::headers':6,'td::height':0,'td::nowrap':0,'td::rowspan':0,'td::scope':0,'td::valign':0,'td::width':0,'textarea::accesskey':0,'textarea::autocomplete':0,'textarea::cols':0,'textarea::disabled':0,'textarea::inputmode':0,'textarea::name':8,'textarea::onblur':2,'textarea::onchange':2,'textarea::onfocus':2,'textarea::onselect':2,'textarea::placeholder':0,'textarea::readonly':0,'textarea::required':0,'textarea::rows':0,'textarea::tabindex':0,'textarea::wrap':0,'tfoot::align':0,'tfoot::char':0,'tfoot::charoff':0,'tfoot::valign':0,'th::abbr':0,'th::align':0,'th::axis':0,'th::bgcolor':0,'th::char':0,'th::charoff':0,'th::colspan':0,'th::headers':6,'th::height':0,'th::nowrap':0,'th::rowspan':0,'th::scope':0,'th::valign':0,'th::width':0,'thead::align':0,'thead::char':0,'thead::charoff':0,'thead::valign':0,'tr::align':0,'tr::bgcolor':0,'tr::char':0,'tr::charoff':0,'tr::valign':0,'track::default':0,'track::kind':0,'track::label':0,'track::srclang':0,'ul::compact':0,'ul::type':0,'video::controls':0,'video::height':0,'video::loop':0,'video::mediagroup':5,'video::muted':0,'video::poster':1,'video::preload':0,'video::width':0},html4['ATTRIBS']=html4.ATTRIBS,html4.eflags={'OPTIONAL_ENDTAG':1,'EMPTY':2,'CDATA':4,'RCDATA':8,'UNSAFE':16,'FOLDABLE':32,'SCRIPT':64,'STYLE':128,'VIRTUALIZED':256},html4['eflags']=html4.eflags,html4.ELEMENTS={'a':0,'abbr':0,'acronym':0,'address':0,'applet':272,'area':2,'article':0,'aside':0,'audio':0,'b':0,'base':274,'basefont':274,'bdi':0,'bdo':0,'big':0,'blockquote':0,'body':305,'br':2,'button':0,'canvas':0,'caption':0,'center':0,'cite':0,'code':0,'col':2,'colgroup':1,'command':2,'data':0,'datalist':0,'dd':1,'del':0,'details':0,'dfn':0,'dialog':272,'dir':0,'div':0,'dl':0,'dt':1,'em':0,'fieldset':0,'figcaption':0,'figure':0,'font':0,'footer':0,'form':0,'frame':274,'frameset':272,'h1':0,'h2':0,'h3':0,'h4':0,'h5':0,'h6':0,'head':305,'header':0,'hgroup':0,'hr':2,'html':305,'i':0,'iframe':4,'img':2,'input':2,'ins':0,'isindex':274,'kbd':0,'keygen':274,'label':0,'legend':0,'li':1,'link':274,'map':0,'mark':0,'menu':0,'meta':274,'meter':0,'nav':0,'nobr':0,'noembed':276,'noframes':276,'noscript':276,'object':272,'ol':0,'optgroup':0,'option':1,'output':0,'p':1,'param':274,'pre':0,'progress':0,'q':0,'s':0,'samp':0,'script':84,'section':0,'select':0,'small':0,'source':2,'span':0,'strike':0,'strong':0,'style':148,'sub':0,'summary':0,'sup':0,'table':0,'tbody':1,'td':1,'textarea':8,'tfoot':1,'th':1,'thead':1,'time':0,'title':280,'tr':1,'track':2,'tt':0,'u':0,'ul':0,'var':0,'video':0,'wbr':2},html4['ELEMENTS']=html4.ELEMENTS,html4.ELEMENT_DOM_INTERFACES={'a':'HTMLAnchorElement','abbr':'HTMLElement','acronym':'HTMLElement','address':'HTMLElement','applet':'HTMLAppletElement','area':'HTMLAreaElement','article':'HTMLElement','aside':'HTMLElement','audio':'HTMLAudioElement','b':'HTMLElement','base':'HTMLBaseElement','basefont':'HTMLBaseFontElement','bdi':'HTMLElement','bdo':'HTMLElement','big':'HTMLElement','blockquote':'HTMLQuoteElement','body':'HTMLBodyElement','br':'HTMLBRElement','button':'HTMLButtonElement','canvas':'HTMLCanvasElement','caption':'HTMLTableCaptionElement','center':'HTMLElement','cite':'HTMLElement','code':'HTMLElement','col':'HTMLTableColElement','colgroup':'HTMLTableColElement','command':'HTMLCommandElement','data':'HTMLElement','datalist':'HTMLDataListElement','dd':'HTMLElement','del':'HTMLModElement','details':'HTMLDetailsElement','dfn':'HTMLElement','dialog':'HTMLDialogElement','dir':'HTMLDirectoryElement','div':'HTMLDivElement','dl':'HTMLDListElement','dt':'HTMLElement','em':'HTMLElement','fieldset':'HTMLFieldSetElement','figcaption':'HTMLElement','figure':'HTMLElement','font':'HTMLFontElement','footer':'HTMLElement','form':'HTMLFormElement','frame':'HTMLFrameElement','frameset':'HTMLFrameSetElement','h1':'HTMLHeadingElement','h2':'HTMLHeadingElement','h3':'HTMLHeadingElement','h4':'HTMLHeadingElement','h5':'HTMLHeadingElement','h6':'HTMLHeadingElement','head':'HTMLHeadElement','header':'HTMLElement','hgroup':'HTMLElement','hr':'HTMLHRElement','html':'HTMLHtmlElement','i':'HTMLElement','iframe':'HTMLIFrameElement','img':'HTMLImageElement','input':'HTMLInputElement','ins':'HTMLModElement','isindex':'HTMLUnknownElement','kbd':'HTMLElement','keygen':'HTMLKeygenElement','label':'HTMLLabelElement','legend':'HTMLLegendElement','li':'HTMLLIElement','link':'HTMLLinkElement','map':'HTMLMapElement','mark':'HTMLElement','menu':'HTMLMenuElement','meta':'HTMLMetaElement','meter':'HTMLMeterElement','nav':'HTMLElement','nobr':'HTMLElement','noembed':'HTMLElement','noframes':'HTMLElement','noscript':'HTMLElement','object':'HTMLObjectElement','ol':'HTMLOListElement','optgroup':'HTMLOptGroupElement','option':'HTMLOptionElement','output':'HTMLOutputElement','p':'HTMLParagraphElement','param':'HTMLParamElement','pre':'HTMLPreElement','progress':'HTMLProgressElement','q':'HTMLQuoteElement','s':'HTMLElement','samp':'HTMLElement','script':'HTMLScriptElement','section':'HTMLElement','select':'HTMLSelectElement','small':'HTMLElement','source':'HTMLSourceElement','span':'HTMLSpanElement','strike':'HTMLElement','strong':'HTMLElement','style':'HTMLStyleElement','sub':'HTMLElement','summary':'HTMLElement','sup':'HTMLElement','table':'HTMLTableElement','tbody':'HTMLTableSectionElement','td':'HTMLTableDataCellElement','textarea':'HTMLTextAreaElement','tfoot':'HTMLTableSectionElement','th':'HTMLTableHeaderCellElement','thead':'HTMLTableSectionElement','time':'HTMLTimeElement','title':'HTMLTitleElement','tr':'HTMLTableRowElement','track':'HTMLTrackElement','tt':'HTMLElement','u':'HTMLElement','ul':'HTMLUListElement','var':'HTMLElement','video':'HTMLVideoElement','wbr':'HTMLElement'},html4['ELEMENT_DOM_INTERFACES']=html4.ELEMENT_DOM_INTERFACES,html4.ueffects={'NOT_LOADED':0,'SAME_DOCUMENT':1,'NEW_DOCUMENT':2},html4['ueffects']=html4.ueffects,html4.URIEFFECTS={'a::href':2,'area::href':2,'blockquote::cite':0,'command::icon':1,'del::cite':0,'form::action':2,'img::src':1,'input::src':1,'ins::cite':0,'q::cite':0,'video::poster':1},html4['URIEFFECTS']=html4.URIEFFECTS,html4.ltypes={'UNSANDBOXED':2,'SANDBOXED':1,'DATA':0},html4['ltypes']=html4.ltypes,html4.LOADERTYPES={'a::href':2,'area::href':2,'blockquote::cite':2,'command::icon':1,'del::cite':2,'form::action':2,'img::src':1,'input::src':1,'ins::cite':2,'q::cite':2,'video::poster':1},html4['LOADERTYPES']=html4.LOADERTYPES,typeof
window!=='undefined'&&(window['html4']=html4);if('I'.toLowerCase()!=='i')throw'I/i problem';html=(function(html4){var
ALLOWED_URI_SCHEMES,ATTR_RE,EFLAGS_TEXT,ENTITIES,ENTITY_RE_1,ENTITY_RE_2,ampRe,continuationMarker,cssSchema,decimalEscapeRe,endTagRe,entityLookupElement,gtRe,hexEscapeRe,html,looseAmpRe,ltRe,nulRe,parseCssDeclarations,quotRe,safeEntityNameRe,sanitizeCssProperty,splitWillCapture;'undefined'!==typeof
window&&(parseCssDeclarations=window['parseCssDeclarations'],sanitizeCssProperty=window['sanitizeCssProperty'],cssSchema=window['cssSchema']),ENTITIES={'lt':'\x3c','LT':'\x3c','gt':'\x3e','GT':'\x3e','amp':'\x26','AMP':'\x26','quot':'\"','apos':'\'','nbsp':'\xa0'},decimalEscapeRe=/^#(\d+)$/,hexEscapeRe=/^#x([0-9A-Fa-f]+)$/,safeEntityNameRe=/^[A-Za-z][A-za-z0-9]+$/,entityLookupElement='undefined'!==typeof
window&&window['document']?window.document.createElement('textarea'):null;function
lookupEntity(name){var m,text;return ENTITIES.hasOwnProperty(name)?ENTITIES[name]:(m=name.match(decimalEscapeRe),m?String.fromCharCode(parseInt(m[1],10)):(m=name.match(hexEscapeRe))?String.fromCharCode(parseInt(m[1],16)):entityLookupElement&&safeEntityNameRe.test(name)?(entityLookupElement.innerHTML='\x26'+name+';',text=entityLookupElement.textContent,ENTITIES[name]=text,text):'\x26'+name+';')}function
decodeOneEntity(_,name){return lookupEntity(name)}nulRe=/\0/g;function stripNULs(s){return s.replace(nulRe,'')}ENTITY_RE_1=/\x26(#[0-9]+|#[xX][0-9A-Fa-f]+|\w+);/g,ENTITY_RE_2=/^(#[0-9]+|#[xX][0-9A-Fa-f]+|\w+);/;function
unescapeEntities(s){return s.replace(ENTITY_RE_1,decodeOneEntity)}ampRe=/\x26/g,looseAmpRe=/\x26([^a-z#]|#(?:[^0-9x]|x(?:[^0-9a-f]|$)|$)|$)/gi,ltRe=/[\x3c]/g,gtRe=/\x3e/g,quotRe=/\"/g;function
escapeAttrib(s){return(''+s).replace(ampRe,'\x26amp;').replace(ltRe,'\x26lt;').replace(gtRe,'\x26gt;').replace(quotRe,'\x26#34;')}function
normalizeRCData(rcdata){return rcdata.replace(looseAmpRe,'\x26amp;$1').replace(ltRe,'\x26lt;').replace(gtRe,'\x26gt;')}ATTR_RE=new
RegExp('^\\s*([-.:\\w]+)(?:\\s*(=)\\s*((\")[^\"]*(\"|$)|(\')[^\']*(\'|$)|(?=[a-z][-\\w]*\\s*=)|[^\"\'\\s]*))?','i'),splitWillCapture='a,b'.split(/(,)/).length===3,EFLAGS_TEXT=html4.eflags['CDATA']|html4.eflags['RCDATA'];function
makeSaxParser(handler){var hcopy={'cdata':handler.cdata||handler['cdata'],'comment':handler.comment||handler['comment'],'endDoc':handler.endDoc||handler['endDoc'],'endTag':handler.endTag||handler['endTag'],'pcdata':handler.pcdata||handler['pcdata'],'rcdata':handler.rcdata||handler['rcdata'],'startDoc':handler.startDoc||handler['startDoc'],'startTag':handler.startTag||handler['startTag']};return function(htmlText,param){return parse(htmlText,hcopy,param)}}continuationMarker={};function
parse(htmlText,handler,param){var parts=htmlSplit(htmlText),state={'noMoreGT':false,'noMoreEndComments':false},m,p,tagName;parseCPS(handler,parts,0,state,param)}function
continuationMaker(h,parts,initial,state,param){return function(){parseCPS(h,parts,initial,state,param)}}function
parseCPS(h,parts,initial,state,param){var comment,current,eflags,end,m,next,p,pos,tag,tagName;try{h.startDoc&&initial==0&&h.startDoc(param);for(pos=initial,end=parts.length;pos<end;){current=parts[pos++],next=parts[pos];switch(current){case'\x26':ENTITY_RE_2.test(next)?(h.pcdata&&h.pcdata('\x26'+next,param,continuationMarker,continuationMaker(h,parts,pos,state,param)),++pos):h.pcdata&&h.pcdata('\x26amp;',param,continuationMarker,continuationMaker(h,parts,pos,state,param));break;case'\x3c/':(m=/^([-\w:]+)[^\'\"]*/.exec(next))?m[0].length===next.length&&parts[pos+1]==='\x3e'?(pos+=2,tagName=m[1].toLowerCase(),h.endTag&&h.endTag(tagName,param,continuationMarker,continuationMaker(h,parts,pos,state,param))):(pos=parseEndTag(parts,pos,h,param,continuationMarker,state)):h.pcdata&&h.pcdata('\x26lt;/',param,continuationMarker,continuationMaker(h,parts,pos,state,param));break;case'\x3c':(m=/^([-\w:]+)\s*\/?/.exec(next))?m[0].length===next.length&&parts[pos+1]==='\x3e'?(pos+=2,tagName=m[1].toLowerCase(),h.startTag&&h.startTag(tagName,[],param,continuationMarker,continuationMaker(h,parts,pos,state,param)),eflags=html4.ELEMENTS[tagName],eflags&EFLAGS_TEXT&&(tag={'name':tagName,'next':pos,'eflags':eflags},pos=parseText(parts,tag,h,param,continuationMarker,state))):(pos=parseStartTag(parts,pos,h,param,continuationMarker,state)):h.pcdata&&h.pcdata('\x26lt;',param,continuationMarker,continuationMaker(h,parts,pos,state,param));break;case'\x3c!--':if(!state.noMoreEndComments){for(p=pos+1;p<end;++p)if(parts[p]==='\x3e'&&/--$/.test(parts[p-1]))break;p<end?(h.comment&&(comment=parts.slice(pos,p).join(''),h.comment(comment.substr(0,comment.length-2),param,continuationMarker,continuationMaker(h,parts,p+1,state,param))),pos=p+1):(state.noMoreEndComments=true)}state.noMoreEndComments&&(h.pcdata&&h.pcdata('\x26lt;!--',param,continuationMarker,continuationMaker(h,parts,pos,state,param)));break;case'\x3c!':if(!/^\w/.test(next))h.pcdata&&h.pcdata('\x26lt;!',param,continuationMarker,continuationMaker(h,parts,pos,state,param));else{if(!state.noMoreGT){for(p=pos+1;p<end;++p)if(parts[p]==='\x3e')break;p<end?(pos=p+1):(state.noMoreGT=true)}state.noMoreGT&&(h.pcdata&&h.pcdata('\x26lt;!',param,continuationMarker,continuationMaker(h,parts,pos,state,param)))}break;case'\x3c?':if(!state.noMoreGT){for(p=pos+1;p<end;++p)if(parts[p]==='\x3e')break;p<end?(pos=p+1):(state.noMoreGT=true)}state.noMoreGT&&(h.pcdata&&h.pcdata('\x26lt;?',param,continuationMarker,continuationMaker(h,parts,pos,state,param)));break;case'\x3e':h.pcdata&&h.pcdata('\x26gt;',param,continuationMarker,continuationMaker(h,parts,pos,state,param));break;case'':break;default:h.pcdata&&h.pcdata(current,param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}h.endDoc&&h.endDoc(param)}catch(e){if(e!==continuationMarker)throw e}}function
htmlSplit(str){var re=/(\x3c\/|\x3c\!--|\x3c[!?]|[\x26\x3c\x3e])/g,lastPos,m,parts;str+='';if(splitWillCapture)return str.split(re);parts=[],lastPos=0;while((m=re.exec(str))!==null)parts.push(str.substring(lastPos,m.index)),parts.push(m[0]),lastPos=m.index+m[0].length;return parts.push(str.substring(lastPos)),parts}function
parseEndTag(parts,pos,h,param,continuationMarker,state){var tag=parseTagAndAttrs(parts,pos);return tag?(h.endTag&&h.endTag(tag.name,param,continuationMarker,continuationMaker(h,parts,pos,state,param)),tag.next):parts.length}function
parseStartTag(parts,pos,h,param,continuationMarker,state){var tag=parseTagAndAttrs(parts,pos);return tag?(h.startTag&&h.startTag(tag.name,tag.attrs,param,continuationMarker,continuationMaker(h,parts,tag.next,state,param)),tag.eflags&EFLAGS_TEXT?parseText(parts,tag,h,param,continuationMarker,state):tag.next):parts.length}endTagRe={};function
parseText(parts,tag,h,param,continuationMarker,state){var end=parts.length,buf,first,p,re;endTagRe.hasOwnProperty(tag.name)||(endTagRe[tag.name]=new
RegExp(('^'+tag.name+'(?:[\\s\\/]|$)'),'i')),re=endTagRe[tag.name],first=tag.next,p=tag.next+1;for(;p<end;++p)if(parts[p-1]==='\x3c/'&&re.test(parts[p]))break;p<end&&(p-=1),buf=parts.slice(first,p).join('');if(tag.eflags&html4.eflags['CDATA'])h.cdata&&h.cdata(buf,param,continuationMarker,continuationMaker(h,parts,p,state,param));else
if(tag.eflags&html4.eflags['RCDATA'])h.rcdata&&h.rcdata(normalizeRCData(buf),param,continuationMarker,continuationMaker(h,parts,p,state,param));else
throw new Error('bug');return p}function parseTagAndAttrs(parts,pos){var m=/^([-\w:]+)/.exec(parts[pos]),tag={},aName,aValue,abuf,attrs,buf,end,p,quote,sawQuote;tag.name=m[1].toLowerCase(),tag.eflags=html4.ELEMENTS[tag.name],buf=parts[pos].substr(m[0].length),p=pos+1,end=parts.length;for(;p<end;++p){if(parts[p]==='\x3e')break;buf+=parts[p]}if(end<=p)return;attrs=[];while(buf!==''){m=ATTR_RE.exec(buf);if(!m)buf=buf.replace(/^[\s\S][^a-z\s]*/,'');else
if(m[4]&&!m[5]||m[6]&&!m[7]){quote=m[4]||m[6],sawQuote=false,abuf=[buf,parts[p++]];for(;p<end;++p){if(sawQuote){if(parts[p]==='\x3e')break}else
if(0<=parts[p].indexOf(quote))sawQuote=true;abuf.push(parts[p])}if(end<=p)break;buf=abuf.join('');continue}else
aName=m[1].toLowerCase(),aValue=m[2]?decodeValue(m[3]):'',attrs.push(aName,aValue),buf=buf.substr(m[0].length)}return tag.attrs=attrs,tag.next=p+1,tag}function
decodeValue(v){var q=v.charCodeAt(0);return(q===34||q===39)&&(v=v.substr(1,v.length-2)),unescapeEntities(stripNULs(v))}function
makeHtmlSanitizer(tagPolicy){var emit=function(text,out){ignoring||out.push(text)},ignoring,stack;return makeSaxParser({'startDoc':function(_){stack=[],ignoring=false},'startTag':function(tagNameOrig,attribs,out){var
attribName,decision,eflagsOrig,eflagsRep,i,n,onStack,tagNameRep,value;if(ignoring)return;if(!html4.ELEMENTS.hasOwnProperty(tagNameOrig))return;eflagsOrig=html4.ELEMENTS[tagNameOrig];if(eflagsOrig&html4.eflags['FOLDABLE'])return;decision=tagPolicy(tagNameOrig,attribs);if(!decision)return ignoring=!(eflagsOrig&html4.eflags['EMPTY']),void
0;else if(typeof decision!=='object')throw new Error('tagPolicy did not return object (old API?)');if('attribs'in
decision)attribs=decision['attribs'];else throw new Error('tagPolicy gave no attribs');'tagName'in
decision?(tagNameRep=decision['tagName'],eflagsRep=html4.ELEMENTS[tagNameRep]):(tagNameRep=tagNameOrig,eflagsRep=eflagsOrig),eflagsOrig&html4.eflags['OPTIONAL_ENDTAG']&&(onStack=stack[stack.length-1],onStack&&onStack.orig===tagNameOrig&&(onStack.rep!==tagNameRep||tagNameOrig!==tagNameRep)&&out.push('\x3c/',onStack.rep,'\x3e')),eflagsOrig&html4.eflags['EMPTY']||stack.push({'orig':tagNameOrig,'rep':tagNameRep}),out.push('\x3c',tagNameRep);for(i=0,n=attribs.length;i<n;i+=2)attribName=attribs[i],value=attribs[i+1],value!==null&&value!==void
0&&out.push(' ',attribName,'=\"',escapeAttrib(value),'\"');out.push('\x3e'),eflagsOrig&html4.eflags['EMPTY']&&!(eflagsRep&html4.eflags['EMPTY'])&&out.push('\x3c/',tagNameRep,'\x3e')},'endTag':function(tagName,out){var
eflags,i,index,stackElOrigTag,stackElRepTag;if(ignoring)return ignoring=false,void
0;if(!html4.ELEMENTS.hasOwnProperty(tagName))return;eflags=html4.ELEMENTS[tagName];if(!(eflags&(html4.eflags['EMPTY']|html4.eflags['FOLDABLE']))){if(eflags&html4.eflags['OPTIONAL_ENDTAG'])for(index=stack.length;--index>=0;){stackElOrigTag=stack[index].orig;if(stackElOrigTag===tagName)break;if(!(html4.ELEMENTS[stackElOrigTag]&html4.eflags['OPTIONAL_ENDTAG']))return}else
for(index=stack.length;--index>=0;)if(stack[index].orig===tagName)break;if(index<0)return;for(i=stack.length;--i>index;)stackElRepTag=stack[i].rep,html4.ELEMENTS[stackElRepTag]&html4.eflags['OPTIONAL_ENDTAG']||out.push('\x3c/',stackElRepTag,'\x3e');index<stack.length&&(tagName=stack[index].rep),stack.length=index,out.push('\x3c/',tagName,'\x3e')}},'pcdata':emit,'rcdata':emit,'cdata':emit,'endDoc':function(out){for(;stack.length;--stack.length)out.push('\x3c/',stack[stack.length-1].rep,'\x3e')}})}ALLOWED_URI_SCHEMES=/^(?:https?|mailto)$/i;function
safeUri(uri,effect,ltype,hints,naiveUriRewriter){var parsed,safe;if(!naiveUriRewriter)return null;try{parsed=URI.parse(''+uri);if(parsed){if(!parsed.hasScheme()||ALLOWED_URI_SCHEMES.test(parsed.getScheme()))return safe=naiveUriRewriter(parsed,effect,ltype,hints),safe?safe.toString():null}}catch(e){return null}return null}function
log(logger,tagName,attribName,oldValue,newValue){var changed;attribName||logger(tagName+' removed',{'change':'removed','tagName':tagName}),oldValue!==newValue&&(changed='changed',oldValue&&!newValue?(changed='removed'):!oldValue&&newValue&&(changed='added'),logger(tagName+'.'+attribName+' '+changed,{'change':changed,'tagName':tagName,'attribName':attribName,'oldValue':oldValue,'newValue':newValue}))}function
lookupAttribute(map,tagName,attribName){var attribKey=tagName+'::'+attribName;return map.hasOwnProperty(attribKey)?map[attribKey]:(attribKey='*::'+attribName,map.hasOwnProperty(attribKey)?map[attribKey]:void
0)}function getAttributeType(tagName,attribName){return lookupAttribute(html4.ATTRIBS,tagName,attribName)}function
getLoaderType(tagName,attribName){return lookupAttribute(html4.LOADERTYPES,tagName,attribName)}function
getUriEffect(tagName,attribName){return lookupAttribute(html4.URIEFFECTS,tagName,attribName)}function
sanitizeAttribs(tagName,attribs,opt_naiveUriRewriter,opt_nmTokenPolicy,opt_logger){var
attribKey,attribName,atype,i,oldValue,sanitizedDeclarations,value;for(i=0;i<attribs.length;i+=2){attribName=attribs[i],value=attribs[i+1],oldValue=value,atype=null,((attribKey=tagName+'::'+attribName,html4.ATTRIBS.hasOwnProperty(attribKey))||(attribKey='*::'+attribName,html4.ATTRIBS.hasOwnProperty(attribKey)))&&(atype=html4.ATTRIBS[attribKey]);if(atype!==null)switch(atype){case
html4.atype['NONE']:break;case html4.atype['SCRIPT']:value=null,opt_logger&&log(opt_logger,tagName,attribName,oldValue,value);break;case
html4.atype['STYLE']:if('undefined'===typeof parseCssDeclarations){value=null,opt_logger&&log(opt_logger,tagName,attribName,oldValue,value);break}sanitizedDeclarations=[],parseCssDeclarations(value,{'declaration':function(property,tokens){var
normProp=property.toLowerCase(),schema=cssSchema[normProp];if(!schema)return;sanitizeCssProperty(normProp,schema,tokens,opt_naiveUriRewriter?function(url){return safeUri(url,html4.ueffects.SAME_DOCUMENT,html4.ltypes.SANDBOXED,{'TYPE':'CSS','CSS_PROP':normProp},opt_naiveUriRewriter)}:null),sanitizedDeclarations.push(property+': '+tokens.join(' '))}}),value=sanitizedDeclarations.length>0?sanitizedDeclarations.join(' ; '):null,opt_logger&&log(opt_logger,tagName,attribName,oldValue,value);break;case
html4.atype['ID']:case html4.atype['IDREF']:case html4.atype['IDREFS']:case html4.atype['GLOBAL_NAME']:case
html4.atype['LOCAL_NAME']:case html4.atype['CLASSES']:value=opt_nmTokenPolicy?opt_nmTokenPolicy(value):value,opt_logger&&log(opt_logger,tagName,attribName,oldValue,value);break;case
html4.atype['URI']:value=safeUri(value,getUriEffect(tagName,attribName),getLoaderType(tagName,attribName),{'TYPE':'MARKUP','XML_ATTR':attribName,'XML_TAG':tagName},opt_naiveUriRewriter),opt_logger&&log(opt_logger,tagName,attribName,oldValue,value);break;case
html4.atype['URI_FRAGMENT']:value&&'#'===value.charAt(0)?(value=value.substring(1),value=opt_nmTokenPolicy?opt_nmTokenPolicy(value):value,value!==null&&value!==void
0&&(value='#'+value)):(value=null),opt_logger&&log(opt_logger,tagName,attribName,oldValue,value);break;default:value=null,opt_logger&&log(opt_logger,tagName,attribName,oldValue,value)}else
value=null,opt_logger&&log(opt_logger,tagName,attribName,oldValue,value);attribs[i+1]=value}return attribs}function
makeTagPolicy(opt_naiveUriRewriter,opt_nmTokenPolicy,opt_logger){return function(tagName,attribs){if(!(html4.ELEMENTS[tagName]&html4.eflags['UNSAFE']))return{'attribs':sanitizeAttribs(tagName,attribs,opt_naiveUriRewriter,opt_nmTokenPolicy,opt_logger)};opt_logger&&log(opt_logger,tagName,undefined,undefined,undefined)}}function
sanitizeWithPolicy(inputHtml,tagPolicy){var outputArray=[];return makeHtmlSanitizer(tagPolicy)(inputHtml,outputArray),outputArray.join('')}function
sanitize(inputHtml,opt_naiveUriRewriter,opt_nmTokenPolicy,opt_logger){var tagPolicy=makeTagPolicy(opt_naiveUriRewriter,opt_nmTokenPolicy,opt_logger);return sanitizeWithPolicy(inputHtml,tagPolicy)}return html={},html.escapeAttrib=html['escapeAttrib']=escapeAttrib,html.makeHtmlSanitizer=html['makeHtmlSanitizer']=makeHtmlSanitizer,html.makeSaxParser=html['makeSaxParser']=makeSaxParser,html.makeTagPolicy=html['makeTagPolicy']=makeTagPolicy,html.normalizeRCData=html['normalizeRCData']=normalizeRCData,html.sanitize=html['sanitize']=sanitize,html.sanitizeAttribs=html['sanitizeAttribs']=sanitizeAttribs,html.sanitizeWithPolicy=html['sanitizeWithPolicy']=sanitizeWithPolicy,html.unescapeEntities=html['unescapeEntities']=unescapeEntities,html})(html4),html_sanitize=html['sanitize'],typeof
window!=='undefined'&&(window['html']=html,window['html_sanitize']=html_sanitize)}

/*!
 * jQuery JavaScript Library v1.9.1
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2012 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-2-4
 */
(function( window, undefined ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//"use strict";
var
	// The deferred used on DOM ready
	readyList,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// Support: IE<9
	// For `typeof node.method` instead of `node.method !== undefined`
	core_strundefined = typeof undefined,

	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,
	location = window.location,

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// [[Class]] -> type pairs
	class2type = {},

	// List of deleted data cache ids, so we can reuse them
	core_deletedIds = [],

	core_version = "1.9.1",

	// Save a reference to some core methods
	core_concat = core_deletedIds.concat,
	core_push = core_deletedIds.push,
	core_slice = core_deletedIds.slice,
	core_indexOf = core_deletedIds.indexOf,
	core_toString = class2type.toString,
	core_hasOwn = class2type.hasOwnProperty,
	core_trim = core_version.trim,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Used for matching numbers
	core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,

	// Used for splitting on whitespace
	core_rnotwhite = /\S+/g,

	// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	},

	// The ready event handler
	completed = function( event ) {

		// readyState === "complete" is good enough for us to call the dom ready in oldIE
		if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
			detach();
			jQuery.ready();
		}
	},
	// Clean-up method for dom ready events
	detach = function() {
		if ( document.addEventListener ) {
			document.removeEventListener( "DOMContentLoaded", completed, false );
			window.removeEventListener( "load", completed, false );

		} else {
			document.detachEvent( "onreadystatechange", completed );
			window.detachEvent( "onload", completed );
		}
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: core_version,

	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return core_slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	},

	slice: function() {
		return this.pushStack( core_slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: core_push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var src, copyIsArray, copy, name, options, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		if ( obj == null ) {
			return String( obj );
		}
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ core_toString.call(obj) ] || "object" :
			typeof obj;
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!core_hasOwn.call(obj, "constructor") &&
				!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || core_hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	parseHTML: function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts );
		if ( scripts ) {
			jQuery( scripts ).remove();
		}
		return jQuery.merge( [], parsed.childNodes );
	},

	parseJSON: function( data ) {
		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		if ( data === null ) {
			return data;
		}

		if ( typeof data === "string" ) {

			// Make sure leading/trailing whitespace is removed (IE can't handle it)
			data = jQuery.trim( data );

			if ( data ) {
				// Make sure the incoming data is actual JSON
				// Logic borrowed from http://json.org/json2.js
				if ( rvalidchars.test( data.replace( rvalidescape, "@" )
					.replace( rvalidtokens, "]" )
					.replace( rvalidbraces, "")) ) {

					return ( new Function( "return " + data ) )();
				}
			}
		}

		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && jQuery.trim( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Use native String.trim function wherever possible
	trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
		function( text ) {
			return text == null ?
				"" :
				core_trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				core_push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( core_indexOf ) {
				return core_indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var l = second.length,
			i = first.length,
			j = 0;

		if ( typeof l === "number" ) {
			for ( ; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}
		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var retVal,
			ret = [],
			i = 0,
			length = elems.length;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return core_concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var args, proxy, tmp;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = core_slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			length = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < length; i++ ) {
					fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	}
});

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", completed );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", completed );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// detach all dom ready events
						detach();

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || type !== "function" &&
		( length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj );
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);
// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				args = args || [];
				args = [ context, args.slice ? args.slice() : args ];
				if ( list && ( !fired || stack ) ) {
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};
jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var action = tuple[ 0 ],
								fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ action + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = core_slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
					if( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});
jQuery.support = (function() {

	var support, all, a,
		input, select, fragment,
		opt, eventName, isSupported, i,
		div = document.createElement("div");

	// Setup
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	// Support tests won't run in some limited or non-browser environments
	all = div.getElementsByTagName("*");
	a = div.getElementsByTagName("a")[ 0 ];
	if ( !all || !a || !all.length ) {
		return {};
	}

	// First batch of tests
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px;float:left;opacity:.5";
	support = {
		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: div.firstChild.nodeType === 3,

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: a.getAttribute("href") === "/a",

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.5/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
		checkOn: !!input.value,

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Tests for enctype support on a form (#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
		boxModel: document.compatMode === "CSS1Compat",

		// Will be defined later
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true,
		boxSizingReliable: true,
		pixelPosition: false
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<9
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	// Check if we can trust getAttribute("value")
	input = document.createElement("input");
	input.setAttribute( "value", "" );
	support.input = input.getAttribute( "value" ) === "";

	// Check if an input maintains its value after becoming a radio
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "checked", "t" );
	input.setAttribute( "name", "t" );

	fragment = document.createDocumentFragment();
	fragment.appendChild( input );

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<9
	// Opera does not clone events (and typeof div.attachEvent === undefined).
	// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
	if ( div.attachEvent ) {
		div.attachEvent( "onclick", function() {
			support.noCloneEvent = false;
		});

		div.cloneNode( true ).click();
	}

	// Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)
	// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP), test/csp.php
	for ( i in { submit: true, change: true, focusin: true }) {
		div.setAttribute( eventName = "on" + i, "t" );

		support[ i + "Bubbles" ] = eventName in window || div.attributes[ eventName ].expando === false;
	}

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, marginDiv, tds,
			divReset = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		container = document.createElement("div");
		container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";

		body.appendChild( container ).appendChild( div );

		// Support: IE8
		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName("td");
		tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Support: IE8
		// Check if empty table cells still have offsetWidth/Height
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Check box-sizing and margin behavior
		div.innerHTML = "";
		div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
		support.boxSizing = ( div.offsetWidth === 4 );
		support.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );

		// Use window.getComputedStyle because jsdom on node.js will break without it.
		if ( window.getComputedStyle ) {
			support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. (#3333)
			// Fails in WebKit before Feb 2011 nightlies
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			marginDiv = div.appendChild( document.createElement("div") );
			marginDiv.style.cssText = div.style.cssText = divReset;
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";

			support.reliableMarginRight =
				!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
		}

		if ( typeof div.style.zoom !== core_strundefined ) {
			// Support: IE<8
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			div.innerHTML = "";
			div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Support: IE6
			// Check if elements with layout shrink-wrap their children
			div.style.display = "block";
			div.innerHTML = "<div></div>";
			div.firstChild.style.width = "5px";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );

			if ( support.inlineBlockNeedsLayout ) {
				// Prevent IE 6 from affecting layout for positioned elements #11048
				// Prevent IE from shrinking the body in IE 7 mode #12869
				// Support: IE<8
				body.style.zoom = 1;
			}
		}

		body.removeChild( container );

		// Null elements to avoid leaks in IE
		container = div = tds = marginDiv = null;
	});

	// Null elements to avoid leaks in IE
	all = select = fragment = opt = a = input = null;

	return support;
})();

var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
	rmultiDash = /([A-Z])/g;

function internalData( elem, name, data, pvt /* Internal Use Only */ ){
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var thisCache, ret,
		internalKey = jQuery.expando,
		getByName = typeof name === "string",

		// We have to handle DOM nodes and JS objects differently because IE6-7
		// can't GC object references properly across the DOM-JS boundary
		isNode = elem.nodeType,

		// Only DOM nodes need the global jQuery cache; JS object data is
		// attached directly to the object so GC can occur automatically
		cache = isNode ? jQuery.cache : elem,

		// Only defining an ID for JS objects if its cache already exists allows
		// the code to shortcut on the same path as a DOM node with no cache
		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

	// Avoid doing any more work than we need to when trying to get data on an
	// object that has no data at all
	if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {
		return;
	}

	if ( !id ) {
		// Only DOM nodes need a new unique ID for each element since their data
		// ends up in the global cache
		if ( isNode ) {
			elem[ internalKey ] = id = core_deletedIds.pop() || jQuery.guid++;
		} else {
			id = internalKey;
		}
	}

	if ( !cache[ id ] ) {
		cache[ id ] = {};

		// Avoids exposing jQuery metadata on plain JS objects when the object
		// is serialized using JSON.stringify
		if ( !isNode ) {
			cache[ id ].toJSON = jQuery.noop;
		}
	}

	// An object can be passed to jQuery.data instead of a key/value pair; this gets
	// shallow copied over onto the existing cache
	if ( typeof name === "object" || typeof name === "function" ) {
		if ( pvt ) {
			cache[ id ] = jQuery.extend( cache[ id ], name );
		} else {
			cache[ id ].data = jQuery.extend( cache[ id ].data, name );
		}
	}

	thisCache = cache[ id ];

	// jQuery data() is stored in a separate object inside the object's internal data
	// cache in order to avoid key collisions between internal data and user-defined
	// data.
	if ( !pvt ) {
		if ( !thisCache.data ) {
			thisCache.data = {};
		}

		thisCache = thisCache.data;
	}

	if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
	}

	// Check for both converted-to-camel and non-converted data property names
	// If a data property was specified
	if ( getByName ) {

		// First Try to find as-is property data
		ret = thisCache[ name ];

		// Test for null|undefined property data
		if ( ret == null ) {

			// Try to find the camelCased property
			ret = thisCache[ jQuery.camelCase( name ) ];
		}
	} else {
		ret = thisCache;
	}

	return ret;
}

function internalRemoveData( elem, name, pvt ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var i, l, thisCache,
		isNode = elem.nodeType,

		// See jQuery.data for more information
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	// If there is already no cache entry for this object, there is no
	// purpose in continuing
	if ( !cache[ id ] ) {
		return;
	}

	if ( name ) {

		thisCache = pvt ? cache[ id ] : cache[ id ].data;

		if ( thisCache ) {

			// Support array or space separated string names for data keys
			if ( !jQuery.isArray( name ) ) {

				// try the string as a key before any manipulation
				if ( name in thisCache ) {
					name = [ name ];
				} else {

					// split the camel cased version by spaces unless a key with the spaces exists
					name = jQuery.camelCase( name );
					if ( name in thisCache ) {
						name = [ name ];
					} else {
						name = name.split(" ");
					}
				}
			} else {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
			}

			for ( i = 0, l = name.length; i < l; i++ ) {
				delete thisCache[ name[i] ];
			}

			// If there is no data left in the cache, we want to continue
			// and let the cache object itself get destroyed
			if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
				return;
			}
		}
	}

	// See jQuery.data for more information
	if ( !pvt ) {
		delete cache[ id ].data;

		// Don't destroy the parent cache unless the internal data object
		// had been the only thing left in it
		if ( !isEmptyDataObject( cache[ id ] ) ) {
			return;
		}
	}

	// Destroy the cache
	if ( isNode ) {
		jQuery.cleanData( [ elem ], true );

	// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
	} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
		delete cache[ id ];

	// When all else fails, null
	} else {
		cache[ id ] = null;
	}
}

jQuery.extend({
	cache: {},

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( core_version + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data ) {
		return internalData( elem, name, data );
	},

	removeData: function( elem, name ) {
		return internalRemoveData( elem, name );
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return internalData( elem, name, data, true );
	},

	_removeData: function( elem, name ) {
		return internalRemoveData( elem, name, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		// Do not set data on non-element because it will not be cleared (#8335).
		if ( elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9 ) {
			return false;
		}

		var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];

		// nodes accept data unless otherwise specified; rejection can be conditional
		return !noData || noData !== true && elem.getAttribute("classid") === noData;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var attrs, name,
			elem = this[0],
			i = 0,
			data = null;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attrs = elem.attributes;
					for ( ; i < attrs.length; i++ ) {
						name = attrs[i].name;

						if ( !name.indexOf( "data-" ) ) {
							name = jQuery.camelCase( name.slice(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		return jQuery.access( this, function( value ) {

			if ( value === undefined ) {
				// Try to fetch any internally stored data first
				return elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : null;
			}

			this.each(function() {
				jQuery.data( this, key, value );
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}
jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		hooks.cur = fn;
		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery._removeData( elem, type + "queue" );
				jQuery._removeData( elem, key );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var nodeHook, boolHook,
	rclass = /[\t\r\n]/g,
	rreturn = /\r/g,
	rfocusable = /^(?:input|select|textarea|button|object)$/i,
	rclickable = /^(?:a|area)$/i,
	rboolean = /^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,
	ruseDefault = /^(?:checked|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	getSetInput = jQuery.support.input;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classes, elem, cur, clazz, j,
			i = 0,
			len = this.length,
			proceed = typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( core_rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}
					elem.className = jQuery.trim( cur );

				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j,
			i = 0,
			len = this.length,
			proceed = arguments.length === 0 || typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( core_rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}
					elem.className = value ? jQuery.trim( cur ) : "";
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.match( core_rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			// Toggle whole class name
			} else if ( type === core_strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var ret, hooks, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val,
				self = jQuery(this);

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attr: function( elem, name, value ) {
		var hooks, notxml, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === core_strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && notxml && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && notxml && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			// In IE9+, Flash objects don't have .getAttribute (#12945)
			// Support: IE9+
			if ( typeof elem.getAttribute !== core_strundefined ) {
				ret =  elem.getAttribute( name );
			}

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( core_rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( rboolean.test( name ) ) {
					// Set corresponding property to false for boolean attributes
					// Also clear defaultChecked/defaultSelected (if appropriate) for IE<8
					if ( !getSetAttribute && ruseDefault.test( name ) ) {
						elem[ jQuery.camelCase( "default-" + name ) ] =
							elem[ propName ] = false;
					} else {
						elem[ propName ] = false;
					}

				// See #9699 for explanation of this approach (setting first, then removal)
				} else {
					jQuery.attr( elem, name, "" );
				}

				elem.removeAttribute( getSetAttribute ? name : propName );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		var
			// Use .prop to determine if this attribute is understood as boolean
			prop = jQuery.prop( elem, name ),

			// Fetch it accordingly
			attr = typeof prop === "boolean" && elem.getAttribute( name ),
			detail = typeof prop === "boolean" ?

				getSetInput && getSetAttribute ?
					attr != null :
					// oldIE fabricates an empty string for missing boolean attributes
					// and conflates checked/selected into attroperties
					ruseDefault.test( name ) ?
						elem[ jQuery.camelCase( "default-" + name ) ] :
						!!attr :

				// fetch an attribute node for properties not recognized as boolean
				elem.getAttributeNode( name );

		return detail && detail.value !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
			// IE<8 needs the *property* name
			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

		// Use defaultChecked and defaultSelected for oldIE
		} else {
			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
		}

		return name;
	}
};

// fix oldIE value attroperty
if ( !getSetInput || !getSetAttribute ) {
	jQuery.attrHooks.value = {
		get: function( elem, name ) {
			var ret = elem.getAttributeNode( name );
			return jQuery.nodeName( elem, "input" ) ?

				// Ignore the value *property* by using defaultValue
				elem.defaultValue :

				ret && ret.specified ? ret.value : undefined;
		},
		set: function( elem, value, name ) {
			if ( jQuery.nodeName( elem, "input" ) ) {
				// Does not return so that setAttribute is also used
				elem.defaultValue = value;
			} else {
				// Use nodeHook if defined (#1954); otherwise setAttribute is fine
				return nodeHook && nodeHook.set( elem, value, name );
			}
		}
	};
}

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret = elem.getAttributeNode( name );
			return ret && ( name === "id" || name === "name" || name === "coords" ? ret.value !== "" : ret.specified ) ?
				ret.value :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				elem.setAttributeNode(
					(ret = elem.ownerDocument.createAttribute( name ))
				);
			}

			ret.value = value += "";

			// Break association with cloned elements by also using setAttribute (#9646)
			return name === "value" || value === elem.getAttribute( name ) ?
				value :
				undefined;
		}
	};

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			nodeHook.set( elem, value === "" ? false : value, name );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});
}


// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret == null ? undefined : ret;
			}
		});
	});

	// href/src property should get the full normalized URL (#10299/#12915)
	jQuery.each([ "href", "src" ], function( i, name ) {
		jQuery.propHooks[ name ] = {
			get: function( elem ) {
				return elem.getAttribute( name, 4 );
			}
		};
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Note: IE uppercases css property names, but if we were to .toLowerCase()
			// .cssText, that would destroy case senstitivity in URL's, like in "background"
			return elem.style.cssText || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});
var rformElems = /^(?:input|select|textarea)$/i,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {
		var tmp, events, t, handleObjIn,
			special, eventHandle, handleObj,
			handlers, type, namespaces, origType,
			elemData = jQuery._data( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = ( types || "" ).match( core_rnotwhite ) || [""];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {
		var j, handleObj, tmp,
			origCount, t, events,
			special, handlers, type,
			namespaces, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( core_rnotwhite ) || [""];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery._removeData( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		var handle, ontype, cur,
			bubbleType, special, tmp, i,
			eventPath = [ elem || document ],
			type = core_hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = core_hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		event.isTrigger = true;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					try {
						elem[ type ]();
					} catch ( e ) {
						// IE<9 dies on focus/blur to hidden element (#1486,#12518)
						// only reproducible on winXP IE8 native, not IE9 in IE8 mode
					}
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, ret, handleObj, matched, j,
			handlerQueue = [],
			args = core_slice.call( arguments ),
			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var sel, handleObj, matches, i,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur != this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: IE<9
		// Fix target property (#1925)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Support: Chrome 23+, Safari?
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Support: IE<9
		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
		event.metaKey = !!event.metaKey;

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var body, eventDoc, doc,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
					this.click();
					return false;
				}
			}
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== document.activeElement && this.focus ) {
					try {
						this.focus();
						return false;
					} catch ( e ) {
						// Support: IE<9
						// If we error on focus to hidden element (#1486, #12518),
						// let .trigger() run the handlers
					}
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === document.activeElement && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Even when returnValue equals to undefined Firefox will still show alert
				if ( event.result !== undefined ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === core_strundefined ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;
		if ( !e ) {
			return;
		}

		// If preventDefault exists, run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// Support: IE
		// Otherwise set the returnValue property of the original event to false
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;
		if ( !e ) {
			return;
		}
		// If stopPropagation exists, run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}

		// Support: IE
		// Set the cancelBubble property of the original event to true
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "submitBubbles" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "submitBubbles", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "changeBubbles", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var type, origFn;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});
/*!
 * Sizzle CSS Selector Engine
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://sizzlejs.com/
 */
(function( window, undefined ) {

var i,
	cachedruns,
	Expr,
	getText,
	isXML,
	compile,
	hasDuplicate,
	outermostContext,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsXML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,
	sortOrder,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	support = {},
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),

	// General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	// Array methods
	arr = [],
	pop = arr.pop,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},


	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	operators = "([*^$|!~]?=)",
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	// Prefer arguments quoted,
	//   then not containing pseudos/brackets,
	//   then attribute selectors/non-parenthetical expressions,
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*" ),
	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"NAME": new RegExp( "^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rsibling = /[\x20\t\r\n\f]*[+~]/,

	rnative = /^[^{]+\{\s*\[native code/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rescape = /'|\\/g,
	rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = /\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,
	funescape = function( _, escaped ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		return high !== high ?
			escaped :
			// BMP codepoint
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Use a stripped-down slice if we can't use a native one
try {
	slice.call( preferredDoc.documentElement.childNodes, 0 )[0].nodeType;
} catch ( e ) {
	slice = function( i ) {
		var elem,
			results = [];
		while ( (elem = this[i++]) ) {
			results.push( elem );
		}
		return results;
	};
}

/**
 * For feature detection
 * @param {Function} fn The function to test for native support
 */
function isNative( fn ) {
	return rnative.test( fn + "" );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var cache,
		keys = [];

	return (cache = function( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key += " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key ] = value);
	});
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return fn( div );
	} catch (e) {
		return false;
	} finally {
		// release memory in IE
		div = null;
	}
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( !documentIsXML && !seed ) {

		// Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getByClassName && context.getElementsByClassName ) {
				push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && !rbuggyQSA.test(selector) ) {
			old = true;
			nid = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && context.parentNode || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results, slice.call( newContext.querySelectorAll(
						newSelector
					), 0 ) );
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Detect xml
 * @param {Element|Object} elem An element or a document
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;

	// Support tests
	documentIsXML = isXML( doc );

	// Check if getElementsByTagName("*") returns only elements
	support.tagNameNoComments = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Check if attributes should be retrieved by attribute nodes
	support.attributes = assert(function( div ) {
		div.innerHTML = "<select></select>";
		var type = typeof div.lastChild.getAttribute("multiple");
		// IE8 returns a string for some attributes even when not present
		return type !== "boolean" && type !== "string";
	});

	// Check if getElementsByClassName can be trusted
	support.getByClassName = assert(function( div ) {
		// Opera can't find a second classname (in 9.6)
		div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
		if ( !div.getElementsByClassName || !div.getElementsByClassName("e").length ) {
			return false;
		}

		// Safari 3.2 caches class attributes and doesn't catch changes
		div.lastChild.className = "e";
		return div.getElementsByClassName("e").length === 2;
	});

	// Check if getElementById returns elements by name
	// Check if getElementsByName privileges form controls or returns elements by ID
	support.getByName = assert(function( div ) {
		// Inject content
		div.id = expando + 0;
		div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
		docElem.insertBefore( div, docElem.firstChild );

		// Test
		var pass = doc.getElementsByName &&
			// buggy browsers will return fewer than the correct 2
			doc.getElementsByName( expando ).length === 2 +
			// buggy browsers will return more than the correct 0
			doc.getElementsByName( expando + 0 ).length;
		support.getIdNotName = !doc.getElementById( expando );

		// Cleanup
		docElem.removeChild( div );

		return pass;
	});

	// IE6/7 return modified attributes
	Expr.attrHandle = assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
			div.firstChild.getAttribute("href") === "#";
	}) ?
		{} :
		{
			"href": function( elem ) {
				return elem.getAttribute( "href", 2 );
			},
			"type": function( elem ) {
				return elem.getAttribute("type");
			}
		};

	// ID find and filter
	if ( support.getIdNotName ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && !documentIsXML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && !documentIsXML ) {
				var m = context.getElementById( id );

				return m ?
					m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
						[m] :
						undefined :
					[];
			}
		};
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.tagNameNoComments ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Name
	Expr.find["NAME"] = support.getByName && function( tag, context ) {
		if ( typeof context.getElementsByName !== strundefined ) {
			return context.getElementsByName( name );
		}
	};

	// Class
	Expr.find["CLASS"] = support.getByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && !documentIsXML ) {
			return context.getElementsByClassName( className );
		}
	};

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21),
	// no need to also add to buggyMatches since matches checks buggyQSA
	// A support test would require too much code (would include document ready)
	rbuggyQSA = [ ":focus" ];

	if ( (support.qsa = isNative(doc.querySelectorAll)) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explictly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select><option selected=''></option></select>";

			// IE8 - Some boolean attributes are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {

			// Opera 10-12/IE8 - ^= $= *= and empty values
			// Should not select anything
			div.innerHTML = "<input type='hidden' i=''/>";
			if ( div.querySelectorAll("[i^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\"\"|'')" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = isNative( (matches = docElem.matchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.webkitMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = new RegExp( rbuggyMatches.join("|") );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = isNative(docElem.contains) || docElem.compareDocumentPosition ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	// Document order sorting
	sortOrder = docElem.compareDocumentPosition ?
	function( a, b ) {
		var compare;

		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( (compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b )) ) {
			if ( compare & 1 || a.parentNode && a.parentNode.nodeType === 11 ) {
				if ( a === doc || contains( preferredDoc, a ) ) {
					return -1;
				}
				if ( b === doc || contains( preferredDoc, b ) ) {
					return 1;
				}
				return 0;
			}
			return compare & 4 ? -1 : 1;
		}

		return a.compareDocumentPosition ? -1 : 1;
	} :
	function( a, b ) {
		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Parentless nodes are either documents or disconnected
		} else if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	// Always assume the presence of duplicates if sort doesn't
	// pass them to our comparison function (as in Google Chrome).
	hasDuplicate = false;
	[0, 0].sort( sortOrder );
	support.detectDuplicates = hasDuplicate;

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	// rbuggyQSA always contains :focus, so no need for an existence check
	if ( support.matchesSelector && !documentIsXML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && !rbuggyQSA.test(expr) ) {
		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [elem] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	var val;

	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( !documentIsXML ) {
		name = name.toLowerCase();
	}
	if ( (val = Expr.attrHandle[ name ]) ) {
		return val( elem );
	}
	if ( documentIsXML || support.attributes ) {
		return elem.getAttribute( name );
	}
	return ( (val = elem.getAttributeNode( name )) || elem.getAttribute( name ) ) && elem[ name ] === true ?
		name :
		val && val.specified ? val.value : null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

// Document sorting and removing duplicates
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		i = 1,
		j = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		for ( ; (elem = results[i]); i++ ) {
			if ( elem === results[ i - 1 ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	return results;
};

function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && ( ~b.sourceIndex || MAX_NEGATIVE ) - ( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

// Returns a function to use in pseudos for input types
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

// Returns a function to use in pseudos for buttons
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

// Returns a function to use in pseudos for positionals
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		for ( ; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (see #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[5] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[4] ) {
				match[2] = match[4];

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeName ) {
			if ( nodeName === "*" ) {
				return function() { return true; };
			}

			nodeName = nodeName.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
			};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifider
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsXML ?
						elem.getAttribute("xml:lang") || elem.getAttribute("lang") :
						elem.lang) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
			//   not comment, processing instructions, or others
			// Thanks to Diego Perini for the nodeName shortcut
			//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeName > "@" || elem.nodeType === 3 || elem.nodeType === 4 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === elem.type );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( tokens = [] );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var data, cache, outerCache,
				dirkey = dirruns + " " + doneName;

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {
							if ( (data = cache[1]) === true || data === cachedruns ) {
								return data === true;
							}
						} else {
							cache = outerCache[ dir ] = [ dirkey ];
							cache[1] = matcher( elem, context, xml ) || cachedruns;
							if ( cache[1] === true ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector( tokens.slice( 0, i - 1 ) ).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	// A counter to specify which element is currently being matched
	var matcherCachedRuns = 0,
		bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, expandContext ) {
			var elem, j, matcher,
				setMatched = [],
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				outermost = expandContext != null,
				contextBackup = outermostContext,
				// We must always have either seed elements or context
				elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);

			if ( outermost ) {
				outermostContext = context !== document && context;
				cachedruns = matcherCachedRuns;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
						cachedruns = ++matcherCachedRuns;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		match = tokenize( selector );

	if ( !seed ) {
		// Try to minimize operations if there is only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && !documentIsXML &&
					Expr.relative[ tokens[1].type ] ) {

				context = Expr.find["ID"]( token.matches[0].replace( runescape, funescape ), context )[0];
				if ( !context ) {
					return results;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && context.parentNode || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, slice.call( seed, 0 ) );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	// Compile and execute a filtering function
	// Provide `match` to avoid retokenization if we modified the selector above
	compile( selector, match )(
		seed,
		context,
		documentIsXML,
		results,
		rsibling.test( selector )
	);
	return results;
}

// Deprecated
Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Easy API for creating new setFilters
function setFilters() {}
Expr.filters = setFilters.prototype = Expr.pseudos;
Expr.setFilters = new setFilters();

// Initialize with the default document
setDocument();

// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})( window );
var runtil = /Until$/,
	rparentsprev = /^(?:parents|prev(?:Until|All))/,
	isSimple = /^.[^:#\[\.,]*$/,
	rneedsContext = jQuery.expr.match.needsContext,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var i, ret, self,
			len = this.length;

		if ( typeof selector !== "string" ) {
			self = this;
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		ret = [];
		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, this[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = ( this.selector ? this.selector + " " : "" ) + selector;
		return ret;
	},

	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false) );
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true) );
	},

	is: function( selector ) {
		return !!selector && (
			typeof selector === "string" ?
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				rneedsContext.test( selector ) ?
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			ret = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			cur = this[i];

			while ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;
				}
				cur = cur.parentNode;
			}
		}

		return this.pushStack( ret.length > 1 ? jQuery.unique( ret ) : ret );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( jQuery.unique(all) );
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

jQuery.fn.andSelf = jQuery.fn.addBack;

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( this.length > 1 && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}
function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
		safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		area: [ 1, "<map>", "</map>" ],
		param: [ 1, "<object>", "</object>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
		// unless wrapped in a div with non-breaking characters in front of it.
		_default: jQuery.support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, false, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, false, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length > 0 ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( getAll( elem ) );
				}

				if ( elem.parentNode ) {
					if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
						setGlobalEval( getAll( elem, "script" ) );
					}
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem, false ) );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}

			// If this is a select, ensure that it displays empty (#12336)
			// Support: IE<9
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
				elem.options.length = 0;
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function( value ) {
		var isFunc = jQuery.isFunction( value );

		// Make sure that the elements are removed from the DOM before they are inserted
		// this can help fix replacing a parent with child elements
		if ( !isFunc && typeof value !== "string" ) {
			value = jQuery( value ).not( this ).detach();
		}

		return this.domManip( [ value ], true, function( elem ) {
			var next = this.nextSibling,
				parent = this.parentNode;

			if ( parent ) {
				jQuery( this ).remove();
				parent.insertBefore( elem, next );
			}
		});
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {

		// Flatten any nested arrays
		args = core_concat.apply( [], args );

		var first, node, hasScripts,
			scripts, doc, fragment,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[0],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction || !( l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[0] = value.call( this, index, table ? self.html() : undefined );
				}
				self.domManip( args, table, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call(
						table && jQuery.nodeName( this[i], "table" ) ?
							findOrAppend( this[i], "tbody" ) :
							this[i],
						node,
						i
					);
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Hope ajax is available...
								jQuery.ajax({
									url: node.src,
									type: "GET",
									dataType: "script",
									async: false,
									global: false,
									"throws": true
								});
							} else {
								jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
							}
						}
					}
				}

				// Fix #11809: Avoid leaking memory
				fragment = first = null;
			}
		}

		return this;
	}
});

function findOrAppend( elem, tag ) {
	return elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	var attr = elem.getAttributeNode("type");
	elem.type = ( attr && attr.specified ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );
	if ( match ) {
		elem.type = match[1];
	} else {
		elem.removeAttribute("type");
	}
	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var elem,
		i = 0;
	for ( ; (elem = elems[i]) != null; i++ ) {
		jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
	}
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function fixCloneNodeIssues( src, dest ) {
	var nodeName, e, data;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 copies events bound via attachEvent when using cloneNode.
	if ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {
		data = jQuery._data( dest );

		for ( e in data.events ) {
			jQuery.removeEvent( dest, e, data.handle );
		}

		// Event data gets referenced instead of copied if the expando gets copied too
		dest.removeAttribute( jQuery.expando );
	}

	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
	if ( nodeName === "script" && dest.text !== src.text ) {
		disableScript( dest ).text = src.text;
		restoreScript( dest );

	// IE6-10 improperly clones children of object elements using classid.
	// IE10 throws NoModificationAllowedError if parent is null, #12132.
	} else if ( nodeName === "object" ) {
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && manipulation_rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.defaultSelected = dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone(true);
			jQuery( insert[i] )[ original ]( elems );

			// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
			core_push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});

function getAll( context, tag ) {
	var elems, elem,
		i = 0,
		found = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll( tag || "*" ) :
			undefined;

	if ( !found ) {
		for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
			if ( !tag || jQuery.nodeName( elem, tag ) ) {
				found.push( elem );
			} else {
				jQuery.merge( found, getAll( elem, tag ) );
			}
		}
	}

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], found ) :
		found;
}

// Used in buildFragment, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( manipulation_rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var destElements, node, clone, i, srcElements,
			inPage = jQuery.contains( elem.ownerDocument, elem );

		if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			// Fix all IE cloning issues
			for ( i = 0; (node = srcElements[i]) != null; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					fixCloneNodeIssues( node, destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0; (node = srcElements[i]) != null; i++ ) {
					cloneCopyEvent( node, destElements[i] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		destElements = srcElements = node = null;

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var j, elem, contains,
			tmp, tag, tbody, wrap,
			l = elems.length,

			// Ensure a safe fragment
			safe = createSafeFragment( context ),

			nodes = [],
			i = 0;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || safe.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;

					tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Manually add leading whitespace removed by IE
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						elem = tag === "table" && !rtbody.test( elem ) ?
							tmp.firstChild :

							// String was a bare <thead> or <tfoot>
							wrap[1] === "<table>" && !rtbody.test( elem ) ?
								tmp :
								0;

						j = elem && elem.childNodes.length;
						while ( j-- ) {
							if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
								elem.removeChild( tbody );
							}
						}
					}

					jQuery.merge( nodes, tmp.childNodes );

					// Fix #12392 for WebKit and IE > 9
					tmp.textContent = "";

					// Fix #12392 for oldIE
					while ( tmp.firstChild ) {
						tmp.removeChild( tmp.firstChild );
					}

					// Remember the top-level container for proper cleanup
					tmp = safe.lastChild;
				}
			}
		}

		// Fix #11356: Clear elements from fragment
		if ( tmp ) {
			safe.removeChild( tmp );
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !jQuery.support.appendChecked ) {
			jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
		}

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( safe.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		tmp = null;

		return safe;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var elem, type, id, data,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = jQuery.support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( typeof elem.removeAttribute !== core_strundefined ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						core_deletedIds.push( id );
					}
				}
			}
		}
	}
});
var iframe, getStyles, curCSS,
	ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity\s*=\s*([^)]*)/,
	rposition = /^(top|right|bottom|left)$/,
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rmargin = /^margin/,
	rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
	rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + core_pnum + ")", "i" ),
	elemdisplay = { BODY: "block" },

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssExpand = [ "Top", "Right", "Bottom", "Left" ],
	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function isHidden( elem, el ) {
	// isHidden might be called from jQuery#filter function;
	// in that case, element will be second argument
	elem = el || elem;
	return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = jQuery._data( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
			}
		} else {

			if ( !values[ index ] ) {
				hidden = isHidden( elem );

				if ( display && display !== "none" || !hidden ) {
					jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
				}
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.fn.extend({
	css: function( name, value ) {
		return jQuery.access( this, function( elem, name, value ) {
			var len, styles,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		var bool = typeof state === "boolean";

		return this.each(function() {
			if ( bool ? state : isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var num, val, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

// NOTE: we've included the "window" in window.getComputedStyle
// because jsdom on node.js will break without it.
if ( window.getComputedStyle ) {
	getStyles = function( elem ) {
		return window.getComputedStyle( elem, null );
	};

	curCSS = function( elem, name, _computed ) {
		var width, minWidth, maxWidth,
			computed = _computed || getStyles( elem ),

			// getPropertyValue is only needed for .css('filter') in IE9, see #12537
			ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,
			style = elem.style;

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret;
	};
} else if ( document.documentElement.currentStyle ) {
	getStyles = function( elem ) {
		return elem.currentStyle;
	};

	curCSS = function( elem, name, _computed ) {
		var left, rs, rsLeft,
			computed = _computed || getStyles( elem ),
			ret = computed ? computed[ name ] : undefined,
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rs = elem.runtimeStyle;
			rsLeft = rs && rs.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				rs.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				rs.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {
			// Use the already-created iframe if possible
			iframe = ( iframe ||
				jQuery("<iframe frameborder='0' width='0' height='0'/>")
				.css( "cssText", "display:block !important" )
			).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;
			doc.write("<!doctype html><html><body>");
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}

// Called ONLY from within css_defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
		display = jQuery.css( elem[0], "display" );
	elem.remove();
	return display;
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			// if value === "", then remove inline opacity #12685
			if ( ( value >= 1 || value === "" ) &&
					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
					style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there is no filter style applied in a css rule or unset inline opacity, we are done
				if ( value === "" || currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
jQuery(function() {
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				if ( computed ) {
					// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
					// Work around by temporarily setting element display to inline-block
					return jQuery.swap( elem, { "display": "inline-block" },
						curCSS, [ elem, "marginRight" ] );
				}
			}
		};
	}

	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// getComputedStyle returns percent when specified for top/left/bottom/right
	// rather than make the css module depend on the offset module, we just check for it here
	if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
		jQuery.each( [ "top", "left" ], function( i, prop ) {
			jQuery.cssHooks[ prop ] = {
				get: function( elem, computed ) {
					if ( computed ) {
						computed = curCSS( elem, prop );
						// if curCSS returns percentage, fallback to offset
						return rnumnonpx.test( computed ) ?
							jQuery( elem ).position()[ prop ] + "px" :
							computed;
					}
				}
			};
		});
	}

});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
			(!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});
var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function(){
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function(){
			var type = this.type;
			// Use .is(":disabled") so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !manipulation_rcheckableType.test( type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

//Serialize an array of form elements or a set of
//key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}
jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.hover = function( fnOver, fnOut ) {
	return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
};
var
	// Document location
	ajaxLocParts,
	ajaxLocation,
	ajax_nonce = jQuery.now(),

	ajax_rquery = /\?/,
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var deep, key,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, response, type,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off, url.length );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ){
	jQuery.fn[ type ] = function( fn ){
		return this.on( type, fn );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Cross-domain detection vars
			parts,
			// Loop variable
			i,
			// URL without anti-cache param
			cacheURL,
			// Response headers as string
			responseHeadersString,
			// timeout handle
			timeoutTimer,

			// To know if global events are to be dispatched
			fireGlobals,

			transport,
			// Response headers
			responseHeaders,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( core_rnotwhite ) || [""];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + ajax_nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ajax_nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 ) {
					isSuccess = true;
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					isSuccess = true;
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					isSuccess = ajaxConvert( s, response );
					statusText = isSuccess.state;
					success = isSuccess.data;
					error = isSuccess.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	}
});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
	var firstDataType, ct, finalDataType, type,
		contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {
	var conv2, current, conv, tmp,
		converters = {},
		i = 0,
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice(),
		prev = dataTypes[ 0 ];

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	// Convert to each sequential dataType, tolerating list modification
	for ( ; (current = dataTypes[++i]); ) {

		// There's only work to do if current dataType is non-auto
		if ( current !== "*" ) {

			// Convert response if prev dataType is non-auto and differs from current
			if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split(" ");
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.splice( i--, 0, current );
								}

								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s["throws"] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}

			// Update prev for next iteration
			prev = current;
		}
	}

	return { state: "success", data: response };
}
// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || jQuery("head")[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement("script");

				script.async = true;

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( script.parentNode ) {
							script.parentNode.removeChild( script );
						}

						// Dereference the script
						script = null;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};

				// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
				// Use native DOM manipulation to avoid our domManip AJAX trickery
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( undefined, true );
				}
			}
		};
	}
});
var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( ajax_nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( ajax_rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});
var xhrCallbacks, xhrSupported,
	xhrId = 0,
	// #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject && function() {
		// Abort all pending requests
		var key;
		for ( key in xhrCallbacks ) {
			xhrCallbacks[ key ]( undefined, true );
		}
	};

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject("Microsoft.XMLHTTP");
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
xhrSupported = jQuery.ajaxSettings.xhr();
jQuery.support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = jQuery.support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
if ( xhrSupported ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var handle, i,
						xhr = s.xhr();

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( err ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {
						var status, responseHeaders, statusText, responses;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occurred
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									responses = {};
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									if ( typeof xhr.responseText === "string" ) {
										responses.text = xhr.responseText;
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					if ( !s.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback );
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback( undefined, true );
					}
				}
			};
		}
	});
}
var fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [function( prop, value ) {
			var end, unit,
				tween = this.createTween( prop, value ),
				parts = rfxnum.exec( value ),
				target = tween.cur(),
				start = +target || 0,
				scale = 1,
				maxIterations = 20;

			if ( parts ) {
				end = +parts[2];
				unit = parts[3] || ( jQuery.cssNumber[ prop ] ? "" : "px" );

				// We need to compute starting value
				if ( unit !== "px" && start ) {
					// Iteratively approximate from a nonzero starting point
					// Prefer the current property, because this process will be trivial if it uses the same units
					// Fallback to end or a simple constant
					start = jQuery.css( tween.elem, prop, true ) || end || 1;

					do {
						// If previous iteration zeroed out, double until we get *something*
						// Use a string for doubling factor so we don't accidentally see scale as unchanged below
						scale = scale || ".5";

						// Adjust and apply
						start = start / scale;
						jQuery.style( tween.elem, prop, start + unit );

					// Update scale, tolerating zero or NaN from tween.cur()
					// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
					} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
				}

				tween.unit = unit;
				tween.start = start;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
			}
			return tween;
		}]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

function createTweens( animation, props ) {
	jQuery.each( props, function( prop, value ) {
		var collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( collection[ index ].call( animation, prop, value ) ) {

				// we're done with this property
				return;
			}
		}
	});
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	createTweens( animation, props );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

function propFilter( props, specialEasing ) {
	var value, name, index, easing, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

function defaultPrefilter( elem, props, opts ) {
	/*jshint validthis:true */
	var prop, index, length,
		value, dataShow, toggle,
		tween, hooks, oldfire,
		anim = this,
		style = elem.style,
		orig = {},
		handled = [],
		hidden = elem.nodeType && isHidden( elem );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		if ( jQuery.css( elem, "display" ) === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";

			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !jQuery.support.shrinkWrapBlocks ) {
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}


	// show/hide pass
	for ( index in props ) {
		value = props[ index ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ index ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {
				continue;
			}
			handled.push( index );
		}
	}

	length = handled.length;
	if ( length ) {
		dataShow = jQuery._data( elem, "fxshow" ) || jQuery._data( elem, "fxshow", {} );
		if ( "hidden" in dataShow ) {
			hidden = dataShow.hidden;
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery._removeData( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( index = 0 ; index < length ; index++ ) {
			prop = handled[ index ];
			tween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );
			orig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Remove in 2.0 - this supports IE8's panic based approach
// to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );
				doAnimation.finish = function() {
					anim.stop( true );
				};
				// Empty animations, or finishing resolves immediately
				if ( empty || jQuery._data( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = jQuery._data( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.cur && hooks.cur.finish ) {
				hooks.cur.finish.call( this );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth? 1 : 0;
	for( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p*Math.PI ) / 2;
	}
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	if ( timer() && jQuery.timers.push( timer ) ) {
		jQuery.fx.start();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};

// Back Compat <1.8 extension point
jQuery.fx.step = {};

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}
jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var docElem, win,
		box = { top: 0, left: 0 },
		elem = this[ 0 ],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return;
	}

	docElem = doc.documentElement;

	// Make sure it's not a disconnected DOM node
	if ( !jQuery.contains( docElem, elem ) ) {
		return box;
	}

	// If we don't have gBCR, just use 0,0 rather than error
	// BlackBerry 5, iOS 3 (original iPhone)
	if ( typeof elem.getBoundingClientRect !== core_strundefined ) {
		box = elem.getBoundingClientRect();
	}
	win = getWindow( doc );
	return {
		top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
		left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
	};
};

jQuery.offset = {

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			parentOffset = { top: 0, left: 0 },
			elem = this[ 0 ];

		// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// we assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();
		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		return {
			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.documentElement;
			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position") === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || document.documentElement;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return jQuery.access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});
// Limit scope pollution from any deprecated API
// (function() {

// })();
// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}

})( window );

/*!
 * jQuery Transit - CSS3 transitions and transformations
 * (c) 2011-2012 Rico Sta. Cruz <rico@ricostacruz.com>
 * MIT Licensed.
 *
 * http://ricostacruz.com/jquery.transit
 * http://github.com/rstacruz/jquery.transit
 */
(function(k){k.transit={version:"0.9.9",propertyMap:{marginLeft:"margin",marginRight:"margin",marginBottom:"margin",marginTop:"margin",paddingLeft:"padding",paddingRight:"padding",paddingBottom:"padding",paddingTop:"padding"},enabled:true,useTransitionEnd:false};var d=document.createElement("div");var q={};function b(v){if(v in d.style){return v}var u=["Moz","Webkit","O","ms"];var r=v.charAt(0).toUpperCase()+v.substr(1);if(v in d.style){return v}for(var t=0;t<u.length;++t){var s=u[t]+r;if(s in d.style){return s}}}function e(){d.style[q.transform]="";d.style[q.transform]="rotateY(90deg)";return d.style[q.transform]!==""}var a=navigator.userAgent.toLowerCase().indexOf("chrome")>-1;q.transition=b("transition");q.transitionDelay=b("transitionDelay");q.transform=b("transform");q.transformOrigin=b("transformOrigin");q.transform3d=e();var i={transition:"transitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd",WebkitTransition:"webkitTransitionEnd",msTransition:"MSTransitionEnd"};var f=q.transitionEnd=i[q.transition]||null;for(var p in q){if(q.hasOwnProperty(p)&&typeof k.support[p]==="undefined"){k.support[p]=q[p]}}d=null;k.cssEase={_default:"ease","in":"ease-in",out:"ease-out","in-out":"ease-in-out",snap:"cubic-bezier(0,1,.5,1)",easeOutCubic:"cubic-bezier(.215,.61,.355,1)",easeInOutCubic:"cubic-bezier(.645,.045,.355,1)",easeInCirc:"cubic-bezier(.6,.04,.98,.335)",easeOutCirc:"cubic-bezier(.075,.82,.165,1)",easeInOutCirc:"cubic-bezier(.785,.135,.15,.86)",easeInExpo:"cubic-bezier(.95,.05,.795,.035)",easeOutExpo:"cubic-bezier(.19,1,.22,1)",easeInOutExpo:"cubic-bezier(1,0,0,1)",easeInQuad:"cubic-bezier(.55,.085,.68,.53)",easeOutQuad:"cubic-bezier(.25,.46,.45,.94)",easeInOutQuad:"cubic-bezier(.455,.03,.515,.955)",easeInQuart:"cubic-bezier(.895,.03,.685,.22)",easeOutQuart:"cubic-bezier(.165,.84,.44,1)",easeInOutQuart:"cubic-bezier(.77,0,.175,1)",easeInQuint:"cubic-bezier(.755,.05,.855,.06)",easeOutQuint:"cubic-bezier(.23,1,.32,1)",easeInOutQuint:"cubic-bezier(.86,0,.07,1)",easeInSine:"cubic-bezier(.47,0,.745,.715)",easeOutSine:"cubic-bezier(.39,.575,.565,1)",easeInOutSine:"cubic-bezier(.445,.05,.55,.95)",easeInBack:"cubic-bezier(.6,-.28,.735,.045)",easeOutBack:"cubic-bezier(.175, .885,.32,1.275)",easeInOutBack:"cubic-bezier(.68,-.55,.265,1.55)"};k.cssHooks["transit:transform"]={get:function(r){return k(r).data("transform")||new j()},set:function(s,r){var t=r;if(!(t instanceof j)){t=new j(t)}if(q.transform==="WebkitTransform"&&!a){s.style[q.transform]=t.toString(true)}else{s.style[q.transform]=t.toString()}k(s).data("transform",t)}};k.cssHooks.transform={set:k.cssHooks["transit:transform"].set};if(k.fn.jquery<"1.8"){k.cssHooks.transformOrigin={get:function(r){return r.style[q.transformOrigin]},set:function(r,s){r.style[q.transformOrigin]=s}};k.cssHooks.transition={get:function(r){return r.style[q.transition]},set:function(r,s){r.style[q.transition]=s}}}n("scale");n("translate");n("rotate");n("rotateX");n("rotateY");n("rotate3d");n("perspective");n("skewX");n("skewY");n("x",true);n("y",true);function j(r){if(typeof r==="string"){this.parse(r)}return this}j.prototype={setFromString:function(t,s){var r=(typeof s==="string")?s.split(","):(s.constructor===Array)?s:[s];r.unshift(t);j.prototype.set.apply(this,r)},set:function(s){var r=Array.prototype.slice.apply(arguments,[1]);if(this.setter[s]){this.setter[s].apply(this,r)}else{this[s]=r.join(",")}},get:function(r){if(this.getter[r]){return this.getter[r].apply(this)}else{return this[r]||0}},setter:{rotate:function(r){this.rotate=o(r,"deg")},rotateX:function(r){this.rotateX=o(r,"deg")},rotateY:function(r){this.rotateY=o(r,"deg")},scale:function(r,s){if(s===undefined){s=r}this.scale=r+","+s},skewX:function(r){this.skewX=o(r,"deg")},skewY:function(r){this.skewY=o(r,"deg")},perspective:function(r){this.perspective=o(r,"px")},x:function(r){this.set("translate",r,null)},y:function(r){this.set("translate",null,r)},translate:function(r,s){if(this._translateX===undefined){this._translateX=0}if(this._translateY===undefined){this._translateY=0}if(r!==null&&r!==undefined){this._translateX=o(r,"px")}if(s!==null&&s!==undefined){this._translateY=o(s,"px")}this.translate=this._translateX+","+this._translateY}},getter:{x:function(){return this._translateX||0},y:function(){return this._translateY||0},scale:function(){var r=(this.scale||"1,1").split(",");if(r[0]){r[0]=parseFloat(r[0])}if(r[1]){r[1]=parseFloat(r[1])}return(r[0]===r[1])?r[0]:r},rotate3d:function(){var t=(this.rotate3d||"0,0,0,0deg").split(",");for(var r=0;r<=3;++r){if(t[r]){t[r]=parseFloat(t[r])}}if(t[3]){t[3]=o(t[3],"deg")}return t}},parse:function(s){var r=this;s.replace(/([a-zA-Z0-9]+)\((.*?)\)/g,function(t,v,u){r.setFromString(v,u)})},toString:function(t){var s=[];for(var r in this){if(this.hasOwnProperty(r)){if((!q.transform3d)&&((r==="rotateX")||(r==="rotateY")||(r==="perspective")||(r==="transformOrigin"))){continue}if(r[0]!=="_"){if(t&&(r==="scale")){s.push(r+"3d("+this[r]+",1)")}else{if(t&&(r==="translate")){s.push(r+"3d("+this[r]+",0)")}else{s.push(r+"("+this[r]+")")}}}}}return s.join(" ")}};function m(s,r,t){if(r===true){s.queue(t)}else{if(r){s.queue(r,t)}else{t()}}}function h(s){var r=[];k.each(s,function(t){t=k.camelCase(t);t=k.transit.propertyMap[t]||k.cssProps[t]||t;t=c(t);if(k.inArray(t,r)===-1){r.push(t)}});return r}function g(s,v,x,r){var t=h(s);if(k.cssEase[x]){x=k.cssEase[x]}var w=""+l(v)+" "+x;if(parseInt(r,10)>0){w+=" "+l(r)}var u=[];k.each(t,function(z,y){u.push(y+" "+w)});return u.join(", ")}k.fn.transition=k.fn.transit=function(z,s,y,C){var D=this;var u=0;var w=true;if(typeof s==="function"){C=s;s=undefined}if(typeof y==="function"){C=y;y=undefined}if(typeof z.easing!=="undefined"){y=z.easing;delete z.easing}if(typeof z.duration!=="undefined"){s=z.duration;delete z.duration}if(typeof z.complete!=="undefined"){C=z.complete;delete z.complete}if(typeof z.queue!=="undefined"){w=z.queue;delete z.queue}if(typeof z.delay!=="undefined"){u=z.delay;delete z.delay}if(typeof s==="undefined"){s=k.fx.speeds._default}if(typeof y==="undefined"){y=k.cssEase._default}s=l(s);var E=g(z,s,y,u);var B=k.transit.enabled&&q.transition;var t=B?(parseInt(s,10)+parseInt(u,10)):0;if(t===0){var A=function(F){D.css(z);if(C){C.apply(D)}if(F){F()}};m(D,w,A);return D}var x={};var r=function(H){var G=false;var F=function(){if(G){D.unbind(f,F)}if(t>0){D.each(function(){this.style[q.transition]=(x[this]||null)})}if(typeof C==="function"){C.apply(D)}if(typeof H==="function"){H()}};if((t>0)&&(f)&&(k.transit.useTransitionEnd)){G=true;D.bind(f,F)}else{window.setTimeout(F,t)}D.each(function(){if(t>0){this.style[q.transition]=E}k(this).css(z)})};var v=function(F){this.offsetWidth;r(F)};m(D,w,v);return this};function n(s,r){if(!r){k.cssNumber[s]=true}k.transit.propertyMap[s]=q.transform;k.cssHooks[s]={get:function(v){var u=k(v).css("transit:transform");return u.get(s)},set:function(v,w){var u=k(v).css("transit:transform");u.setFromString(s,w);k(v).css({"transit:transform":u})}}}function c(r){return r.replace(/([A-Z])/g,function(s){return"-"+s.toLowerCase()})}function o(s,r){if((typeof s==="string")&&(!s.match(/^[\-0-9\.]+$/))){return s}else{return""+s+r}}function l(s){var r=s;if(k.fx.speeds[r]){r=k.fx.speeds[r]}return o(r,"ms")}k.transit.getTransitionValue=g})(jQuery);
// Knockout JavaScript library v2.2.1
// (c) Steven Sanderson - http://knockoutjs.com/
// License: MIT (http://www.opensource.org/licenses/mit-license.php)

(function(){
var DEBUG=true;
(function(window,document,navigator,jQuery,undefined){
!function(factory) {
    // Support three module loading scenarios
    if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {
        // [1] CommonJS/Node.js
        var target = module['exports'] || exports; // module.exports is for Node.js
        factory(target);
    } else if (typeof define === 'function' && define['amd']) {
        // [2] AMD anonymous module
        define(['exports'], factory);
    } else {
        // [3] No module loader (plain <script> tag) - put directly in global namespace
        factory(window['ko'] = {});
    }
}(function(koExports){
// Internally, all KO objects are attached to koExports (even the non-exported ones whose names will be minified by the closure compiler).
// In the future, the following "ko" variable may be made distinct from "koExports" so that private objects are not externally reachable.
var ko = typeof koExports !== 'undefined' ? koExports : {};
// Google Closure Compiler helpers (used only to make the minified file smaller)
ko.exportSymbol = function(koPath, object) {
	var tokens = koPath.split(".");

	// In the future, "ko" may become distinct from "koExports" (so that non-exported objects are not reachable)
	// At that point, "target" would be set to: (typeof koExports !== "undefined" ? koExports : ko)
	var target = ko;

	for (var i = 0; i < tokens.length - 1; i++)
		target = target[tokens[i]];
	target[tokens[tokens.length - 1]] = object;
};
ko.exportProperty = function(owner, publicName, object) {
  owner[publicName] = object;
};
ko.version = "2.2.1";

ko.exportSymbol('version', ko.version);
ko.utils = new (function () {
    var stringTrimRegex = /^(\s|\u00A0)+|(\s|\u00A0)+$/g;

    // Represent the known event types in a compact way, then at runtime transform it into a hash with event name as key (for fast lookup)
    var knownEvents = {}, knownEventTypesByEventName = {};
    var keyEventTypeName = /Firefox\/2/i.test(navigator.userAgent) ? 'KeyboardEvent' : 'UIEvents';
    knownEvents[keyEventTypeName] = ['keyup', 'keydown', 'keypress'];
    knownEvents['MouseEvents'] = ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave'];
    for (var eventType in knownEvents) {
        var knownEventsForType = knownEvents[eventType];
        if (knownEventsForType.length) {
            for (var i = 0, j = knownEventsForType.length; i < j; i++)
                knownEventTypesByEventName[knownEventsForType[i]] = eventType;
        }
    }
    var eventsThatMustBeRegisteredUsingAttachEvent = { 'propertychange': true }; // Workaround for an IE9 issue - https://github.com/SteveSanderson/knockout/issues/406

    // Detect IE versions for bug workarounds (uses IE conditionals, not UA string, for robustness)
    // Note that, since IE 10 does not support conditional comments, the following logic only detects IE < 10.
    // Currently this is by design, since IE 10+ behaves correctly when treated as a standard browser.
    // If there is a future need to detect specific versions of IE10+, we will amend this.
    var ieVersion = (function() {
        var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');

        // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment
        while (
            div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',
            iElems[0]
        );
        return version > 4 ? version : undefined;
    }());
    var isIe6 = ieVersion === 6,
        isIe7 = ieVersion === 7;

    function isClickOnCheckableElement(element, eventType) {
        if ((ko.utils.tagNameLower(element) !== "input") || !element.type) return false;
        if (eventType.toLowerCase() != "click") return false;
        var inputType = element.type;
        return (inputType == "checkbox") || (inputType == "radio");
    }

    return {
        fieldsIncludedWithJsonPost: ['authenticity_token', /^__RequestVerificationToken(_.*)?$/],

        arrayForEach: function (array, action) {
            for (var i = 0, j = array.length; i < j; i++)
                action(array[i]);
        },

        arrayIndexOf: function (array, item) {
            if (typeof Array.prototype.indexOf == "function")
                return Array.prototype.indexOf.call(array, item);
            for (var i = 0, j = array.length; i < j; i++)
                if (array[i] === item)
                    return i;
            return -1;
        },

        arrayFirst: function (array, predicate, predicateOwner) {
            for (var i = 0, j = array.length; i < j; i++)
                if (predicate.call(predicateOwner, array[i]))
                    return array[i];
            return null;
        },

        arrayRemoveItem: function (array, itemToRemove) {
            var index = ko.utils.arrayIndexOf(array, itemToRemove);
            if (index >= 0)
                array.splice(index, 1);
        },

        arrayGetDistinctValues: function (array) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++) {
                if (ko.utils.arrayIndexOf(result, array[i]) < 0)
                    result.push(array[i]);
            }
            return result;
        },

        arrayMap: function (array, mapping) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++)
                result.push(mapping(array[i]));
            return result;
        },

        arrayFilter: function (array, predicate) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++)
                if (predicate(array[i]))
                    result.push(array[i]);
            return result;
        },

        arrayPushAll: function (array, valuesToPush) {
            if (valuesToPush instanceof Array)
                array.push.apply(array, valuesToPush);
            else
                for (var i = 0, j = valuesToPush.length; i < j; i++)
                    array.push(valuesToPush[i]);
            return array;
        },

        extend: function (target, source) {
            if (source) {
                for(var prop in source) {
                    if(source.hasOwnProperty(prop)) {
                        target[prop] = source[prop];
                    }
                }
            }
            return target;
        },

        emptyDomNode: function (domNode) {
            while (domNode.firstChild) {
                ko.removeNode(domNode.firstChild);
            }
        },

        moveCleanedNodesToContainerElement: function(nodes) {
            // Ensure it's a real array, as we're about to reparent the nodes and
            // we don't want the underlying collection to change while we're doing that.
            var nodesArray = ko.utils.makeArray(nodes);

            var container = document.createElement('div');
            for (var i = 0, j = nodesArray.length; i < j; i++) {
                container.appendChild(ko.cleanNode(nodesArray[i]));
            }
            return container;
        },

        cloneNodes: function (nodesArray, shouldCleanNodes) {
            for (var i = 0, j = nodesArray.length, newNodesArray = []; i < j; i++) {
                var clonedNode = nodesArray[i].cloneNode(true);
                newNodesArray.push(shouldCleanNodes ? ko.cleanNode(clonedNode) : clonedNode);
            }
            return newNodesArray;
        },

        setDomNodeChildren: function (domNode, childNodes) {
            ko.utils.emptyDomNode(domNode);
            if (childNodes) {
                for (var i = 0, j = childNodes.length; i < j; i++)
                    domNode.appendChild(childNodes[i]);
            }
        },

        replaceDomNodes: function (nodeToReplaceOrNodeArray, newNodesArray) {
            var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray;
            if (nodesToReplaceArray.length > 0) {
                var insertionPoint = nodesToReplaceArray[0];
                var parent = insertionPoint.parentNode;
                for (var i = 0, j = newNodesArray.length; i < j; i++)
                    parent.insertBefore(newNodesArray[i], insertionPoint);
                for (var i = 0, j = nodesToReplaceArray.length; i < j; i++) {
                    ko.removeNode(nodesToReplaceArray[i]);
                }
            }
        },

        setOptionNodeSelectionState: function (optionNode, isSelected) {
            // IE6 sometimes throws "unknown error" if you try to write to .selected directly, whereas Firefox struggles with setAttribute. Pick one based on browser.
            if (ieVersion < 7)
                optionNode.setAttribute("selected", isSelected);
            else
                optionNode.selected = isSelected;
        },

        stringTrim: function (string) {
            return (string || "").replace(stringTrimRegex, "");
        },

        stringTokenize: function (string, delimiter) {
            var result = [];
            var tokens = (string || "").split(delimiter);
            for (var i = 0, j = tokens.length; i < j; i++) {
                var trimmed = ko.utils.stringTrim(tokens[i]);
                if (trimmed !== "")
                    result.push(trimmed);
            }
            return result;
        },

        stringStartsWith: function (string, startsWith) {
            string = string || "";
            if (startsWith.length > string.length)
                return false;
            return string.substring(0, startsWith.length) === startsWith;
        },

        domNodeIsContainedBy: function (node, containedByNode) {
            if (containedByNode.compareDocumentPosition)
                return (containedByNode.compareDocumentPosition(node) & 16) == 16;
            while (node != null) {
                if (node == containedByNode)
                    return true;
                node = node.parentNode;
            }
            return false;
        },

        domNodeIsAttachedToDocument: function (node) {
            return ko.utils.domNodeIsContainedBy(node, node.ownerDocument);
        },

        tagNameLower: function(element) {
            // For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.
            // Possible future optimization: If we know it's an element from an XHTML document (not HTML),
            // we don't need to do the .toLowerCase() as it will always be lower case anyway.
            return element && element.tagName && element.tagName.toLowerCase();
        },

        registerEventHandler: function (element, eventType, handler) {
            var mustUseAttachEvent = ieVersion && eventsThatMustBeRegisteredUsingAttachEvent[eventType];
            if (!mustUseAttachEvent && typeof jQuery != "undefined") {
                if (isClickOnCheckableElement(element, eventType)) {
                    // For click events on checkboxes, jQuery interferes with the event handling in an awkward way:
                    // it toggles the element checked state *after* the click event handlers run, whereas native
                    // click events toggle the checked state *before* the event handler.
                    // Fix this by intecepting the handler and applying the correct checkedness before it runs.
                    var originalHandler = handler;
                    handler = function(event, eventData) {
                        var jQuerySuppliedCheckedState = this.checked;
                        if (eventData)
                            this.checked = eventData.checkedStateBeforeEvent !== true;
                        originalHandler.call(this, event);
                        this.checked = jQuerySuppliedCheckedState; // Restore the state jQuery applied
                    };
                }
                jQuery(element)['bind'](eventType, handler);
            } else if (!mustUseAttachEvent && typeof element.addEventListener == "function")
                element.addEventListener(eventType, handler, false);
            else if (typeof element.attachEvent != "undefined")
                element.attachEvent("on" + eventType, function (event) {
                    handler.call(element, event);
                });
            else
                throw new Error("Browser doesn't support addEventListener or attachEvent");
        },

        triggerEvent: function (element, eventType) {
            if (!(element && element.nodeType))
                throw new Error("element must be a DOM node when calling triggerEvent");

            if (typeof jQuery != "undefined") {
                var eventData = [];
                if (isClickOnCheckableElement(element, eventType)) {
                    // Work around the jQuery "click events on checkboxes" issue described above by storing the original checked state before triggering the handler
                    eventData.push({ checkedStateBeforeEvent: element.checked });
                }
                jQuery(element)['trigger'](eventType, eventData);
            } else if (typeof document.createEvent == "function") {
                if (typeof element.dispatchEvent == "function") {
                    var eventCategory = knownEventTypesByEventName[eventType] || "HTMLEvents";
                    var event = document.createEvent(eventCategory);
                    event.initEvent(eventType, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, element);
                    element.dispatchEvent(event);
                }
                else
                    throw new Error("The supplied element doesn't support dispatchEvent");
            } else if (typeof element.fireEvent != "undefined") {
                // Unlike other browsers, IE doesn't change the checked state of checkboxes/radiobuttons when you trigger their "click" event
                // so to make it consistent, we'll do it manually here
                if (isClickOnCheckableElement(element, eventType))
                    element.checked = element.checked !== true;
                element.fireEvent("on" + eventType);
            }
            else
                throw new Error("Browser doesn't support triggering events");
        },

        unwrapObservable: function (value) {
            return ko.isObservable(value) ? value() : value;
        },

        peekObservable: function (value) {
            return ko.isObservable(value) ? value.peek() : value;
        },

        toggleDomNodeCssClass: function (node, classNames, shouldHaveClass) {
            if (classNames) {
                var cssClassNameRegex = /[\w-]+/g,
                    currentClassNames = node.className.match(cssClassNameRegex) || [];
                ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {
                    var indexOfClass = ko.utils.arrayIndexOf(currentClassNames, className);
                    if (indexOfClass >= 0) {
                        if (!shouldHaveClass)
                            currentClassNames.splice(indexOfClass, 1);
                    } else {
                        if (shouldHaveClass)
                            currentClassNames.push(className);
                    }
                });
                node.className = currentClassNames.join(" ");
            }
        },

        setTextContent: function(element, textContent) {
            var value = ko.utils.unwrapObservable(textContent);
            if ((value === null) || (value === undefined))
                value = "";

            if (element.nodeType === 3) {
                element.data = value;
            } else {
                // We need there to be exactly one child: a text node.
                // If there are no children, more than one, or if it's not a text node,
                // we'll clear everything and create a single text node.
                var innerTextNode = ko.virtualElements.firstChild(element);
                if (!innerTextNode || innerTextNode.nodeType != 3 || ko.virtualElements.nextSibling(innerTextNode)) {
                    ko.virtualElements.setDomNodeChildren(element, [document.createTextNode(value)]);
                } else {
                    innerTextNode.data = value;
                }

                ko.utils.forceRefresh(element);
            }
        },

        setElementName: function(element, name) {
            element.name = name;

            // Workaround IE 6/7 issue
            // - https://github.com/SteveSanderson/knockout/issues/197
            // - http://www.matts411.com/post/setting_the_name_attribute_in_ie_dom/
            if (ieVersion <= 7) {
                try {
                    element.mergeAttributes(document.createElement("<input name='" + element.name + "'/>"), false);
                }
                catch(e) {} // For IE9 with doc mode "IE9 Standards" and browser mode "IE9 Compatibility View"
            }
        },

        forceRefresh: function(node) {
            // Workaround for an IE9 rendering bug - https://github.com/SteveSanderson/knockout/issues/209
            if (ieVersion >= 9) {
                // For text nodes and comment nodes (most likely virtual elements), we will have to refresh the container
                var elem = node.nodeType == 1 ? node : node.parentNode;
                if (elem.style)
                    elem.style.zoom = elem.style.zoom;
            }
        },

        ensureSelectElementIsRenderedCorrectly: function(selectElement) {
            // Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you force it to re-render by updating the width.
            // (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-first-char-of-selected-option)
            if (ieVersion >= 9) {
                var originalWidth = selectElement.style.width;
                selectElement.style.width = 0;
                selectElement.style.width = originalWidth;
            }
        },

        range: function (min, max) {
            min = ko.utils.unwrapObservable(min);
            max = ko.utils.unwrapObservable(max);
            var result = [];
            for (var i = min; i <= max; i++)
                result.push(i);
            return result;
        },

        makeArray: function(arrayLikeObject) {
            var result = [];
            for (var i = 0, j = arrayLikeObject.length; i < j; i++) {
                result.push(arrayLikeObject[i]);
            };
            return result;
        },

        isIe6 : isIe6,
        isIe7 : isIe7,
        ieVersion : ieVersion,

        getFormFields: function(form, fieldName) {
            var fields = ko.utils.makeArray(form.getElementsByTagName("input")).concat(ko.utils.makeArray(form.getElementsByTagName("textarea")));
            var isMatchingField = (typeof fieldName == 'string')
                ? function(field) { return field.name === fieldName }
                : function(field) { return fieldName.test(field.name) }; // Treat fieldName as regex or object containing predicate
            var matches = [];
            for (var i = fields.length - 1; i >= 0; i--) {
                if (isMatchingField(fields[i]))
                    matches.push(fields[i]);
            };
            return matches;
        },

        parseJson: function (jsonString) {
            if (typeof jsonString == "string") {
                jsonString = ko.utils.stringTrim(jsonString);
                if (jsonString) {
                    if (window.JSON && window.JSON.parse) // Use native parsing where available
                        return window.JSON.parse(jsonString);
                    return (new Function("return " + jsonString))(); // Fallback on less safe parsing for older browsers
                }
            }
            return null;
        },

        stringifyJson: function (data, replacer, space) {   // replacer and space are optional
            if ((typeof JSON == "undefined") || (typeof JSON.stringify == "undefined"))
                throw new Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
            return JSON.stringify(ko.utils.unwrapObservable(data), replacer, space);
        },

        postJson: function (urlOrForm, data, options) {
            options = options || {};
            var params = options['params'] || {};
            var includeFields = options['includeFields'] || this.fieldsIncludedWithJsonPost;
            var url = urlOrForm;

            // If we were given a form, use its 'action' URL and pick out any requested field values
            if((typeof urlOrForm == 'object') && (ko.utils.tagNameLower(urlOrForm) === "form")) {
                var originalForm = urlOrForm;
                url = originalForm.action;
                for (var i = includeFields.length - 1; i >= 0; i--) {
                    var fields = ko.utils.getFormFields(originalForm, includeFields[i]);
                    for (var j = fields.length - 1; j >= 0; j--)
                        params[fields[j].name] = fields[j].value;
                }
            }

            data = ko.utils.unwrapObservable(data);
            var form = document.createElement("form");
            form.style.display = "none";
            form.action = url;
            form.method = "post";
            for (var key in data) {
                var input = document.createElement("input");
                input.name = key;
                input.value = ko.utils.stringifyJson(ko.utils.unwrapObservable(data[key]));
                form.appendChild(input);
            }
            for (var key in params) {
                var input = document.createElement("input");
                input.name = key;
                input.value = params[key];
                form.appendChild(input);
            }
            document.body.appendChild(form);
            options['submitter'] ? options['submitter'](form) : form.submit();
            setTimeout(function () { form.parentNode.removeChild(form); }, 0);
        }
    }
})();

ko.exportSymbol('utils', ko.utils);
ko.exportSymbol('utils.arrayForEach', ko.utils.arrayForEach);
ko.exportSymbol('utils.arrayFirst', ko.utils.arrayFirst);
ko.exportSymbol('utils.arrayFilter', ko.utils.arrayFilter);
ko.exportSymbol('utils.arrayGetDistinctValues', ko.utils.arrayGetDistinctValues);
ko.exportSymbol('utils.arrayIndexOf', ko.utils.arrayIndexOf);
ko.exportSymbol('utils.arrayMap', ko.utils.arrayMap);
ko.exportSymbol('utils.arrayPushAll', ko.utils.arrayPushAll);
ko.exportSymbol('utils.arrayRemoveItem', ko.utils.arrayRemoveItem);
ko.exportSymbol('utils.extend', ko.utils.extend);
ko.exportSymbol('utils.fieldsIncludedWithJsonPost', ko.utils.fieldsIncludedWithJsonPost);
ko.exportSymbol('utils.getFormFields', ko.utils.getFormFields);
ko.exportSymbol('utils.peekObservable', ko.utils.peekObservable);
ko.exportSymbol('utils.postJson', ko.utils.postJson);
ko.exportSymbol('utils.parseJson', ko.utils.parseJson);
ko.exportSymbol('utils.registerEventHandler', ko.utils.registerEventHandler);
ko.exportSymbol('utils.stringifyJson', ko.utils.stringifyJson);
ko.exportSymbol('utils.range', ko.utils.range);
ko.exportSymbol('utils.toggleDomNodeCssClass', ko.utils.toggleDomNodeCssClass);
ko.exportSymbol('utils.triggerEvent', ko.utils.triggerEvent);
ko.exportSymbol('utils.unwrapObservable', ko.utils.unwrapObservable);

if (!Function.prototype['bind']) {
    // Function.prototype.bind is a standard part of ECMAScript 5th Edition (December 2009, http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf)
    // In case the browser doesn't implement it natively, provide a JavaScript implementation. This implementation is based on the one in prototype.js
    Function.prototype['bind'] = function (object) {
        var originalFunction = this, args = Array.prototype.slice.call(arguments), object = args.shift();
        return function () {
            return originalFunction.apply(object, args.concat(Array.prototype.slice.call(arguments)));
        };
    };
}

ko.utils.domData = new (function () {
    var uniqueId = 0;
    var dataStoreKeyExpandoPropertyName = "__ko__" + (new Date).getTime();
    var dataStore = {};
    return {
        get: function (node, key) {
            var allDataForNode = ko.utils.domData.getAll(node, false);
            return allDataForNode === undefined ? undefined : allDataForNode[key];
        },
        set: function (node, key, value) {
            if (value === undefined) {
                // Make sure we don't actually create a new domData key if we are actually deleting a value
                if (ko.utils.domData.getAll(node, false) === undefined)
                    return;
            }
            var allDataForNode = ko.utils.domData.getAll(node, true);
            allDataForNode[key] = value;
        },
        getAll: function (node, createIfNotFound) {
            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
            var hasExistingDataStore = dataStoreKey && (dataStoreKey !== "null") && dataStore[dataStoreKey];
            if (!hasExistingDataStore) {
                if (!createIfNotFound)
                    return undefined;
                dataStoreKey = node[dataStoreKeyExpandoPropertyName] = "ko" + uniqueId++;
                dataStore[dataStoreKey] = {};
            }
            return dataStore[dataStoreKey];
        },
        clear: function (node) {
            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
            if (dataStoreKey) {
                delete dataStore[dataStoreKey];
                node[dataStoreKeyExpandoPropertyName] = null;
                return true; // Exposing "did clean" flag purely so specs can infer whether things have been cleaned up as intended
            }
            return false;
        }
    }
})();

ko.exportSymbol('utils.domData', ko.utils.domData);
ko.exportSymbol('utils.domData.clear', ko.utils.domData.clear); // Exporting only so specs can clear up after themselves fully

ko.utils.domNodeDisposal = new (function () {
    var domDataKey = "__ko_domNodeDisposal__" + (new Date).getTime();
    var cleanableNodeTypes = { 1: true, 8: true, 9: true };       // Element, Comment, Document
    var cleanableNodeTypesWithDescendants = { 1: true, 9: true }; // Element, Document

    function getDisposeCallbacksCollection(node, createIfNotFound) {
        var allDisposeCallbacks = ko.utils.domData.get(node, domDataKey);
        if ((allDisposeCallbacks === undefined) && createIfNotFound) {
            allDisposeCallbacks = [];
            ko.utils.domData.set(node, domDataKey, allDisposeCallbacks);
        }
        return allDisposeCallbacks;
    }
    function destroyCallbacksCollection(node) {
        ko.utils.domData.set(node, domDataKey, undefined);
    }

    function cleanSingleNode(node) {
        // Run all the dispose callbacks
        var callbacks = getDisposeCallbacksCollection(node, false);
        if (callbacks) {
            callbacks = callbacks.slice(0); // Clone, as the array may be modified during iteration (typically, callbacks will remove themselves)
            for (var i = 0; i < callbacks.length; i++)
                callbacks[i](node);
        }

        // Also erase the DOM data
        ko.utils.domData.clear(node);

        // Special support for jQuery here because it's so commonly used.
        // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData
        // so notify it to tear down any resources associated with the node & descendants here.
        if ((typeof jQuery == "function") && (typeof jQuery['cleanData'] == "function"))
            jQuery['cleanData']([node]);

        // Also clear any immediate-child comment nodes, as these wouldn't have been found by
        // node.getElementsByTagName("*") in cleanNode() (comment nodes aren't elements)
        if (cleanableNodeTypesWithDescendants[node.nodeType])
            cleanImmediateCommentTypeChildren(node);
    }

    function cleanImmediateCommentTypeChildren(nodeWithChildren) {
        var child, nextChild = nodeWithChildren.firstChild;
        while (child = nextChild) {
            nextChild = child.nextSibling;
            if (child.nodeType === 8)
                cleanSingleNode(child);
        }
    }

    return {
        addDisposeCallback : function(node, callback) {
            if (typeof callback != "function")
                throw new Error("Callback must be a function");
            getDisposeCallbacksCollection(node, true).push(callback);
        },

        removeDisposeCallback : function(node, callback) {
            var callbacksCollection = getDisposeCallbacksCollection(node, false);
            if (callbacksCollection) {
                ko.utils.arrayRemoveItem(callbacksCollection, callback);
                if (callbacksCollection.length == 0)
                    destroyCallbacksCollection(node);
            }
        },

        cleanNode : function(node) {
            // First clean this node, where applicable
            if (cleanableNodeTypes[node.nodeType]) {
                cleanSingleNode(node);

                // ... then its descendants, where applicable
                if (cleanableNodeTypesWithDescendants[node.nodeType]) {
                    // Clone the descendants list in case it changes during iteration
                    var descendants = [];
                    ko.utils.arrayPushAll(descendants, node.getElementsByTagName("*"));
                    for (var i = 0, j = descendants.length; i < j; i++)
                        cleanSingleNode(descendants[i]);
                }
            }
            return node;
        },

        removeNode : function(node) {
            ko.cleanNode(node);
            if (node.parentNode)
                node.parentNode.removeChild(node);
        }
    }
})();
ko.cleanNode = ko.utils.domNodeDisposal.cleanNode; // Shorthand name for convenience
ko.removeNode = ko.utils.domNodeDisposal.removeNode; // Shorthand name for convenience
ko.exportSymbol('cleanNode', ko.cleanNode);
ko.exportSymbol('removeNode', ko.removeNode);
ko.exportSymbol('utils.domNodeDisposal', ko.utils.domNodeDisposal);
ko.exportSymbol('utils.domNodeDisposal.addDisposeCallback', ko.utils.domNodeDisposal.addDisposeCallback);
ko.exportSymbol('utils.domNodeDisposal.removeDisposeCallback', ko.utils.domNodeDisposal.removeDisposeCallback);
(function () {
    var leadingCommentRegex = /^(\s*)<!--(.*?)-->/;

    function simpleHtmlParse(html) {
        // Based on jQuery's "clean" function, but only accounting for table-related elements.
        // If you have referenced jQuery, this won't be used anyway - KO will use jQuery's "clean" function directly

        // Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of
        // a descendant node. For example: "<div><!-- mycomment -->abc</div>" will get parsed as "<div>abc</div>"
        // This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node
        // (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.

        // Trim whitespace, otherwise indexOf won't work as expected
        var tags = ko.utils.stringTrim(html).toLowerCase(), div = document.createElement("div");

        // Finds the first match from the left column, and returns the corresponding "wrap" data from the right column
        var wrap = tags.match(/^<(thead|tbody|tfoot)/)              && [1, "<table>", "</table>"] ||
                   !tags.indexOf("<tr")                             && [2, "<table><tbody>", "</tbody></table>"] ||
                   (!tags.indexOf("<td") || !tags.indexOf("<th"))   && [3, "<table><tbody><tr>", "</tr></tbody></table>"] ||
                   /* anything else */                                 [0, "", ""];

        // Go to html and back, then peel off extra wrappers
        // Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.
        var markup = "ignored<div>" + wrap[1] + html + wrap[2] + "</div>";
        if (typeof window['innerShiv'] == "function") {
            div.appendChild(window['innerShiv'](markup));
        } else {
            div.innerHTML = markup;
        }

        // Move to the right depth
        while (wrap[0]--)
            div = div.lastChild;

        return ko.utils.makeArray(div.lastChild.childNodes);
    }

    function jQueryHtmlParse(html) {
        // jQuery's "parseHTML" function was introduced in jQuery 1.8.0 and is a documented public API.
        if (jQuery['parseHTML']) {
            return jQuery['parseHTML'](html);
        } else {
            // For jQuery < 1.8.0, we fall back on the undocumented internal "clean" function.
            var elems = jQuery['clean']([html]);

            // As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.
            // Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.
            // Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.
            if (elems && elems[0]) {
                // Find the top-most parent element that's a direct child of a document fragment
                var elem = elems[0];
                while (elem.parentNode && elem.parentNode.nodeType !== 11 /* i.e., DocumentFragment */)
                    elem = elem.parentNode;
                // ... then detach it
                if (elem.parentNode)
                    elem.parentNode.removeChild(elem);
            }

            return elems;
        }
    }

    ko.utils.parseHtmlFragment = function(html) {
        return typeof jQuery != 'undefined' ? jQueryHtmlParse(html)   // As below, benefit from jQuery's optimisations where possible
                                            : simpleHtmlParse(html);  // ... otherwise, this simple logic will do in most common cases.
    };

    ko.utils.setHtml = function(node, html) {
        ko.utils.emptyDomNode(node);

        // There's no legitimate reason to display a stringified observable without unwrapping it, so we'll unwrap it
        html = ko.utils.unwrapObservable(html);

        if ((html !== null) && (html !== undefined)) {
            if (typeof html != 'string')
                html = html.toString();

            // jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,
            // for example <tr> elements which are not normally allowed to exist on their own.
            // If you've referenced jQuery we'll use that rather than duplicating its code.
            if (typeof jQuery != 'undefined') {
                jQuery(node)['html'](html);
            } else {
                // ... otherwise, use KO's own parsing logic.
                var parsedNodes = ko.utils.parseHtmlFragment(html);
                for (var i = 0; i < parsedNodes.length; i++)
                    node.appendChild(parsedNodes[i]);
            }
        }
    };
})();

ko.exportSymbol('utils.parseHtmlFragment', ko.utils.parseHtmlFragment);
ko.exportSymbol('utils.setHtml', ko.utils.setHtml);

ko.memoization = (function () {
    var memos = {};

    function randomMax8HexChars() {
        return (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1);
    }
    function generateRandomId() {
        return randomMax8HexChars() + randomMax8HexChars();
    }
    function findMemoNodes(rootNode, appendToArray) {
        if (!rootNode)
            return;
        if (rootNode.nodeType == 8) {
            var memoId = ko.memoization.parseMemoText(rootNode.nodeValue);
            if (memoId != null)
                appendToArray.push({ domNode: rootNode, memoId: memoId });
        } else if (rootNode.nodeType == 1) {
            for (var i = 0, childNodes = rootNode.childNodes, j = childNodes.length; i < j; i++)
                findMemoNodes(childNodes[i], appendToArray);
        }
    }

    return {
        memoize: function (callback) {
            if (typeof callback != "function")
                throw new Error("You can only pass a function to ko.memoization.memoize()");
            var memoId = generateRandomId();
            memos[memoId] = callback;
            return "<!--[ko_memo:" + memoId + "]-->";
        },

        unmemoize: function (memoId, callbackParams) {
            var callback = memos[memoId];
            if (callback === undefined)
                throw new Error("Couldn't find any memo with ID " + memoId + ". Perhaps it's already been unmemoized.");
            try {
                callback.apply(null, callbackParams || []);
                return true;
            }
            finally { delete memos[memoId]; }
        },

        unmemoizeDomNodeAndDescendants: function (domNode, extraCallbackParamsArray) {
            var memos = [];
            findMemoNodes(domNode, memos);
            for (var i = 0, j = memos.length; i < j; i++) {
                var node = memos[i].domNode;
                var combinedParams = [node];
                if (extraCallbackParamsArray)
                    ko.utils.arrayPushAll(combinedParams, extraCallbackParamsArray);
                ko.memoization.unmemoize(memos[i].memoId, combinedParams);
                node.nodeValue = ""; // Neuter this node so we don't try to unmemoize it again
                if (node.parentNode)
                    node.parentNode.removeChild(node); // If possible, erase it totally (not always possible - someone else might just hold a reference to it then call unmemoizeDomNodeAndDescendants again)
            }
        },

        parseMemoText: function (memoText) {
            var match = memoText.match(/^\[ko_memo\:(.*?)\]$/);
            return match ? match[1] : null;
        }
    };
})();

ko.exportSymbol('memoization', ko.memoization);
ko.exportSymbol('memoization.memoize', ko.memoization.memoize);
ko.exportSymbol('memoization.unmemoize', ko.memoization.unmemoize);
ko.exportSymbol('memoization.parseMemoText', ko.memoization.parseMemoText);
ko.exportSymbol('memoization.unmemoizeDomNodeAndDescendants', ko.memoization.unmemoizeDomNodeAndDescendants);
ko.extenders = {
    'throttle': function(target, timeout) {
        // Throttling means two things:

        // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies
        //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate
        target['throttleEvaluation'] = timeout;

        // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*
        //     so the target cannot change value synchronously or faster than a certain rate
        var writeTimeoutInstance = null;
        return ko.dependentObservable({
            'read': target,
            'write': function(value) {
                clearTimeout(writeTimeoutInstance);
                writeTimeoutInstance = setTimeout(function() {
                    target(value);
                }, timeout);
            }
        });
    },

    'notify': function(target, notifyWhen) {
        target["equalityComparer"] = notifyWhen == "always"
            ? function() { return false } // Treat all values as not equal
            : ko.observable["fn"]["equalityComparer"];
        return target;
    }
};

function applyExtenders(requestedExtenders) {
    var target = this;
    if (requestedExtenders) {
        for (var key in requestedExtenders) {
            var extenderHandler = ko.extenders[key];
            if (typeof extenderHandler == 'function') {
                target = extenderHandler(target, requestedExtenders[key]);
            }
        }
    }
    return target;
}

ko.exportSymbol('extenders', ko.extenders);

ko.subscription = function (target, callback, disposeCallback) {
    this.target = target;
    this.callback = callback;
    this.disposeCallback = disposeCallback;
    ko.exportProperty(this, 'dispose', this.dispose);
};
ko.subscription.prototype.dispose = function () {
    this.isDisposed = true;
    this.disposeCallback();
};

ko.subscribable = function () {
    this._subscriptions = {};

    ko.utils.extend(this, ko.subscribable['fn']);
    ko.exportProperty(this, 'subscribe', this.subscribe);
    ko.exportProperty(this, 'extend', this.extend);
    ko.exportProperty(this, 'getSubscriptionsCount', this.getSubscriptionsCount);
}

var defaultEvent = "change";

ko.subscribable['fn'] = {
    subscribe: function (callback, callbackTarget, event) {
        event = event || defaultEvent;
        var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback;

        var subscription = new ko.subscription(this, boundCallback, function () {
            ko.utils.arrayRemoveItem(this._subscriptions[event], subscription);
        }.bind(this));

        if (!this._subscriptions[event])
            this._subscriptions[event] = [];
        this._subscriptions[event].push(subscription);
        return subscription;
    },

    "notifySubscribers": function (valueToNotify, event) {
        event = event || defaultEvent;
        if (this._subscriptions[event]) {
            ko.dependencyDetection.ignore(function() {
                ko.utils.arrayForEach(this._subscriptions[event].slice(0), function (subscription) {
                    // In case a subscription was disposed during the arrayForEach cycle, check
                    // for isDisposed on each subscription before invoking its callback
                    if (subscription && (subscription.isDisposed !== true))
                        subscription.callback(valueToNotify);
                });
            }, this);
        }
    },

    getSubscriptionsCount: function () {
        var total = 0;
        for (var eventName in this._subscriptions) {
            if (this._subscriptions.hasOwnProperty(eventName))
                total += this._subscriptions[eventName].length;
        }
        return total;
    },

    extend: applyExtenders
};


ko.isSubscribable = function (instance) {
    return typeof instance.subscribe == "function" && typeof instance["notifySubscribers"] == "function";
};

ko.exportSymbol('subscribable', ko.subscribable);
ko.exportSymbol('isSubscribable', ko.isSubscribable);

ko.dependencyDetection = (function () {
    var _frames = [];

    return {
        begin: function (callback) {
            _frames.push({ callback: callback, distinctDependencies:[] });
        },

        end: function () {
            _frames.pop();
        },

        registerDependency: function (subscribable) {
            if (!ko.isSubscribable(subscribable))
                throw new Error("Only subscribable things can act as dependencies");
            if (_frames.length > 0) {
                var topFrame = _frames[_frames.length - 1];
                if (!topFrame || ko.utils.arrayIndexOf(topFrame.distinctDependencies, subscribable) >= 0)
                    return;
                topFrame.distinctDependencies.push(subscribable);
                topFrame.callback(subscribable);
            }
        },

        ignore: function(callback, callbackTarget, callbackArgs) {
            try {
                _frames.push(null);
                return callback.apply(callbackTarget, callbackArgs || []);
            } finally {
                _frames.pop();
            }
        }
    };
})();
var primitiveTypes = { 'undefined':true, 'boolean':true, 'number':true, 'string':true };

ko.observable = function (initialValue) {
    var _latestValue = initialValue;

    function observable() {
        if (arguments.length > 0) {
            // Write

            // Ignore writes if the value hasn't changed
            if ((!observable['equalityComparer']) || !observable['equalityComparer'](_latestValue, arguments[0])) {
                observable.valueWillMutate();
                _latestValue = arguments[0];
                if (DEBUG) observable._latestValue = _latestValue;
                observable.valueHasMutated();
            }
            return this; // Permits chained assignments
        }
        else {
            // Read
            ko.dependencyDetection.registerDependency(observable); // The caller only needs to be notified of changes if they did a "read" operation
            return _latestValue;
        }
    }
    if (DEBUG) observable._latestValue = _latestValue;
    ko.subscribable.call(observable);
    observable.peek = function() { return _latestValue };
    observable.valueHasMutated = function () { observable["notifySubscribers"](_latestValue); }
    observable.valueWillMutate = function () { observable["notifySubscribers"](_latestValue, "beforeChange"); }
    ko.utils.extend(observable, ko.observable['fn']);

    ko.exportProperty(observable, 'peek', observable.peek);
    ko.exportProperty(observable, "valueHasMutated", observable.valueHasMutated);
    ko.exportProperty(observable, "valueWillMutate", observable.valueWillMutate);

    return observable;
}

ko.observable['fn'] = {
    "equalityComparer": function valuesArePrimitiveAndEqual(a, b) {
        var oldValueIsPrimitive = (a === null) || (typeof(a) in primitiveTypes);
        return oldValueIsPrimitive ? (a === b) : false;
    }
};

var protoProperty = ko.observable.protoProperty = "__ko_proto__";
ko.observable['fn'][protoProperty] = ko.observable;

ko.hasPrototype = function(instance, prototype) {
    if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;
    if (instance[protoProperty] === prototype) return true;
    return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain
};

ko.isObservable = function (instance) {
    return ko.hasPrototype(instance, ko.observable);
}
ko.isWriteableObservable = function (instance) {
    // Observable
    if ((typeof instance == "function") && instance[protoProperty] === ko.observable)
        return true;
    // Writeable dependent observable
    if ((typeof instance == "function") && (instance[protoProperty] === ko.dependentObservable) && (instance.hasWriteFunction))
        return true;
    // Anything else
    return false;
}


ko.exportSymbol('observable', ko.observable);
ko.exportSymbol('isObservable', ko.isObservable);
ko.exportSymbol('isWriteableObservable', ko.isWriteableObservable);
ko.observableArray = function (initialValues) {
    if (arguments.length == 0) {
        // Zero-parameter constructor initializes to empty array
        initialValues = [];
    }
    if ((initialValues !== null) && (initialValues !== undefined) && !('length' in initialValues))
        throw new Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");

    var result = ko.observable(initialValues);
    ko.utils.extend(result, ko.observableArray['fn']);
    return result;
}

ko.observableArray['fn'] = {
    'remove': function (valueOrPredicate) {
        var underlyingArray = this.peek();
        var removedValues = [];
        var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
        for (var i = 0; i < underlyingArray.length; i++) {
            var value = underlyingArray[i];
            if (predicate(value)) {
                if (removedValues.length === 0) {
                    this.valueWillMutate();
                }
                removedValues.push(value);
                underlyingArray.splice(i, 1);
                i--;
            }
        }
        if (removedValues.length) {
            this.valueHasMutated();
        }
        return removedValues;
    },

    'removeAll': function (arrayOfValues) {
        // If you passed zero args, we remove everything
        if (arrayOfValues === undefined) {
            var underlyingArray = this.peek();
            var allValues = underlyingArray.slice(0);
            this.valueWillMutate();
            underlyingArray.splice(0, underlyingArray.length);
            this.valueHasMutated();
            return allValues;
        }
        // If you passed an arg, we interpret it as an array of entries to remove
        if (!arrayOfValues)
            return [];
        return this['remove'](function (value) {
            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
        });
    },

    'destroy': function (valueOrPredicate) {
        var underlyingArray = this.peek();
        var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
        this.valueWillMutate();
        for (var i = underlyingArray.length - 1; i >= 0; i--) {
            var value = underlyingArray[i];
            if (predicate(value))
                underlyingArray[i]["_destroy"] = true;
        }
        this.valueHasMutated();
    },

    'destroyAll': function (arrayOfValues) {
        // If you passed zero args, we destroy everything
        if (arrayOfValues === undefined)
            return this['destroy'](function() { return true });

        // If you passed an arg, we interpret it as an array of entries to destroy
        if (!arrayOfValues)
            return [];
        return this['destroy'](function (value) {
            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
        });
    },

    'indexOf': function (item) {
        var underlyingArray = this();
        return ko.utils.arrayIndexOf(underlyingArray, item);
    },

    'replace': function(oldItem, newItem) {
        var index = this['indexOf'](oldItem);
        if (index >= 0) {
            this.valueWillMutate();
            this.peek()[index] = newItem;
            this.valueHasMutated();
        }
    }
}

// Populate ko.observableArray.fn with read/write functions from native arrays
// Important: Do not add any additional functions here that may reasonably be used to *read* data from the array
// because we'll eval them without causing subscriptions, so ko.computed output could end up getting stale
ko.utils.arrayForEach(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (methodName) {
    ko.observableArray['fn'][methodName] = function () {
        // Use "peek" to avoid creating a subscription in any computed that we're executing in the context of
        // (for consistency with mutating regular observables)
        var underlyingArray = this.peek();
        this.valueWillMutate();
        var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);
        this.valueHasMutated();
        return methodCallResult;
    };
});

// Populate ko.observableArray.fn with read-only functions from native arrays
ko.utils.arrayForEach(["slice"], function (methodName) {
    ko.observableArray['fn'][methodName] = function () {
        var underlyingArray = this();
        return underlyingArray[methodName].apply(underlyingArray, arguments);
    };
});

ko.exportSymbol('observableArray', ko.observableArray);
ko.dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {
    var _latestValue,
        _hasBeenEvaluated = false,
        _isBeingEvaluated = false,
        readFunction = evaluatorFunctionOrOptions;

    if (readFunction && typeof readFunction == "object") {
        // Single-parameter syntax - everything is on this "options" param
        options = readFunction;
        readFunction = options["read"];
    } else {
        // Multi-parameter syntax - construct the options according to the params passed
        options = options || {};
        if (!readFunction)
            readFunction = options["read"];
    }
    if (typeof readFunction != "function")
        throw new Error("Pass a function that returns the value of the ko.computed");

    function addSubscriptionToDependency(subscribable) {
        _subscriptionsToDependencies.push(subscribable.subscribe(evaluatePossiblyAsync));
    }

    function disposeAllSubscriptionsToDependencies() {
        ko.utils.arrayForEach(_subscriptionsToDependencies, function (subscription) {
            subscription.dispose();
        });
        _subscriptionsToDependencies = [];
    }

    function evaluatePossiblyAsync() {
        var throttleEvaluationTimeout = dependentObservable['throttleEvaluation'];
        if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {
            clearTimeout(evaluationTimeoutInstance);
            evaluationTimeoutInstance = setTimeout(evaluateImmediate, throttleEvaluationTimeout);
        } else
            evaluateImmediate();
    }

    function evaluateImmediate() {
        if (_isBeingEvaluated) {
            // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.
            // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost
            // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing
            // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387
            return;
        }

        // Don't dispose on first evaluation, because the "disposeWhen" callback might
        // e.g., dispose when the associated DOM element isn't in the doc, and it's not
        // going to be in the doc until *after* the first evaluation
        if (_hasBeenEvaluated && disposeWhen()) {
            dispose();
            return;
        }

        _isBeingEvaluated = true;
        try {
            // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).
            // Then, during evaluation, we cross off any that are in fact still being used.
            var disposalCandidates = ko.utils.arrayMap(_subscriptionsToDependencies, function(item) {return item.target;});

            ko.dependencyDetection.begin(function(subscribable) {
                var inOld;
                if ((inOld = ko.utils.arrayIndexOf(disposalCandidates, subscribable)) >= 0)
                    disposalCandidates[inOld] = undefined; // Don't want to dispose this subscription, as it's still being used
                else
                    addSubscriptionToDependency(subscribable); // Brand new subscription - add it
            });

            var newValue = readFunction.call(evaluatorFunctionTarget);

            // For each subscription no longer being used, remove it from the active subscriptions list and dispose it
            for (var i = disposalCandidates.length - 1; i >= 0; i--) {
                if (disposalCandidates[i])
                    _subscriptionsToDependencies.splice(i, 1)[0].dispose();
            }
            _hasBeenEvaluated = true;

            dependentObservable["notifySubscribers"](_latestValue, "beforeChange");
            _latestValue = newValue;
            if (DEBUG) dependentObservable._latestValue = _latestValue;
        } finally {
            ko.dependencyDetection.end();
        }

        dependentObservable["notifySubscribers"](_latestValue);
        _isBeingEvaluated = false;
        if (!_subscriptionsToDependencies.length)
            dispose();
    }

    function dependentObservable() {
        if (arguments.length > 0) {
            if (typeof writeFunction === "function") {
                // Writing a value
                writeFunction.apply(evaluatorFunctionTarget, arguments);
            } else {
                throw new Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
            }
            return this; // Permits chained assignments
        } else {
            // Reading the value
            if (!_hasBeenEvaluated)
                evaluateImmediate();
            ko.dependencyDetection.registerDependency(dependentObservable);
            return _latestValue;
        }
    }

    function peek() {
        if (!_hasBeenEvaluated)
            evaluateImmediate();
        return _latestValue;
    }

    function isActive() {
        return !_hasBeenEvaluated || _subscriptionsToDependencies.length > 0;
    }

    // By here, "options" is always non-null
    var writeFunction = options["write"],
        disposeWhenNodeIsRemoved = options["disposeWhenNodeIsRemoved"] || options.disposeWhenNodeIsRemoved || null,
        disposeWhen = options["disposeWhen"] || options.disposeWhen || function() { return false; },
        dispose = disposeAllSubscriptionsToDependencies,
        _subscriptionsToDependencies = [],
        evaluationTimeoutInstance = null;

    if (!evaluatorFunctionTarget)
        evaluatorFunctionTarget = options["owner"];

    dependentObservable.peek = peek;
    dependentObservable.getDependenciesCount = function () { return _subscriptionsToDependencies.length; };
    dependentObservable.hasWriteFunction = typeof options["write"] === "function";
    dependentObservable.dispose = function () { dispose(); };
    dependentObservable.isActive = isActive;

    ko.subscribable.call(dependentObservable);
    ko.utils.extend(dependentObservable, ko.dependentObservable['fn']);

    ko.exportProperty(dependentObservable, 'peek', dependentObservable.peek);
    ko.exportProperty(dependentObservable, 'dispose', dependentObservable.dispose);
    ko.exportProperty(dependentObservable, 'isActive', dependentObservable.isActive);
    ko.exportProperty(dependentObservable, 'getDependenciesCount', dependentObservable.getDependenciesCount);

    // Evaluate, unless deferEvaluation is true
    if (options['deferEvaluation'] !== true)
        evaluateImmediate();

    // Build "disposeWhenNodeIsRemoved" and "disposeWhenNodeIsRemovedCallback" option values.
    // But skip if isActive is false (there will never be any dependencies to dispose).
    // (Note: "disposeWhenNodeIsRemoved" option both proactively disposes as soon as the node is removed using ko.removeNode(),
    // plus adds a "disposeWhen" callback that, on each evaluation, disposes if the node was removed by some other means.)
    if (disposeWhenNodeIsRemoved && isActive()) {
        dispose = function() {
            ko.utils.domNodeDisposal.removeDisposeCallback(disposeWhenNodeIsRemoved, arguments.callee);
            disposeAllSubscriptionsToDependencies();
        };
        ko.utils.domNodeDisposal.addDisposeCallback(disposeWhenNodeIsRemoved, dispose);
        var existingDisposeWhenFunction = disposeWhen;
        disposeWhen = function () {
            return !ko.utils.domNodeIsAttachedToDocument(disposeWhenNodeIsRemoved) || existingDisposeWhenFunction();
        }
    }

    return dependentObservable;
};

ko.isComputed = function(instance) {
    return ko.hasPrototype(instance, ko.dependentObservable);
};

var protoProp = ko.observable.protoProperty; // == "__ko_proto__"
ko.dependentObservable[protoProp] = ko.observable;

ko.dependentObservable['fn'] = {};
ko.dependentObservable['fn'][protoProp] = ko.dependentObservable;

ko.exportSymbol('dependentObservable', ko.dependentObservable);
ko.exportSymbol('computed', ko.dependentObservable); // Make "ko.computed" an alias for "ko.dependentObservable"
ko.exportSymbol('isComputed', ko.isComputed);

(function() {
    var maxNestedObservableDepth = 10; // Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)

    ko.toJS = function(rootObject) {
        if (arguments.length == 0)
            throw new Error("When calling ko.toJS, pass the object you want to convert.");

        // We just unwrap everything at every level in the object graph
        return mapJsObjectGraph(rootObject, function(valueToMap) {
            // Loop because an observable's value might in turn be another observable wrapper
            for (var i = 0; ko.isObservable(valueToMap) && (i < maxNestedObservableDepth); i++)
                valueToMap = valueToMap();
            return valueToMap;
        });
    };

    ko.toJSON = function(rootObject, replacer, space) {     // replacer and space are optional
        var plainJavaScriptObject = ko.toJS(rootObject);
        return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);
    };

    function mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {
        visitedObjects = visitedObjects || new objectLookup();

        rootObject = mapInputCallback(rootObject);
        var canHaveProperties = (typeof rootObject == "object") && (rootObject !== null) && (rootObject !== undefined) && (!(rootObject instanceof Date));
        if (!canHaveProperties)
            return rootObject;

        var outputProperties = rootObject instanceof Array ? [] : {};
        visitedObjects.save(rootObject, outputProperties);

        visitPropertiesOrArrayEntries(rootObject, function(indexer) {
            var propertyValue = mapInputCallback(rootObject[indexer]);

            switch (typeof propertyValue) {
                case "boolean":
                case "number":
                case "string":
                case "function":
                    outputProperties[indexer] = propertyValue;
                    break;
                case "object":
                case "undefined":
                    var previouslyMappedValue = visitedObjects.get(propertyValue);
                    outputProperties[indexer] = (previouslyMappedValue !== undefined)
                        ? previouslyMappedValue
                        : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);
                    break;
            }
        });

        return outputProperties;
    }

    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {
        if (rootObject instanceof Array) {
            for (var i = 0; i < rootObject.length; i++)
                visitorCallback(i);

            // For arrays, also respect toJSON property for custom mappings (fixes #278)
            if (typeof rootObject['toJSON'] == 'function')
                visitorCallback('toJSON');
        } else {
            for (var propertyName in rootObject)
                visitorCallback(propertyName);
        }
    };

    function objectLookup() {
        var keys = [];
        var values = [];
        this.save = function(key, value) {
            var existingIndex = ko.utils.arrayIndexOf(keys, key);
            if (existingIndex >= 0)
                values[existingIndex] = value;
            else {
                keys.push(key);
                values.push(value);
            }
        };
        this.get = function(key) {
            var existingIndex = ko.utils.arrayIndexOf(keys, key);
            return (existingIndex >= 0) ? values[existingIndex] : undefined;
        };
    };
})();

ko.exportSymbol('toJS', ko.toJS);
ko.exportSymbol('toJSON', ko.toJSON);
(function () {
    var hasDomDataExpandoProperty = '__ko__hasDomDataOptionValue__';

    // Normally, SELECT elements and their OPTIONs can only take value of type 'string' (because the values
    // are stored on DOM attributes). ko.selectExtensions provides a way for SELECTs/OPTIONs to have values
    // that are arbitrary objects. This is very convenient when implementing things like cascading dropdowns.
    ko.selectExtensions = {
        readValue : function(element) {
            switch (ko.utils.tagNameLower(element)) {
                case 'option':
                    if (element[hasDomDataExpandoProperty] === true)
                        return ko.utils.domData.get(element, ko.bindingHandlers.options.optionValueDomDataKey);
                    return ko.utils.ieVersion <= 7
                        ? (element.getAttributeNode('value').specified ? element.value : element.text)
                        : element.value;
                case 'select':
                    return element.selectedIndex >= 0 ? ko.selectExtensions.readValue(element.options[element.selectedIndex]) : undefined;
                default:
                    return element.value;
            }
        },

        writeValue: function(element, value) {
            switch (ko.utils.tagNameLower(element)) {
                case 'option':
                    switch(typeof value) {
                        case "string":
                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, undefined);
                            if (hasDomDataExpandoProperty in element) { // IE <= 8 throws errors if you delete non-existent properties from a DOM node
                                delete element[hasDomDataExpandoProperty];
                            }
                            element.value = value;
                            break;
                        default:
                            // Store arbitrary object using DomData
                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, value);
                            element[hasDomDataExpandoProperty] = true;

                            // Special treatment of numbers is just for backward compatibility. KO 1.2.1 wrote numerical values to element.value.
                            element.value = typeof value === "number" ? value : "";
                            break;
                    }
                    break;
                case 'select':
                    for (var i = element.options.length - 1; i >= 0; i--) {
                        if (ko.selectExtensions.readValue(element.options[i]) == value) {
                            element.selectedIndex = i;
                            break;
                        }
                    }
                    break;
                default:
                    if ((value === null) || (value === undefined))
                        value = "";
                    element.value = value;
                    break;
            }
        }
    };
})();

ko.exportSymbol('selectExtensions', ko.selectExtensions);
ko.exportSymbol('selectExtensions.readValue', ko.selectExtensions.readValue);
ko.exportSymbol('selectExtensions.writeValue', ko.selectExtensions.writeValue);
ko.expressionRewriting = (function () {
    var restoreCapturedTokensRegex = /\@ko_token_(\d+)\@/g;
    var javaScriptReservedWords = ["true", "false"];

    // Matches something that can be assigned to--either an isolated identifier or something ending with a property accessor
    // This is designed to be simple and avoid false negatives, but could produce false positives (e.g., a+b.c).
    var javaScriptAssignmentTarget = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i;

    function restoreTokens(string, tokens) {
        var prevValue = null;
        while (string != prevValue) { // Keep restoring tokens until it no longer makes a difference (they may be nested)
            prevValue = string;
            string = string.replace(restoreCapturedTokensRegex, function (match, tokenIndex) {
                return tokens[tokenIndex];
            });
        }
        return string;
    }

    function getWriteableValue(expression) {
        if (ko.utils.arrayIndexOf(javaScriptReservedWords, ko.utils.stringTrim(expression).toLowerCase()) >= 0)
            return false;
        var match = expression.match(javaScriptAssignmentTarget);
        return match === null ? false : match[1] ? ('Object(' + match[1] + ')' + match[2]) : expression;
    }

    function ensureQuoted(key) {
        var trimmedKey = ko.utils.stringTrim(key);
        switch (trimmedKey.length && trimmedKey.charAt(0)) {
            case "'":
            case '"':
                return key;
            default:
                return "'" + trimmedKey + "'";
        }
    }

    return {
        bindingRewriteValidators: [],

        parseObjectLiteral: function(objectLiteralString) {
            // A full tokeniser+lexer would add too much weight to this library, so here's a simple parser
            // that is sufficient just to split an object literal string into a set of top-level key-value pairs

            var str = ko.utils.stringTrim(objectLiteralString);
            if (str.length < 3)
                return [];
            if (str.charAt(0) === "{")// Ignore any braces surrounding the whole object literal
                str = str.substring(1, str.length - 1);

            // Pull out any string literals and regex literals
            var tokens = [];
            var tokenStart = null, tokenEndChar;
            for (var position = 0; position < str.length; position++) {
                var c = str.charAt(position);
                if (tokenStart === null) {
                    switch (c) {
                        case '"':
                        case "'":
                        case "/":
                            tokenStart = position;
                            tokenEndChar = c;
                            break;
                    }
                } else if ((c == tokenEndChar) && (str.charAt(position - 1) !== "\\")) {
                    var token = str.substring(tokenStart, position + 1);
                    tokens.push(token);
                    var replacement = "@ko_token_" + (tokens.length - 1) + "@";
                    str = str.substring(0, tokenStart) + replacement + str.substring(position + 1);
                    position -= (token.length - replacement.length);
                    tokenStart = null;
                }
            }

            // Next pull out balanced paren, brace, and bracket blocks
            tokenStart = null;
            tokenEndChar = null;
            var tokenDepth = 0, tokenStartChar = null;
            for (var position = 0; position < str.length; position++) {
                var c = str.charAt(position);
                if (tokenStart === null) {
                    switch (c) {
                        case "{": tokenStart = position; tokenStartChar = c;
                                  tokenEndChar = "}";
                                  break;
                        case "(": tokenStart = position; tokenStartChar = c;
                                  tokenEndChar = ")";
                                  break;
                        case "[": tokenStart = position; tokenStartChar = c;
                                  tokenEndChar = "]";
                                  break;
                    }
                }

                if (c === tokenStartChar)
                    tokenDepth++;
                else if (c === tokenEndChar) {
                    tokenDepth--;
                    if (tokenDepth === 0) {
                        var token = str.substring(tokenStart, position + 1);
                        tokens.push(token);
                        var replacement = "@ko_token_" + (tokens.length - 1) + "@";
                        str = str.substring(0, tokenStart) + replacement + str.substring(position + 1);
                        position -= (token.length - replacement.length);
                        tokenStart = null;
                    }
                }
            }

            // Now we can safely split on commas to get the key/value pairs
            var result = [];
            var keyValuePairs = str.split(",");
            for (var i = 0, j = keyValuePairs.length; i < j; i++) {
                var pair = keyValuePairs[i];
                var colonPos = pair.indexOf(":");
                if ((colonPos > 0) && (colonPos < pair.length - 1)) {
                    var key = pair.substring(0, colonPos);
                    var value = pair.substring(colonPos + 1);
                    result.push({ 'key': restoreTokens(key, tokens), 'value': restoreTokens(value, tokens) });
                } else {
                    result.push({ 'unknown': restoreTokens(pair, tokens) });
                }
            }
            return result;
        },

        preProcessBindings: function (objectLiteralStringOrKeyValueArray) {
            var keyValueArray = typeof objectLiteralStringOrKeyValueArray === "string"
                ? ko.expressionRewriting.parseObjectLiteral(objectLiteralStringOrKeyValueArray)
                : objectLiteralStringOrKeyValueArray;
            var resultStrings = [], propertyAccessorResultStrings = [];

            var keyValueEntry;
            for (var i = 0; keyValueEntry = keyValueArray[i]; i++) {
                if (resultStrings.length > 0)
                    resultStrings.push(",");

                if (keyValueEntry['key']) {
                    var quotedKey = ensureQuoted(keyValueEntry['key']), val = keyValueEntry['value'];
                    resultStrings.push(quotedKey);
                    resultStrings.push(":");
                    resultStrings.push(val);

                    if (val = getWriteableValue(ko.utils.stringTrim(val))) {
                        if (propertyAccessorResultStrings.length > 0)
                            propertyAccessorResultStrings.push(", ");
                        propertyAccessorResultStrings.push(quotedKey + " : function(__ko_value) { " + val + " = __ko_value; }");
                    }
                } else if (keyValueEntry['unknown']) {
                    resultStrings.push(keyValueEntry['unknown']);
                }
            }

            var combinedResult = resultStrings.join("");
            if (propertyAccessorResultStrings.length > 0) {
                var allPropertyAccessors = propertyAccessorResultStrings.join("");
                combinedResult = combinedResult + ", '_ko_property_writers' : { " + allPropertyAccessors + " } ";
            }

            return combinedResult;
        },

        keyValueArrayContainsKey: function(keyValueArray, key) {
            for (var i = 0; i < keyValueArray.length; i++)
                if (ko.utils.stringTrim(keyValueArray[i]['key']) == key)
                    return true;
            return false;
        },

        // Internal, private KO utility for updating model properties from within bindings
        // property:            If the property being updated is (or might be) an observable, pass it here
        //                      If it turns out to be a writable observable, it will be written to directly
        // allBindingsAccessor: All bindings in the current execution context.
        //                      This will be searched for a '_ko_property_writers' property in case you're writing to a non-observable
        // key:                 The key identifying the property to be written. Example: for { hasFocus: myValue }, write to 'myValue' by specifying the key 'hasFocus'
        // value:               The value to be written
        // checkIfDifferent:    If true, and if the property being written is a writable observable, the value will only be written if
        //                      it is !== existing value on that writable observable
        writeValueToProperty: function(property, allBindingsAccessor, key, value, checkIfDifferent) {
            if (!property || !ko.isWriteableObservable(property)) {
                var propWriters = allBindingsAccessor()['_ko_property_writers'];
                if (propWriters && propWriters[key])
                    propWriters[key](value);
            } else if (!checkIfDifferent || property.peek() !== value) {
                property(value);
            }
        }
    };
})();

ko.exportSymbol('expressionRewriting', ko.expressionRewriting);
ko.exportSymbol('expressionRewriting.bindingRewriteValidators', ko.expressionRewriting.bindingRewriteValidators);
ko.exportSymbol('expressionRewriting.parseObjectLiteral', ko.expressionRewriting.parseObjectLiteral);
ko.exportSymbol('expressionRewriting.preProcessBindings', ko.expressionRewriting.preProcessBindings);

// For backward compatibility, define the following aliases. (Previously, these function names were misleading because
// they referred to JSON specifically, even though they actually work with arbitrary JavaScript object literal expressions.)
ko.exportSymbol('jsonExpressionRewriting', ko.expressionRewriting);
ko.exportSymbol('jsonExpressionRewriting.insertPropertyAccessorsIntoJson', ko.expressionRewriting.preProcessBindings);(function() {
    // "Virtual elements" is an abstraction on top of the usual DOM API which understands the notion that comment nodes
    // may be used to represent hierarchy (in addition to the DOM's natural hierarchy).
    // If you call the DOM-manipulating functions on ko.virtualElements, you will be able to read and write the state
    // of that virtual hierarchy
    //
    // The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)
    // without having to scatter special cases all over the binding and templating code.

    // IE 9 cannot reliably read the "nodeValue" property of a comment node (see https://github.com/SteveSanderson/knockout/issues/186)
    // but it does give them a nonstandard alternative property called "text" that it can read reliably. Other browsers don't have that property.
    // So, use node.text where available, and node.nodeValue elsewhere
    var commentNodesHaveTextProperty = document.createComment("test").text === "<!--test-->";

    var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\s*ko(?:\s+(.+\s*\:[\s\S]*))?\s*-->$/ : /^\s*ko(?:\s+(.+\s*\:[\s\S]*))?\s*$/;
    var endCommentRegex =   commentNodesHaveTextProperty ? /^<!--\s*\/ko\s*-->$/ : /^\s*\/ko\s*$/;
    var htmlTagsWithOptionallyClosingChildren = { 'ul': true, 'ol': true };

    function isStartComment(node) {
        return (node.nodeType == 8) && (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);
    }

    function isEndComment(node) {
        return (node.nodeType == 8) && (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(endCommentRegex);
    }

    function getVirtualChildren(startComment, allowUnbalanced) {
        var currentNode = startComment;
        var depth = 1;
        var children = [];
        while (currentNode = currentNode.nextSibling) {
            if (isEndComment(currentNode)) {
                depth--;
                if (depth === 0)
                    return children;
            }

            children.push(currentNode);

            if (isStartComment(currentNode))
                depth++;
        }
        if (!allowUnbalanced)
            throw new Error("Cannot find closing comment tag to match: " + startComment.nodeValue);
        return null;
    }

    function getMatchingEndComment(startComment, allowUnbalanced) {
        var allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced);
        if (allVirtualChildren) {
            if (allVirtualChildren.length > 0)
                return allVirtualChildren[allVirtualChildren.length - 1].nextSibling;
            return startComment.nextSibling;
        } else
            return null; // Must have no matching end comment, and allowUnbalanced is true
    }

    function getUnbalancedChildTags(node) {
        // e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>
        //       from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko -->
        var childNode = node.firstChild, captureRemaining = null;
        if (childNode) {
            do {
                if (captureRemaining)                   // We already hit an unbalanced node and are now just scooping up all subsequent nodes
                    captureRemaining.push(childNode);
                else if (isStartComment(childNode)) {
                    var matchingEndComment = getMatchingEndComment(childNode, /* allowUnbalanced: */ true);
                    if (matchingEndComment)             // It's a balanced tag, so skip immediately to the end of this virtual set
                        childNode = matchingEndComment;
                    else
                        captureRemaining = [childNode]; // It's unbalanced, so start capturing from this point
                } else if (isEndComment(childNode)) {
                    captureRemaining = [childNode];     // It's unbalanced (if it wasn't, we'd have skipped over it already), so start capturing
                }
            } while (childNode = childNode.nextSibling);
        }
        return captureRemaining;
    }

    ko.virtualElements = {
        allowedBindings: {},

        childNodes: function(node) {
            return isStartComment(node) ? getVirtualChildren(node) : node.childNodes;
        },

        emptyNode: function(node) {
            if (!isStartComment(node))
                ko.utils.emptyDomNode(node);
            else {
                var virtualChildren = ko.virtualElements.childNodes(node);
                for (var i = 0, j = virtualChildren.length; i < j; i++)
                    ko.removeNode(virtualChildren[i]);
            }
        },

        setDomNodeChildren: function(node, childNodes) {
            if (!isStartComment(node))
                ko.utils.setDomNodeChildren(node, childNodes);
            else {
                ko.virtualElements.emptyNode(node);
                var endCommentNode = node.nextSibling; // Must be the next sibling, as we just emptied the children
                for (var i = 0, j = childNodes.length; i < j; i++)
                    endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);
            }
        },

        prepend: function(containerNode, nodeToPrepend) {
            if (!isStartComment(containerNode)) {
                if (containerNode.firstChild)
                    containerNode.insertBefore(nodeToPrepend, containerNode.firstChild);
                else
                    containerNode.appendChild(nodeToPrepend);
            } else {
                // Start comments must always have a parent and at least one following sibling (the end comment)
                containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);
            }
        },

        insertAfter: function(containerNode, nodeToInsert, insertAfterNode) {
            if (!insertAfterNode) {
                ko.virtualElements.prepend(containerNode, nodeToInsert);
            } else if (!isStartComment(containerNode)) {
                // Insert after insertion point
                if (insertAfterNode.nextSibling)
                    containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
                else
                    containerNode.appendChild(nodeToInsert);
            } else {
                // Children of start comments must always have a parent and at least one following sibling (the end comment)
                containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
            }
        },

        firstChild: function(node) {
            if (!isStartComment(node))
                return node.firstChild;
            if (!node.nextSibling || isEndComment(node.nextSibling))
                return null;
            return node.nextSibling;
        },

        nextSibling: function(node) {
            if (isStartComment(node))
                node = getMatchingEndComment(node);
            if (node.nextSibling && isEndComment(node.nextSibling))
                return null;
            return node.nextSibling;
        },

        virtualNodeBindingValue: function(node) {
            var regexMatch = isStartComment(node);
            return regexMatch ? regexMatch[1] : null;
        },

        normaliseVirtualElementDomStructure: function(elementVerified) {
            // Workaround for https://github.com/SteveSanderson/knockout/issues/155
            // (IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist, thereby moving comment nodes
            // that are direct descendants of <ul> into the preceding <li>)
            if (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])
                return;

            // Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags
            // must be intended to appear *after* that child, so move them there.
            var childNode = elementVerified.firstChild;
            if (childNode) {
                do {
                    if (childNode.nodeType === 1) {
                        var unbalancedTags = getUnbalancedChildTags(childNode);
                        if (unbalancedTags) {
                            // Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after* the child
                            var nodeToInsertBefore = childNode.nextSibling;
                            for (var i = 0; i < unbalancedTags.length; i++) {
                                if (nodeToInsertBefore)
                                    elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore);
                                else
                                    elementVerified.appendChild(unbalancedTags[i]);
                            }
                        }
                    }
                } while (childNode = childNode.nextSibling);
            }
        }
    };
})();
ko.exportSymbol('virtualElements', ko.virtualElements);
ko.exportSymbol('virtualElements.allowedBindings', ko.virtualElements.allowedBindings);
ko.exportSymbol('virtualElements.emptyNode', ko.virtualElements.emptyNode);
//ko.exportSymbol('virtualElements.firstChild', ko.virtualElements.firstChild);     // firstChild is not minified
ko.exportSymbol('virtualElements.insertAfter', ko.virtualElements.insertAfter);
//ko.exportSymbol('virtualElements.nextSibling', ko.virtualElements.nextSibling);   // nextSibling is not minified
ko.exportSymbol('virtualElements.prepend', ko.virtualElements.prepend);
ko.exportSymbol('virtualElements.setDomNodeChildren', ko.virtualElements.setDomNodeChildren);
(function() {
    var defaultBindingAttributeName = "data-bind";

    ko.bindingProvider = function() {
        this.bindingCache = {};
    };

    ko.utils.extend(ko.bindingProvider.prototype, {
        'nodeHasBindings': function(node) {
            switch (node.nodeType) {
                case 1: return node.getAttribute(defaultBindingAttributeName) != null;   // Element
                case 8: return ko.virtualElements.virtualNodeBindingValue(node) != null; // Comment node
                default: return false;
            }
        },

        'getBindings': function(node, bindingContext) {
            var bindingsString = this['getBindingsString'](node, bindingContext);
            return bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node) : null;
        },

        // The following function is only used internally by this default provider.
        // It's not part of the interface definition for a general binding provider.
        'getBindingsString': function(node, bindingContext) {
            switch (node.nodeType) {
                case 1: return node.getAttribute(defaultBindingAttributeName);   // Element
                case 8: return ko.virtualElements.virtualNodeBindingValue(node); // Comment node
                default: return null;
            }
        },

        // The following function is only used internally by this default provider.
        // It's not part of the interface definition for a general binding provider.
        'parseBindingsString': function(bindingsString, bindingContext, node) {
            try {
                var bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, this.bindingCache);
                return bindingFunction(bindingContext, node);
            } catch (ex) {
                throw new Error("Unable to parse bindings.\nMessage: " + ex + ";\nBindings value: " + bindingsString);
            }
        }
    });

    ko.bindingProvider['instance'] = new ko.bindingProvider();

    function createBindingsStringEvaluatorViaCache(bindingsString, cache) {
        var cacheKey = bindingsString;
        return cache[cacheKey]
            || (cache[cacheKey] = createBindingsStringEvaluator(bindingsString));
    }

    function createBindingsStringEvaluator(bindingsString) {
        // Build the source for a function that evaluates "expression"
        // For each scope variable, add an extra level of "with" nesting
        // Example result: with(sc1) { with(sc0) { return (expression) } }
        var rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString),
            functionBody = "with($context){with($data||{}){return{" + rewrittenBindings + "}}}";
        return new Function("$context", "$element", functionBody);
    }
})();

ko.exportSymbol('bindingProvider', ko.bindingProvider);
(function () {
    ko.bindingHandlers = {};

    ko.bindingContext = function(dataItem, parentBindingContext, dataItemAlias) {
        if (parentBindingContext) {
            ko.utils.extend(this, parentBindingContext); // Inherit $root and any custom properties
            this['$parentContext'] = parentBindingContext;
            this['$parent'] = parentBindingContext['$data'];
            this['$parents'] = (parentBindingContext['$parents'] || []).slice(0);
            this['$parents'].unshift(this['$parent']);
        } else {
            this['$parents'] = [];
            this['$root'] = dataItem;
            // Export 'ko' in the binding context so it will be available in bindings and templates
            // even if 'ko' isn't exported as a global, such as when using an AMD loader.
            // See https://github.com/SteveSanderson/knockout/issues/490
            this['ko'] = ko;
        }
        this['$data'] = dataItem;
        if (dataItemAlias)
            this[dataItemAlias] = dataItem;
    }
    ko.bindingContext.prototype['createChildContext'] = function (dataItem, dataItemAlias) {
        return new ko.bindingContext(dataItem, this, dataItemAlias);
    };
    ko.bindingContext.prototype['extend'] = function(properties) {
        var clone = ko.utils.extend(new ko.bindingContext(), this);
        return ko.utils.extend(clone, properties);
    };

    function validateThatBindingIsAllowedForVirtualElements(bindingName) {
        var validator = ko.virtualElements.allowedBindings[bindingName];
        if (!validator)
            throw new Error("The binding '" + bindingName + "' cannot be used with virtual elements")
    }

    function applyBindingsToDescendantsInternal (viewModel, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement) {
        var currentChild, nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement);
        while (currentChild = nextInQueue) {
            // Keep a record of the next child *before* applying bindings, in case the binding removes the current child from its position
            nextInQueue = ko.virtualElements.nextSibling(currentChild);
            applyBindingsToNodeAndDescendantsInternal(viewModel, currentChild, bindingContextsMayDifferFromDomParentElement);
        }
    }

    function applyBindingsToNodeAndDescendantsInternal (viewModel, nodeVerified, bindingContextMayDifferFromDomParentElement) {
        var shouldBindDescendants = true;

        // Perf optimisation: Apply bindings only if...
        // (1) We need to store the binding context on this node (because it may differ from the DOM parent node's binding context)
        //     Note that we can't store binding contexts on non-elements (e.g., text nodes), as IE doesn't allow expando properties for those
        // (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)
        var isElement = (nodeVerified.nodeType === 1);
        if (isElement) // Workaround IE <= 8 HTML parsing weirdness
            ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified);

        var shouldApplyBindings = (isElement && bindingContextMayDifferFromDomParentElement)             // Case (1)
                               || ko.bindingProvider['instance']['nodeHasBindings'](nodeVerified);       // Case (2)
        if (shouldApplyBindings)
            shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, null, viewModel, bindingContextMayDifferFromDomParentElement).shouldBindDescendants;

        if (shouldBindDescendants) {
            // We're recursing automatically into (real or virtual) child nodes without changing binding contexts. So,
            //  * For children of a *real* element, the binding context is certainly the same as on their DOM .parentNode,
            //    hence bindingContextsMayDifferFromDomParentElement is false
            //  * For children of a *virtual* element, we can't be sure. Evaluating .parentNode on those children may
            //    skip over any number of intermediate virtual elements, any of which might define a custom binding context,
            //    hence bindingContextsMayDifferFromDomParentElement is true
            applyBindingsToDescendantsInternal(viewModel, nodeVerified, /* bindingContextsMayDifferFromDomParentElement: */ !isElement);
        }
    }

    function applyBindingsToNodeInternal (node, bindings, viewModelOrBindingContext, bindingContextMayDifferFromDomParentElement) {
        // Need to be sure that inits are only run once, and updates never run until all the inits have been run
        var initPhase = 0; // 0 = before all inits, 1 = during inits, 2 = after all inits

        // Each time the dependentObservable is evaluated (after data changes),
        // the binding attribute is reparsed so that it can pick out the correct
        // model properties in the context of the changed data.
        // DOM event callbacks need to be able to access this changed data,
        // so we need a single parsedBindings variable (shared by all callbacks
        // associated with this node's bindings) that all the closures can access.
        var parsedBindings;
        function makeValueAccessor(bindingKey) {
            return function () { return parsedBindings[bindingKey] }
        }
        function parsedBindingsAccessor() {
            return parsedBindings;
        }

        var bindingHandlerThatControlsDescendantBindings;
        ko.dependentObservable(
            function () {
                // Ensure we have a nonnull binding context to work with
                var bindingContextInstance = viewModelOrBindingContext && (viewModelOrBindingContext instanceof ko.bindingContext)
                    ? viewModelOrBindingContext
                    : new ko.bindingContext(ko.utils.unwrapObservable(viewModelOrBindingContext));
                var viewModel = bindingContextInstance['$data'];

                // Optimization: Don't store the binding context on this node if it's definitely the same as on node.parentNode, because
                // we can easily recover it just by scanning up the node's ancestors in the DOM
                // (note: here, parent node means "real DOM parent" not "virtual parent", as there's no O(1) way to find the virtual parent)
                if (bindingContextMayDifferFromDomParentElement)
                    ko.storedBindingContextForNode(node, bindingContextInstance);

                // Use evaluatedBindings if given, otherwise fall back on asking the bindings provider to give us some bindings
                var evaluatedBindings = (typeof bindings == "function") ? bindings(bindingContextInstance, node) : bindings;
                parsedBindings = evaluatedBindings || ko.bindingProvider['instance']['getBindings'](node, bindingContextInstance);

                if (parsedBindings) {
                    // First run all the inits, so bindings can register for notification on changes
                    if (initPhase === 0) {
                        initPhase = 1;
                        for (var bindingKey in parsedBindings) {
                            var binding = ko.bindingHandlers[bindingKey];
                            if (binding && node.nodeType === 8)
                                validateThatBindingIsAllowedForVirtualElements(bindingKey);

                            if (binding && typeof binding["init"] == "function") {
                                var handlerInitFn = binding["init"];
                                var initResult = handlerInitFn(node, makeValueAccessor(bindingKey), parsedBindingsAccessor, viewModel, bindingContextInstance);

                                // If this binding handler claims to control descendant bindings, make a note of this
                                if (initResult && initResult['controlsDescendantBindings']) {
                                    if (bindingHandlerThatControlsDescendantBindings !== undefined)
                                        throw new Error("Multiple bindings (" + bindingHandlerThatControlsDescendantBindings + " and " + bindingKey + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
                                    bindingHandlerThatControlsDescendantBindings = bindingKey;
                                }
                            }
                        }
                        initPhase = 2;
                    }

                    // ... then run all the updates, which might trigger changes even on the first evaluation
                    if (initPhase === 2) {
                        for (var bindingKey in parsedBindings) {
                            var binding = ko.bindingHandlers[bindingKey];
                            if (binding && typeof binding["update"] == "function") {
                                var handlerUpdateFn = binding["update"];
                                handlerUpdateFn(node, makeValueAccessor(bindingKey), parsedBindingsAccessor, viewModel, bindingContextInstance);
                            }
                        }
                    }
                }
            },
            null,
            { disposeWhenNodeIsRemoved : node }
        );

        return {
            shouldBindDescendants: bindingHandlerThatControlsDescendantBindings === undefined
        };
    };

    var storedBindingContextDomDataKey = "__ko_bindingContext__";
    ko.storedBindingContextForNode = function (node, bindingContext) {
        if (arguments.length == 2)
            ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);
        else
            return ko.utils.domData.get(node, storedBindingContextDomDataKey);
    }

    ko.applyBindingsToNode = function (node, bindings, viewModel) {
        if (node.nodeType === 1) // If it's an element, workaround IE <= 8 HTML parsing weirdness
            ko.virtualElements.normaliseVirtualElementDomStructure(node);
        return applyBindingsToNodeInternal(node, bindings, viewModel, true);
    };

    ko.applyBindingsToDescendants = function(viewModel, rootNode) {
        if (rootNode.nodeType === 1 || rootNode.nodeType === 8)
            applyBindingsToDescendantsInternal(viewModel, rootNode, true);
    };

    ko.applyBindings = function (viewModel, rootNode) {
        if (rootNode && (rootNode.nodeType !== 1) && (rootNode.nodeType !== 8))
            throw new Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
        rootNode = rootNode || window.document.body; // Make "rootNode" parameter optional

        applyBindingsToNodeAndDescendantsInternal(viewModel, rootNode, true);
    };

    // Retrieving binding context from arbitrary nodes
    ko.contextFor = function(node) {
        // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)
        switch (node.nodeType) {
            case 1:
            case 8:
                var context = ko.storedBindingContextForNode(node);
                if (context) return context;
                if (node.parentNode) return ko.contextFor(node.parentNode);
                break;
        }
        return undefined;
    };
    ko.dataFor = function(node) {
        var context = ko.contextFor(node);
        return context ? context['$data'] : undefined;
    };

    ko.exportSymbol('bindingHandlers', ko.bindingHandlers);
    ko.exportSymbol('applyBindings', ko.applyBindings);
    ko.exportSymbol('applyBindingsToDescendants', ko.applyBindingsToDescendants);
    ko.exportSymbol('applyBindingsToNode', ko.applyBindingsToNode);
    ko.exportSymbol('contextFor', ko.contextFor);
    ko.exportSymbol('dataFor', ko.dataFor);
})();
var attrHtmlToJavascriptMap = { 'class': 'className', 'for': 'htmlFor' };
ko.bindingHandlers['attr'] = {
    'update': function(element, valueAccessor, allBindingsAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor()) || {};
        for (var attrName in value) {
            if (typeof attrName == "string") {
                var attrValue = ko.utils.unwrapObservable(value[attrName]);

                // To cover cases like "attr: { checked:someProp }", we want to remove the attribute entirely
                // when someProp is a "no value"-like value (strictly null, false, or undefined)
                // (because the absence of the "checked" attr is how to mark an element as not checked, etc.)
                var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);
                if (toRemove)
                    element.removeAttribute(attrName);

                // In IE <= 7 and IE8 Quirks Mode, you have to use the Javascript property name instead of the
                // HTML attribute name for certain attributes. IE8 Standards Mode supports the correct behavior,
                // but instead of figuring out the mode, we'll just set the attribute through the Javascript
                // property for IE <= 8.
                if (ko.utils.ieVersion <= 8 && attrName in attrHtmlToJavascriptMap) {
                    attrName = attrHtmlToJavascriptMap[attrName];
                    if (toRemove)
                        element.removeAttribute(attrName);
                    else
                        element[attrName] = attrValue;
                } else if (!toRemove) {
                    element.setAttribute(attrName, attrValue.toString());
                }

                // Treat "name" specially - although you can think of it as an attribute, it also needs
                // special handling on older versions of IE (https://github.com/SteveSanderson/knockout/pull/333)
                // Deliberately being case-sensitive here because XHTML would regard "Name" as a different thing
                // entirely, and there's no strong reason to allow for such casing in HTML.
                if (attrName === "name") {
                    ko.utils.setElementName(element, toRemove ? "" : attrValue.toString());
                }
            }
        }
    }
};
ko.bindingHandlers['checked'] = {
    'init': function (element, valueAccessor, allBindingsAccessor) {
        var updateHandler = function() {
            var valueToWrite;
            if (element.type == "checkbox") {
                valueToWrite = element.checked;
            } else if ((element.type == "radio") && (element.checked)) {
                valueToWrite = element.value;
            } else {
                return; // "checked" binding only responds to checkboxes and selected radio buttons
            }

            var modelValue = valueAccessor(), unwrappedValue = ko.utils.unwrapObservable(modelValue);
            if ((element.type == "checkbox") && (unwrappedValue instanceof Array)) {
                // For checkboxes bound to an array, we add/remove the checkbox value to that array
                // This works for both observable and non-observable arrays
                var existingEntryIndex = ko.utils.arrayIndexOf(unwrappedValue, element.value);
                if (element.checked && (existingEntryIndex < 0))
                    modelValue.push(element.value);
                else if ((!element.checked) && (existingEntryIndex >= 0))
                    modelValue.splice(existingEntryIndex, 1);
            } else {
                ko.expressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'checked', valueToWrite, true);
            }
        };
        ko.utils.registerEventHandler(element, "click", updateHandler);

        // IE 6 won't allow radio buttons to be selected unless they have a name
        if ((element.type == "radio") && !element.name)
            ko.bindingHandlers['uniqueName']['init'](element, function() { return true });
    },
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());

        if (element.type == "checkbox") {
            if (value instanceof Array) {
                // When bound to an array, the checkbox being checked represents its value being present in that array
                element.checked = ko.utils.arrayIndexOf(value, element.value) >= 0;
            } else {
                // When bound to anything other value (not an array), the checkbox being checked represents the value being trueish
                element.checked = value;
            }
        } else if (element.type == "radio") {
            element.checked = (element.value == value);
        }
    }
};
var classesWrittenByBindingKey = '__ko__cssValue';
ko.bindingHandlers['css'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        if (typeof value == "object") {
            for (var className in value) {
                var shouldHaveClass = ko.utils.unwrapObservable(value[className]);
                ko.utils.toggleDomNodeCssClass(element, className, shouldHaveClass);
            }
        } else {
            value = String(value || ''); // Make sure we don't try to store or set a non-string value
            ko.utils.toggleDomNodeCssClass(element, element[classesWrittenByBindingKey], false);
            element[classesWrittenByBindingKey] = value;
            ko.utils.toggleDomNodeCssClass(element, value, true);
        }
    }
};
ko.bindingHandlers['enable'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        if (value && element.disabled)
            element.removeAttribute("disabled");
        else if ((!value) && (!element.disabled))
            element.disabled = true;
    }
};

ko.bindingHandlers['disable'] = {
    'update': function (element, valueAccessor) {
        ko.bindingHandlers['enable']['update'](element, function() { return !ko.utils.unwrapObservable(valueAccessor()) });
    }
};
// For certain common events (currently just 'click'), allow a simplified data-binding syntax
// e.g. click:handler instead of the usual full-length event:{click:handler}
function makeEventHandlerShortcut(eventName) {
    ko.bindingHandlers[eventName] = {
        'init': function(element, valueAccessor, allBindingsAccessor, viewModel) {
            var newValueAccessor = function () {
                var result = {};
                result[eventName] = valueAccessor();
                return result;
            };
            return ko.bindingHandlers['event']['init'].call(this, element, newValueAccessor, allBindingsAccessor, viewModel);
        }
    }
}

ko.bindingHandlers['event'] = {
    'init' : function (element, valueAccessor, allBindingsAccessor, viewModel) {
        var eventsToHandle = valueAccessor() || {};
        for(var eventNameOutsideClosure in eventsToHandle) {
            (function() {
                var eventName = eventNameOutsideClosure; // Separate variable to be captured by event handler closure
                if (typeof eventName == "string") {
                    ko.utils.registerEventHandler(element, eventName, function (event) {
                        var handlerReturnValue;
                        var handlerFunction = valueAccessor()[eventName];
                        if (!handlerFunction)
                            return;
                        var allBindings = allBindingsAccessor();

                        try {
                            // Take all the event args, and prefix with the viewmodel
                            var argsForHandler = ko.utils.makeArray(arguments);
                            argsForHandler.unshift(viewModel);
                            handlerReturnValue = handlerFunction.apply(viewModel, argsForHandler);
                        } finally {
                            if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
                                if (event.preventDefault)
                                    event.preventDefault();
                                else
                                    event.returnValue = false;
                            }
                        }

                        var bubble = allBindings[eventName + 'Bubble'] !== false;
                        if (!bubble) {
                            event.cancelBubble = true;
                            if (event.stopPropagation)
                                event.stopPropagation();
                        }
                    });
                }
            })();
        }
    }
};
// "foreach: someExpression" is equivalent to "template: { foreach: someExpression }"
// "foreach: { data: someExpression, afterAdd: myfn }" is equivalent to "template: { foreach: someExpression, afterAdd: myfn }"
ko.bindingHandlers['foreach'] = {
    makeTemplateValueAccessor: function(valueAccessor) {
        return function() {
            var modelValue = valueAccessor(),
                unwrappedValue = ko.utils.peekObservable(modelValue);    // Unwrap without setting a dependency here

            // If unwrappedValue is the array, pass in the wrapped value on its own
            // The value will be unwrapped and tracked within the template binding
            // (See https://github.com/SteveSanderson/knockout/issues/523)
            if ((!unwrappedValue) || typeof unwrappedValue.length == "number")
                return { 'foreach': modelValue, 'templateEngine': ko.nativeTemplateEngine.instance };

            // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates
            ko.utils.unwrapObservable(modelValue);
            return {
                'foreach': unwrappedValue['data'],
                'as': unwrappedValue['as'],
                'includeDestroyed': unwrappedValue['includeDestroyed'],
                'afterAdd': unwrappedValue['afterAdd'],
                'beforeRemove': unwrappedValue['beforeRemove'],
                'afterRender': unwrappedValue['afterRender'],
                'beforeMove': unwrappedValue['beforeMove'],
                'afterMove': unwrappedValue['afterMove'],
                'templateEngine': ko.nativeTemplateEngine.instance
            };
        };
    },
    'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor));
    },
    'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor), allBindingsAccessor, viewModel, bindingContext);
    }
};
ko.expressionRewriting.bindingRewriteValidators['foreach'] = false; // Can't rewrite control flow bindings
ko.virtualElements.allowedBindings['foreach'] = true;
var hasfocusUpdatingProperty = '__ko_hasfocusUpdating';
ko.bindingHandlers['hasfocus'] = {
    'init': function(element, valueAccessor, allBindingsAccessor) {
        var handleElementFocusChange = function(isFocused) {
            // Where possible, ignore which event was raised and determine focus state using activeElement,
            // as this avoids phantom focus/blur events raised when changing tabs in modern browsers.
            // However, not all KO-targeted browsers (Firefox 2) support activeElement. For those browsers,
            // prevent a loss of focus when changing tabs/windows by setting a flag that prevents hasfocus
            // from calling 'blur()' on the element when it loses focus.
            // Discussion at https://github.com/SteveSanderson/knockout/pull/352
            element[hasfocusUpdatingProperty] = true;
            var ownerDoc = element.ownerDocument;
            if ("activeElement" in ownerDoc) {
                isFocused = (ownerDoc.activeElement === element);
            }
            var modelValue = valueAccessor();
            ko.expressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'hasfocus', isFocused, true);
            element[hasfocusUpdatingProperty] = false;
        };
        var handleElementFocusIn = handleElementFocusChange.bind(null, true);
        var handleElementFocusOut = handleElementFocusChange.bind(null, false);

        ko.utils.registerEventHandler(element, "focus", handleElementFocusIn);
        ko.utils.registerEventHandler(element, "focusin", handleElementFocusIn); // For IE
        ko.utils.registerEventHandler(element, "blur",  handleElementFocusOut);
        ko.utils.registerEventHandler(element, "focusout",  handleElementFocusOut); // For IE
    },
    'update': function(element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        if (!element[hasfocusUpdatingProperty]) {
            value ? element.focus() : element.blur();
            ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, value ? "focusin" : "focusout"]); // For IE, which doesn't reliably fire "focus" or "blur" events synchronously
        }
    }
};
ko.bindingHandlers['html'] = {
    'init': function() {
        // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)
        return { 'controlsDescendantBindings': true };
    },
    'update': function (element, valueAccessor) {
        // setHtml will unwrap the value if needed
        ko.utils.setHtml(element, valueAccessor());
    }
};
var withIfDomDataKey = '__ko_withIfBindingData';
// Makes a binding like with or if
function makeWithIfBinding(bindingKey, isWith, isNot, makeContextCallback) {
    ko.bindingHandlers[bindingKey] = {
        'init': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            ko.utils.domData.set(element, withIfDomDataKey, {});
            return { 'controlsDescendantBindings': true };
        },
        'update': function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            var withIfData = ko.utils.domData.get(element, withIfDomDataKey),
                dataValue = ko.utils.unwrapObservable(valueAccessor()),
                shouldDisplay = !isNot !== !dataValue, // equivalent to isNot ? !dataValue : !!dataValue
                isFirstRender = !withIfData.savedNodes,
                needsRefresh = isFirstRender || isWith || (shouldDisplay !== withIfData.didDisplayOnLastUpdate);

            if (needsRefresh) {
                if (isFirstRender) {
                    withIfData.savedNodes = ko.utils.cloneNodes(ko.virtualElements.childNodes(element), true /* shouldCleanNodes */);
                }

                if (shouldDisplay) {
                    if (!isFirstRender) {
                        ko.virtualElements.setDomNodeChildren(element, ko.utils.cloneNodes(withIfData.savedNodes));
                    }
                    ko.applyBindingsToDescendants(makeContextCallback ? makeContextCallback(bindingContext, dataValue) : bindingContext, element);
                } else {
                    ko.virtualElements.emptyNode(element);
                }

                withIfData.didDisplayOnLastUpdate = shouldDisplay;
            }
        }
    };
    ko.expressionRewriting.bindingRewriteValidators[bindingKey] = false; // Can't rewrite control flow bindings
    ko.virtualElements.allowedBindings[bindingKey] = true;
}

// Construct the actual binding handlers
makeWithIfBinding('if');
makeWithIfBinding('ifnot', false /* isWith */, true /* isNot */);
makeWithIfBinding('with', true /* isWith */, false /* isNot */,
    function(bindingContext, dataValue) {
        return bindingContext['createChildContext'](dataValue);
    }
);
function ensureDropdownSelectionIsConsistentWithModelValue(element, modelValue, preferModelValue) {
    if (preferModelValue) {
        if (modelValue !== ko.selectExtensions.readValue(element))
            ko.selectExtensions.writeValue(element, modelValue);
    }

    // No matter which direction we're syncing in, we want the end result to be equality between dropdown value and model value.
    // If they aren't equal, either we prefer the dropdown value, or the model value couldn't be represented, so either way,
    // change the model value to match the dropdown.
    if (modelValue !== ko.selectExtensions.readValue(element))
        ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, "change"]);
};

ko.bindingHandlers['options'] = {
    'update': function (element, valueAccessor, allBindingsAccessor) {
        if (ko.utils.tagNameLower(element) !== "select")
            throw new Error("options binding applies only to SELECT elements");

        var selectWasPreviouslyEmpty = element.length == 0;
        var previousSelectedValues = ko.utils.arrayMap(ko.utils.arrayFilter(element.childNodes, function (node) {
            return node.tagName && (ko.utils.tagNameLower(node) === "option") && node.selected;
        }), function (node) {
            return ko.selectExtensions.readValue(node) || node.innerText || node.textContent;
        });
        var previousScrollTop = element.scrollTop;

        var value = ko.utils.unwrapObservable(valueAccessor());
        var selectedValue = element.value;

        // Remove all existing <option>s.
        // Need to use .remove() rather than .removeChild() for <option>s otherwise IE behaves oddly (https://github.com/SteveSanderson/knockout/issues/134)
        while (element.length > 0) {
            ko.cleanNode(element.options[0]);
            element.remove(0);
        }

        if (value) {
            var allBindings = allBindingsAccessor(),
                includeDestroyed = allBindings['optionsIncludeDestroyed'];

            if (typeof value.length != "number")
                value = [value];
            if (allBindings['optionsCaption']) {
                var option = document.createElement("option");
                ko.utils.setHtml(option, allBindings['optionsCaption']);
                ko.selectExtensions.writeValue(option, undefined);
                element.appendChild(option);
            }

            for (var i = 0, j = value.length; i < j; i++) {
                // Skip destroyed items
                var arrayEntry = value[i];
                if (arrayEntry && arrayEntry['_destroy'] && !includeDestroyed)
                    continue;

                var option = document.createElement("option");

                function applyToObject(object, predicate, defaultValue) {
                    var predicateType = typeof predicate;
                    if (predicateType == "function")    // Given a function; run it against the data value
                        return predicate(object);
                    else if (predicateType == "string") // Given a string; treat it as a property name on the data value
                        return object[predicate];
                    else                                // Given no optionsText arg; use the data value itself
                        return defaultValue;
                }

                // Apply a value to the option element
                var optionValue = applyToObject(arrayEntry, allBindings['optionsValue'], arrayEntry);
                ko.selectExtensions.writeValue(option, ko.utils.unwrapObservable(optionValue));

                // Apply some text to the option element
                var optionText = applyToObject(arrayEntry, allBindings['optionsText'], optionValue);
                ko.utils.setTextContent(option, optionText);

                element.appendChild(option);
            }

            // IE6 doesn't like us to assign selection to OPTION nodes before they're added to the document.
            // That's why we first added them without selection. Now it's time to set the selection.
            var newOptions = element.getElementsByTagName("option");
            var countSelectionsRetained = 0;
            for (var i = 0, j = newOptions.length; i < j; i++) {
                if (ko.utils.arrayIndexOf(previousSelectedValues, ko.selectExtensions.readValue(newOptions[i])) >= 0) {
                    ko.utils.setOptionNodeSelectionState(newOptions[i], true);
                    countSelectionsRetained++;
                }
            }

            element.scrollTop = previousScrollTop;

            if (selectWasPreviouslyEmpty && ('value' in allBindings)) {
                // Ensure consistency between model value and selected option.
                // If the dropdown is being populated for the first time here (or was otherwise previously empty),
                // the dropdown selection state is meaningless, so we preserve the model value.
                ensureDropdownSelectionIsConsistentWithModelValue(element, ko.utils.peekObservable(allBindings['value']), /* preferModelValue */ true);
            }

            // Workaround for IE9 bug
            ko.utils.ensureSelectElementIsRenderedCorrectly(element);
        }
    }
};
ko.bindingHandlers['options'].optionValueDomDataKey = '__ko.optionValueDomData__';
ko.bindingHandlers['selectedOptions'] = {
    'init': function (element, valueAccessor, allBindingsAccessor) {
        ko.utils.registerEventHandler(element, "change", function () {
            var value = valueAccessor(), valueToWrite = [];
            ko.utils.arrayForEach(element.getElementsByTagName("option"), function(node) {
                if (node.selected)
                    valueToWrite.push(ko.selectExtensions.readValue(node));
            });
            ko.expressionRewriting.writeValueToProperty(value, allBindingsAccessor, 'value', valueToWrite);
        });
    },
    'update': function (element, valueAccessor) {
        if (ko.utils.tagNameLower(element) != "select")
            throw new Error("values binding applies only to SELECT elements");

        var newValue = ko.utils.unwrapObservable(valueAccessor());
        if (newValue && typeof newValue.length == "number") {
            ko.utils.arrayForEach(element.getElementsByTagName("option"), function(node) {
                var isSelected = ko.utils.arrayIndexOf(newValue, ko.selectExtensions.readValue(node)) >= 0;
                ko.utils.setOptionNodeSelectionState(node, isSelected);
            });
        }
    }
};
ko.bindingHandlers['style'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor() || {});
        for (var styleName in value) {
            if (typeof styleName == "string") {
                var styleValue = ko.utils.unwrapObservable(value[styleName]);
                element.style[styleName] = styleValue || ""; // Empty string removes the value, whereas null/undefined have no effect
            }
        }
    }
};
ko.bindingHandlers['submit'] = {
    'init': function (element, valueAccessor, allBindingsAccessor, viewModel) {
        if (typeof valueAccessor() != "function")
            throw new Error("The value for a submit binding must be a function");
        ko.utils.registerEventHandler(element, "submit", function (event) {
            var handlerReturnValue;
            var value = valueAccessor();
            try { handlerReturnValue = value.call(viewModel, element); }
            finally {
                if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
                    if (event.preventDefault)
                        event.preventDefault();
                    else
                        event.returnValue = false;
                }
            }
        });
    }
};
ko.bindingHandlers['text'] = {
    'update': function (element, valueAccessor) {
        ko.utils.setTextContent(element, valueAccessor());
    }
};
ko.virtualElements.allowedBindings['text'] = true;
ko.bindingHandlers['uniqueName'] = {
    'init': function (element, valueAccessor) {
        if (valueAccessor()) {
            var name = "ko_unique_" + (++ko.bindingHandlers['uniqueName'].currentIndex);
            ko.utils.setElementName(element, name);
        }
    }
};
ko.bindingHandlers['uniqueName'].currentIndex = 0;
ko.bindingHandlers['value'] = {
    'init': function (element, valueAccessor, allBindingsAccessor) {
        // Always catch "change" event; possibly other events too if asked
        var eventsToCatch = ["change"];
        var requestedEventsToCatch = allBindingsAccessor()["valueUpdate"];
        var propertyChangedFired = false;
        if (requestedEventsToCatch) {
            if (typeof requestedEventsToCatch == "string") // Allow both individual event names, and arrays of event names
                requestedEventsToCatch = [requestedEventsToCatch];
            ko.utils.arrayPushAll(eventsToCatch, requestedEventsToCatch);
            eventsToCatch = ko.utils.arrayGetDistinctValues(eventsToCatch);
        }

        var valueUpdateHandler = function() {
            propertyChangedFired = false;
            var modelValue = valueAccessor();
            var elementValue = ko.selectExtensions.readValue(element);
            ko.expressionRewriting.writeValueToProperty(modelValue, allBindingsAccessor, 'value', elementValue);
        }

        // Workaround for https://github.com/SteveSanderson/knockout/issues/122
        // IE doesn't fire "change" events on textboxes if the user selects a value from its autocomplete list
        var ieAutoCompleteHackNeeded = ko.utils.ieVersion && element.tagName.toLowerCase() == "input" && element.type == "text"
                                       && element.autocomplete != "off" && (!element.form || element.form.autocomplete != "off");
        if (ieAutoCompleteHackNeeded && ko.utils.arrayIndexOf(eventsToCatch, "propertychange") == -1) {
            ko.utils.registerEventHandler(element, "propertychange", function () { propertyChangedFired = true });
            ko.utils.registerEventHandler(element, "blur", function() {
                if (propertyChangedFired) {
                    valueUpdateHandler();
                }
            });
        }

        ko.utils.arrayForEach(eventsToCatch, function(eventName) {
            // The syntax "after<eventname>" means "run the handler asynchronously after the event"
            // This is useful, for example, to catch "keydown" events after the browser has updated the control
            // (otherwise, ko.selectExtensions.readValue(this) will receive the control's value *before* the key event)
            var handler = valueUpdateHandler;
            if (ko.utils.stringStartsWith(eventName, "after")) {
                handler = function() { setTimeout(valueUpdateHandler, 0) };
                eventName = eventName.substring("after".length);
            }
            ko.utils.registerEventHandler(element, eventName, handler);
        });
    },
    'update': function (element, valueAccessor) {
        var valueIsSelectOption = ko.utils.tagNameLower(element) === "select";
        var newValue = ko.utils.unwrapObservable(valueAccessor());
        var elementValue = ko.selectExtensions.readValue(element);
        var valueHasChanged = (newValue != elementValue);

        // JavaScript's 0 == "" behavious is unfortunate here as it prevents writing 0 to an empty text box (loose equality suggests the values are the same).
        // We don't want to do a strict equality comparison as that is more confusing for developers in certain cases, so we specifically special case 0 != "" here.
        if ((newValue === 0) && (elementValue !== 0) && (elementValue !== "0"))
            valueHasChanged = true;

        if (valueHasChanged) {
            var applyValueAction = function () { ko.selectExtensions.writeValue(element, newValue); };
            applyValueAction();

            // Workaround for IE6 bug: It won't reliably apply values to SELECT nodes during the same execution thread
            // right after you've changed the set of OPTION nodes on it. So for that node type, we'll schedule a second thread
            // to apply the value as well.
            var alsoApplyAsynchronously = valueIsSelectOption;
            if (alsoApplyAsynchronously)
                setTimeout(applyValueAction, 0);
        }

        // If you try to set a model value that can't be represented in an already-populated dropdown, reject that change,
        // because you're not allowed to have a model value that disagrees with a visible UI selection.
        if (valueIsSelectOption && (element.length > 0))
            ensureDropdownSelectionIsConsistentWithModelValue(element, newValue, /* preferModelValue */ false);
    }
};
ko.bindingHandlers['visible'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        var isCurrentlyVisible = !(element.style.display == "none");
        if (value && !isCurrentlyVisible)
            element.style.display = "";
        else if ((!value) && isCurrentlyVisible)
            element.style.display = "none";
    }
};
// 'click' is just a shorthand for the usual full-length event:{click:handler}
makeEventHandlerShortcut('click');
// If you want to make a custom template engine,
//
// [1] Inherit from this class (like ko.nativeTemplateEngine does)
// [2] Override 'renderTemplateSource', supplying a function with this signature:
//
//        function (templateSource, bindingContext, options) {
//            // - templateSource.text() is the text of the template you should render
//            // - bindingContext.$data is the data you should pass into the template
//            //   - you might also want to make bindingContext.$parent, bindingContext.$parents,
//            //     and bindingContext.$root available in the template too
//            // - options gives you access to any other properties set on "data-bind: { template: options }"
//            //
//            // Return value: an array of DOM nodes
//        }
//
// [3] Override 'createJavaScriptEvaluatorBlock', supplying a function with this signature:
//
//        function (script) {
//            // Return value: Whatever syntax means "Evaluate the JavaScript statement 'script' and output the result"
//            //               For example, the jquery.tmpl template engine converts 'someScript' to '${ someScript }'
//        }
//
//     This is only necessary if you want to allow data-bind attributes to reference arbitrary template variables.
//     If you don't want to allow that, you can set the property 'allowTemplateRewriting' to false (like ko.nativeTemplateEngine does)
//     and then you don't need to override 'createJavaScriptEvaluatorBlock'.

ko.templateEngine = function () { };

ko.templateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options) {
    throw new Error("Override renderTemplateSource");
};

ko.templateEngine.prototype['createJavaScriptEvaluatorBlock'] = function (script) {
    throw new Error("Override createJavaScriptEvaluatorBlock");
};

ko.templateEngine.prototype['makeTemplateSource'] = function(template, templateDocument) {
    // Named template
    if (typeof template == "string") {
        templateDocument = templateDocument || document;
        var elem = templateDocument.getElementById(template);
        if (!elem)
            throw new Error("Cannot find template with ID " + template);
        return new ko.templateSources.domElement(elem);
    } else if ((template.nodeType == 1) || (template.nodeType == 8)) {
        // Anonymous template
        return new ko.templateSources.anonymousTemplate(template);
    } else
        throw new Error("Unknown template type: " + template);
};

ko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) {
    var templateSource = this['makeTemplateSource'](template, templateDocument);
    return this['renderTemplateSource'](templateSource, bindingContext, options);
};

ko.templateEngine.prototype['isTemplateRewritten'] = function (template, templateDocument) {
    // Skip rewriting if requested
    if (this['allowTemplateRewriting'] === false)
        return true;
    return this['makeTemplateSource'](template, templateDocument)['data']("isRewritten");
};

ko.templateEngine.prototype['rewriteTemplate'] = function (template, rewriterCallback, templateDocument) {
    var templateSource = this['makeTemplateSource'](template, templateDocument);
    var rewritten = rewriterCallback(templateSource['text']());
    templateSource['text'](rewritten);
    templateSource['data']("isRewritten", true);
};

ko.exportSymbol('templateEngine', ko.templateEngine);

ko.templateRewriting = (function () {
    var memoizeDataBindingAttributeSyntaxRegex = /(<[a-z]+\d*(\s+(?!data-bind=)[a-z0-9\-]+(=(\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind=(["'])([\s\S]*?)\5/gi;
    var memoizeVirtualContainerBindingSyntaxRegex = /<!--\s*ko\b\s*([\s\S]*?)\s*-->/g;

    function validateDataBindValuesForRewriting(keyValueArray) {
        var allValidators = ko.expressionRewriting.bindingRewriteValidators;
        for (var i = 0; i < keyValueArray.length; i++) {
            var key = keyValueArray[i]['key'];
            if (allValidators.hasOwnProperty(key)) {
                var validator = allValidators[key];

                if (typeof validator === "function") {
                    var possibleErrorMessage = validator(keyValueArray[i]['value']);
                    if (possibleErrorMessage)
                        throw new Error(possibleErrorMessage);
                } else if (!validator) {
                    throw new Error("This template engine does not support the '" + key + "' binding within its templates");
                }
            }
        }
    }

    function constructMemoizedTagReplacement(dataBindAttributeValue, tagToRetain, templateEngine) {
        var dataBindKeyValueArray = ko.expressionRewriting.parseObjectLiteral(dataBindAttributeValue);
        validateDataBindValuesForRewriting(dataBindKeyValueArray);
        var rewrittenDataBindAttributeValue = ko.expressionRewriting.preProcessBindings(dataBindKeyValueArray);

        // For no obvious reason, Opera fails to evaluate rewrittenDataBindAttributeValue unless it's wrapped in an additional
        // anonymous function, even though Opera's built-in debugger can evaluate it anyway. No other browser requires this
        // extra indirection.
        var applyBindingsToNextSiblingScript =
            "ko.__tr_ambtns(function($context,$element){return(function(){return{ " + rewrittenDataBindAttributeValue + " } })()})";
        return templateEngine['createJavaScriptEvaluatorBlock'](applyBindingsToNextSiblingScript) + tagToRetain;
    }

    return {
        ensureTemplateIsRewritten: function (template, templateEngine, templateDocument) {
            if (!templateEngine['isTemplateRewritten'](template, templateDocument))
                templateEngine['rewriteTemplate'](template, function (htmlString) {
                    return ko.templateRewriting.memoizeBindingAttributeSyntax(htmlString, templateEngine);
                }, templateDocument);
        },

        memoizeBindingAttributeSyntax: function (htmlString, templateEngine) {
            return htmlString.replace(memoizeDataBindingAttributeSyntaxRegex, function () {
                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[6], /* tagToRetain: */ arguments[1], templateEngine);
            }).replace(memoizeVirtualContainerBindingSyntaxRegex, function() {
                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[1], /* tagToRetain: */ "<!-- ko -->", templateEngine);
            });
        },

        applyMemoizedBindingsToNextSibling: function (bindings) {
            return ko.memoization.memoize(function (domNode, bindingContext) {
                if (domNode.nextSibling)
                    ko.applyBindingsToNode(domNode.nextSibling, bindings, bindingContext);
            });
        }
    }
})();


// Exported only because it has to be referenced by string lookup from within rewritten template
ko.exportSymbol('__tr_ambtns', ko.templateRewriting.applyMemoizedBindingsToNextSibling);
(function() {
    // A template source represents a read/write way of accessing a template. This is to eliminate the need for template loading/saving
    // logic to be duplicated in every template engine (and means they can all work with anonymous templates, etc.)
    //
    // Two are provided by default:
    //  1. ko.templateSources.domElement       - reads/writes the text content of an arbitrary DOM element
    //  2. ko.templateSources.anonymousElement - uses ko.utils.domData to read/write text *associated* with the DOM element, but
    //                                           without reading/writing the actual element text content, since it will be overwritten
    //                                           with the rendered template output.
    // You can implement your own template source if you want to fetch/store templates somewhere other than in DOM elements.
    // Template sources need to have the following functions:
    //   text() 			- returns the template text from your storage location
    //   text(value)		- writes the supplied template text to your storage location
    //   data(key)			- reads values stored using data(key, value) - see below
    //   data(key, value)	- associates "value" with this template and the key "key". Is used to store information like "isRewritten".
    //
    // Optionally, template sources can also have the following functions:
    //   nodes()            - returns a DOM element containing the nodes of this template, where available
    //   nodes(value)       - writes the given DOM element to your storage location
    // If a DOM element is available for a given template source, template engines are encouraged to use it in preference over text()
    // for improved speed. However, all templateSources must supply text() even if they don't supply nodes().
    //
    // Once you've implemented a templateSource, make your template engine use it by subclassing whatever template engine you were
    // using and overriding "makeTemplateSource" to return an instance of your custom template source.

    ko.templateSources = {};

    // ---- ko.templateSources.domElement -----

    ko.templateSources.domElement = function(element) {
        this.domElement = element;
    }

    ko.templateSources.domElement.prototype['text'] = function(/* valueToWrite */) {
        var tagNameLower = ko.utils.tagNameLower(this.domElement),
            elemContentsProperty = tagNameLower === "script" ? "text"
                                 : tagNameLower === "textarea" ? "value"
                                 : "innerHTML";

        if (arguments.length == 0) {
            return this.domElement[elemContentsProperty];
        } else {
            var valueToWrite = arguments[0];
            if (elemContentsProperty === "innerHTML")
                ko.utils.setHtml(this.domElement, valueToWrite);
            else
                this.domElement[elemContentsProperty] = valueToWrite;
        }
    };

    ko.templateSources.domElement.prototype['data'] = function(key /*, valueToWrite */) {
        if (arguments.length === 1) {
            return ko.utils.domData.get(this.domElement, "templateSourceData_" + key);
        } else {
            ko.utils.domData.set(this.domElement, "templateSourceData_" + key, arguments[1]);
        }
    };

    // ---- ko.templateSources.anonymousTemplate -----
    // Anonymous templates are normally saved/retrieved as DOM nodes through "nodes".
    // For compatibility, you can also read "text"; it will be serialized from the nodes on demand.
    // Writing to "text" is still supported, but then the template data will not be available as DOM nodes.

    var anonymousTemplatesDomDataKey = "__ko_anon_template__";
    ko.templateSources.anonymousTemplate = function(element) {
        this.domElement = element;
    }
    ko.templateSources.anonymousTemplate.prototype = new ko.templateSources.domElement();
    ko.templateSources.anonymousTemplate.prototype['text'] = function(/* valueToWrite */) {
        if (arguments.length == 0) {
            var templateData = ko.utils.domData.get(this.domElement, anonymousTemplatesDomDataKey) || {};
            if (templateData.textData === undefined && templateData.containerData)
                templateData.textData = templateData.containerData.innerHTML;
            return templateData.textData;
        } else {
            var valueToWrite = arguments[0];
            ko.utils.domData.set(this.domElement, anonymousTemplatesDomDataKey, {textData: valueToWrite});
        }
    };
    ko.templateSources.domElement.prototype['nodes'] = function(/* valueToWrite */) {
        if (arguments.length == 0) {
            var templateData = ko.utils.domData.get(this.domElement, anonymousTemplatesDomDataKey) || {};
            return templateData.containerData;
        } else {
            var valueToWrite = arguments[0];
            ko.utils.domData.set(this.domElement, anonymousTemplatesDomDataKey, {containerData: valueToWrite});
        }
    };

    ko.exportSymbol('templateSources', ko.templateSources);
    ko.exportSymbol('templateSources.domElement', ko.templateSources.domElement);
    ko.exportSymbol('templateSources.anonymousTemplate', ko.templateSources.anonymousTemplate);
})();
(function () {
    var _templateEngine;
    ko.setTemplateEngine = function (templateEngine) {
        if ((templateEngine != undefined) && !(templateEngine instanceof ko.templateEngine))
            throw new Error("templateEngine must inherit from ko.templateEngine");
        _templateEngine = templateEngine;
    }

    function invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, action) {
        var node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode);
        while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {
            nextInQueue = ko.virtualElements.nextSibling(node);
            if (node.nodeType === 1 || node.nodeType === 8)
                action(node);
        }
    }

    function activateBindingsOnContinuousNodeArray(continuousNodeArray, bindingContext) {
        // To be used on any nodes that have been rendered by a template and have been inserted into some parent element
        // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because
        // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,
        // (1) Does a regular "applyBindings" to associate bindingContext with this node and to activate any non-memoized bindings
        // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)

        if (continuousNodeArray.length) {
            var firstNode = continuousNodeArray[0], lastNode = continuousNodeArray[continuousNodeArray.length - 1];

            // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)
            // whereas a regular applyBindings won't introduce new memoized nodes
            invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, function(node) {
                ko.applyBindings(bindingContext, node);
            });
            invokeForEachNodeOrCommentInContinuousRange(firstNode, lastNode, function(node) {
                ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);
            });
        }
    }

    function getFirstNodeFromPossibleArray(nodeOrNodeArray) {
        return nodeOrNodeArray.nodeType ? nodeOrNodeArray
                                        : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]
                                        : null;
    }

    function executeTemplate(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {
        options = options || {};
        var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
        var templateDocument = firstTargetNode && firstTargetNode.ownerDocument;
        var templateEngineToUse = (options['templateEngine'] || _templateEngine);
        ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);
        var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument);

        // Loosely check result is an array of DOM nodes
        if ((typeof renderedNodesArray.length != "number") || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType != "number"))
            throw new Error("Template engine must return an array of DOM nodes");

        var haveAddedNodesToParent = false;
        switch (renderMode) {
            case "replaceChildren":
                ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);
                haveAddedNodesToParent = true;
                break;
            case "replaceNode":
                ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);
                haveAddedNodesToParent = true;
                break;
            case "ignoreTargetNode": break;
            default:
                throw new Error("Unknown renderMode: " + renderMode);
        }

        if (haveAddedNodesToParent) {
            activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);
            if (options['afterRender'])
                ko.dependencyDetection.ignore(options['afterRender'], null, [renderedNodesArray, bindingContext['$data']]);
        }

        return renderedNodesArray;
    }

    ko.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {
        options = options || {};
        if ((options['templateEngine'] || _templateEngine) == undefined)
            throw new Error("Set a template engine before calling renderTemplate");
        renderMode = renderMode || "replaceChildren";

        if (targetNodeOrNodeArray) {
            var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);

            var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; // Passive disposal (on next evaluation)
            var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == "replaceNode") ? firstTargetNode.parentNode : firstTargetNode;

            return ko.dependentObservable( // So the DOM is automatically updated when any dependency changes
                function () {
                    // Ensure we've got a proper binding context to work with
                    var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof ko.bindingContext))
                        ? dataOrBindingContext
                        : new ko.bindingContext(ko.utils.unwrapObservable(dataOrBindingContext));

                    // Support selecting template as a function of the data being rendered
                    var templateName = typeof(template) == 'function' ? template(bindingContext['$data'], bindingContext) : template;

                    var renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);
                    if (renderMode == "replaceNode") {
                        targetNodeOrNodeArray = renderedNodesArray;
                        firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
                    }
                },
                null,
                { disposeWhen: whenToDispose, disposeWhenNodeIsRemoved: activelyDisposeWhenNodeIsRemoved }
            );
        } else {
            // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node
            return ko.memoization.memoize(function (domNode) {
                ko.renderTemplate(template, dataOrBindingContext, options, domNode, "replaceNode");
            });
        }
    };

    ko.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {
        // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then
        // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.
        var arrayItemContext;

        // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode
        var executeTemplateForArrayItem = function (arrayValue, index) {
            // Support selecting template as a function of the data being rendered
            arrayItemContext = parentBindingContext['createChildContext'](ko.utils.unwrapObservable(arrayValue), options['as']);
            arrayItemContext['$index'] = index;
            var templateName = typeof(template) == 'function' ? template(arrayValue, arrayItemContext) : template;
            return executeTemplate(null, "ignoreTargetNode", templateName, arrayItemContext, options);
        }

        // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode
        var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {
            activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);
            if (options['afterRender'])
                options['afterRender'](addedNodesArray, arrayValue);
        };

        return ko.dependentObservable(function () {
            var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];
            if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
                unwrappedArray = [unwrappedArray];

            // Filter out any entries marked as destroyed
            var filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {
                return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);
            });

            // Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function).
            // If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within setDomNodeChildrenFromArrayMapping.
            ko.dependencyDetection.ignore(ko.utils.setDomNodeChildrenFromArrayMapping, null, [targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback]);

        }, null, { disposeWhenNodeIsRemoved: targetNode });
    };

    var templateComputedDomDataKey = '__ko__templateComputedDomDataKey__';
    function disposeOldComputedAndStoreNewOne(element, newComputed) {
        var oldComputed = ko.utils.domData.get(element, templateComputedDomDataKey);
        if (oldComputed && (typeof(oldComputed.dispose) == 'function'))
            oldComputed.dispose();
        ko.utils.domData.set(element, templateComputedDomDataKey, (newComputed && newComputed.isActive()) ? newComputed : undefined);
    }

    ko.bindingHandlers['template'] = {
        'init': function(element, valueAccessor) {
            // Support anonymous templates
            var bindingValue = ko.utils.unwrapObservable(valueAccessor());
            if ((typeof bindingValue != "string") && (!bindingValue['name']) && (element.nodeType == 1 || element.nodeType == 8)) {
                // It's an anonymous template - store the element contents, then clear the element
                var templateNodes = element.nodeType == 1 ? element.childNodes : ko.virtualElements.childNodes(element),
                    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); // This also removes the nodes from their current parent
                new ko.templateSources.anonymousTemplate(element)['nodes'](container);
            }
            return { 'controlsDescendantBindings': true };
        },
        'update': function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            var templateName = ko.utils.unwrapObservable(valueAccessor()),
                options = {},
                shouldDisplay = true,
                dataValue,
                templateComputed = null;

            if (typeof templateName != "string") {
                options = templateName;
                templateName = options['name'];

                // Support "if"/"ifnot" conditions
                if ('if' in options)
                    shouldDisplay = ko.utils.unwrapObservable(options['if']);
                if (shouldDisplay && 'ifnot' in options)
                    shouldDisplay = !ko.utils.unwrapObservable(options['ifnot']);

                dataValue = ko.utils.unwrapObservable(options['data']);
            }

            if ('foreach' in options) {
                // Render once for each data point (treating data set as empty if shouldDisplay==false)
                var dataArray = (shouldDisplay && options['foreach']) || [];
                templateComputed = ko.renderTemplateForEach(templateName || element, dataArray, options, element, bindingContext);
            } else if (!shouldDisplay) {
                ko.virtualElements.emptyNode(element);
            } else {
                // Render once for this single data point (or use the viewModel if no data was provided)
                var innerBindingContext = ('data' in options) ?
                    bindingContext['createChildContext'](dataValue, options['as']) :  // Given an explitit 'data' value, we create a child binding context for it
                    bindingContext;                                                        // Given no explicit 'data' value, we retain the same binding context
                templateComputed = ko.renderTemplate(templateName || element, innerBindingContext, options, element);
            }

            // It only makes sense to have a single template computed per element (otherwise which one should have its output displayed?)
            disposeOldComputedAndStoreNewOne(element, templateComputed);
        }
    };

    // Anonymous templates can't be rewritten. Give a nice error message if you try to do it.
    ko.expressionRewriting.bindingRewriteValidators['template'] = function(bindingValue) {
        var parsedBindingValue = ko.expressionRewriting.parseObjectLiteral(bindingValue);

        if ((parsedBindingValue.length == 1) && parsedBindingValue[0]['unknown'])
            return null; // It looks like a string literal, not an object literal, so treat it as a named template (which is allowed for rewriting)

        if (ko.expressionRewriting.keyValueArrayContainsKey(parsedBindingValue, "name"))
            return null; // Named templates can be rewritten, so return "no error"
        return "This template engine does not support anonymous templates nested within its templates";
    };

    ko.virtualElements.allowedBindings['template'] = true;
})();

ko.exportSymbol('setTemplateEngine', ko.setTemplateEngine);
ko.exportSymbol('renderTemplate', ko.renderTemplate);

ko.utils.compareArrays = (function () {
    var statusNotInOld = 'added', statusNotInNew = 'deleted';

    // Simple calculation based on Levenshtein distance.
    function compareArrays(oldArray, newArray, dontLimitMoves) {
        oldArray = oldArray || [];
        newArray = newArray || [];

        if (oldArray.length <= newArray.length)
            return compareSmallArrayToBigArray(oldArray, newArray, statusNotInOld, statusNotInNew, dontLimitMoves);
        else
            return compareSmallArrayToBigArray(newArray, oldArray, statusNotInNew, statusNotInOld, dontLimitMoves);
    }

    function compareSmallArrayToBigArray(smlArray, bigArray, statusNotInSml, statusNotInBig, dontLimitMoves) {
        var myMin = Math.min,
            myMax = Math.max,
            editDistanceMatrix = [],
            smlIndex, smlIndexMax = smlArray.length,
            bigIndex, bigIndexMax = bigArray.length,
            compareRange = (bigIndexMax - smlIndexMax) || 1,
            maxDistance = smlIndexMax + bigIndexMax + 1,
            thisRow, lastRow,
            bigIndexMaxForRow, bigIndexMinForRow;

        for (smlIndex = 0; smlIndex <= smlIndexMax; smlIndex++) {
            lastRow = thisRow;
            editDistanceMatrix.push(thisRow = []);
            bigIndexMaxForRow = myMin(bigIndexMax, smlIndex + compareRange);
            bigIndexMinForRow = myMax(0, smlIndex - 1);
            for (bigIndex = bigIndexMinForRow; bigIndex <= bigIndexMaxForRow; bigIndex++) {
                if (!bigIndex)
                    thisRow[bigIndex] = smlIndex + 1;
                else if (!smlIndex)  // Top row - transform empty array into new array via additions
                    thisRow[bigIndex] = bigIndex + 1;
                else if (smlArray[smlIndex - 1] === bigArray[bigIndex - 1])
                    thisRow[bigIndex] = lastRow[bigIndex - 1];                  // copy value (no edit)
                else {
                    var northDistance = lastRow[bigIndex] || maxDistance;       // not in big (deletion)
                    var westDistance = thisRow[bigIndex - 1] || maxDistance;    // not in small (addition)
                    thisRow[bigIndex] = myMin(northDistance, westDistance) + 1;
                }
            }
        }

        var editScript = [], meMinusOne, notInSml = [], notInBig = [];
        for (smlIndex = smlIndexMax, bigIndex = bigIndexMax; smlIndex || bigIndex;) {
            meMinusOne = editDistanceMatrix[smlIndex][bigIndex] - 1;
            if (bigIndex && meMinusOne === editDistanceMatrix[smlIndex][bigIndex-1]) {
                notInSml.push(editScript[editScript.length] = {     // added
                    'status': statusNotInSml,
                    'value': bigArray[--bigIndex],
                    'index': bigIndex });
            } else if (smlIndex && meMinusOne === editDistanceMatrix[smlIndex - 1][bigIndex]) {
                notInBig.push(editScript[editScript.length] = {     // deleted
                    'status': statusNotInBig,
                    'value': smlArray[--smlIndex],
                    'index': smlIndex });
            } else {
                editScript.push({
                    'status': "retained",
                    'value': bigArray[--bigIndex] });
                --smlIndex;
            }
        }

        if (notInSml.length && notInBig.length) {
            // Set a limit on the number of consecutive non-matching comparisons; having it a multiple of
            // smlIndexMax keeps the time complexity of this algorithm linear.
            var limitFailedCompares = smlIndexMax * 10, failedCompares,
                a, d, notInSmlItem, notInBigItem;
            // Go through the items that have been added and deleted and try to find matches between them.
            for (failedCompares = a = 0; (dontLimitMoves || failedCompares < limitFailedCompares) && (notInSmlItem = notInSml[a]); a++) {
                for (d = 0; notInBigItem = notInBig[d]; d++) {
                    if (notInSmlItem['value'] === notInBigItem['value']) {
                        notInSmlItem['moved'] = notInBigItem['index'];
                        notInBigItem['moved'] = notInSmlItem['index'];
                        notInBig.splice(d,1);       // This item is marked as moved; so remove it from notInBig list
                        failedCompares = d = 0;     // Reset failed compares count because we're checking for consecutive failures
                        break;
                    }
                }
                failedCompares += d;
            }
        }
        return editScript.reverse();
    }

    return compareArrays;
})();

ko.exportSymbol('utils.compareArrays', ko.utils.compareArrays);

(function () {
    // Objective:
    // * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,
    //   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node
    // * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node
    //   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we
    //   previously mapped - retain those nodes, and just insert/delete other ones

    // "callbackAfterAddingNodes" will be invoked after any "mapping"-generated nodes are inserted into the container node
    // You can use this, for example, to activate bindings on those nodes.

    function fixUpNodesToBeMovedOrRemoved(contiguousNodeArray) {
        // Before moving, deleting, or replacing a set of nodes that were previously outputted by the "map" function, we have to reconcile
        // them against what is in the DOM right now. It may be that some of the nodes have already been removed from the document,
        // or that new nodes might have been inserted in the middle, for example by a binding. Also, there may previously have been
        // leading comment nodes (created by rewritten string-based templates) that have since been removed during binding.
        // So, this function translates the old "map" output array into its best guess of what set of current DOM nodes should be removed.
        //
        // Rules:
        //   [A] Any leading nodes that aren't in the document any more should be ignored
        //       These most likely correspond to memoization nodes that were already removed during binding
        //       See https://github.com/SteveSanderson/knockout/pull/440
        //   [B] We want to output a contiguous series of nodes that are still in the document. So, ignore any nodes that
        //       have already been removed, and include any nodes that have been inserted among the previous collection

        // Rule [A]
        while (contiguousNodeArray.length && !ko.utils.domNodeIsAttachedToDocument(contiguousNodeArray[0]))
            contiguousNodeArray.splice(0, 1);

        // Rule [B]
        if (contiguousNodeArray.length > 1) {
            // Build up the actual new contiguous node set
            var current = contiguousNodeArray[0], last = contiguousNodeArray[contiguousNodeArray.length - 1], newContiguousSet = [current];
            while (current !== last) {
                current = current.nextSibling;
                if (!current) // Won't happen, except if the developer has manually removed some DOM elements (then we're in an undefined scenario)
                    return;
                newContiguousSet.push(current);
            }

            // ... then mutate the input array to match this.
            // (The following line replaces the contents of contiguousNodeArray with newContiguousSet)
            Array.prototype.splice.apply(contiguousNodeArray, [0, contiguousNodeArray.length].concat(newContiguousSet));
        }
        return contiguousNodeArray;
    }

    function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {
        // Map this array value inside a dependentObservable so we re-map when any dependency changes
        var mappedNodes = [];
        var dependentObservable = ko.dependentObservable(function() {
            var newMappedNodes = mapping(valueToMap, index) || [];

            // On subsequent evaluations, just replace the previously-inserted DOM nodes
            if (mappedNodes.length > 0) {
                ko.utils.replaceDomNodes(fixUpNodesToBeMovedOrRemoved(mappedNodes), newMappedNodes);
                if (callbackAfterAddingNodes)
                    ko.dependencyDetection.ignore(callbackAfterAddingNodes, null, [valueToMap, newMappedNodes, index]);
            }

            // Replace the contents of the mappedNodes array, thereby updating the record
            // of which nodes would be deleted if valueToMap was itself later removed
            mappedNodes.splice(0, mappedNodes.length);
            ko.utils.arrayPushAll(mappedNodes, newMappedNodes);
        }, null, { disposeWhenNodeIsRemoved: containerNode, disposeWhen: function() { return (mappedNodes.length == 0) || !ko.utils.domNodeIsAttachedToDocument(mappedNodes[0]) } });
        return { mappedNodes : mappedNodes, dependentObservable : (dependentObservable.isActive() ? dependentObservable : undefined) };
    }

    var lastMappingResultDomDataKey = "setDomNodeChildrenFromArrayMapping_lastMappingResult";

    ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {
        // Compare the provided array against the previous one
        array = array || [];
        options = options || {};
        var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined;
        var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];
        var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; });
        var editScript = ko.utils.compareArrays(lastArray, array);

        // Build the new mapping result
        var newMappingResult = [];
        var lastMappingResultIndex = 0;
        var newMappingResultIndex = 0;

        var nodesToDelete = [];
        var itemsToProcess = [];
        var itemsForBeforeRemoveCallbacks = [];
        var itemsForMoveCallbacks = [];
        var itemsForAfterAddCallbacks = [];
        var mapData;

        function itemMovedOrRetained(editScriptIndex, oldPosition) {
            mapData = lastMappingResult[oldPosition];
            if (newMappingResultIndex !== oldPosition)
                itemsForMoveCallbacks[editScriptIndex] = mapData;
            // Since updating the index might change the nodes, do so before calling fixUpNodesToBeMovedOrRemoved
            mapData.indexObservable(newMappingResultIndex++);
            fixUpNodesToBeMovedOrRemoved(mapData.mappedNodes);
            newMappingResult.push(mapData);
            itemsToProcess.push(mapData);
        }

        function callCallback(callback, items) {
            if (callback) {
                for (var i = 0, n = items.length; i < n; i++) {
                    if (items[i]) {
                        ko.utils.arrayForEach(items[i].mappedNodes, function(node) {
                            callback(node, i, items[i].arrayEntry);
                        });
                    }
                }
            }
        }

        for (var i = 0, editScriptItem, movedIndex; editScriptItem = editScript[i]; i++) {
            movedIndex = editScriptItem['moved'];
            switch (editScriptItem['status']) {
                case "deleted":
                    if (movedIndex === undefined) {
                        mapData = lastMappingResult[lastMappingResultIndex];

                        // Stop tracking changes to the mapping for these nodes
                        if (mapData.dependentObservable)
                            mapData.dependentObservable.dispose();

                        // Queue these nodes for later removal
                        nodesToDelete.push.apply(nodesToDelete, fixUpNodesToBeMovedOrRemoved(mapData.mappedNodes));
                        if (options['beforeRemove']) {
                            itemsForBeforeRemoveCallbacks[i] = mapData;
                            itemsToProcess.push(mapData);
                        }
                    }
                    lastMappingResultIndex++;
                    break;

                case "retained":
                    itemMovedOrRetained(i, lastMappingResultIndex++);
                    break;

                case "added":
                    if (movedIndex !== undefined) {
                        itemMovedOrRetained(i, movedIndex);
                    } else {
                        mapData = { arrayEntry: editScriptItem['value'], indexObservable: ko.observable(newMappingResultIndex++) };
                        newMappingResult.push(mapData);
                        itemsToProcess.push(mapData);
                        if (!isFirstExecution)
                            itemsForAfterAddCallbacks[i] = mapData;
                    }
                    break;
            }
        }

        // Call beforeMove first before any changes have been made to the DOM
        callCallback(options['beforeMove'], itemsForMoveCallbacks);

        // Next remove nodes for deleted items (or just clean if there's a beforeRemove callback)
        ko.utils.arrayForEach(nodesToDelete, options['beforeRemove'] ? ko.cleanNode : ko.removeNode);

        // Next add/reorder the remaining items (will include deleted items if there's a beforeRemove callback)
        for (var i = 0, nextNode = ko.virtualElements.firstChild(domNode), lastNode, node; mapData = itemsToProcess[i]; i++) {
            // Get nodes for newly added items
            if (!mapData.mappedNodes)
                ko.utils.extend(mapData, mapNodeAndRefreshWhenChanged(domNode, mapping, mapData.arrayEntry, callbackAfterAddingNodes, mapData.indexObservable));

            // Put nodes in the right place if they aren't there already
            for (var j = 0; node = mapData.mappedNodes[j]; nextNode = node.nextSibling, lastNode = node, j++) {
                if (node !== nextNode)
                    ko.virtualElements.insertAfter(domNode, node, lastNode);
            }

            // Run the callbacks for newly added nodes (for example, to apply bindings, etc.)
            if (!mapData.initialized && callbackAfterAddingNodes) {
                callbackAfterAddingNodes(mapData.arrayEntry, mapData.mappedNodes, mapData.indexObservable);
                mapData.initialized = true;
            }
        }

        // If there's a beforeRemove callback, call it after reordering.
        // Note that we assume that the beforeRemove callback will usually be used to remove the nodes using
        // some sort of animation, which is why we first reorder the nodes that will be removed. If the
        // callback instead removes the nodes right away, it would be more efficient to skip reordering them.
        // Perhaps we'll make that change in the future if this scenario becomes more common.
        callCallback(options['beforeRemove'], itemsForBeforeRemoveCallbacks);

        // Finally call afterMove and afterAdd callbacks
        callCallback(options['afterMove'], itemsForMoveCallbacks);
        callCallback(options['afterAdd'], itemsForAfterAddCallbacks);

        // Store a copy of the array items we just considered so we can difference it next time
        ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);
    }
})();

ko.exportSymbol('utils.setDomNodeChildrenFromArrayMapping', ko.utils.setDomNodeChildrenFromArrayMapping);
ko.nativeTemplateEngine = function () {
    this['allowTemplateRewriting'] = false;
}

ko.nativeTemplateEngine.prototype = new ko.templateEngine();
ko.nativeTemplateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options) {
    var useNodesIfAvailable = !(ko.utils.ieVersion < 9), // IE<9 cloneNode doesn't work properly
        templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,
        templateNodes = templateNodesFunc ? templateSource['nodes']() : null;

    if (templateNodes) {
        return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);
    } else {
        var templateText = templateSource['text']();
        return ko.utils.parseHtmlFragment(templateText);
    }
};

ko.nativeTemplateEngine.instance = new ko.nativeTemplateEngine();
ko.setTemplateEngine(ko.nativeTemplateEngine.instance);

ko.exportSymbol('nativeTemplateEngine', ko.nativeTemplateEngine);
(function() {
    ko.jqueryTmplTemplateEngine = function () {
        // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl
        // doesn't expose a version number, so we have to infer it.
        // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,
        // which KO internally refers to as version "2", so older versions are no longer detected.
        var jQueryTmplVersion = this.jQueryTmplVersion = (function() {
            if ((typeof(jQuery) == "undefined") || !(jQuery['tmpl']))
                return 0;
            // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.
            try {
                if (jQuery['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') >= 0) {
                    // Since 1.0.0pre, custom tags should append markup to an array called "__"
                    return 2; // Final version of jquery.tmpl
                }
            } catch(ex) { /* Apparently not the version we were looking for */ }

            return 1; // Any older version that we don't support
        })();

        function ensureHasReferencedJQueryTemplates() {
            if (jQueryTmplVersion < 2)
                throw new Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
        }

        function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {
            return jQuery['tmpl'](compiledTemplate, data, jQueryTemplateOptions);
        }

        this['renderTemplateSource'] = function(templateSource, bindingContext, options) {
            options = options || {};
            ensureHasReferencedJQueryTemplates();

            // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)
            var precompiled = templateSource['data']('precompiled');
            if (!precompiled) {
                var templateText = templateSource['text']() || "";
                // Wrap in "with($whatever.koBindingContext) { ... }"
                templateText = "{{ko_with $item.koBindingContext}}" + templateText + "{{/ko_with}}";

                precompiled = jQuery['template'](null, templateText);
                templateSource['data']('precompiled', precompiled);
            }

            var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays
            var jQueryTemplateOptions = jQuery['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);

            var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);
            resultNodes['appendTo'](document.createElement("div")); // Using "appendTo" forces jQuery/jQuery.tmpl to perform necessary cleanup work

            jQuery['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template renders
            return resultNodes;
        };

        this['createJavaScriptEvaluatorBlock'] = function(script) {
            return "{{ko_code ((function() { return " + script + " })()) }}";
        };

        this['addTemplate'] = function(templateName, templateMarkup) {
            document.write("<script type='text/html' id='" + templateName + "'>" + templateMarkup + "</script>");
        };

        if (jQueryTmplVersion > 0) {
            jQuery['tmpl']['tag']['ko_code'] = {
                open: "__.push($1 || '');"
            };
            jQuery['tmpl']['tag']['ko_with'] = {
                open: "with($1) {",
                close: "} "
            };
        }
    };

    ko.jqueryTmplTemplateEngine.prototype = new ko.templateEngine();

    // Use this one by default *only if jquery.tmpl is referenced*
    var jqueryTmplTemplateEngineInstance = new ko.jqueryTmplTemplateEngine();
    if (jqueryTmplTemplateEngineInstance.jQueryTmplVersion > 0)
        ko.setTemplateEngine(jqueryTmplTemplateEngineInstance);

    ko.exportSymbol('jqueryTmplTemplateEngine', ko.jqueryTmplTemplateEngine);
})();
});
})(window,document,navigator,window["jQuery"]);
})();

/*!
 * Operative
 * ---
 * Operative is a small JS utility for seamlessly creating Web Worker scripts.
 * ---
 * @author James Padolsey http://james.padolsey.com
 * @repo http://github.com/padolsey/operative
 * @version 0.3.1
 * @license MIT
 */
(function() {

	if (typeof window == 'undefined' && self.importScripts) {
		// I'm a worker! Run the boiler-script:
		// (Operative itself is called in IE10 as a worker,
		//  to avoid SecurityErrors)
		workerBoilerScript();
		return;
	}

	var slice = [].slice;
	var hasOwn = {}.hasOwnProperty;

	var scripts = document.getElementsByTagName('script');
	var opScript = scripts[scripts.length - 1];
	var opScriptURL = /operative/.test(opScript.src) && opScript.src;

	// Default base URL (to be prepended to relative dependency URLs)
	// is current page's parent dir:
	var baseURL = (
		location.protocol + '//' +
		location.hostname +
		(location.port?':'+location.port:'') +
		location.pathname
	).replace(/[^\/]+$/, '');

	var URL = window.URL || window.webkitURL;
	var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;

	var workerViaBlobSupport = (function() {
		try {
			new Worker(makeBlobURI(';'));
		} catch(e) {
			return false;
		}
		return true;
	}());

	/**
	 * Provide Object.create shim
	 */
	var objCreate = Object.create || function(o) {
		function F() {}
		F.prototype = o;
		return new F();
	};

	function makeBlobURI(script) {
		var blob;

		try {
			blob = new Blob([script], { type: 'text/javascript' });
		} catch (e) { 
			blob = new BlobBuilder();
			blob.append(script);
			blob = blob.getBlob();
		}

		return URL.createObjectURL(blob);
	}

	// Indicates whether operatives will run within workers:
	operative.hasWorkerSupport = !!window.Worker;

	operative.Promise = window.Promise;

	// Expose:
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = operative;
	} else {
		window.operative = operative;
	}
	

	operative.setSelfURL = function(url) {
		opScriptURL = url;
	};

	operative.setBaseURL = function(base) {
		baseURL = base;
	};

	operative.getBaseURL = function() {
		return baseURL;
	};

	/**
	 * Operative: Exposed Operative Constructor
	 * @param {Object} module Object containing methods/properties
	 */
	function Operative(module, dependencies) {

		var _self = this;

		module.get = module.get || function(prop) {
			return this[prop];
		};

		module.set = module.set || function(prop, value) {
			return this[prop] = value;
		};

		this._curToken = 0;
		this._queue = [];

		this.isDestroyed = false;
		this.isContextReady = false;

		this.module = module;
		this.dependencies = dependencies || [];

		this.dataProperties = {};
		this.api = {};
		this.callbacks = {};
		this.deferreds = {};

		this._fixDependencyURLs();
		this._setup();

		for (var methodName in module) {
			if (hasOwn.call(module, methodName)) {
				this._createExposedMethod(methodName);
			}
		}

		this.api.__operative__ = this;

		// Provide the instance's destroy method on the exposed API:
		this.api.destroy = this.api.terminate = function() {
			return _self.destroy();
		};

	}

	Operative.prototype = {

		_marshal: function(v) {
			return v;
		},

		_demarshal: function(v) {
			return v;
		},

		_enqueue: function(fn) {
			this._queue.push(fn);
		},

		_fixDependencyURLs: function() {
			var deps = this.dependencies;
			for (var i = 0, l = deps.length; i < l; ++i) {
				var dep = deps[i];
				if (!/\/\//.test(dep)) {
					deps[i] = dep.replace(/^\/?/, baseURL);
				}
			}
		},

		_dequeueAll: function() {
			for (var i = 0, l = this._queue.length; i < l; ++i) {
				this._queue[i].call(this);
			}
			this._queue = [];
		},

		_buildContextScript: function(boilerScript) {

			var script = [];
			var module = this.module;
			var dataProperties = this.dataProperties;
			var property;

			for (var i in module) {
				property = module[i];
				if (typeof property == 'function') {
					script.push('   self["' + i.replace(/"/g, '\\"') + '"] = ' + property.toString() + ';');
				} else {
					dataProperties[i] = property;
				}
			}

			return script.join('\n') + (
				boilerScript ? '\n(' + boilerScript.toString() + '());' : ''
			);

		},

		_createExposedMethod: function(methodName) {

			var self = this;

			this.api[methodName] = function() {

				if (self.isDestroyed) {
					throw new Error('Operative: Cannot run method. Operative has already been destroyed');
				}

				var token = ++self._curToken;
				var args = slice.call(arguments);
				var cb = typeof args[args.length - 1] == 'function' && args.pop();

				if (!cb && !operative.Promise) {
					throw new Error(
						'Operative: No callback has been passed. Assumed that you want a promise. ' +
						'But `operative.Promise` is null. Please provide Promise polyfill/lib.'
					);
				}

				if (cb) {

					self.callbacks[token] = cb;

					// Ensure either context runs the method async:
					setTimeout(function() {
						runMethod();
					}, 1);

				} else if (operative.Promise) {

					// No Callback -- Promise used:

					return new operative.Promise(function(deferred) {
						deferred.fulfil = deferred.fulfill;
						self.deferreds[token] = deferred;
						runMethod();
					});

				}

				function runMethod() {
					if (self.isContextReady) {
						self._runMethod(methodName, token, args);
					} else {
						self._enqueue(runMethod);
					}
				}

			};

		},

		destroy: function() {
			this.isDestroyed = true;
		}
	};


	/**
	 * Operative Worker
	 */
	Operative.Worker = function Worker(module) {
		this._msgQueue = [];
		Operative.apply(this, arguments);
	};

	var WorkerProto = Operative.Worker.prototype = objCreate(Operative.prototype);

	WorkerProto._onWorkerMessage = function(e) {
		var data = e.data;

		if (typeof data === 'string' && data.indexOf('pingback') === 0) {
			if (data === 'pingback:structuredCloningSupport=NO') {
				// No structuredCloningSupport support (marshal JSON from now on):
				this._marshal = function(o) { return JSON.stringify(o); };
				this._demarshal = function(o) { return JSON.parse(o); };
			}

			this.isContextReady = true;
			this._postMessage({
				definitions: this.dataProperties
			});
			this._dequeueAll();
			return;

		}

		data = this._demarshal(data);

		switch (data.cmd) {
			case 'console':
				window.console && window.console[data.method].apply(window.console, data.args);
				break;
			case 'result':

				var callback = this.callbacks[data.token];
				var deferred = this.deferreds[data.token];

				delete this.callbacks[data.token];
				delete this.deferreds[data.token];

				var deferredAction = data.result && data.result.isDeferred && data.result.action;

				if (deferred && deferredAction) {
					deferred[deferredAction](data.result.args[0]);
				} else if (callback) {
					callback.apply(this, data.result.args);
				}

				break;
		}
	};

	WorkerProto._setup = function() {
		var self = this;

		var worker;
		var script = this._buildContextScript(
			// The script is not included if we're Eval'ing this file directly:
			workerViaBlobSupport ? workerBoilerScript : ''
		);

		if (this.dependencies.length) {
			script = 'importScripts("' + this.dependencies.join('", "') + '");\n' + script;
		}

		if (workerViaBlobSupport) {
			worker = this.worker = new Worker( makeBlobURI(script) );
		}  else {
			if (!opScriptURL) {
				throw new Error('Operaritve: No operative.js URL available. Please set via operative.setSelfURL(...)');
			}
			worker = this.worker = new Worker( opScriptURL );
			// Marshal-agnostic initial message is boiler-code:
			// (We don't yet know if structured-cloning is supported so we send a string)
			worker.postMessage('EVAL|' + script);
		}

		worker.postMessage(['PING']); // Initial PING

		worker.addEventListener('message', function(e) {
			self._onWorkerMessage(e);
		});
	};

	WorkerProto._postMessage = function(msg) {
		return this.worker.postMessage(this._marshal(msg));
	};

	WorkerProto._runMethod = function(methodName, token, args) {
		this._postMessage({
			method: methodName,
			args: args,
			token: token
		});
	};

	WorkerProto.destroy = function() {
		this.worker.terminate();
		Operative.prototype.destroy.call(this);
	};


	/**
	 * Operative IFrame
	 */
	Operative.Iframe = function Iframe(module) {
		Operative.apply(this, arguments);
	};

	var IframeProto = Operative.Iframe.prototype = objCreate(Operative.prototype);

	var _loadedMethodNameI = 0;

	IframeProto._setup = function() {

		var self = this;
		var loadedMethodName = '__operativeIFrameLoaded' + ++_loadedMethodNameI;

		this.module.isWorker = false;

		var iframe = this.iframe = document.body.appendChild(
			document.createElement('iframe')
		);

		iframe.style.display = 'none';

		var iWin = this.iframeWindow = iframe.contentWindow;
		var iDoc = iWin.document;

		// Cross browser (tested in IE8,9) way to call method from within
		// IFRAME after all <Script>s have loaded:
		window[loadedMethodName] = function() {

			window[loadedMethodName] = null;

			var script = iDoc.createElement('script');
			var js = self._buildContextScript(iframeBoilerScript);

			if (script.text !== void 0) {
				script.text = js;
			} else {
				script.innerHTML = js;
			}

			iDoc.documentElement.appendChild(script);

			for (var i in self.dataProperties) {
				iWin[i] = self.dataProperties[i];
			}

			self.isContextReady = true;
			self._dequeueAll();

		};

		iDoc.open();
		if (this.dependencies.length) {
			iDoc.write(
				'<script src="' + this.dependencies.join('"></script><script src="') + '"></script>'
			);
		}
		// Place <script> at bottom to tell parent-page when dependencies are loaded:
		iDoc.write('<script>window.top.' + loadedMethodName + '();</script>');
		iDoc.close();

	};

	IframeProto._runMethod = function(methodName, token, args) {
		var self = this;
		var callback = this.callbacks[token];
		var deferred = this.deferreds[token];
		delete this.callbacks[token];
		delete this.deferreds[token];
		this.iframeWindow.__run__(methodName, args, function() {
			var cb = callback;
			if (cb) {
				callback = null;
				cb.apply(self, arguments);
			} else {
				throw new Error('Operative: You have already returned.');
			}
		}, deferred);
	};

	IframeProto.destroy = function() {
		this.iframe.parentNode.removeChild(this.iframe);
		Operative.prototype.destroy.call(this);
	};

	operative.Operative = Operative;

	/**
	 * Exposed operative factory
	 */
	function operative(module, dependencies) {

		var OperativeContext = operative.hasWorkerSupport ?
			Operative.Worker : Operative.Iframe;

		if (typeof module == 'function') {
			// Allow a single function to be passed.
			var o = new OperativeContext({ main: module }, dependencies);
			var singularOperative = function() {
				return o.api.main.apply(o, arguments);
			};
			// Copy across exposable API to the returned function:
			for (var i in o.api) {
				if (hasOwn.call(o.api, i)) {
					singularOperative[i] = o.api[i];
				}
			}
			return singularOperative;
		}

		return new OperativeContext(module, dependencies).api;

	}

/**
 * The boilerplate for the Iframe Context
 * NOTE:
 *  this'll be executed within an iframe, not here.
 *  Indented @ Zero to make nicer debug code within worker
 */
function iframeBoilerScript() {

	// Called from parent-window:
	window.__run__ = function(methodName, args, cb, deferred) {

		var isAsync = false;
		var isDeferred = false;

		window.async = function() {
			isAsync = true;
			return cb;
		};

		window.deferred = function() {
			isDeferred = true;
			return deferred;
		};

		if (cb) {
			args.push(cb);
		}

		var result = window[methodName].apply(window, args);

		window.async = function() {
			throw new Error('Operative: async() called at odd time');
		};

		window.deferred = function() {
			throw new Error('Operative: deferred() called at odd time');
		};


		if (!isDeferred && !isAsync && result !== void 0) {
			// Deprecated direct-returning as of 0.2.0
			cb(result);
		}
	};
}

/**
 * The boilerplate for the Worker Blob
 * NOTE:
 *  this'll be executed within an iframe, not here.
 *  Indented @ Zero to make nicer debug code within worker
 */
function workerBoilerScript() {

	var postMessage = self.postMessage;
	var structuredCloningSupport = null;

	self.console = {};
	self.isWorker = true;

	// Provide basic console interface:
	['log', 'debug', 'error', 'info', 'warn', 'time', 'timeEnd'].forEach(function(meth) {
		self.console[meth] = function() {
			postMessage({
				cmd: 'console',
				method: meth,
				args: [].slice.call(arguments)
			});
		};
	});

	self.addEventListener('message', function(e) {

		var data = e.data;

		if (typeof data == 'string' && data.indexOf('EVAL|') === 0) {
			eval(data.substring(5));
			return;
		}

		if (structuredCloningSupport == null) {

			// e.data of ['PING'] (An array) indicates transferrableObjSupport
			// e.data of '"PING"' (A string) indicates no support (Array has been serialized)
			structuredCloningSupport = e.data[0] === 'PING';

			// Pingback to parent page:
			self.postMessage(
				structuredCloningSupport ?
					'pingback:structuredCloningSupport=YES' :
					'pingback:structuredCloningSupport=NO'
			);

			if (!structuredCloningSupport) {
				postMessage = function(msg) {
					// Marshal before sending
					return self.postMessage(JSON.stringify(msg));
				};
			}

			return;
		}

		if (!structuredCloningSupport) {
			// Demarshal:
			data = JSON.parse(data);
		}

		var defs = data.definitions;
		var isDeferred = false;
		var isAsync = false;
		var args = data.args;

		if (defs) {
			// Initial definitions:
			for (var i in defs) {
				self[i] = defs[i];
			}
			return;
		}

		args.push(function() {
			// Callback function to be passed to operative method
			returnResult({
				args: [].slice.call(arguments)
			});
		});

		self.async = function() { // Async deprecated as of 0.2.0
			isAsync = true;
			return function() { returnResult({ args: [].slice.call(arguments) }); };
		};

		self.deferred = function() {
			isDeferred = true;
			var def = {};
			function fulfill(r) {
				returnResult({
					isDeferred: true,
					action: 'fulfill',
					args: [r]
				});
				return def;
			}
			function reject(r) {
				returnResult({
					isDeferred: true,
					action: 'reject',
					args: [r]
				});
			}
			def.fulfil = def.fulfill = fulfill;
			def.reject = reject;
			return def;
		};

		// Call actual operative method:
		var result = self[data.method].apply(self, args);

		if (!isDeferred && !isAsync && result !== void 0) {
			// Deprecated direct-returning as of 0.2.0
			returnResult({
				args: [result]
			});
		}

		self.deferred = function() {
			throw new Error('Operative: deferred() called at odd time');
		};

		self.async = function() { // Async deprecated as of 0.2.0
			throw new Error('Operative: async() called at odd time');
		};

		function returnResult(res) {
			postMessage({
				cmd: 'result',
				token: data.token,
				result: res
			});
			// Override with error-thrower if we've already returned:
			returnResult = function() {
				throw new Error('Operative: You have already returned.');
			};
		}
	});
}

}());

var Path = {
    'version': "0.8.4",
    'map': function (path) {
        if (Path.routes.defined.hasOwnProperty(path)) {
            return Path.routes.defined[path];
        } else {
            return new Path.core.route(path);
        }
    },
    'root': function (path) {
        Path.routes.root = path;
    },
    'rescue': function (fn) {
        Path.routes.rescue = fn;
    },
    'history': {
        'initial':{}, // Empty container for "Initial Popstate" checking variables.
        'pushState': function(state, title, path){
            if(Path.history.supported){
                if(Path.dispatch(path)){
                    history.pushState(state, title, path);
                }
            } else {
                if(Path.history.fallback){
                    window.location.hash = "#" + path;
                }
            }
        },
        'popState': function(event){
            var initialPop = !Path.history.initial.popped && location.href == Path.history.initial.URL;
            Path.history.initial.popped = true;
            if(initialPop) return;
            Path.dispatch(document.location.pathname);
        },
        'listen': function(fallback){
            Path.history.supported = !!(window.history && window.history.pushState);
            Path.history.fallback  = fallback;

            if(Path.history.supported){
                Path.history.initial.popped = ('state' in window.history), Path.history.initial.URL = location.href;
                window.onpopstate = Path.history.popState;
            } else {
                if(Path.history.fallback){
                    for(route in Path.routes.defined){
                        if(route.charAt(0) != "#"){
                          Path.routes.defined["#"+route] = Path.routes.defined[route];
                          Path.routes.defined["#"+route].path = "#"+route;
                        }
                    }
                    Path.listen();
                }
            }
        }
    },
    'match': function (path, parameterize) {
        var params = {}, route = null, possible_routes, slice, i, j, compare;
        for (route in Path.routes.defined) {
            if (route !== null && route !== undefined) {
                route = Path.routes.defined[route];
                possible_routes = route.partition();
                for (j = 0; j < possible_routes.length; j++) {
                    slice = possible_routes[j];
                    compare = path;
                    if (slice.search(/:/) > 0) {
                        for (i = 0; i < slice.split("/").length; i++) {
                            if ((i < compare.split("/").length) && (slice.split("/")[i].charAt(0) === ":")) {
                                params[slice.split('/')[i].replace(/:/, '')] = compare.split("/")[i];
                                compare = compare.replace(compare.split("/")[i], slice.split("/")[i]);
                            }
                        }
                    }
                    if (slice === compare) {
                        if (parameterize) {
                            route.params = params;
                        }
                        return route;
                    }
                }
            }
        }
        return null;
    },
    'dispatch': function (passed_route) {
        var previous_route, matched_route;
        if (Path.routes.current !== passed_route) {
            Path.routes.previous = Path.routes.current;
            Path.routes.current = passed_route;
            matched_route = Path.match(passed_route, true);

            if (Path.routes.previous) {
                previous_route = Path.match(Path.routes.previous);
                if (previous_route !== null && previous_route.do_exit !== null) {
                    previous_route.do_exit();
                }
            }

            if (matched_route !== null) {
                matched_route.run();
                return true;
            } else {
                if (Path.routes.rescue !== null) {
                    Path.routes.rescue();
                }
            }
        }
    },
    'listen': function () {
        var fn = function(){ Path.dispatch(location.hash); }

        if (location.hash === "") {
            if (Path.routes.root !== null) {
                location.hash = Path.routes.root;
            }
        }

        // The 'document.documentMode' checks below ensure that PathJS fires the right events
        // even in IE "Quirks Mode".
        if ("onhashchange" in window && (!document.documentMode || document.documentMode >= 8)) {
            window.onhashchange = fn;
        } else {
            setInterval(fn, 50);
        }

        if(location.hash !== "") {
            Path.dispatch(location.hash);
        }
    },
    'core': {
        'route': function (path) {
            this.path = path;
            this.action = null;
            this.do_enter = [];
            this.do_exit = null;
            this.params = {};
            Path.routes.defined[path] = this;
        }
    },
    'routes': {
        'current': null,
        'root': null,
        'rescue': null,
        'previous': null,
        'defined': {}
    }
};
Path.core.route.prototype = {
    'to': function (fn) {
        this.action = fn;
        return this;
    },
    'enter': function (fns) {
        if (fns instanceof Array) {
            this.do_enter = this.do_enter.concat(fns);
        } else {
            this.do_enter.push(fns);
        }
        return this;
    },
    'exit': function (fn) {
        this.do_exit = fn;
        return this;
    },
    'partition': function () {
        var parts = [], options = [], re = /\(([^}]+?)\)/g, text, i;
        while (text = re.exec(this.path)) {
            parts.push(text[1]);
        }
        options.push(this.path.split("(")[0]);
        for (i = 0; i < parts.length; i++) {
            options.push(options[options.length - 1] + parts[i]);
        }
        return options;
    },
    'run': function () {
        var halt_execution = false, i, result, previous;

        if (Path.routes.defined[this.path].hasOwnProperty("do_enter")) {
            if (Path.routes.defined[this.path].do_enter.length > 0) {
                for (i = 0; i < Path.routes.defined[this.path].do_enter.length; i++) {
                    result = Path.routes.defined[this.path].do_enter[i].apply(this, null);
                    if (result === false) {
                        halt_execution = true;
                        break;
                    }
                }
            }
        }
        if (!halt_execution) {
            Path.routes.defined[this.path].action();
        }
    }
};
/*	SWFObject v2.2 <http://code.google.com/p/swfobject/> 
	is released under the MIT License <http://www.opensource.org/licenses/mit-license.php> 
*/
var swfobject=function(){var D="undefined",r="object",S="Shockwave Flash",W="ShockwaveFlash.ShockwaveFlash",q="application/x-shockwave-flash",R="SWFObjectExprInst",x="onreadystatechange",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")):false,X=!+"\v1",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\s+(\S+\s+\S+$)/,"$1");ag[0]=parseInt(ab.replace(/^(.*)\..*$/,"$1"),10);ag[1]=parseInt(ab.replace(/^.*\.(.*)\s.*$/,"$1"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,"$1"),10):0}}else{if(typeof O.ActiveXObject!=D){try{var ad=new ActiveXObject(W);if(ad){ab=ad.GetVariable("$version");if(ab){X=true;ab=ab.split(" ")[1].split(",");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState=="complete")||(typeof j.readyState==D&&(j.getElementsByTagName("body")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener("DOMContentLoaded",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState=="complete"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll("left")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName("body")[0].appendChild(C("span"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener("load",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener("load",Y,false)}else{if(typeof O.attachEvent!=D){i(O,"onload",Y)}else{if(typeof O.onload=="function"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName("body")[0];var aa=C(r);aa.setAttribute("type",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable("$version");if(ab){ab=ab.split(" ")[1].split(",");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute("width")||"0";ai.height=ae.getAttribute("height")||"0";if(ae.getAttribute("class")){ai.styleclass=ae.getAttribute("class")}if(ae.getAttribute("align")){ai.align=ae.getAttribute("align")}var ah={};var X=ae.getElementsByTagName("param");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute("name").toLowerCase()!="movie"){ah[X[ad].getAttribute("name")]=X[ad].getAttribute("value")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName=="OBJECT"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F("6.0.65")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName=="OBJECT"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width="310"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height="137"}j.title=j.title.slice(0,47)+" - Flash Player Installation";var ad=M.ie&&M.win?"ActiveX":"PlugIn",ac="MMredirectURL="+O.location.toString().replace(/&/g,"%26")+"&MMplayerType="+ad+"&MMdoctitle="+j.title;if(typeof ab.flashvars!=D){ab.flashvars+="&"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C("div");X+="SWFObjectNew";Y.setAttribute("id",X);ae.parentNode.insertBefore(Y,ae);ae.style.display="none";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C("div");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display="none";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C("div");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName=="PARAM")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah="";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()=="data"){ag.movie=ai[ae]}else{if(ae.toLowerCase()=="styleclass"){ah+=' class="'+ai[ae]+'"'}else{if(ae.toLowerCase()!="classid"){ah+=" "+ae+'="'+ai[ae]+'"'}}}}}var af="";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name="'+ad+'" value="'+ag[ad]+'" />'}}aa.outerHTML='<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"'+ah+">"+af+"</object>";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute("type",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()=="styleclass"){Z.setAttribute("class",ai[ac])}else{if(ac.toLowerCase()!="classid"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!="movie"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C("param");aa.setAttribute("name",X);aa.setAttribute("value",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName=="OBJECT"){if(M.ie&&M.win){X.style.display="none";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]=="function"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(".");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName("head")[0];if(!aa){return}var X=(ad&&typeof ad=="string")?ad:"screen";if(ab){n=null;G=null}if(!n||G!=X){var Z=C("style");Z.setAttribute("type","text/css");Z.setAttribute("media",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+" {"+Y+"}"))}}}function w(Z,X){if(!m){return}var Y=X?"visible":"hidden";if(J&&c(Z)){c(Z).style.visibility=Y}else{v("#"+Z,"visibility:"+Y)}}function L(Y){var Z=/[\\\"<>\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent("onunload",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+="";ag+="";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+="&"+ai+"="+Z[ai]}else{am.flashvars=ai+"="+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\?/.test(Z)){Z=Z.split("?")[1]}if(aa==null){return L(Z)}var Y=Z.split("&");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf("="))==aa){return L(Y[X].substring((Y[X].indexOf("=")+1)))}}}return""},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display="block"}}if(E){E(B)}}a=false}}}}();}

"use strict";

tutao.provide('tutao.locator');
tutao.provide("tutao.tutanota.Bootstrap");

/**
 * Executes all initializations needed for the live one-and-only tutanota website.
 * This binding is located in gui, so that it is not used for unit or integration tests.
 */
tutao.tutanota.Bootstrap.init = function () {
    var launch = function () {
        // disable all registered event handlers on the document and the window
        $(document).off();
        $(window).off();

        if (tutao.tutanota.util.ClientDetector.isSupported()) {
            $(window).unload(function () {
                tutao.locator.eventBus.close(); // close the socket in non legacy-mode
            });
        }

        if (tutao.locator && tutao.locator.eventBus) {
            tutao.locator.eventBus.close();
        }

        tutao.tutanota.Bootstrap.initControllers();
        Promise.longStackTraces();
        Promise.onPossiblyUnhandledRejection(function (e) {
            if (e instanceof tutao.ConnectionError) {
                tutao.tutanota.gui.alert(tutao.lang("serverNotReachable_msg"));
            } else if (e instanceof  tutao.InvalidSoftwareVersionError) {
                tutao.tutanota.gui.alert(tutao.lang("outdatedClient_msg"));
            } else {
                if (tutao.locator.viewManager.feedbackSupported()) {
                    // only logged in users can report errors
                    tutao.locator.feedbackViewModel.open(e.stack);
                } else {
                    tutao.tutanota.gui.alert(tutao.lang("unknownError_msg"));
                }
            }
            console.log(e.stack);
        });

        if (!tutao.tutanota.app) {
            tutao.tutanota.app = ko.observable(true);
        } else {
            tutao.tutanota.app(!tutao.tutanota.app());
        }
        tutao.locator.viewManager.select(tutao.locator.fastMessageView);
        setTimeout(function () {
            tutao.locator.navigator.setup();
            tutao.locator.entropyCollector.start();

        }, 0);

        if (window.applicationCache) {
            var listener = new tutao.tutanota.ctrl.AppCacheListener();
        }

        // only for testing
        //	tutao.locator.loginViewModel.mailAddress("arne@tutanota.de");
        //	tutao.locator.loginViewModel.passphrase("arm");
        //	tutao.locator.loginViewModel.login();
        //setTimeout(function() {        tutao.locator.navigator.customer();}, 1000);

        tutao.tutanota.gui.initKnockout();
    };

    if (typeof cordova != 'undefined') {
        tutao.env.mode = tutao.Mode.App;
    }

    if (tutao.env.mode == tutao.Mode.App) {
        document.addEventListener("deviceready", launch, false);
    } else {
        $(document).ready(function () {
            launch();
        });
    }
};

tutao.tutanota.Bootstrap.getSingletons = function() {
    operative.setSelfURL("operative-0.3.1.js");

    //override native implementation with device specific one, if available
    var cryptoImpl = tutao.native.CryptoJsbn;
    var phoneImpl = tutao.native.Phone;
    var notificationImpl = tutao.native.NotificationBrowser;
    var contactImpl = tutao.native.ContactBrowser;
    var fileTransferImpl = tutao.native.FileTransferBrowser;
    if (tutao.env.mode == tutao.Mode.App) {
        console.log("overriding native interfaces");
        cryptoImpl = tutao.native.device.Crypto;
        //phoneImpl = tutao.native.device.Phone;
        //notificationImpl = tutao.native.NotificationApp;
        //contactImpl = tutao.native.ContactApp;
        //fileTransferImpl = tutao.native.FileTransferApp;
    }

    var singletons = {
        crypto: cryptoImpl,
        phone: phoneImpl,
        notification: notificationImpl,
        contacts: contactImpl,
        fileTransfer: fileTransferImpl,

        randomizer: tutao.crypto.SjclRandomizer,
        aesCrypter: tutao.crypto.AesWorkerProxy,
        rsaCrypter: tutao.native.RsaInterfaceAdapter,
        kdfCrypter: tutao.crypto.JBCryptAdapter,
        shaCrypter: tutao.crypto.SjclSha256,
        userController: tutao.ctrl.UserController,
        clientWorkerProxy: tutao.crypto.ClientWorkerProxy,
        dao: tutao.db.WebSqlDb,
        restClient: tutao.rest.RestClient,
        entityRestClient: tutao.rest.EntityRestClient,
        mailBoxController: tutao.tutanota.ctrl.MailBoxController,
        viewManager: tutao.tutanota.ctrl.ViewManager,
        loginViewModel: tutao.tutanota.ctrl.LoginViewModel,
        externalLoginViewModel: tutao.tutanota.ctrl.ExternalLoginViewModel,
        tagListViewModel: tutao.tutanota.ctrl.TagListViewModel,
        mailListViewModel: tutao.tutanota.ctrl.MailListViewModel,
        mailViewModel: tutao.tutanota.ctrl.MailViewModel,
        passwordChannelViewModel: tutao.tutanota.ctrl.PasswordChannelViewModel,
        contactListViewModel: tutao.tutanota.ctrl.ContactListViewModel,
        contactViewModel: tutao.tutanota.ctrl.ContactViewModel,
        feedbackViewModel: tutao.tutanota.ctrl.FeedbackViewModel,
        fontViewModel: tutao.tutanota.ctrl.FontViewModel,
        themeViewModel: tutao.tutanota.ctrl.ThemeViewModel,
        loginView: tutao.tutanota.gui.LoginView,
        externalLoginView: tutao.tutanota.gui.ExternalLoginView,
        notFoundView: tutao.tutanota.gui.LoginView,
        mailView: tutao.tutanota.gui.MailView,
        contactView: tutao.tutanota.gui.ContactView,
        fastMessageView: tutao.tutanota.gui.FastMessageView,
        notSupportedView: tutao.tutanota.gui.NotSupportedView,
        registrationVerifyDomainView: tutao.tutanota.gui.RegistrationVerifyDomainView,
        registrationVerifyDomainViewModel: tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel,
        registrationView: tutao.tutanota.gui.RegistrationView,
        registrationViewModel: tutao.tutanota.ctrl.RegistrationViewModel,
        settingsView: tutao.tutanota.gui.SettingsView,
        settingsViewModel: tutao.tutanota.ctrl.SettingsViewModel,
        entropyCollector: tutao.crypto.EntropyCollector,
        htmlSanitizer: tutao.tutanota.security.CajaSanitizer,
        languageViewModel: tutao.tutanota.ctrl.LanguageViewModel,
        eventBus: tutao.event.EventBusClient,
        fileViewModel: tutao.tutanota.ctrl.FileViewModel,
        fileView: tutao.tutanota.gui.FileView,
        navigator: tutao.tutanota.ctrl.Navigator,
        legacyDownloadViewModel: tutao.tutanota.ctrl.LegacyDownloadViewModel,
        progressDialogModel: tutao.tutanota.ctrl.ProgressDialogModel,
        modalPageBackgroundViewModel: tutao.tutanota.ctrl.ModalPageBackgroundViewModel
    };

    if (tutao.tutanota.util.ClientDetector.isMobileDevice()) {
        singletons['swipeRecognizer'] = tutao.tutanota.ctrl.SwipeRecognizer;
    }
    tutao.tutanota.legacy.Legacy.setup(singletons);

    return singletons;
};

tutao.tutanota.Bootstrap.initControllers = function () {
    tutao.native.CryptoJsbn.initWorkerFileNames("");
    tutao.crypto.ClientWorkerProxy.initWorkerFileNames('/js/', '/lib/worker/');

    // @type {tutao.Locator}
    tutao.locator = new tutao.Locator(tutao.tutanota.Bootstrap.getSingletons());

    var external = tutao.util.StringUtils.startsWith(location.hash, "#mail");
    tutao.locator.viewManager.init(external);

    // shortcuts
    tutao.lang = tutao.locator.languageViewModel.get;

    if (tutao.tutanota.util.ClientDetector.getDeviceType() == tutao.tutanota.util.ClientDetector.DEVICE_TYPE_IPHONE) {
        var viewport = document.querySelector("meta[name=viewport]");
        //viewport.setAttribute('content', 'initial-scale=0.85, maximum-scale=0.85, user-scalable=no');
    }

    // indexing is disabled currently
    // if (!tutao.locator.dao.isSupported() || tutao.tutanota.util.ClientDetector.isMobileDevice()) {
    tutao.locator.replace('dao', new tutao.db.DummyDb);
    // }

    // add a cache to the rest entity chain
    var cache = new tutao.rest.EntityRestCache();
    cache.setTarget(tutao.locator.entityRestClient);
    tutao.locator.replace('entityRestClient', cache);

    if (tutao.locator.swipeRecognizer) {
        tutao.locator.swipeRecognizer.setScreenSize(tutao.tutanota.gui.getWindowWidth(), tutao.tutanota.gui.getWindowHeight());
        tutao.locator.swipeRecognizer.addSwipeListener(tutao.tutanota.ctrl.SwipeRecognizer.TYPE_LEFT, function () {
            tutao.locator.viewManager.getActiveView().getSwipeSlider().swipeRecognized(tutao.tutanota.ctrl.SwipeRecognizer.TYPE_LEFT);
        });
        tutao.locator.swipeRecognizer.addSwipeListener(tutao.tutanota.ctrl.SwipeRecognizer.TYPE_RIGHT, function () {
            tutao.locator.viewManager.getActiveView().getSwipeSlider().swipeRecognized(tutao.tutanota.ctrl.SwipeRecognizer.TYPE_RIGHT);
        });
    }

    tutao.tutanota.gui.initEvents();

    tutao.tutanota.gui.addWindowResizeListener(function (width, height) {
        // notify the active view and the swipe recognizer
        if (tutao.locator.viewManager.getActiveView() != null) {
            tutao.locator.viewManager.getActiveView().getSwipeSlider().windowSizeChanged(width, height);
        }
        if (tutao.locator.swipeRecognizer) {
            tutao.locator.swipeRecognizer.setScreenSize(width, height);
        }
    });
};
"use strict";

tutao.provide('tutao.Locator');

/**
 * The Locator is our central instance cache. It is a "singleton store"
 * that is used to retrieve instances.
 * The Locator is used instead of dependency injection.
 * @constructor
 * @param {Object.<string, Object>} services A map of service names and constructors or constructor/argument pairs.
 * @param {function()=} initializer The initializer sets up the locator and is used on each reset
 * The constructors are used to create the services. Getters are defined for every service.
 */
tutao.Locator = function(services, initializer) {
	/**
	 * @type {Object.<string, Object>} the mapping from service names to cached instances
	 */
	this._services = services;
	this._initializer = initializer ? initializer : function() {};
	this._replacedStaticMethods = [];

    // @type {tutao.native.CryptoInterface}
    this.crypto = null;
    // @type {tutao.native.PhoneInterface}
    this.phone = null;
    // @type {tutao.native.NotificationInterface}
    this.notification = null;
    // @type {tutao.native.ContactInterface}
    this.contacts = null;
    // @type {tutao.native.FileTransferInterface}
    this.fileTransfer = null;

    // @type {tutao.crypto.SjclRandomizer}
    this.randomizer= null;
    // @type {tutao.crypto.AesWorkerProxy}
    this.aesCrypter= null;
    // @type {tutao.crypto.RsaWorkerProxy}
    this.rsaCrypter= null;
    // @type {tutao.crypto.JBCryptAdapter}
    this.kdfCrypter= null;
    // @type {tutao.crypto.SjclSha256}
    this.shaCrypter= null;
    // @type {tutao.ctrl.UserController}
    this.userController= null;
    // @type {tutao.crypto.ClientWorkerProxy}
    this.clientWorkerProxy= null;
    // @type {tutao.db.WebSqlDb}
    this.dao= null;
    // @type {tutao.rest.RestClient}
    this.restClient= null;
    // @type {tutao.rest.EntityRestClient}
    this.entityRestClient= null;
    // @type {tutao.tutanota.index.Indexer}
    this.indexer= null;
    // @type {tutao.tutanota.ctrl.MailBoxController}
    this.mailBoxController= null;
    // @type {tutao.tutanota.ctrl.ViewManager}
    this.viewManager= null;
    // @type {tutao.tutanota.ctrl.LoginViewModel}
    this.loginViewModel= null;
    // @type {tutao.tutanota.ctrl.ExternalLoginViewModel}
    this.externalLoginViewModel= null;
    // @type {tutao.tutanota.ctrl.TagListViewModel}
    this.tagListViewModel= null;
    // @type {tutao.tutanota.ctrl.MailListViewModel}
    this.mailListViewModel= null;
    // @type {tutao.tutanota.ctrl.MailViewModel}
    this.mailViewModel= null;
    // @type {tutao.tutanota.ctrl.PasswordChannelViewModel}
    this.passwordChannelViewModel= null;
    // @type {tutao.tutanota.ctrl.ContactListViewModel}
    this.contactListViewModel= null;
    // @type {tutao.tutanota.ctrl.ContactViewModel}
    this.contactViewModel= null;
    // @type {tutao.tutanota.ctrl.FeedbackViewModel}
    this.feedbackViewModel= null;
    // @type {tutao.tutanota.ctrl.FontViewModel}
    this.fontViewModel= null;
    // @type {tutao.tutanota.ctrl.ThemeViewModel}
    this.themeViewModel= null;
    // @type {tutao.tutanota.gui.LoginView}
    this.loginView= null;
    // @type {tutao.tutanota.gui.ExternalLoginView}
    this.externalLoginView= null;
    // @type {tutao.tutanota.gui.LoginView}
    this.notFoundView= null;
    // @type {tutao.tutanota.gui.MailView}
    this.mailView= null;
    // @type {tutao.tutanota.gui.ContactView}
    this.contactView= null;
    // @type {tutao.tutanota.gui.FastMessageView}
    this.fastMessageView= null;
    // @type {tutao.tutanota.gui.NotSupportedView}
    this.notSupportedView= null;
    // @type {tutao.tutanota.gui.RegistrationVerifyDomainView}
    this.registrationVerifyDomainView= null;
    // @type {tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel}
    this.registrationVerifyDomainViewModel= null;
    // @type {tutao.tutanota.gui.RegistrationView}
    this.registrationView= null;
    // @type {tutao.tutanota.ctrl.RegistrationViewModel}
    this.registrationViewModel= null;
    // @type {tutao.tutanota.gui.LogView}
    this.logView= null;
    // @type {tutao.tutanota.ctrl.LogViewModel}
    this.logViewModel= null;
    // @type {tutao.tutanota.gui.DbView}
    this.dbView= null;
    // @type {tutao.tutanota.ctrl.DbViewModel}
    this.dbViewModel= null;
    // @type {tutao.tutanota.gui.MonitorView}
    this.monitorView= null;
    // @type {tutao.tutanota.ctrl.MonitorViewModel}
    this.monitorViewModel= null;
    // @type {tutao.tutanota.gui.ConfigView}
    this.configView= null;
    // @type {tutao.tutanota.ctrl.ConfigViewModel}
    this.configViewModel= null;
    // @type {tutao.tutanota.gui.CustomerView}
    this.customerView= null;
    // @type {tutao.tutanota.ctrl.CustomerViewModel}
    this.customerViewModel= null;
    // @type {tutao.tutanota.gui.SettingsView}
    this.settingsView= null;
    // @type {tutao.tutanota.ctrl.SettingsViewModel}
    this.settingsViewModel= null;
    // @type {tutao.crypto.EntropyCollector}
    this.entropyCollector= null;
    // @type {tutao.tutanota.security.CajaSanitizer}
    this.htmlSanitizer= null;
    // @type {tutao.tutanota.ctrl.LanguageViewModel}
    this.languageViewModel= null;
    // @type {tutao.event.EventBusClient}
    this.eventBus= null;
    // @type {tutao.tutanota.ctrl.FileViewModel}
    this.fileViewModel= null;
    // @type {tutao.tutanota.gui.FileView}
    this.fileView= null;
    // @type {tutao.tutanota.ctrl.Navigator}
    this.navigator= null;
    // @type {tutao.tutanota.ctrl.LegacyDownloadViewModel}
    this.legacyDownloadViewModel= null;
    // @type {tutao.tutanota.ctrl.ProgressDialogModel}
    this.progressDialogModel= null;
    // @type {tutao.tutanota.ctrl.ModalPageBackgroundViewModel}
    this.modalPageBackgroundViewModel= null;

	this.reset();
};

/**
 * Only for Testing: sets an instance to be returned on requests for a specific serviceName
 * @param {string} serviceName Service name.
 * @param {Object} instance Instance to return.
 */
tutao.Locator.prototype.replace = function(serviceName, instance) {
	var self = this;
	self[serviceName] = instance;
};

/**
 * Only for Testing: overrides a static method and saves it's original behavior.
 * @param {Object} clazz The class where the function should be replaced.
 * @param {function(...[Object])} original The original function defined on class.
 * @param {function(...[Object])} replacement The replacement function to define on class.
 */
tutao.Locator.prototype.replaceStatic = function(clazz, original, replacement) {
	for (var attributeName in clazz) {
		if (clazz[attributeName] === original) {
			clazz[attributeName] = replacement;
			this._replacedStaticMethods.push({clazz: clazz, attributeName: attributeName, original: original});
			return;
		}
	}
	throw new Error("did not find function in clazz");
};

/**
 * removes all cached instances
 */
tutao.Locator.prototype.reset = function() {
	var self = this;
	for (var serviceName in this._services) {
		var Constructor = this._services[serviceName];
        if (typeof Constructor == "undefined") {
            throw new Error("failed to create " + serviceName);
        }
		self[serviceName] = new Constructor();
	}

	for (var i = 0; i < this._replacedStaticMethods.length; i++) {
		var a = this._replacedStaticMethods[i];
		a.clazz[a.attributeName] = a.original;
	}
	this._replacedStaticMethods = [];
	this._initializer();
};

"use strict";

tutao.provide('tutao.crypto.AesInterface');

/**
 * This Interface provides an abstraction of the AES cryptographic implementation.
 * A concrete instance is bound by the Locator.
 * @interface
 */
tutao.crypto.AesInterface = function() {};

/**
 * Create a random 128 bit symmetric AES key.
 * @return {Object} The key.
 */
tutao.crypto.AesInterface.prototype.generateRandomKey = function() {};

/**
 * Converts the given key to a hex string.
 * @param {Object} key The key.
 * @return {String} The hex string representation of the key.
 */
tutao.crypto.AesInterface.prototype.keyToHex = function(key) {};

/**
 * Converts the given key to a base64 coded string.
 * @param {Object} key The key.
 * @return {String} The base64 coded string representation of the key.
 */
tutao.crypto.AesInterface.prototype.keyToBase64 = function(key) {};

/**
 * Converts the given hex string to a key.
 * @param {String} hex The hex string representation of the key.
 * @return {Object} The key.
 * @throws {tutao.crypto.CryptoError} If the conversion fails.
 */
tutao.crypto.AesInterface.prototype.hexToKey = function(hex) {};

/**
 * Converts the given base64 coded string to a key.
 * @param {String} base64 The base64 coded string representation of the key.
 * @return {Object} The key.
 * @throws {tutao.crypto.CryptoError} If the conversion fails.
 */
tutao.crypto.AesInterface.prototype.base64ToKey = function(base64) {};

/**
 * Encrypts an utf8 coded string with AES in CBC mode.
 * @param {Object} key The key to use for the encryption.
 * @param {String} utf8 Utf8 coded data.
 * @return {String} The encrypted text, base64 coded.
 * @throws {tutao.crypto.CryptoError} If the encryption fails.
 */
tutao.crypto.AesInterface.prototype.encryptUtf8 = function(key, utf8) {};

/**
 * Decrypts base64 coded binary data with AES in CBC mode to a utf8 string.
 * @param {Object} key The key to use for the decryption.
 * @param {String} base64 A base64 coded string that was encrypted with the same key before.
 * @return {String} The decrypted text, utf8 coded.
 * @throws {tutao.crypto.CryptoError} If the decryption fails.
 */
tutao.crypto.AesInterface.prototype.decryptUtf8 = function(key, base64) {};

/**
 * Encrypts an utf8 coded string with AES in CBC mode with a static initialization vector for search indices.
 * @param {Object} key The key to use for the encryption.
 * @param {String} utf8 Utf8 coded data.
 * @return {String} The encrypted text, base64 coded.
 * @throws {tutao.crypto.CryptoError} If the encryption fails.
 */
tutao.crypto.AesInterface.prototype.encryptUtf8Index = function(key, utf8) {};

/**
 * Decrypts base64 coded binary data with AES in CBC mode to a utf8 string with a static initialization vector for search indices.
 * @param {Object} key The key to use for the decryption.
 * @param {String} base64 A base64 coded string that was encrypted with the same key before.
 * @return {String} The decrypted text, utf8 coded.
 * @throws {tutao.crypto.CryptoError} If the decryption fails.
 */
tutao.crypto.AesInterface.prototype.decryptUtf8Index = function(key, base64) {};


/**
 * Encrypts bytes coded as base64 with AES in CBC mode.
 * @param {Object} key The key to use for the encryption.
 * @param {String} base64 Bas64 coded bytes.
 * @return {String} The encrypted bytes, base64 coded.
 * @throws {tutao.crypto.CryptoError} If the encryption fails.
 */
tutao.crypto.AesInterface.prototype.encryptBytes = function(key, base64) {};

/**
 * Decrypts base64 coded binary data with AES in CBC mode to bytes.
 * @param {Object} key The key to use for the decryption.
 * @param {String} base64 A base64 coded string that represents the encrypted bytes that weres encrypted with the same key before.
 * @return {String} The decrypted bytes, base64 coded.
 * @throws {tutao.crypto.CryptoError} If the decryption fails.
 */
tutao.crypto.AesInterface.prototype.decryptBytes = function(key, base64) {};

/**
 * Encrypts a hex coded key with AES in CBC mode.
 * @param {Object} key The key to use for the encryption.
 * @param {Object} keyToEncrypt The key that shall be encrypted.
 * @return {String} The encrypted key, base64 coded.
 * @throws {tutao.crypto.CryptoError} If the encryption fails.
 */
tutao.crypto.AesInterface.prototype.encryptKey = function(key, keyToEncrypt) {};

/**
 * Decrypts a base64 coded key with AES in CBC mode.
 * @param {Object} key The key to use for the decryption.
 * @param {String} base64 The key that shall be decrypted, base64 coded.
 * @return {Object} The decrypted key.
 * @throws {tutao.crypto.CryptoError} If the decryption fails.
 */
tutao.crypto.AesInterface.prototype.decryptKey = function(key, base64) {};

/**
 * Encrypts a hex coded RSA private key with AES in CBC mode.
 * @param {Object} key The key to use for the encryption.
 * @param {String} keyToEncrypt The key that shall be encrypted, hex coded.
 * @return {String} The encrypted key, base64 coded.
 * @throws {tutao.crypto.CryptoError} If the encryption fails.
 */
tutao.crypto.AesInterface.prototype.encryptPrivateRsaKey = function(key, hexRsaPrivateKey) {};

/**
 * Decrypts an encrypted private RSA key with AES in CBC mode.
 * @param {Object} key The key to use for the decryption.
 * @param {String} base64 The key that shall be decrypted, base64 coded.
 * @return {String} The decrypted private RSA key, hex coded.
 * @throws {tutao.crypto.CryptoError} If the decryption fails.
 */
tutao.crypto.AesInterface.prototype.decryptPrivateRsaKey = function(key, base64) {};

/**
 * Encrypts the content of an array buffer with AES in CBC mode.
 * @param {Object} key The key to use for the encryption.
 * @param {ArrayBuffer} arrayBuffer The plain text data.
 * @param {function(?ArrayBuffer,tutao.crypto.CryptoError=)} callback Called when finished receiving the encrypted array buffer. Receives an exception if the encryption failed.
 */
tutao.crypto.AesInterface.prototype.encryptArrayBuffer = function(key, arrayBuffer, callback) {};

/**
 * Decrypts the content of an array buffer with AES in CBC mode.
 * @param {Object} key The key to use for the decryption.
 * @param {ArrayBuffer} arrayBuffer The encrypted data.
 * @param {number} decryptedSize The number of bytes the decrypted data.
 * @param {function(?ArrayBuffer,tutao.crypto.CryptoError=)} callback Called when finished receiving the decrypted array buffer. Receives an exception if the decryption failed.
 */
tutao.crypto.AesInterface.prototype.decryptArrayBuffer = function(key, arrayBuffer, decryptedSize, callback) {};

/**
 * LEGACY: Decrypts the content of base64 coded binary data in CBC mode and provides the decrypted data as base64.
 * @param {Object} key The key to use for the decryption.
 * @param {String} srcBase64 The encrypted data, base64 coded.
 * @param {number} decryptedSize The number of bytes the decrypted data.
 * @param {function(?String,tutao.crypto.CryptoError=)} callback Called when finished receiving the decrypted base64 data. Receives an exception if the decryption failed.
 */
tutao.crypto.AesInterface.prototype.decryptBase64 = function(key, srcBase64, decryptedSize, callback) {};

"use strict";

tutao.provide('tutao.crypto.AesWorkerProxy');

/**
 * @constructor
 * @param {tutao.crypto.AesInterface=} aes The actual AES implementation. If not provided, then SjclAes is used.
 * @implements {tutao.crypto.AesInterface}
 */
tutao.crypto.AesWorkerProxy = function(aes) {
	if (aes) {
		this._aes = aes;
	} else {
		this._aes = new tutao.crypto.SjclAes();
	}
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.generateRandomKey = function() {
	return this._aes.generateRandomKey();
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.keyToHex = function(key) {
	return this._aes.keyToHex(key);
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.keyToBase64 = function(key) {
	return this._aes.keyToBase64(key);
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.hexToKey = function(hex) {
	return this._aes.hexToKey(hex);
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.base64ToKey = function(base64) {
	return this._aes.base64ToKey(base64);
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.encryptUtf8 = function(key, utf8) {
	return this._aes.encryptUtf8(key, utf8);
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.decryptUtf8 = function(key, base64) {
	return this._aes.decryptUtf8(key, base64);
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.encryptUtf8Index = function(key, utf8) {
    return this._aes.encryptUtf8Index(key, utf8);
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.decryptUtf8Index = function(key, base64) {
    return this._aes.decryptUtf8Index(key, base64);
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.encryptBytes = function(key, base64) {
	return this._aes.encryptBytes(key, base64);
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.decryptBytes = function(key, base64) {
	return this._aes.decryptBytes(key, base64);
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.encryptKey = function(key, keyToEncrypt) {
	return this._aes.encryptKey(key, keyToEncrypt);
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.decryptKey = function(key, base64) {
	return this._aes.decryptKey(key, base64);
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.encryptPrivateRsaKey = function(key, hexKeyToEncrypt) {
	return this._aes.encryptPrivateRsaKey(key, hexKeyToEncrypt);
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.decryptPrivateRsaKey = function(key, base64) {
	return this._aes.decryptPrivateRsaKey(key, base64);
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.encryptArrayBuffer = function(key, srcBuffer, callback) {
	// pass random data for the iv padding
	var data = { key: this.keyToHex(key), data: srcBuffer, randomData: tutao.locator.randomizer.generateRandomData(32) };
	tutao.locator.clientWorkerProxy.sendCommand("encryptArrayBuffer", data, function(encrypted, errorMessage) {
		if (errorMessage) {
			callback(null, new tutao.crypto.CryptoError(errorMessage));
		} else {
			callback(encrypted);
		}
	});
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.decryptArrayBuffer = function(key, srcBuffer, decryptedSize, callback) {
	var data = { key: this.keyToHex(key), data: srcBuffer, decryptedSize: decryptedSize };
	tutao.locator.clientWorkerProxy.sendCommand("decryptArrayBuffer", data, function(decrypted, errorMessage) {
		if (errorMessage) {
			callback(null, new tutao.crypto.CryptoError(errorMessage));
		} else {
			callback(decrypted);
		}
	});
};

/**
 * @inheritDoc
 */
tutao.crypto.AesWorkerProxy.prototype.decryptBase64 = function(key, srcBase64, decryptedSize, callback) {
	throw new tutao.crypto.CryptoError("legacy implementation, not meant to be used with a worker!");
};

"use strict";

// this file shall only be loaded if we are in the worker scope
var global = Function('return this')();
if (global.importScripts) {

	/**
	 * There may be only one command running at any time, no new command is allowed to be sent to this worker as long as the current one has not finished execution.
	 */
	global.addEventListener('message', function(e) {
		var me = self;
		var operation = e.data.operation;
		var data = e.data.data;
		if (operation == "initWorker") {
			for (var i = 0; i < data.imports.length; i++) {
				importScripts(data.imports[i]);
			}
			// simulate the locator with all objects needed
			eval("tutao.locator = { randomizer: new tutao.crypto.WorkerRandomizer(), aesCrypter: new tutao.crypto.SjclAes(), rsaCrypter: new tutao.crypto.JsbnRsa() };");
			me.postMessage({});
		} else if (operation == "encryptAesKey") {
			tutao.locator.randomizer.setNextRandomBytes(data.randomData);
			tutao.locator.rsaCrypter.encryptAesKey(tutao.locator.rsaCrypter.hexToKey(data.key), data.data, function(encryptedKey, exception) {
				if (exception) {
					// send exception messages as message attribute
					me.postMessage({message: exception.message});
				} else {
					me.postMessage(encryptedKey);
				}
			});
		} else if (operation == "decryptAesKey") {
			tutao.locator.rsaCrypter.decryptAesKey(tutao.locator.rsaCrypter.hexToKey(data.key), data.data, function(decryptedKey, exception) {
				if (exception) {
					me.postMessage({message: exception.message});
				} else {
					me.postMessage(decryptedKey);
				}
			});
		} else if (operation == "generateKeyPair") {
            tutao.locator.randomizer.setNextRandomBytes(data.randomData);
			tutao.locator.rsaCrypter.generateKeyPair(function(keyPair, exception) {
				if (exception) {
					me.postMessage({message: exception.message});
				} else {
					var publicKey = tutao.locator.rsaCrypter.keyToHex(keyPair.publicKey);
					var privateKey = tutao.locator.rsaCrypter.keyToHex(keyPair.privateKey);
					me.postMessage({publicKeyHex: publicKey, privateKeyHex: privateKey});
				}
			});
		} else if (operation == "encryptArrayBuffer") {
			tutao.locator.randomizer.setNextRandomBytes(data.randomData);
			tutao.locator.aesCrypter.encryptArrayBuffer(tutao.locator.aesCrypter.hexToKey(data.key), data.data, function(encrypted, exception) {
				if (exception) {
					// send exception messages as message attribute
					me.postMessage({message: exception.message});
				} else {
					me.postMessage(encrypted);
				}
			});
		} else if (operation == "decryptArrayBuffer") {
			tutao.locator.aesCrypter.decryptArrayBuffer(tutao.locator.aesCrypter.hexToKey(data.key), data.data, data.decryptedSize, function(decrypted, exception) {
				if (exception) {
					// send exception messages as message attribute
					me.postMessage({message: exception.message});
				} else {
					me.postMessage(decrypted);
				}
			});
		}
	}, false);
}

"use strict";

if (typeof tutao === "undefined") {
    this['tutao'] = {};
    tutao.crypto = {};
} else {
    tutao.provide('tutao.crypto.ClientWorkerImpl');
}

/**
 * This is the actual worker implementation. The worker communications with the ClientWorkerProxy via postMessage.
 * @param {Object} workerScope The scope of the worker
 * @constructor
 */
tutao.crypto.ClientWorkerImpl = function(workerScope) {
    this._taskId = 0;
    // the queue elements have the following format: this._runningTasks[id] = {callback: function(?Object,string=)}
    this._runningTasks = {};
    this._workerScope = workerScope;
};

tutao.crypto.ClientWorkerImpl.prototype._sendResult = function(id, result, exception) {
    if (exception) {
        this._workerScope.postMessage({resultId: id, result: result, exception: {message: exception.message, stack: exception.stack}});
    } else {
        this._workerScope.postMessage({resultId: id, result: result});
    }
};

tutao.crypto.ClientWorkerImpl.prototype.initWorker = function(id, data) {
    for (var i = 0; i < data.imports.length; i++) {
        importScripts(data.imports[i]);
    }
    // simulate the locator with all objects needed
    eval("tutao.locator = { randomizer: new tutao.crypto.WorkerRandomizer(), aesCrypter: new tutao.crypto.SjclAes(), rsaCrypter: new tutao.crypto.JsbnRsa() };");
    this._sendResult(id, {});
};

tutao.crypto.ClientWorkerImpl.prototype.encryptAesKey = function(id, data) {
    var self = this;
    tutao.locator.randomizer.setNextRandomBytes(data.randomData);
    tutao.locator.rsaCrypter.encryptAesKey(tutao.locator.rsaCrypter.hexToKey(data.key), data.data, function(encryptedKey, exception) {
        self._sendResult(id, encryptedKey, exception);
    });
};

tutao.crypto.ClientWorkerImpl.prototype.decryptAesKey = function(id, data) {
    var self = this;
    tutao.locator.rsaCrypter.decryptAesKey(tutao.locator.rsaCrypter.hexToKey(data.key), data.data, function(decryptedKey, exception) {
        self._sendResult(id, decryptedKey, exception);
    });
};

tutao.crypto.ClientWorkerImpl.prototype.generateKeyPair = function(id, data) {
    var self = this;
    tutao.locator.randomizer.setNextRandomBytes(data.randomData);
    tutao.locator.rsaCrypter.generateKeyPair(function(keyPair, exception) {
        if (exception) {
            self._sendResult(id, null, exception);
        } else {
            var publicKey = tutao.locator.rsaCrypter.keyToHex(keyPair.publicKey);
            var privateKey = tutao.locator.rsaCrypter.keyToHex(keyPair.privateKey);
            self._sendResult(id, {publicKeyHex: publicKey, privateKeyHex: privateKey}, exception);
        }
    });
};

tutao.crypto.ClientWorkerImpl.prototype.encryptArrayBuffer = function(id, data) {
    var self = this;
    tutao.locator.randomizer.setNextRandomBytes(data.randomData);
    tutao.locator.aesCrypter.encryptArrayBuffer(tutao.locator.aesCrypter.hexToKey(data.key), data.data, function(encrypted, exception) {
        self._sendResult(id, encrypted, exception);
    });
};

tutao.crypto.ClientWorkerImpl.prototype.decryptArrayBuffer = function(id, data) {
    var self = this;
    tutao.locator.aesCrypter.decryptArrayBuffer(tutao.locator.aesCrypter.hexToKey(data.key), data.data, data.decryptedSize, function(decrypted, exception) {
        self._sendResult(id, decrypted, exception);
    });
};

/**
 * Pass a command to the main Thread.
 * @param {String} operation A name that identifies the command on the worker side.
 * @param {Object} data An arbitrary object to be passed to the worker.
 * @param {function(?Object,string=)} callback Called when the command is finished. Receives the data result from the worker. If an error occurred, the result is null and an
 * error message is passed as second argument.
 */
tutao.crypto.ClientWorkerImpl.prototype.sendCommand = function(operation, data, callback) {
    var id = this._getNextTaskId();
    this._runningTasks.push[id] = { callback: callback };
    this._worker.postMessage({id: id, operation: operation, data: data });
};

tutao.crypto.ClientWorkerImpl.prototype._getNextTaskId = function() {
    var id = this._taskId++;
    if (id == 9007199254740992) { // we have to start on zero on overflow (http://stackoverflow.com/a/307200)
        this._taskId = 0;
    }
    return id;
};

// this file shall only be loaded if we are in the worker scope
/* TODO (before release) switch from ClientWorkerProxy to this implementation and from ClientWorker to ClientWorkerImpl
var global = Function('return this')();
if (global.importScripts) {
    // There may be only one command running at any time, no new command is allowed to be sent to this worker as long as the current one has not finished execution.
    var clientWorkerImpl = new tutao.crypto.ClientWorkerImpl(self);
    global.addEventListener('message', function(event) {
        var resultId = event.data.resultId;
        if (typeof resultId === "number") {
            // this is a response to a previous request
            var exceptionMessage = null;
            if (event.data.exception) {
                exceptionMessage = event.data.exception.message;
            }
            clientWorkerImpl._runningTasks[resultId].callback(event.data.result, exceptionMessage);
            delete clientWorkerImpl._runningTasks[resultId];
        } else {
            clientWorkerImpl[event.data.operation](event.data.id, event.data.data);
        }

    }, false);
}
*/
"use strict";

tutao.provide('tutao.crypto.ClientWorkerProxy');

/**
 * The worker proxy acts as a proxy to a worker. It is responsible for creating the worker and may receive arbitrary commands for the worker. The worker
 * must contain an implementation that supports the command data. The result is passed back to a callback. A command queue makes sure that only one command at
 * a time is passed to the worker.
 * @constructor
 */
tutao.crypto.ClientWorkerProxy = function() {
	// the queue elements have the following format: {callback: function, operation: name, key: optionalKey, data: optionalData}
	this._queue = [];

	var self = this;

	this._worker = new Worker(tutao.crypto.ClientWorkerProxy.WORKER_FILE);

	this._worker.addEventListener('message', function(event) {
		var executedCommand = self._queue.splice(0, 1)[0]; // remove finished operation from the queue (first element)

		// send the next command now before calling the callback to avoid that inside the callback another command is added, directly executed
		// and then we send the same command again
		if (self._queue.length > 0) {
			self._sendNextOperation();
		}

		// if the message attribute is set, then an exception has occurred
		if (event.data.message) {
			executedCommand.callback(null, event.data.message);
		} else {
			executedCommand.callback(event.data);
		}
	}, false);
	this._worker.onerror = function(event) {
	    throw new Error(event.message + " (" + event.filename + ":" + event.lineno + ")");
	};

	this.sendCommand("initWorker", { imports: tutao.crypto.ClientWorkerProxy.WORKER_IMPORTS }, function() {});
};

tutao.crypto.ClientWorkerProxy.initWorkerFileNames = function(srcPath, libsPath) {
    if (tutao.env.type === tutao.Env.LOCAL) {
        tutao.crypto.ClientWorkerProxy.WORKER_FILE = srcPath + 'crypto/ClientWorker.js';
        tutao.crypto.ClientWorkerProxy.WORKER_IMPORTS = [
                libsPath + 'base.js',
                libsPath + 'crypto-jsbn-2012-08-09_1.js',
                libsPath + 'crypto-sjcl-2012-08-09_1.js',
                srcPath + 'crypto/AesInterface.js',
                srcPath + 'crypto/SjclAes.js',
                srcPath + 'crypto/RsaInterface.js',
                srcPath + 'crypto/JsbnRsa.js',
                srcPath + 'crypto/CryptoError.js',
                srcPath + 'crypto/RandomizerInterface.js',
                srcPath + 'crypto/WorkerRandomizer.js',
                srcPath + 'crypto/Oaep.js',
                srcPath + 'util/EncodingConverter.js'
        ];
    } else {
        tutao.crypto.ClientWorkerProxy.WORKER_FILE = 'app.min.js';
        tutao.crypto.ClientWorkerProxy.WORKER_IMPORTS = [];
    }
};

/**
 * Pass a command to the worker. The command might be queued and sent later.
 * @param {string} operation A name that identifies the command on the worker side.
 * @param {Object} data An arbitrary object to be passed to the worker.
 * @param {function(?Object,string=)} callback Called when the command is finished. Receives the data result from the worker. If an error occurred, the result is null and an
 * error message is passed as second argument.
 */
tutao.crypto.ClientWorkerProxy.prototype.sendCommand = function(operation, data, callback) {
	this._queue.push({ operation: operation, data: data, callback: callback });
	if (this._queue.length == 1) {
		this._sendNextOperation();
	}
};

/**
 * Sends the next operation to the worker.
 * @pre this._queue.length > 0, worker is not busy
 */
tutao.crypto.ClientWorkerProxy.prototype._sendNextOperation = function() {
	this._worker.postMessage({ operation: this._queue[0].operation, data: this._queue[0].data });
};

"use strict";

tutao.provide('tutao.crypto.CryptoError');

/**
 * A crypto exception is thrown whenever an encryption/decryption or conversion of keys fails.
 * @param {string} message An information about the exception.
 * @param {Error=} error The original error that was thrown.
 * @constructor
 */
tutao.crypto.CryptoError = function(message, error) {
	if (!error) {
		this.message = message;
	} else {
		this.message = message + ", original message: " + error.message;
	}

    if (Error.captureStackTrace) {
        Error.captureStackTrace(this, tutao.crypto.CryptoError);
    } else {
        var error = new Error();
        if (!error.stack){
            // fill the stack trace on ios devices
            try {
                throw error;
            } catch (e) {
            }
        }
        this.stack = this.name + ". " + this.message + "\n" + error.stack.split("\n").slice(1).join("\n"); // removes first line from stack
    }

	this.name = "CryptoError";
	this.error = error;
};

tutao.crypto.CryptoError.prototype = Object.create(Error.prototype);
tutao.crypto.CryptoError.prototype.constructor = tutao.crypto.CryptoError;
"use strict";

tutao.provide('tutao.crypto.EntropyCollector');

/**
 * Automatically collects entropy and feeds it into the Randomizer.
 */
tutao.crypto.EntropyCollector = function() {
	this.intervalId = null;
};

/**
 * Starts collecting entropy.
 */
tutao.crypto.EntropyCollector.prototype.start = function() {
	if (window.performance && window.performance.timing) {
		// get values from window.performance.timing
		var values = window.performance.timing;
		for (var v in values) {
			if (typeof values[v] == "number" && values[v] != 0) {
				tutao.locator.randomizer.addEntropy(values[v], 1, tutao.crypto.RandomizerInterface.ENTROPY_SRC_STATIC);
			}
		}
	}

	// get cryptographically strong values if available
	try {
	    var valueList = new Uint32Array(32);
	    window.crypto.getRandomValues(valueList);
	    for (var i = 0; i < valueList.length; i++) {
	    	tutao.locator.randomizer.addEntropy(valueList[i], 32, tutao.crypto.RandomizerInterface.ENTROPY_SRC_RANDOM);
	    }
	} catch (e) {}
	this.stopped = false;
	$("body").bind("mousemove", this._mouse);
	$("body").bind("mouseclick", this._mouse);
	$("body").bind("keydown", this._keyDown);
	this.intervalId = setInterval(this._random, 1000);

    //this._checkEntropy();
};

/* just for testing
tutao.crypto.EntropyCollector.prototype._checkEntropy = function() {
    var self = this;
    if (!tutao.locator.randomizer.isReady()) {
        console.log("missing entropy");
        setTimeout(function() {
            self._checkEntropy();
        }, 1000);
    } else {
        console.log("enough entropy");
    }
};*/

/**
 * Stops collecting entropy.
 */
tutao.crypto.EntropyCollector.prototype.stop = function() {
	this.stopped = true;
	$("body").unbind("mousemove", this._mouse);
	$("body").unbind("mouseclick", this._mouse);
	$("body").unbind("keydown", this._keyDown);
	clearInterval(this.intervalId);
};

/**
 * Add data from the given mouse event as entropy.
 */
tutao.crypto.EntropyCollector.prototype._mouse = function(e) {
	var value = e.pageX ^ e.pageY;
	tutao.locator.randomizer.addEntropy(value, 2, tutao.crypto.RandomizerInterface.ENTROPY_SRC_MOUSE);
};

/**
 * Add data from the given key event as entropy.
 */
tutao.crypto.EntropyCollector.prototype._keyDown = function(e) {
	var value = e.keyCode;
	tutao.locator.randomizer.addEntropy(value, 2, tutao.crypto.RandomizerInterface.ENTROPY_SRC_KEY);
};

/**
 * Add data from either secure random source or Math.random as entropy.
 */
tutao.crypto.EntropyCollector.prototype._random = function() {
	try {
		// get cryptographically strong values if available
	    var valueList = new Uint32Array(1);
	    window.crypto.getRandomValues(valueList);
	    tutao.locator.randomizer.addEntropy(valueList[0], 32, tutao.crypto.RandomizerInterface.ENTROPY_SRC_RANDOM);
	  } catch (e) {
		 var value = Math.floor(tutao.crypto.EntropyCollector._getRandomNumber() * 0x100000000);
		 tutao.locator.randomizer.addEntropy(value, 1, tutao.crypto.RandomizerInterface.ENTROPY_SRC_RANDOM);
	  }
};

/**
 * A wrapper for Math.random().
 */
tutao.crypto.EntropyCollector._getRandomNumber = function() {
	return Math.random();
};

/**
 * Adds the given bytes as static entropy.
 * @param {string} bytes Base64 coded byte values.
 */
tutao.crypto.EntropyCollector.prototype.addStaticEntropy = function(bytes) {
    var byteArray = tutao.util.EncodingConverter.hexToBytes(tutao.util.EncodingConverter.base64ToHex(bytes));
    for (var i=0; i<byteArray.length; i++) {
        tutao.locator.randomizer.addEntropy(byteArray[i], 8, tutao.crypto.RandomizerInterface.ENTROPY_SRC_STATIC);
    }
};

/**
 * Fetches the missing entropy by pinging URLs from tutao.crypto.EntropyCollector.URLs and measuring the response times.
 * @param {function()} callback Called when the randomizer has been initialized.
 */
tutao.crypto.EntropyCollector.prototype.fetchMissingEntropy = function(callback) {
	var self = this;
	if (tutao.locator.randomizer.isReady()) {
		callback();
		return;
	}

    tutao.util.FunctionUtils.executeInParallel(10, function(finishedCallback) {
        var url = tutao.crypto.EntropyCollector.URLs[Math.floor(tutao.crypto.EntropyCollector._getRandomNumber() * tutao.crypto.EntropyCollector.URLs.length)];

        self._ping(url, function(diff) {
            tutao.locator.randomizer.addEntropy(diff, 4, tutao.crypto.RandomizerInterface.ENTROPY_SRC_PING);
            //console.log("fetched entropy: " + url + ", " + diff);
            finishedCallback(!tutao.locator.randomizer.isReady());
        });
    }, callback);
};

tutao.crypto.EntropyCollector.URLs = ["www.heise.de", "www.cnn.com", "www.google.cn", "www.facebook.com", "www.mail.ru", "www.linkedin.com", "www.hotmail.com", "www.rakuten.co.jp", "www.aol.com", "www.yahoo.com", "www.craigslist.org", "www.imageshack.us", "www.imdb.com", "www.bbc.com", "www.cnet.com", "www.paypal.com", "www.fc2.com", "www.tudou.com", "www.photobucket.com", "www.flickr.com", "www.about.com", "www.windows.com", "www.apple.com", "www.sohu.com", "www.ebay.com", "www.myspace.com", "www.youku.com", "www.yahoo.co.jp", "www.amazon.com", "www.taobao.com", "www.twitter.com", "www.ask.com", "www.adobe.com", "www.bing.com", "www.sina.com.cn", "www.qq.com", "www.baidu.com", "www.msn.com"];

/**
 * @param {string} url The url to ping.
 * @param {function(number)} callback Called when the ping has been finished. The time that it took to ping the url is passed to the callback.
 */
tutao.crypto.EntropyCollector.prototype._ping = function(url, callback) {
	var img = new Image();
	var start = new Date().getTime();

	var resultCallback = function() {
		var diff = new Date().getTime() - start;
		callback(diff);
	};

	img.onload = resultCallback;
	img.onerror = resultCallback;

	img.src = "http://" + url + "/donotfetch?time=" + new Date().getTime();
};

"use strict";

tutao.provide('tutao.crypto.JBCryptAdapter');

/**
 * @constructor
 * @implements {tutao.crypto.KdfInterface}
 */
tutao.crypto.JBCryptAdapter = function() {
	this.keyLength = 128;
	this.logRounds = 8; // pbkdf2 number of iterations
};

/**
 * @inheritDoc
 */
tutao.crypto.JBCryptAdapter.prototype.generateRandomSalt = function() {
	return tutao.locator.randomizer.generateRandomData(this.keyLength / 8);
};

/**
 * @inheritDoc
 */
tutao.crypto.JBCryptAdapter.prototype.generateKeyFromPassphrase = function(passphrase, salt) {
	var self = this;

	// jbcrypt needs the salt and password as unsigned bytes
	var saltBytes = this._unsignedToSignedBytes(tutao.util.EncodingConverter.hexToBytes(salt));
	// hash the password first to avoid login with multiples of a password, i.e. "hello" and "hellohello" produce the same key if the same salt is used 
	var passphraseBytes = this._unsignedToSignedBytes(tutao.util.EncodingConverter.hexToBytes(tutao.util.EncodingConverter.base64ToHex(tutao.locator.shaCrypter.hashHex(tutao.util.EncodingConverter.utf8ToHex(passphrase)))));

	// create a new instance for each call to make sure that no concurrency problems occur (the bcrypt library uses setTimeouts)
	var b = new bCrypt();
    return new Promise(function(resolve, reject) {
        b.crypt_raw(passphraseBytes, saltBytes, self.logRounds, function(key) {
            var hexKey = tutao.util.EncodingConverter.bytesToHex(self._signedToUnsignedBytes(key));
            resolve(hexKey);
        }, function() {});
    });
};

/**
 * Converts an array of signed byte values (-128 to 127) to unsigned bytes (0 to 255).
 * @param {Array.<number>} signedBytes The signed byte values.
 * @return {Array.<number>} The unsigned byte values.
 */
tutao.crypto.JBCryptAdapter.prototype._signedToUnsignedBytes = function(signedBytes) {
	var unsignedBytes = [];
	for (var i = 0; i < signedBytes.length; i++) {
		if (signedBytes[i] < 0) {
			unsignedBytes.push(256 + signedBytes[i]);
		} else {
			unsignedBytes.push(signedBytes[i]);
		}
	}
	return unsignedBytes;
};

/**
 * Converts an array of unsigned byte values (0 to 255) to unsigned bytes (-128 to 127).
 * @param {Array.<number>} unsignedBytes The unsigned byte values.
 * @return {Array.<number>} The signed byte values.
 */
tutao.crypto.JBCryptAdapter.prototype._unsignedToSignedBytes = function(unsignedBytes) {
	var signedBytes = [];
	for (var i = 0; i < unsignedBytes.length; i++) {
		if (unsignedBytes[i] > 127) {
			signedBytes.push(unsignedBytes[i] - 256);
		} else {
			signedBytes.push(unsignedBytes[i]);
		}
	}
	return signedBytes;
};

"use strict";

tutao.provide('tutao.crypto.JsbnRsa');

// private key format:
// [ n, d, p, q, pe, qe, c ]

// public key format:
// [ n ]
// e is fixed to 65537 which is recommended for RSA

// private key hex format: [ nLen ] [ n ] [ dLen ] [ d ] [ pLen ] [ p ] [ qLen ] [ q ] [ peLen ] [ pe ] [ qeLen ] [ qe ] [ cLen ] [ c ]
// nbr of hex chars:           4     nLen     4     dLen     4     pLen     4     qLen     4      peLen     4      qeLen     4     cLen

// public key hex format: [ nLen ] [ n ]
// nbr of hex chars:          4     nLen

/**
 * @constructor
 * @implements {tutao.crypto.RsaInterface}
 */
tutao.crypto.JsbnRsa = function() {
	this.keyLengthInBits = 2048;
	this.publicExponent = 65537;
	this.publicExponentAsHex = "10001";
	this._oaep = new tutao.crypto.Oaep();
};

/**
 * @inheritDoc
 */
tutao.crypto.JsbnRsa.prototype.generateKeyPair = function(callback) {
	var rsa = new RSAKey();
	try {
		rsa.generate(this.keyLengthInBits, this.publicExponentAsHex);
		callback({ publicKey: [rsa.n], privateKey: [rsa.n, rsa.d, rsa.p, rsa.q, rsa.dmp1, rsa.dmq1, rsa.coeff]});
	} catch (e) {
		callback(null, new tutao.crypto.CryptoError("key generation failed", e));
	}
};

/**
 * Provides the length of the given string as hex string of 4 characters length. Padding to 4 characters is done with '0'.
 * @param {string} string A string to get the length of.
 * @return {string} A hex string containing the length of string.
 */
tutao.crypto.JsbnRsa.prototype._hexLen = function(string) {
	var hexLen = string.length.toString(16);
	while (hexLen.length < 4) {
        hexLen = "0" + hexLen;
    }
	return hexLen;
};

/**
 * @inheritDoc
 */
tutao.crypto.JsbnRsa.prototype.keyToHex = function(key) {
	var hex = "";
	for (var i = 0; i < key.length; i++) {
		var param = key[i].toString(16);
		if ((param.length % 2) == 1) {
			param = "0" + param;
		}
		hex += this._hexLen(param) + param;
	}
	return hex;
};

/**
 * @inheritDoc
 */
tutao.crypto.JsbnRsa.prototype.hexToKey = function(hex) {
    try {
		var key = [];
		var pos = 0;
		while (pos < hex.length) {
			var nextParamLen = parseInt(hex.substring(pos, pos + 4), 16);
			pos += 4;
			key.push(parseBigInt(hex.substring(pos, pos + nextParamLen), 16));
			pos += nextParamLen;
		}
        this._validateKeyLength(key);
        return key;
	} catch (e) {
		throw new tutao.crypto.CryptoError("hex to rsa key failed", e);
	}
};

/**
 * @param {Array} key
 * @private
 */
tutao.crypto.JsbnRsa.prototype._validateKeyLength = function(key) {
    if (key.length != 1 && key.length != 7) {
        throw new Error("invalid key params");
    }
    if (key[0].bitLength() < this.keyLengthInBits - 1 || key[0].bitLength() > this.keyLengthInBits) {
        throw new Error("invalid key length, expected: around " + this.keyLengthInBits + ", but was: " + key[0].bitLength());
    }
};

/**
 * @inheritDoc
 */
tutao.crypto.JsbnRsa.prototype.encryptAesKey = function(publicKey, hex, callback) {
	try {
		var rsa = new RSAKey();
		rsa.n = publicKey[0];
		rsa.e = this.publicExponent;
		var bytes = tutao.util.EncodingConverter.hexToBytes(hex);
		var randomBytes = tutao.util.EncodingConverter.hexToBytes(tutao.locator.randomizer.generateRandomData(32));
		var paddedBytes = this._oaep.pad(bytes, this.keyLengthInBits, randomBytes);
		var paddedHex = tutao.util.EncodingConverter.bytesToHex(paddedBytes);

		var bigInt = parseBigInt(paddedHex, 16);
		var encrypted = rsa.doPublic(bigInt);

		var encryptedHex = encrypted.toString(16);
		if ((encryptedHex.length % 2) == 1) {
			encryptedHex = "0" + encryptedHex;
		}
		var base64 = tutao.util.EncodingConverter.hexToBase64(encryptedHex);

		callback(base64);
	} catch (e) {
		callback(null, new tutao.crypto.CryptoError("rsa encryption failed", e));
	}
};

/**
 * @inheritDoc
 */
tutao.crypto.JsbnRsa.prototype.decryptAesKey = function(privateKey, base64, callback) {
	try {
		var rsa = new RSAKey();
		rsa.n = privateKey[0];
		rsa.d = privateKey[1];
		rsa.p = privateKey[2];
		rsa.q = privateKey[3];
		rsa.dmp1 = privateKey[4];
		rsa.dmq1 = privateKey[5];
		rsa.coeff = privateKey[6];
		var hex = tutao.util.EncodingConverter.base64ToHex(base64);
		var bigInt = parseBigInt(hex, 16);
		var paddedBigInt = rsa.doPrivate(bigInt);
		var decryptedHex = paddedBigInt.toString(16);
		// fill the hex string to have a padded block of exactly (keylength / 8 - 1 bytes) for the unpad function
		// two possible reasons for smaller string:
		// - one "0" of the byte might be missing because toString(16) does not consider this
		// - the bigint value might be smaller than (keylength / 8 - 1) bytes
		var expectedPaddedHexLength = (this.keyLengthInBits / 8 - 1) * 2;
		var fill = Array(expectedPaddedHexLength - decryptedHex.length + 1).join("0"); // creates the missing zeros
		decryptedHex = fill + decryptedHex;
		var paddedBytes = tutao.util.EncodingConverter.hexToBytes(decryptedHex);
		var bytes = this._oaep.unpad(paddedBytes, this.keyLengthInBits);
		callback(tutao.util.EncodingConverter.bytesToHex(bytes));
	} catch (e) {
		callback(null, new tutao.crypto.CryptoError("rsa decryption failed", e));
	}
};

"use strict";

tutao.provide('tutao.crypto.KdfInterface');

/**
 * This Interface provides an abstraction of a key derivation function implementation.
 * A concrete instance is bound by the Locator.
 * @interface
 */
tutao.crypto.KdfInterface = function() {};

/**
 * Create a 128 bit random salt value.
 * return {string} salt 128 bit of random data, encoded as a hex string.
 */
tutao.crypto.KdfInterface.prototype.generateRandomSalt = function() {};

/**
 * Create a 128 bit symmetric key from the given passphrase.
 * @param {string} passphrase The passphrase to use for key generation as utf8 string.
 * @param {string} salt 128 bit of random data, encoded as a hex string.
 * @return {Promise.<string>} Resolved with the hex codec key
 */
tutao.crypto.KdfInterface.prototype.generateKeyFromPassphrase = function(passphrase, salt) {};

"use strict";

tutao.provide('tutao.crypto.Oaep');

/**
 * @constructor
 */
tutao.crypto.Oaep = function () {

};

/**
 * @param {Array.<number>} value The byte array to pad.
 * @param {number} keyLength The length of the RSA key in bit.
 * @param {Array.<number>} seed An array of random bytes of 256 bytes.
 * @return {Array.<number>} The padded byte array.
 */
tutao.crypto.Oaep.prototype.pad = function (value, keyLength, seed) {
    var hashLength = 32; // bytes sha256
    if (seed.length != hashLength) {
        throw new Error("invalid seed length: " + seed.length + ". expected: " + hashLength + " bytes!");
    }
    if (value.length > (keyLength / 8 - hashLength - 1)) {
        throw new Error("invalid value length: " + value.length + ". expected: max. " + (keyLength / 8 - hashLength - 1));
    }

    var block = this._getPSBlock(value, keyLength);

    var dbMask = this._mgf1(seed, block.length - hashLength);

    for (var i = hashLength; i < block.length; i++) {
        block[i] ^= dbMask[i - hashLength];
    }

    // same as invoking sha256 directly because only one block is hashed
    var seedMask = this._mgf1(block.slice(hashLength, block.length), hashLength);

    for (var i = 0; i < seedMask.length; i++) {
        block[i] = seed[i] ^ seedMask[i];
    }

    return block;
};

/**
 * @param {Array.<number>} value The byte array to unpad.
 * @param {number} keyLength The length of the RSA key in bit.
 * @return {Array.<number>} The unpadded byte array.
 */
tutao.crypto.Oaep.prototype.unpad = function (value, keyLength) {
    var hashLength = 32; // bytes sha256
    if (value.length != keyLength / 8 - 1) {
        throw new Error("invalid value length: " + value.length + ". expected: " + (keyLength / 8 - 1) + " bytes!");
    }

    var seedMask = this._mgf1(value.slice(hashLength, value.length), hashLength);
    var seed = [];
    seed.length = hashLength;
    for (var i = 0; i < seedMask.length; i++) {
        seed[i] = value[i] ^ seedMask[i];
    }

    var dbMask = this._mgf1(seed, value.length - hashLength);

    for (var i = hashLength; i < value.length; i++) {
        value[i] ^= dbMask[i - hashLength];
    }

    // check that the zeros and the one is there
    for (var index = 2 * hashLength; index < value.length; index++) {
        if (value[index] == 1) {
            // found the 0x01
            break;
        } else if (value[index] != 0 || index == value.length) {
            throw new Error("invalid padding");
        }
    }

    return value.slice(index + 1, value.length);
};

/**
 * Provides a block of keyLength / 8 - 1 bytes with the following format:
 * [ zeros ] [ label hash ] [ zeros ] [ 1 ] [ value ]
 *    32           32    keyLen-2*32-2  1  value.length
 * The label is the hash of an empty string like defines in PKCS#1 v2.1
 */
tutao.crypto.Oaep.prototype._getPSBlock = function (value, keyLength) {
    var hashLength = 32; // bytes sha256
    var blockLength = keyLength / 8 - 1; // the leading byte shall be 0 to make the resulting value in any case smaller than the modulus, so we just leave the byte off
    var block = [];
    block.length = blockLength;

    var hash = new sjcl.hash.sha256();
    hash.update([]); // empty label
    var defHash = sjcl.codec.bytes.fromBits(hash.finalize());

    var nbrOfZeros = block.length - (1 + value.length);
    for (var i = 0; i < block.length; i++) {
        if (i >= hashLength && i < 2 * hashLength) {
            block[i] = defHash[i - hashLength];
        } else if (i < nbrOfZeros) {
            block[i] = 0;
        } else if (i == nbrOfZeros) {
            block[i] = 1;
        } else {
            block[i] = value[i - nbrOfZeros - 1];
        }
    }
    return block;
};

/**
 * @param {Array.<Number>} seed An array of byte values.
 * @param {Number} length The length of the return value in bytes.
 */
tutao.crypto.Oaep.prototype._mgf1 = function (seed, length) {
    var C = null;
    var counter = 0;
    var hash = new sjcl.hash.sha256();
    var T = [];

    var seedSjclArray = sjcl.codec.bytes.toBits(seed);

    do {
        C = this._i2osp(counter);
        var cSjclArray = sjcl.codec.bytes.toBits(C);

        hash.update(seedSjclArray);
        hash.update(cSjclArray);
        T = sjcl.bitArray.concat(T, hash.finalize());
    } while (++counter < Math.ceil(length / (256 / 8)));

    var slice = sjcl.bitArray.bitSlice(T, 0, length * 8);
    return sjcl.codec.bytes.fromBits(slice);
};

/**
 * converts an integer to a 4 byte array
 */
tutao.crypto.Oaep.prototype._i2osp = function (i) {
    var array = [];
    array.push((i >> 24) & 255);
    array.push((i >> 16) & 255);
    array.push((i >> 8) & 255);
    array.push((i >> 0) & 255);
    return array;
};

"use strict";

tutao.provide('tutao.crypto.RandomizerInterface');

/**
 * This Interface provides an abstraction of the random number generator implementation.
 * A concrete instance is bound by the ServiceLocator.
 * @interface
 */
tutao.crypto.RandomizerInterface = function() {};

tutao.crypto.RandomizerInterface.ENTROPY_SRC_MOUSE = "mouse";
tutao.crypto.RandomizerInterface.ENTROPY_SRC_KEY = "key";
tutao.crypto.RandomizerInterface.ENTROPY_SRC_RANDOM = "random";
tutao.crypto.RandomizerInterface.ENTROPY_SRC_STATIC = "static";
tutao.crypto.RandomizerInterface.ENTROPY_SRC_PING = "ping";

/**
 * Adds entropy to the random number generator algorithm
 * @param {number} number Any number value.
 * @param {number} entropy The amount of entropy in the number in bit.
 * @param {string} source The source of the number. One of tutao.crypto.RandomizerInterface.ENTROPY_SRC_*.
 */
tutao.crypto.RandomizerInterface.prototype.addEntropy = function(number, entropy, source) {};

/**
 * Verifies if the randomizer is ready to serve.
 * @return {boolean} true, if it is ready, false otherwise.
 */
tutao.crypto.RandomizerInterface.prototype.isReady = function() {};


/**
 * Generates random data. The function initRandomDataGenerator must have been called prior to the first call to this function.
 * @param {number} nbrOfBytes The number of bytes the random data shall have.
 * @return {string} A hex coded string of random data.
 * @throws {tutao.crypto.CryptoError} if the randomizer is not seeded (isReady == false)
 */
tutao.crypto.RandomizerInterface.prototype.generateRandomData = function(nbrOfBytes) {};

"use strict";

tutao.provide('tutao.crypto.RsaInterface');

/**
 * This Interface provides an abstraction of the RSA cryptographic implementation.
 * A concrete instance is bound by the Locator.
 * @interface
 */
tutao.crypto.RsaInterface = function() {};

/**
 * Generates a 2048 bit RSA key pair.
 * @param {function({publicKey: Object, privateKey: Object}=, tutao.crypto.CryptoError=)} callback This callback is called providing the generated key pair or an exception if the key generation fails.
 */
tutao.crypto.RsaInterface.prototype.generateKeyPair = function(callback) {};

/**
 * Converts the given key to a hex string.
 * @param {Object} key The key which may be a public or a private key.
 * @return {String} The hex string representation of the key.
 */
tutao.crypto.RsaInterface.prototype.keyToHex = function(key) {};

/**
 * Converts the given hex string to a key.
 * @param {String} hex The hex string representation of the key which might be a public or a private key.
 * @return {Object} The key.
 * @throws {tutao.crypto.CryptoError} If the conversion fails.
 */
tutao.crypto.RsaInterface.prototype.hexToKey = function(hex) {};

/**
 * Encrypts a hex coded AES key with RSA to a base64 coded string.
 * @param {Object} publicKey The key to use for the encryption.
 * @param {string} hexAesKey Hex coded AES key, max 256 bytes = 512 characters.
 * @param {function(string=, tutao.crypto.CryptoError=)} callback This callback is called providing the encrypted string, base64 coded, max 344 characters or an exception if the enryption fails.
 */
tutao.crypto.RsaInterface.prototype.encryptAesKey = function(publicKey, hexAesKey, callback) {};

/**
 * Decrypts a base64 coded string with RSA to a hex coded string.
 * @param {Object} privateKey The key to use for the decryption.
 * @param {string} base64 The data to decrypt, max 344 characters.
 * @param {function(string=, tutao.crypto.CryptoError=)} callback This callback is called providing the decrypted string, hex coded, max 256 bytes = 512 characters or an exception if the decryption fails.
 */
tutao.crypto.RsaInterface.prototype.decryptAesKey = function(privateKey, base64, callback) {};

"use strict";

tutao.provide('tutao.crypto.RsaWorkerProxy');

/**
 * An RsaWorkerProxy is a proxy for an actual RSA implementation that executes the encryption and decryption in the worker.
 * @constructor
 * @param {tutao.crypto.RsaInterface=} rsa The actual RSA implementation. If not provided, then JsbnRsa is used.
 * @implements {tutao.crypto.RsaInterface}
 */
tutao.crypto.RsaWorkerProxy = function(rsa) {
	if (rsa) {
		this._rsa = rsa;
	} else {
		this._rsa = new tutao.crypto.JsbnRsa();
	}
};

/**
 * @inheritDoc
 */
tutao.crypto.RsaWorkerProxy.prototype.generateKeyPair = function(callback) {
	var self = this;
	tutao.locator.clientWorkerProxy.sendCommand("generateKeyPair", {randomData: tutao.locator.randomizer.generateRandomData(258)}, function(data, errorMessage) {
		if (errorMessage) {
            self.generateKeyPair(callback);
			//TODO (timely) correct retry after out-of-random-data-exception: callback(null, new tutao.crypto.CryptoError(errorMessage));
		} else {
			callback({publicKey: self.hexToKey(data.publicKeyHex), privateKey: self.hexToKey(data.privateKeyHex)});
		}
	});
};

/**
 * @inheritDoc
 */
tutao.crypto.RsaWorkerProxy.prototype.keyToHex = function(key) {
	return this._rsa.keyToHex(key);
};

/**
 * @inheritDoc
 */
tutao.crypto.RsaWorkerProxy.prototype.hexToKey = function(hex) {
	return this._rsa.hexToKey(hex);
};

/**
 * @inheritDoc
 */
tutao.crypto.RsaWorkerProxy.prototype.encryptAesKey = function(publicKey, hex, callback) {
	var self = this;
	// pass random data for the oaep padding
	var data = { key: this.keyToHex(publicKey), data: hex, randomData: tutao.locator.randomizer.generateRandomData(32) };
	tutao.locator.clientWorkerProxy.sendCommand("encryptAesKey", data, function(encrypted, errorMessage) {
		if (errorMessage) {
			callback(null, new tutao.crypto.CryptoError(errorMessage));
		} else {
			callback(encrypted);
		}
	});
};

/**
 * @inheritDoc
 */
tutao.crypto.RsaWorkerProxy.prototype.decryptAesKey = function(privateKey, base64, callback) {
	var self = this;
	var data = { key: this.keyToHex(privateKey), data: base64 };
	tutao.locator.clientWorkerProxy.sendCommand("decryptAesKey", data, function(encrypted, errorMessage) {
		if (errorMessage) {
			callback(null, new tutao.crypto.CryptoError(errorMessage));
		} else {
			callback(encrypted);
		}
	});
};

"use strict";

tutao.provide('SecureRandom');

/**
 * This randomizer does not generate random numbers itself but acts as a proxy. It only provides random numbers if it was feeded with values via setNextRandomBytes().
 * @constructor
 */
var SecureRandom = function() {
};

SecureRandom._nextBytes = [];

/**
 * Only this function is used by jsbn for getting random bytes. Each byte is a value between 0 and 255.
 * @param {Array} array An array to fill with random bytes. The length of the array defines the number of bytes to create.
 */
SecureRandom.prototype.nextBytes = function(array) {
    if (SecureRandom._nextBytes.length < array.length) {
        throw new Error("SecureRandom does not have random numbers.");
    }
    var bytes = SecureRandom._nextBytes.splice(0,array.length);
    for (var i=0;i<array.length;i++) {
        array[i] = bytes[i];
    }
};

/**
 * Adds bytes to this randomizer which are provided in the subsequent calls to generateRandomData().
 * @param {Array} array An array of random bytes
 */
SecureRandom.setNextRandomBytes = function(bytes) {
    SecureRandom._nextBytes = SecureRandom._nextBytes.concat(bytes);
    this._nextBytes = this._nextBytes.concat(bytes);
};
"use strict";

tutao.provide('tutao.crypto.ShaInterface');

/**
 * This Interface provides an abstraction of SHA hashing algorithm.
 * A concrete instance is bound by the Locator.
 * @interface
 */
tutao.crypto.ShaInterface = function() {};

/**
 * Create the hash of the given data.
 * @param {string} hex Hex coded bytes.
 * @return {string} Base64 coded hash.
 */
tutao.crypto.ShaInterface.prototype.hashHex = function(hex) {};

"use strict";

tutao.provide('tutao.crypto.SjclAes');

/**
 * @constructor
 * @implements {tutao.crypto.AesInterface}
 */
tutao.crypto.SjclAes = function() {
	// arbitrary fixed iv
	this.fixedIv = sjcl.codec.hex.toBits('88888888888888888888888888888888');
	this.keyLength = 128;
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.generateRandomKey = function() {
	return sjcl.codec.hex.toBits(tutao.locator.randomizer.generateRandomData(this.keyLength / 8), false);
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.keyToHex = function(key) {
	return sjcl.codec.hex.fromBits(key);
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.keyToBase64 = function(key) {
	return sjcl.codec.base64.fromBits(key);
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.hexToKey = function(hex) {
	try {
		return sjcl.codec.hex.toBits(hex);
	} catch (e) {
		throw new tutao.crypto.CryptoError("hex to aes key failed", e);
	}
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.base64ToKey = function(base64) {
	try {
		return sjcl.codec.base64.toBits(base64);
	} catch (e) {
		throw new tutao.crypto.CryptoError("hex to aes key failed", e);
	}
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.encryptUtf8 = function(key, utf8) {
	try {
		return this._encrypt(key, sjcl.codec.utf8String.toBits(utf8), true, true);
	} catch (e) {
		throw new tutao.crypto.CryptoError("aes utf8 encryption failed", e);
	}
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.decryptUtf8 = function(key, base64) {
	try {
		return sjcl.codec.utf8String.fromBits(this._decrypt(key, base64, true, true));
	} catch (e) {
		throw new tutao.crypto.CryptoError("aes utf8 decryption failed", e);
	}
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.encryptUtf8Index = function(key, utf8) {
    try {
        return this._encrypt(key, sjcl.codec.utf8String.toBits(utf8), false, true);
    } catch (e) {
        throw new tutao.crypto.CryptoError("aes utf8 encryption index failed", e);
    }
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.decryptUtf8Index = function(key, base64) {
    try {
        return sjcl.codec.utf8String.fromBits(this._decrypt(key, base64, false, true));
    } catch (e) {
        throw new tutao.crypto.CryptoError("aes utf8 decryption index failed", e);
    }
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.encryptBytes = function(key, base64) {
	return this._encrypt(key, sjcl.codec.base64.toBits(base64), true, true);
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.decryptBytes = function(key, base64) {
	try {
		return sjcl.codec.base64.fromBits(this._decrypt(key, base64, true, true));
	} catch (e) {
		throw new tutao.crypto.CryptoError("aes bytes decryption failed", e);
	}
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.encryptKey = function(key, keyToEncrypt) {
	try {
		return this._encrypt(key, keyToEncrypt, false, false);
	} catch (e) {
		throw new tutao.crypto.CryptoError("aes key encryption failed", e);
	}
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.decryptKey = function(key, base64) {
	try {
		return this._decrypt(key, base64, false, false);
	} catch (e) {
		throw new tutao.crypto.CryptoError("aes key decryption failed", e);
	}
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.encryptPrivateRsaKey = function(key, hexKeyToEncrypt) {
	try {
		return this._encrypt(key, sjcl.codec.hex.toBits(hexKeyToEncrypt), true, true);
	} catch (e) {
		throw new tutao.crypto.CryptoError("aes private key encryption failed", e);
	}
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.decryptPrivateRsaKey = function(key, base64) {
	try {
		return sjcl.codec.hex.fromBits(this._decrypt(key, base64, true, true));
	} catch (e) {
		throw new tutao.crypto.CryptoError("aes private key decryption failed", e);
	}
};

/**
 * Encrypts a list of words with AES in CBC mode.
 * @protected
 * @param {Object} key The key to use for the encryption.
 * @param {Object} words The words to encrypt (sjcl internal structure).
 * @param {boolean} randomIv If true, a random initialization vector is used (the same plaintext is not encrypted to the same chiffre text).
 * @param {boolean} usePadding If true, padding is used, otherwise no padding is used and the encrypted data must have the key size.
 * @return {string} The encrypted text, base64 coded.
 */
tutao.crypto.SjclAes.prototype._encrypt = function(key, words, randomIv, usePadding) {
	var iv;
	if (randomIv) {
		iv = sjcl.codec.hex.toBits(tutao.locator.randomizer.generateRandomData(this.keyLength / 8));
	} else {
		// use the fixed iv, but do not append it to the ciphertext
		iv = this.fixedIv;
	}
	var encrypted = sjcl.mode.cbc.encrypt(new sjcl.cipher.aes(key), words, iv, [], usePadding);
	if (randomIv) {
		return sjcl.codec.base64.fromBits(sjcl.bitArray.concat(iv, encrypted));
	} else {
		return sjcl.codec.base64.fromBits(encrypted);
	}
};

/**
 * Decrypts a base64 coded string with AES in CBC mode into words.
 * @protected
 * @param {Object} key The key to use for the decryption.
 * @param {string} base64 A base64 coded string that was encrypted with the same key before.
 * @param {boolean} randomIv If true, a random initialization vector is used (the same plaintext is not encrypted to the same chiffre text).
 * @param {boolean} usePadding If true, padding is used, otherwise no padding is used and the encrypted data must have the key size.
 * @return {Object} The decrypted words (CryptoJS internal structure).
 */
tutao.crypto.SjclAes.prototype._decrypt = function(key, base64, randomIv, usePadding) {
	var iv;
	var ciphertext;
	var encrypted = sjcl.codec.base64.toBits(base64);
	if (randomIv) {
		// take the iv from the front of the encrypted data
		iv = sjcl.bitArray.bitSlice(encrypted, 0, this.keyLength);
		ciphertext = sjcl.bitArray.bitSlice(encrypted, this.keyLength);
	} else {
		iv = this.fixedIv;
		ciphertext = encrypted;
	}
	return sjcl.mode.cbc.decrypt(new sjcl.cipher.aes(key), ciphertext, iv, [], usePadding);
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.encryptArrayBuffer = function(key, srcBuffer, callback) {
	var iv = sjcl.codec.hex.toBits(tutao.locator.randomizer.generateRandomData(this.keyLength / 8));
	this._encryptArrayBuffer(key, srcBuffer, iv, callback);
};

/**
 * Encrypts the content of an array buffer with AES in CBC mode with the given initialization vector.
 * @param {Object} key The key to use for the encryption.
 * @param {ArrayBuffer} arrayBuffer The plain text data.
 * @param {Object} iv The initialization vector.
 * @param {function(?ArrayBuffer,tutao.crypto.CryptoError=)} callback Called when finished receiving the encrypted array buffer. Receives an exception if the encryption failed.
 */
tutao.crypto.SjclAes.prototype._encryptArrayBuffer = function(key, srcBuffer, iv, callback) {
	if (sjcl.bitArray.bitLength(iv) !== this.keyLength) {
		callback(null, new tutao.crypto.CryptoError("invalid iv length: " + sjcl.bitArray.bitLength(iv)));
		return;
	}
	if (sjcl.bitArray.bitLength(key) !== this.keyLength) {
		callback(null, new tutao.crypto.CryptoError("invalid key length: " + sjcl.bitArray.bitLength(key)));
		return;
	}
	var xor = sjcl.bitArray._xor4;

	var byteKeyLength = this.keyLength / 8;
	var uint32ArraysPerBlock = byteKeyLength / 4;
	var prp = new sjcl.cipher.aes(key);
	// the floor'ed division cuts off a last partial block which must be padded. if no partial block exists a padding block must be added.
	// so in both cases a padded block is added plus a block for the iv
	var nbrOfFullSrcBlocks = Math.floor(srcBuffer.byteLength / byteKeyLength);

	var dstBuffer = new ArrayBuffer((nbrOfFullSrcBlocks + 2) * byteKeyLength);
	var srcDataView = new DataView(srcBuffer);
	var dstDataView = new DataView(dstBuffer);

	// put the iv into first destination block
	for (var i = 0; i < uint32ArraysPerBlock; i++) {
		dstDataView.setUint32(i * 4, iv[i], false);
	}

	// encrypt full src blocks
	var plainBlock = [0, 0, 0, 0]; // dummy initialization
	for (var i = 0; i < (nbrOfFullSrcBlocks * uint32ArraysPerBlock); i += uint32ArraysPerBlock) {
		plainBlock[0] = srcDataView.getUint32(i * 4, false);
		plainBlock[1] = srcDataView.getUint32((i + 1) * 4, false);
		plainBlock[2] = srcDataView.getUint32((i + 2) * 4, false);
		plainBlock[3] = srcDataView.getUint32((i + 3) * 4, false);
		iv = prp.encrypt(xor(iv, plainBlock));
		var dstBlockOffset = (uint32ArraysPerBlock + i) * 4;
		dstDataView.setUint32(dstBlockOffset, iv[0], false);
		dstDataView.setUint32(dstBlockOffset + 4, iv[1], false);
		dstDataView.setUint32(dstBlockOffset + 8, iv[2], false);
		dstDataView.setUint32(dstBlockOffset + 12, iv[3], false);
	}

	// padding
	var srcDataViewLastBlock = new DataView(new ArrayBuffer(byteKeyLength));
	var i;
	// copy the remaining bytes to the last block
	var nbrOfRemainingSrcBytes = srcBuffer.byteLength - nbrOfFullSrcBlocks * byteKeyLength;
	for (i = 0; i < nbrOfRemainingSrcBytes; i++) {
		srcDataViewLastBlock.setUint8(i, srcDataView.getUint8(nbrOfFullSrcBlocks * byteKeyLength + i));
	}
	// fill the last block with padding bytes
	var paddingByte = byteKeyLength - (srcBuffer.byteLength % byteKeyLength);
	for (; i < byteKeyLength; i++) {
		srcDataViewLastBlock.setUint8(i, paddingByte);
	}
	plainBlock[0] = srcDataViewLastBlock.getUint32(0, false);
	plainBlock[1] = srcDataViewLastBlock.getUint32(4, false);
	plainBlock[2] = srcDataViewLastBlock.getUint32(8, false);
	plainBlock[3] = srcDataViewLastBlock.getUint32(12, false);
	iv = prp.encrypt(xor(iv, plainBlock));
	var dstLastBlockOffset = (nbrOfFullSrcBlocks + 1) * byteKeyLength;
	dstDataView.setUint32(dstLastBlockOffset, iv[0], false);
	dstDataView.setUint32(dstLastBlockOffset + 4, iv[1], false);
	dstDataView.setUint32(dstLastBlockOffset + 8, iv[2], false);
	dstDataView.setUint32(dstLastBlockOffset + 12, iv[3], false);
	callback(dstBuffer);
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.decryptArrayBuffer = function(key, srcBuffer, decryptedSize, callback) {
	if (sjcl.bitArray.bitLength(key) !== this.keyLength) {
		callback(null, new tutao.crypto.CryptoError("invalid key length: " + sjcl.bitArray.bitLength(key)));
		return;
	}
	var byteKeyLength = this.keyLength / 8;
	if (srcBuffer.byteLength % byteKeyLength != 0 || srcBuffer.byteLength < 2 * byteKeyLength) {
		callback(null, new tutao.crypto.CryptoError("invalid src buffer len: " + srcBuffer.byteLength));
		return;
	}
	if (decryptedSize < (srcBuffer.byteLength - 2 * byteKeyLength)) {
		callback(null, new tutao.crypto.CryptoError("invalid dst buffer len: " + decryptedSize + ", src buffer len: " + srcBuffer.byteLength));
		return;
	}
	var xor = sjcl.bitArray._xor4;

	var uint32ArraysPerBlock = byteKeyLength / 4;
	var prp = new sjcl.cipher.aes(key);
	// iv and padding block are not full blocks
	var nbrOfFullSrcBlocks = srcBuffer.byteLength / byteKeyLength - 2;

	var dstBuffer = new ArrayBuffer(decryptedSize);
	var srcDataView = new DataView(srcBuffer);
	var dstDataView = new DataView(dstBuffer);

	var iv = [];
	for (var i = 0; i < uint32ArraysPerBlock; i++) {
		iv.push(srcDataView.getUint32(i * 4, false));
	}
	// move the view behind the iv
	srcDataView = new DataView(srcBuffer, byteKeyLength);

	// decrypt full src blocks
	var decryptedBlock = null;
	for (var i = 0; i < ((nbrOfFullSrcBlocks + 1) * uint32ArraysPerBlock); i += uint32ArraysPerBlock) {
		var encryptedBlock = [srcDataView.getUint32(i * 4, false),
		                      srcDataView.getUint32((i + 1) * 4, false),
		                      srcDataView.getUint32((i + 2) * 4, false),
		                      srcDataView.getUint32((i + 3) * 4, false)];
		decryptedBlock = xor(iv, prp.decrypt(encryptedBlock));
		if (i < (nbrOfFullSrcBlocks * uint32ArraysPerBlock)) {
			dstDataView.setUint32(i * 4, decryptedBlock[0], false);
			dstDataView.setUint32(i * 4 + 4, decryptedBlock[1], false);
			dstDataView.setUint32(i * 4 + 8, decryptedBlock[2], false);
			dstDataView.setUint32(i * 4 + 12, decryptedBlock[3], false);
			iv = encryptedBlock;
		} else {
			var lastSrcBlock = new DataView(new ArrayBuffer(byteKeyLength));
			// copy the decrypted uint32 to the last block
			for (var a = 0; a < uint32ArraysPerBlock; a++) {
				lastSrcBlock.setUint32(a * 4, decryptedBlock[a], false);
			}
			// check the padding length
			var nbrOfPaddingBytes = decryptedBlock[3] & 255;
			if (nbrOfPaddingBytes == 0 || nbrOfPaddingBytes > 16) {
				callback(null, new tutao.crypto.CryptoError("invalid padding value: " + nbrOfPaddingBytes));
				return;
			}
			if (decryptedSize != ((nbrOfFullSrcBlocks + 1) * byteKeyLength - nbrOfPaddingBytes)) {
				callback(null, new tutao.crypto.CryptoError("invalid decrypted size: " + decryptedSize + ", expected: " + (nbrOfFullSrcBlocks * byteKeyLength + nbrOfPaddingBytes)));
				return;
			}
			// copy the remaining bytes
			var a;
			for (a = 0; a < (byteKeyLength - nbrOfPaddingBytes); a++) {
				dstDataView.setUint8(nbrOfFullSrcBlocks * byteKeyLength + a, lastSrcBlock.getUint8(a));
			}
			// check the padding bytes
			for (; a < byteKeyLength; a++) {
				if (lastSrcBlock.getUint8(a) != nbrOfPaddingBytes) {
					callback(null, new tutao.crypto.CryptoError("invalid padding byte found: " + lastSrcBlock.getUint8(a) + ", expected: " + nbrOfPaddingBytes));
					return;
				}
			}
		}
	}
	callback(dstBuffer);
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclAes.prototype.decryptBase64 = function(key, srcBase64, decryptedSize, callback) {
	if (sjcl.bitArray.bitLength(key) !== this.keyLength) {
		callback(null, new tutao.crypto.CryptoError("invalid key length: " + sjcl.bitArray.bitLength(key)));
		return;
	}

	// calculate the original encrypted byte length
	var srcByteLen = srcBase64.length / 4 * 3;
	if (srcBase64.charAt(srcBase64.length - 2) == "=") {
		srcByteLen -= 2;
	} else if (srcBase64.charAt(srcBase64.length - 1) == "=") {
		srcByteLen -= 1;
	}

	var byteKeyLength = this.keyLength / 8;
	if (srcByteLen % byteKeyLength != 0 || srcByteLen < 2 * byteKeyLength) {
		callback(null, new tutao.crypto.CryptoError("invalid src buffer len: " + srcByteLen));
		return;
	}
	if (decryptedSize < (srcByteLen - 2 * byteKeyLength)) {
		callback(null, new tutao.crypto.CryptoError("invalid dst buffer len: " + decryptedSize + ", src buffer len: " + srcByteLen));
		return;
	}

	var aes = new sjcl.cipher.aes(key);

	// one big block is converted from base64 to bits on one step. a big block is 48 bytes = 64 chars per big block.
	// this is the lowest common multiple for key len (16 bytes) and base64 block (4 chars = 3 bytes).
	// one big block therefore consists of 3 blocks a 16 bytes
	var nbrOfFullBigBlocks = Math.floor(srcBase64.length / 64);

	// the destination base64 block array contains big blocks converted into base64
	var dstBase64BlockArray = [];
	dstBase64BlockArray.length = nbrOfFullBigBlocks + 1; // +1 for any partial last block

	// skip the iv
	this._decryptBase64Block(key, srcBase64, srcByteLen, dstBase64BlockArray, null, decryptedSize, aes, 0, 0, [], callback);
};

/**
 * Decrypts the remaining base64 data.
 * @param {Object} key The key to use for the decryption.
 * @param {String} srcBase64 The encrypted base64 data.
 * @param {Number} srcByteLen The original encrypted byte length.
 * @param {Array.<String>} dstArray Contains the already decrypted base64 parts. Is merged later.
 * @param {Object} iv The sjcl initialization vector to use for the next block decryption.
 * @param {Number} decryptedSize The size of the decrypted data in bytes.
 * @param {Object} aes The sjcl crypto object.
 * @param {Number} i The index in the srcBase64 from where the decryption shall start.
 * @param {Number} a The index in dstArray where the next decrypted parts can be stored.
 * @param {Object} remainingOutputBits One decrypted source big block can not be directly converted to base64 again because of the initialization vector which splits the first big block.
 *                  therefore the remaining 2 blocks of each decrypted big block are stored in remainingOutputBits. as soon as the first block of the next big block is decrypted,
 *                  is is appended to the remainingOutputBits and converted to base64.
 * @param {function(string=, tutao.crypto.CryptoError=)} callback Receives an exception if the decryption failed.
 */
tutao.crypto.SjclAes.prototype._decryptBase64Block = function(key, srcBase64, srcByteLen, dstArray, iv, decryptedSize, aes, i, a, remainingOutputBits, callback) {
	try {
		var byteKeyLength = this.keyLength / 8;
		var x = 2 * 1024; // x * 50 bytes is the next chunk = ~100 KB
		var nextStop = Math.min(srcBase64.length, (i + x) * 64);
		for (; i * 64 < nextStop; i++) {
			var bigBlock;
			if ((i + 1) * 64 > srcBase64.length) {
				// partial big block
				bigBlock = sjcl.codec.base64.toBits(srcBase64.substring(i * 64));
			} else {
				// full big block
				bigBlock = sjcl.codec.base64.toBits(srcBase64.substring(i * 64, (i + 1) * 64));
			}
			var bigBlockBitLen = sjcl.bitArray.bitLength(bigBlock);
			var bitIndex = 0;
			for (; bitIndex < bigBlockBitLen; bitIndex += this.keyLength) {
				if (i == 0 && bitIndex == 0) {
					// iv block
					iv = sjcl.bitArray.bitSlice(bigBlock, bitIndex, bitIndex + this.keyLength);
				} else if ((bitIndex == bigBlockBitLen - this.keyLength) && ((i + 1) * 64 >= srcBase64.length)) {
					// padding block
					var enc = sjcl.bitArray.bitSlice(bigBlock, bitIndex, bitIndex + this.keyLength);
					var dec = sjcl.bitArray._xor4(iv, aes.decrypt(enc));
					// check the padding length
					var nbrOfPaddingBytes = sjcl.bitArray.extract(dec, this.keyLength - 8, 8); // the last 8 bit contain the padding length
					if (nbrOfPaddingBytes == 0 || nbrOfPaddingBytes > byteKeyLength) {
						callback(null, new tutao.crypto.CryptoError("invalid padding value: " + nbrOfPaddingBytes));
						return;
					}
					if (decryptedSize != (srcByteLen - byteKeyLength - nbrOfPaddingBytes)) {
						callback(null, new tutao.crypto.CryptoError("invalid decrypted size: " + decryptedSize + ", expected: " + (srcByteLen - byteKeyLength - nbrOfPaddingBytes)));
						return;
					}

					// check the padding bytes
					var paddingBytes = sjcl.codec.bytes.fromBits(sjcl.bitArray.bitSlice(dec, this.keyLength - nbrOfPaddingBytes * 8, this.keyLength));
					for (var o = 0; o < paddingBytes.length; o++) {
						if (paddingBytes[o] != nbrOfPaddingBytes) {
							callback(null, new tutao.crypto.CryptoError("invalid padding byte found: " + paddingBytes[o] + ", expected: " + nbrOfPaddingBytes));
							return;
						}
					}

					// copy the remaining bytes
					remainingOutputBits = sjcl.bitArray.concat(remainingOutputBits, sjcl.bitArray.bitSlice(dec, 0, this.keyLength - nbrOfPaddingBytes * 8));
					dstArray[a] = sjcl.codec.base64.fromBits(remainingOutputBits);
					callback(dstArray.join(''));
					return;
				} else {
					// normal block
					var enc = sjcl.bitArray.bitSlice(bigBlock, bitIndex, bitIndex + this.keyLength);
					var dec = sjcl.bitArray._xor4(iv, aes.decrypt(enc));
					iv = enc;
					remainingOutputBits = sjcl.bitArray.concat(remainingOutputBits, dec);
					if (sjcl.bitArray.bitLength(remainingOutputBits) == 384) { // one big block is 384 bits
						dstArray[a++] = sjcl.codec.base64.fromBits(remainingOutputBits);
						remainingOutputBits = [];
					}
				}
			}
		}
	} catch (e) {
		callback(null, new tutao.crypto.CryptoError("error during base64 decryption", e));
		return;
	}
	var self = this;
	setTimeout(function() {
		self._decryptBase64Block(key, srcBase64, srcByteLen, dstArray, iv, decryptedSize, aes, i, a, remainingOutputBits, callback);
	}, 50); // 50 ms for spinner time
};
"use strict";

tutao.provide('tutao.crypto.SjclRandomizer');

/**
 * This random number implementation uses the sjcl random number generator internally. It is the Fortuna algorithm with small modifications to suite to the JavaScript environment.
 * See http://crypto.stanford.edu/sjcl/acsac.pdf for the corresponding whitepaper.
 * @constructor
 * @implements {tutao.crypto.RandomizerInterface}
 */
tutao.crypto.SjclRandomizer = function() {
	this.random = new sjcl.random();
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclRandomizer.prototype.addEntropy = function(number, entropy, source) {
	this.random.addEntropy(number, entropy, source);
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclRandomizer.prototype.isReady = function() {
	return this.random.isReady() !== 0;
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclRandomizer.prototype.generateRandomData = function(nbrOfBytes) {
	try {
		// read the minimal number of words to get nbrOfBytes
		var nbrOfWords = Math.floor((nbrOfBytes + 3) / 4);
		var words = this.random.randomWords(nbrOfWords);
		var hex = sjcl.codec.hex.fromBits(words);
		// simply cut off the exceeding bytes
		return hex.substring(0, nbrOfBytes * 2);
	} catch (e) {
		throw new tutao.crypto.CryptoError("error during random number generation", e);
	}
};

"use strict";

tutao.provide('tutao.crypto.SjclSha256');

/**
 * Sha256 implementation from the Sjcl library.
 * @constructor
 */
tutao.crypto.SjclSha256 = function() {
	this._hasher = new sjcl.hash.sha256();
};

/**
 * @inheritDoc
 */
tutao.crypto.SjclSha256.prototype.hashHex = function(hexData) {
	this._hasher.reset();
	this._hasher.update(sjcl.codec.hex.toBits(hexData));
	return sjcl.codec.base64.fromBits(this._hasher.finalize());
};

"use strict";

tutao.provide('tutao.crypto.WorkerRandomizer');

/**
 * This randomizer does not generate random numbers itself but acts as a proxy. It only provides random numbers if it was feeded with values via setNextRandomBytes().
 * @constructor
 * @implements {tutao.crypto.RandomizerInterface}
 */
tutao.crypto.WorkerRandomizer = function() {
	this._nextBytes = "";
	this.requestedBytes = 0;
};

/**
 * @inheritDoc
 */
tutao.crypto.WorkerRandomizer.prototype.addEntropy = function(number, entropy, source) {};

/**
 * @inheritDoc
 */
tutao.crypto.WorkerRandomizer.prototype.isReady = function() {
	return true;
};

/**
 * @inheritDoc
 */
tutao.crypto.WorkerRandomizer.prototype.generateRandomData = function(nbrOfBytes) {
	if (this._nextBytes.length / 2 < nbrOfBytes) {
        throw new Error("WorkerRandomizer does not have random numbers.");
	}
	var bytes = this._nextBytes.substring(0, nbrOfBytes * 2);
	this._nextBytes = this._nextBytes.substring(nbrOfBytes * 2);
	return bytes;
};

/**
 * Adds bytes to this randomizer which are provided in the subsequent calls to generateRandomData().
 * @param {string} bytes Hex coded random bytes.
 */
tutao.crypto.WorkerRandomizer.prototype.setNextRandomBytes = function(bytes) {
	this._nextBytes = this._nextBytes.concat(bytes);
};

"use strict";

tutao.provide('tutao.db.DbInterface');
/**
 * The interface to the DB
 * @interface
 */
tutao.db.DbInterface = function() {};

/**
 * A status code that indicates that the operation was successful.
 */
tutao.db.DbInterface.STATUS_SUCCESS = "success";

/**
 * A status code that indicates that the operation did not succeed because there was no memory available any more.
 */
tutao.db.DbInterface.STATUS_NO_MEM = "no_mem";

/**
 * Indicates if the database is supported. This function may (and should) be called before init();
 * @return {boolean} True if this database implementation is supported by the browser, false otherwise.
 */
tutao.db.DbInterface.prototype.isSupported = function() {};

/**
 * Initializes the database. This must be called before any calls to other functions are allowed, except isSupported().
 * @param {string} name A name to distinguish it from other databases stored by the browser. This name should contain some user identification to
 * keep a separate database for each user.
 * @param {function(string)|undefined} callback This optional function is called as soon as the execution is finished with the status code STATUS_SUCCESS.
 */
tutao.db.DbInterface.prototype.init = function(name, callback) {};

/**
 * Deletes all tables in the database.
 * @param {function(string)|undefined} callback This optional function is called as soon as the execution is finished with the status code STATUS_SUCCESS.
 */
tutao.db.DbInterface.prototype.clear = function(callback) {};

/**
 * Stores the information that all searchable attributes of the element have been indexed. As elements should be indexed by age,
 * we assume that this element is now the youngest element that was indexed. A corresponding subsequent call to getLastIndexed() will return elementId.
 * Calls the callback function when finished.
 * @param {number} typeId The id of the type of the element.
 * @param {string} elementId The id of the element (no list id in case of LET instance).
 * @param {function(string)|undefined} callback This optional function is called as soon as the execution is finished with one of
 * the status code STATUS_SUCCESS or STATUS_NO_MEM.
 */
tutao.db.DbInterface.prototype.setIndexed = function(typeId, elementId, callback) {};

/**
 * Provides the id of the youngest element (by element id) that is indexed.
 * @param {number} typeId The id of the type of the element.
 * @param {function(string,?string)} callback This function is called as soon as the execution is finished with the status code STATUS_SUCCESS.
 * As second argument the id of the last indexed element is passed to the callback function. If none was indexed, null is passed.
 */
tutao.db.DbInterface.prototype.getLastIndexed = function(typeId, callback) {};

/**
 * Stores the index entries for an elements attribute. The element is of type ET or LET, but the attribute may be one of the
 * aggregated types. Calls the callback function when finished.
 * @param {number} typeId The id of the type of the element. The type may be an ET or LET.
 * @param {Array.<number>} attributeIds The ids leading to the searchable attribute of the type.
 * This id chain must start with an attribute of the type (ET or LET) and may go down to AggregatedType's attributes.
 * @param {string} elementId The id of the element (no list id in case of LET instance).
 * @param {Array.<string>} values The values that shall reference the element.
 * @param {function(string)|undefined} callback This optional function is called as soon as the execution is finished with one of
 * the status code STATUS_SUCCESS or STATUS_NO_MEM.
 */
tutao.db.DbInterface.prototype.addIndexEntries = function(typeId, attributeIds, elementId, values, callback) {};

/**
 * Retrieves the ids of all elements that contain the given value. The element is of type ET or LET,
 * but the attribute may be one of the aggregated types.
 * @param {number} typeId The id of the type of the element. The type may be an ET or LET.
 * @param {Array.<number>} attributeIds The ids leading to the searchable attribute of the type.
 * This id chain must start with an attribute of the type (ET or LET) and may go down to AggregatedType's attributes.
 * @param {string} value The value that the returned elements shall contain.
 * @param {function(string,Array.<string>)} callback This function is called as soon as the execution is finished with the status code STATUS_SUCCESS.
 * As second argument an array of string ids of the matching elements (only element ids, no list ids) is passed to the callback function.
 */
tutao.db.DbInterface.prototype.getElementsByValue = function(typeId, attributeIds, value, callback) {};

/**
 * Removes all index entries for the given element id for the given attribute ids lists.
 * @param {number} typeId The id of the type of the element. The type may be an ET or LET.
 * @param {Array.<Array.<number>>} attributeIdsList An array of arrays with ids leading to the searchable attribute of the type.
 * This id chain must start with an attribute of the type (ET or LET) and may go down to AggregatedType's attributes.
 * @param {string} elementId The id of the element (no list id in case of LET instance).
 * @param {function(string)} callback This function is called as soon as the execution is finished with the status code STATUS_SUCCESS.
 */
tutao.db.DbInterface.prototype.removeIndexEntries = function(typeId, attributeIdsList, elementId, callback) {};

"use strict";

tutao.provide('tutao.db.DummyDb');
//import('tutao.db.DbInterface');

/**
 * @constructor
 * @implements {tutao.db.DbInterface}
 */
tutao.db.DummyDb = function() {};

/**
 * @inheritDoc
 */
tutao.db.DummyDb.prototype.isSupported = function() {
	// return false because this implementation does not support the actual functionality
	return false;
};

/**
 * @inheritDoc
 */
tutao.db.DummyDb.prototype.init = function(name, callback) {
	if (callback) {
		callback(tutao.db.DbInterface.STATUS_SUCCESS);
	}
};

/**
 * @inheritDoc
 */
tutao.db.DummyDb.prototype.clear = function(callback) {
	if (callback) {
		callback(tutao.db.DbInterface.STATUS_SUCCESS);
	}
};

/**
 * @inheritDoc
 */
tutao.db.DummyDb.prototype.setIndexed = function(typeId, elementId, callback) {
	if (callback) {
		callback(tutao.db.DbInterface.STATUS_SUCCESS);
	}
};

/**
 * @inheritDoc
 */
tutao.db.DummyDb.prototype.getLastIndexed = function(typeId, callback) {
	if (callback) {
		callback(tutao.db.DbInterface.STATUS_SUCCESS, tutao.rest.EntityRestInterface.GENERATED_MAX_ID); // simulate that all elements were indexed
	}
};

/**
 * @inheritDoc
 */
tutao.db.DummyDb.prototype.addIndexEntries = function(typeId, attributeIds, elementId, values, callback) {
	if (callback) {
		callback(tutao.db.DbInterface.STATUS_SUCCESS);
	}
};

/**
 * @inheritDoc
 */
tutao.db.DummyDb.prototype.getElementsByValue = function(typeId, attributeIds, value, callback) {
	if (callback) {
		callback(tutao.db.DbInterface.STATUS_SUCCESS, []);
	}
};

/**
 * @inheritDoc
 */
tutao.db.DummyDb.prototype.removeIndexEntries = function(typeId, attributeIdsList, elementId, callback) {
	if (callback) {
		callback(tutao.db.DbInterface.STATUS_SUCCESS);
	}
};

"use strict";

tutao.provide('tutao.db.WebSqlDb');
//import('tutao.db.DbInterface');
//import('tutao.entity.Mail');

/**
 * @constructor
 * @implements tutao.db.DbInterface
 */
tutao.db.WebSqlDb = function() {
};

/**
 * The name of the table that stores the last indexed element of a type.
 */
tutao.db.WebSqlDb.prototype._LAST_INDEXED_TABLE_NAME = "LastIndexed";

/**
 * @inheritDoc
 */
tutao.db.WebSqlDb.prototype.isSupported = function() {
	// workaround to detect private browsing mode in mobile safari
	try {
		window.localStorage.setItem("test", "test");
	} catch (e) {
		return false;
	}
	return !!window.openDatabase;
};

/**
 * @inheritDoc
 */
tutao.db.WebSqlDb.prototype.init = function(name, callback) {
	// use a fixed version for now
	// the size is a dummy value because it is not used
	this._db = openDatabase(name, "1", name, 1024);

	// stores a map of the names of all tables that we know exists (mapping to the value true), so we do not have to try to create them
	// before inserting data.
	this._availableTables = {};
	var self = this;
	this._db.transaction(function(tx) {
		tx.executeSql("SELECT name FROM sqlite_master WHERE type='table'", [], function(tx, result) {
			for (var i = 0; i < result.rows.length; i++) {
				if (result.rows.item(i).name.indexOf("__") != 0) {
					self._availableTables[result.rows.item(i).name] = true;
				}
			}
		}, function() {
			console.log("error getting table names");
		});
	}, function() {
		console.log("error executing transaction");
	}, function() {
		// there is one table which contains the information if an element was already indexed
		self._makeSureIndexedInfoTableExists(callback);
	});
};

/**
 * @inheritDoc
 */
tutao.db.WebSqlDb.prototype.clear = function(callback) {
	var self = this;
	this._db.transaction(function(tx) {
		for (var property in self._availableTables) {
			tx.executeSql('DROP TABLE IF EXISTS ' + property);
		}
	}, function() {
		console.log("error executing transaction");
	}, function() {
		self._availableTables = {};
		// the indexed table always needs to be available, so create it again
		self._makeSureIndexedInfoTableExists(callback);
	});
};

/**
 * @inheritDoc
 */
tutao.db.WebSqlDb.prototype.setIndexed = function(typeId, elementId, callback) {
	var self = this;
	self._db.transaction(function(tx) {
		tx.executeSql("INSERT OR REPLACE INTO " + self._LAST_INDEXED_TABLE_NAME + "(typeId, elementId) VALUES(?,?)", [typeId, elementId]);
	}, function(error) {
		console.log("error executing transaction in setIndexed", error);
	}, function() {
		if (callback) {
			callback(tutao.db.DbInterface.STATUS_SUCCESS);
		}
	});
};

/**
 * @inheritDoc
 */
tutao.db.WebSqlDb.prototype.getLastIndexed = function(typeId, callback) {
	//cache the last indexed element and return it directly without db access?
	var elementId = null;
	var self = this;
	this._db.transaction(function(tx) {
		tx.executeSql("SELECT elementId FROM " + self._LAST_INDEXED_TABLE_NAME + " WHERE typeId=?", [typeId], function(tx, result) {
			if (result.rows.length === 1) {
				elementId = (result.rows.item(0)["elementId"]);
			}
		}, function(error) {
			console.log(error);
			// no element was indexed yet, elementId shall stay null
		});
	}, function() {
		console.log("error executing transaction");
	}, function() {
		callback(tutao.db.DbInterface.STATUS_SUCCESS, elementId);
	});
};

/**
 * @inheritDoc
 */
tutao.db.WebSqlDb.prototype.addIndexEntries = function(typeId, attributeIds, elementId, values, callback) {
	var self = this;
	// there shall be one table per attribute
	// table names are not allowed to start with a number
	var tableName = this._createTableName(typeId, attributeIds);
	self._makeSureIndexTableExists(tableName, function() {
		self._db.transaction(function(tx) {
			for (var i = 0; i < values.length; i++) {
				tx.executeSql("INSERT INTO " + tableName + "(word, elementId) VALUES(?,?)", [values[i], elementId]);
			}
		}, function(error) {
			console.log("error executing transaction", error);
			if (callback) {
				callback(tutao.db.DbInterface.STATUS_NO_MEM);
			}
		}, function() {
			if (callback) {
				callback(tutao.db.DbInterface.STATUS_SUCCESS);
			}
		});
	});
};

/**
 * @inheritDoc
 */
tutao.db.WebSqlDb.prototype.getElementsByValue = function(typeId, attributeIds, value, callback) {
	var tableName = this._createTableName(typeId, attributeIds);
	// if the table does not exist, then we do not need to execute a query
	if (this._availableTables[tableName] !== true) {
		callback(tutao.db.DbInterface.STATUS_SUCCESS, []);
		return;
	}
	var error = false;
	var ids = [];
	this._db.transaction(function(tx) {
		tx.executeSql("SELECT elementId FROM " + tableName + " WHERE word=?", [value], function(tx, result) {
			for (var i = 0; i < result.rows.length; i++) {
				ids.push(result.rows.item(i)["elementId"]);
			}
		}, function() {
			// this sql command might fail and still the transaction is successful, so remember the error
			error = true;
			console.log("error getting element ids");
		});
	}, function() {
		console.log("error executing transaction");
	}, function() {
		if (!error && callback) {
			callback(tutao.db.DbInterface.STATUS_SUCCESS, ids);
		}
	});
};

/**
 * @inheritDoc
 */
tutao.db.WebSqlDb.prototype.removeIndexEntries = function(typeId, attributeIdsList, elementId, callback) {
	var self = this;
	// there shall be one table per attribute
	// table names are not allowed to start with a number
	self._db.transaction(function(tx) {
		for (var i = 0; i < attributeIdsList.length; i++) {
			var tableName = self._createTableName(typeId, attributeIdsList[i]);
			if (self._availableTables[tableName]) {
				tx.executeSql("DELETE FROM " + tableName + " WHERE elementId=?", [elementId]);
			}
		}
	}, function(error) {
		console.log("error executing transaction", error);
	}, function() {
		if (callback) {
			callback(tutao.db.DbInterface.STATUS_SUCCESS);
		}
	});
};

/**
 * Provides the name of the table that stores the index for the given type and attribute ids.
 * @param {number} typeId The type id of the type of elements.
 * @param {Array.<number>} attributeIds An array of attribute ids that identify an attribute.
 * @return {string} The index table name.
 */
tutao.db.WebSqlDb.prototype._createTableName = function(typeId, attributeIds) {
	// we use this name schema: "index_<typeId>_<attributeId1>_<attributeId2>..."
	var tableName = "index_" + typeId;
	for (var i = 0; i < attributeIds.length; i++) {
		tableName += "_" + attributeIds[i];
	}
	return tableName;
};

/**
 * Creates a table with the given name if it does not yet exist.
 * @param {string} name The name of the table.
 * @param {function(string)} callback Is called when the operation is finished. Passes a status value that indicates failure.
 */
tutao.db.WebSqlDb.prototype._makeSureIndexTableExists = function(name, callback) {
	var self = this;
	if (this._availableTables[name] === true) {
		// the table exist
		callback(tutao.db.DbInterface.STATUS_SUCCESS);
	} else {
		// create the table
		this._db.transaction(function(tx) {
			tx.executeSql('CREATE TABLE IF NOT EXISTS ' + name + '(word, elementId)', []);
		}, function() {
			console.log("failed to create index table");
		}, function() {
			self._availableTables[name] = true;
			if (callback) {
				callback(tutao.db.DbInterface.STATUS_SUCCESS);
			}
		});
	}
};

/**
 * Creates the table that stores the last element indexed element of a type if it does not yet exist.
 * @param {function(string)=} callback Is called when the operation is finished. Passes a status value that indicates failure.
 */
tutao.db.WebSqlDb.prototype._makeSureIndexedInfoTableExists = function(callback) {
	var self = this;
	this._db.transaction(function(tx) {
		tx.executeSql('CREATE TABLE IF NOT EXISTS ' + self._LAST_INDEXED_TABLE_NAME + '(typeId UNIQUE, elementId)', []);
	}, function() {
		console.log("failed to create indexed table");
	}, function() {
		self._availableTables[self._LAST_INDEXED_TABLE_NAME] = true;
		if (callback) {
			callback(tutao.db.DbInterface.STATUS_SUCCESS);
		}
	});
};


"use strict";

tutao.provide('tutao.entity.BucketData');

/**
 * BucketData encapsulates the reference and the key of a Bucket.
 * @param {String} bucketId The id of the bucket.
 * @param {Object} bucketKey The bucketKey is the aes key that is used to encrypt all bucket data.
 * @constructor
 */
tutao.entity.BucketData = function(bucketId, bucketKey) {
	this._bucketId = bucketId;
	this._bucketKey = bucketKey;
};

/**
 * Returns the id of the bucket
 * @return {String} The id of the bucket. 
 */
tutao.entity.BucketData.prototype.getBucketId = function() {
	return this._bucketId;
};

/**
 * Returns the key of the bucket
 * @return {Object} The bucketKey is the aes key that is used to encrypt all bucket data.
 */
tutao.entity.BucketData.prototype.getBucketKey = function() {
	return this._bucketKey;
};
"use strict";

tutao.provide('tutao.entity.tutanota.ContactExtension');

/**
 * Adds extended functionality to the given editable contact.
 * @param {tutao.entity.tutanota.ContactEditable} editableContact The contact to add the functionality to.
 */
tutao.entity.tutanota.ContactExtension = function(editableContact) {
	//noinspection JSUndefinedPropertyAssignment
    editableContact.birthdayString = ko.observable(null);
    //noinspection JSUndefinedPropertyAssignment
	editableContact.birthdayStringInvalid = ko.observable(false);
    //noinspection JSUndefinedPropertyAssignment
	editableContact.birthdayStringComputed = ko.computed({
        read: function() {
        	if (editableContact.birthdayString() == null) {
        		// the birthday string is requested the first time and must be inititialized
        		if (editableContact.birthday()) {
        			editableContact.birthdayString(tutao.tutanota.util.Formatter.dateToSimpleString(editableContact.birthday()));
        		} else {
        			editableContact.birthdayString("");
        		}
        	}
        	return editableContact.birthdayString();
        },
        write: function(value) {
        	if (value == "") {
        		editableContact.birthdayStringInvalid(false);
        		editableContact.birthday(null);
        	} else {
	        	var date = tutao.tutanota.util.Formatter.simpleStringToDate(value);
	        	if (date != null) {
	        		editableContact.birthdayStringInvalid(false);
	        		editableContact.birthday(date);
	        	} else {
	        		editableContact.birthdayStringInvalid(true);
	        		editableContact.birthday(null);
	        	}
        	}
        	editableContact.birthdayString(value);
        },
        owner: editableContact
    });

	tutao.entity.tutanota.ContactExtension.addNewObservable(
			editableContact,
			tutao.entity.tutanota.ContactExtension.createEmptyContactMailAddressEditable,
			"newContactMailAddress",
			"newContactMailAddressUpdated",
			"address",
			"mailAddresses"
	);
	tutao.entity.tutanota.ContactExtension.addNewObservable(
			editableContact,
			tutao.entity.tutanota.ContactExtension.createEmptyContactPhoneNumberEditable,
			"newContactPhoneNumber",
			"newContactPhoneNumberUpdated",
			"number",
			"phoneNumbers"
	);
	tutao.entity.tutanota.ContactExtension.addNewObservable(
			editableContact,
			tutao.entity.tutanota.ContactExtension.createEmptyMobileContactPhoneNumberEditable,
			"newMobileContactPhoneNumber",
			"newMobileContactPhoneNumberUpdated",
			"number",
			"phoneNumbers"
	);
	tutao.entity.tutanota.ContactExtension.addNewObservable(
			editableContact,
			tutao.entity.tutanota.ContactExtension.createEmptyContactAddressEditable,
			"newContactAddress",
			"newContactAddressUpdated",
			"address",
			"addresses"
	);
	tutao.entity.tutanota.ContactExtension.addNewObservable(
			editableContact,
			tutao.entity.tutanota.ContactExtension.createEmptyContactSocialIdEditable,
			"newContactSocialId",
			"newContactSocialIdUpdated",
			"socialId",
			"socialIds"
	);
};

/**
 * Provides the functionality to add a new empty data line in the dom for contact's aggregations of type T, e.g. ContactMailAddress.
 * As soon as the main field (triggerFieldName) was filled and the focus removed, the new data is added to the contact and
 * a new empty data line is created.
 * @param {tutao.entity.tutanota.ContactEditable} editableContact The ContactEditable that is shall be affected.
 * @param {function()} createFunction The function that creates new instances of the editable data type containing an empty instance.
 * @param {string} observableName The name of the observable that is added to the editableContact which holds the empty editable data instance. It should be bound from html.
 * @param {string} updatedFunctionName The name of the function that must be called as soon as the focus leaves the trigger field in the dom.
 * @param {string} triggerFieldName The name of the field in the new observable that triggers the copy to the editable if it is not empty.
 * @param {string} listName The name of the observable array in the ContactEditable that contains the editables of type T. The new instance is added to this list when filled.
 */
tutao.entity.tutanota.ContactExtension.addNewObservable = function(editableContact, createFunction, observableName, updatedFunctionName, triggerFieldName, listName) {
	var a = createFunction(editableContact.getContact());
	editableContact[observableName] = ko.observable(a);

	editableContact[updatedFunctionName] = function(model, event) {
		if (editableContact[observableName]()[triggerFieldName]() != "") {
			editableContact[listName].push(editableContact[observableName]());
			editableContact[observableName](createFunction(editableContact.getContact()));
		}
	};
};

/**
 * Creates a new editable empty mail address for the given contact with the default type CONTACT_MAIL_ADDRESS_TYPE_PRIVATE.
 * @param {tutao.entity.tutanota.Contact} The contact.
 */
tutao.entity.tutanota.ContactExtension.createEmptyContactMailAddressEditable = function(contact) {
	var newma = new tutao.entity.tutanota.ContactMailAddress(contact);
	newma.setAddress("");
	newma.setType(tutao.entity.tutanota.TutanotaConstants.CONTACT_MAIL_ADDRESS_TYPE_PRIVATE);
	newma.setCustomTypeName("");
	return new tutao.entity.tutanota.ContactMailAddressEditable(newma);
};

/**
 * Creates a new editable empty phone number for the given contact with the default type CONTACT_PHONE_NUMBER_TYPE_PRIVATE.
 * @param {tutao.entity.tutanota.Contact} The contact.
 */
tutao.entity.tutanota.ContactExtension.createEmptyContactPhoneNumberEditable = function(contact) {
	var newma = new tutao.entity.tutanota.ContactPhoneNumber(contact);
	newma.setNumber("");
	newma.setType(tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_PRIVATE);
	newma.setCustomTypeName("");
	return new tutao.entity.tutanota.ContactPhoneNumberEditable(newma);
};

/**
 * Creates a new editable empty phone number for the given contact with the default type CONTACT_PHONE_NUMBER_TYPE_MOBILE.
 * @param {tutao.entity.tutanota.Contact} The contact.
 */
tutao.entity.tutanota.ContactExtension.createEmptyMobileContactPhoneNumberEditable = function(contact) {
	var newma = new tutao.entity.tutanota.ContactPhoneNumber(contact);
	newma.setNumber("");
	newma.setType(tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_MOBILE);
	newma.setCustomTypeName("");
	return new tutao.entity.tutanota.ContactPhoneNumberEditable(newma);
};

/**
 * Creates a new editable empty address for the given contact with the default type CONTACT_ADDRESS_TYPE_PRIVATE.
 * @param {tutao.entity.tutanota.Contact} The contact.
 */
tutao.entity.tutanota.ContactExtension.createEmptyContactAddressEditable = function(contact) {
	var newma = new tutao.entity.tutanota.ContactAddress(contact);
	newma.setAddress("");
	newma.setType(tutao.entity.tutanota.TutanotaConstants.CONTACT_ADDRESS_TYPE_PRIVATE);
	newma.setCustomTypeName("");
	return new tutao.entity.tutanota.ContactAddressEditable(newma);
};

/**
 * Creates a new editable empty social id for the given contact with the default type CONTACT_SOCIAL_ID_TYPE_OTHER.
 * @param {tutao.entity.tutanota.Contact} The contact.
 */
tutao.entity.tutanota.ContactExtension.createEmptyContactSocialIdEditable = function(contact) {
	var newma = new tutao.entity.tutanota.ContactSocialId(contact);
	newma.setSocialId("");
	newma.setType(tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_OTHER);
	newma.setCustomTypeName("");
	return new tutao.entity.tutanota.ContactSocialIdEditable(newma);
};

"use strict";

tutao.provide('tutao.entity.tutanota.ContactWrapper');

/**
 * Provides additional methods on a contact.
 * @param {tutao.entity.tutanota.Contact} contact The contact.
 * @constructor
 */
tutao.entity.tutanota.ContactWrapper = function(contact) {
	this._contact = contact;
};

// there shall be only one editable contact instance per contact to sync password channel and contact editing
// the cache contains a map from contact id to ContactEditable
tutao.entity.tutanota.ContactWrapper._editableContactsCache = [];

/**
 * Creates an empty contact and returns it wrapped.
 * @return {tutao.entity.tutanota.ContactWrapper} The wrapped empty contact.
 */
tutao.entity.tutanota.ContactWrapper.createEmptyContactWrapper = function() {
	var contact = new tutao.entity.tutanota.Contact();
    contact.setOwner(tutao.locator.userController.getUserGroupId());
    contact.setArea(tutao.entity.tutanota.TutanotaConstants.AREA_CONTACTS);
	contact.setFirstName("");
	contact.setLastName("");
	contact.setCompany("");
	contact.setTitle("");
	contact.setBirthday(null);
	contact.setComment("");
	contact.setAutoTransmitPassword("");
	return new tutao.entity.tutanota.ContactWrapper(contact);
};

/**
 * Provides the wrapped contact.
 * @return {tutao.entity.tutanota.Contact} The contact.
 */
tutao.entity.tutanota.ContactWrapper.prototype.getContact = function() {
	return this._contact;
};

/**
 * Returns true if the given mail address matches one of the mail addresses of this contact.
 * @param {string} mailAddress The mailAddress to check in lower case.
 * @return {boolean} True if the mailAddress matches, false otherwise.
 */
tutao.entity.tutanota.ContactWrapper.prototype.hasMailAddress = function(mailAddress) {

    var cleanedMailAddress = tutao.tutanota.util.Formatter.getCleanedMailAddress(mailAddress);
	for (var i = 0; i < this._contact.getMailAddresses().length; i++) {
        var cleanedContactMailAddress = tutao.tutanota.util.Formatter.getCleanedMailAddress(this._contact.getMailAddresses()[i].getAddress());
		if (cleanedContactMailAddress === cleanedMailAddress) {
			return true;
		}
	}
	return false;
};

/**
 * Provides the full name of the given contact consisting of first and last name.
 * @return {string} The full name of the contact.
 */
tutao.entity.tutanota.ContactWrapper.prototype.getFullName = function() {
	var fullName = this._contact.getFirstName() + " " + this._contact.getLastName();
	return fullName.trim(); // cut off the whitespace if first or last name is not existing
};

/**
 * Provides the name of the contact by which it is sorted in the contact list.
 * @return {string} The sort name of the contact.
 */
tutao.entity.tutanota.ContactWrapper.prototype.getSortName = function() {
    return (this._contact.getLastName().trim().toLowerCase() != "") ? (this._contact.getLastName().trim().toLowerCase() + ", " + this._contact.getFirstName().trim().toLowerCase()) : this._contact.getFirstName().trim().toLowerCase();
};

/**
 * Provides the age of the contact.
 * @return {string=} The age or null if no birthday exists.
 */
tutao.entity.tutanota.ContactWrapper.prototype.getAge = function() {
	if (this._contact.getBirthday()) {
        var today = new Date();
        var birthDate = this._contact.getBirthday();
        var age = today.getFullYear() - birthDate.getFullYear();
        var m = today.getMonth() - birthDate.getMonth();
        if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
            age--;
        }
        return String(age);
	} else {
		return null;
	}
};

/**
 * Provides the type name of the given mail address.
 * @param {tutao.entity.tutanota.ContactMailAddress} contactMailAddress The mail address of a contact.
 * @return {string} The name of the mail address type.
 */
tutao.entity.tutanota.ContactWrapper.getMailAddressTypeName = function(contactMailAddress) {
	if (contactMailAddress.getType() == tutao.entity.tutanota.TutanotaConstants.CONTACT_MAIL_ADDRESS_TYPE_CUSTOM) {
		return contactMailAddress.getCustomTypeName();
	} else {
		return tutao.entity.tutanota.TutanotaConstants.CONTACT_MAIL_ADDRESS_TYPE_NAMES()[contactMailAddress.getType()].name;
	}
};

/**
 * Provides the type name of the given phone number.
 * @param {tutao.entity.tutanota.ContactPhoneNumber} contactPhoneNumber The phone number of a contact.
 * @return {string} The name of the phone number type.
 */
tutao.entity.tutanota.ContactWrapper.getPhoneNumberTypeName = function(contactPhoneNumber) {
	if (contactPhoneNumber.getType() == tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_CUSTOM) {
		return contactPhoneNumber.getCustomTypeName();
	} else {
		return tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_NAMES()[contactPhoneNumber.getType()].name;
	}
};

/**
 * Provides the type name of the given address.
 * @param {tutao.entity.tutanota.ContactAddress} contactAddress The address of a contact.
 * @return {string} The name of the address type.
 */
tutao.entity.tutanota.ContactWrapper.getAddressTypeName = function(contactAddress) {
	if (contactAddress.getType() == tutao.entity.tutanota.TutanotaConstants.CONTACT_ADDRESS_TYPE_CUSTOM) {
		return contactAddress.getCustomTypeName();
	} else {
		return tutao.entity.tutanota.TutanotaConstants.CONTACT_ADDRESS_TYPE_NAMES()[contactAddress.getType()].name;
	}
};

/**
 * Provides the type name of the given social id.
 * @param {tutao.entity.tutanota.ContactSocialId} contactSocialId The social id of a contact.
 * @return {string} The name of the social id type.
 */
tutao.entity.tutanota.ContactWrapper.getSocialIdTypeName = function(contactSocialId) {
	if (contactSocialId.getType() == tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_CUSTOM) {
		return contactSocialId.getCustomTypeName();
	} else {
		return tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_NAMES()[contactSocialId.getType()].name;
	}
};

/**
 * Provided the ContactEditable instance for this contact. As long as one or more instances edit the same contact, always the same ContactEditable instance is provided.
 * @param {Object} editingInstance The instance that edits the contact.
 */
tutao.entity.tutanota.ContactWrapper.prototype.startEditingContact = function(editingInstance) {
	var cache = tutao.entity.tutanota.ContactWrapper._editableContactsCache;
	var entry = null;
	for (var i = 0; i < cache.length; i++) {
		if (cache[i].editable.getContact() == this._contact) {
			entry = cache[i];
			break;
		}
	}
	if (entry && entry.editingInstances.indexOf(editingInstance) != -1) {
		console.log("start editing without stop", editingInstance);
	} else if (!entry) {
		entry = { "editable": new tutao.entity.tutanota.ContactEditable(this._contact), "editingInstances": [editingInstance] };
		cache.push(entry);
	} else {
		entry.editingInstances.push(editingInstance);
	}
	return entry.editable;
};


/**
 * Deletes the ContactEditable as soon as there are no more instances that edit the contact.
 * @param {Object} editingInstance The instance that has edited the contact.
 */
tutao.entity.tutanota.ContactWrapper.prototype.stopEditingContact = function(editingInstance) {
	var cache = tutao.entity.tutanota.ContactWrapper._editableContactsCache;
	var entry = null;
	var i = 0;
	for (; i < cache.length; i++) {
		if (cache[i].editable.getContact() == this._contact) {
			entry = cache[i];
			break;
		}
	}
	if (!entry || !entry.editingInstances.indexOf(editingInstance) == -1) {
		console.log("stop editing without start", editingInstance);
		return;
	}
	entry.editingInstances.splice(entry.editingInstances.indexOf(editingInstance), 1);
	if (entry.editingInstances.length == 0) {
		cache.splice(i, 1);
	}
};

"use strict";

tutao.provide('tutao.entity.EntityHelper');

/**
 * Entity helper instances exist for each instance.
 * @param {Object} entity The entity this helper belongs to.
 * @constructor
 */
tutao.entity.EntityHelper = function(entity) {
	this._entity = entity;
	// contains objects of the form {listener: function(), id: *}
	this._observers = [];
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is overwritten (i.e. the new id is stored)
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.EntityHelper.prototype.registerObserver = function(listener, id) {
	for (var i = 0; i < this._observers.length; i++) {
		if (this._observers[i].listener == listener) {
			// just update the id
			this._observers[i].id = id;
			return;
		}
	}
	this._observers.push({ listener: listener, id: id });
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.EntityHelper.prototype.unregisterObserver = function(listener) {
	for (var i = 0; i < this._observers.length; i++) {
		if (this._observers[i].listener == listener) {
			this._observers.splice(i, 1);
			break;
		}
	}
};

/**
 * Must be called when any attribute of the entity has changed. Notifies all registered observers.
 * @param {boolean} deleted Indicates if the entity was deleted. True = deleted, false = update.
 */
tutao.entity.EntityHelper.prototype.notifyObservers = function(deleted) {
	for (var i = 0; i < this._observers.length; i++) {
		this._observers[i].listener(deleted, this._entity, this._observers[i].id);
	}
};

/**
 * @return {boolean} True if this is a new object which is not yet stored on the server.
 */
tutao.entity.EntityHelper.prototype._isNewObject = function() {
	return (this._entity.__permissions == null);
};

/**
 * Loads the session key from permissions. If not locally available, the permissions are loaded from the server. If the entity itself is a permission, no session key is loaded because permissions are not encrypted.
 * Tries to retrieve the symmetric encrypted sessionKey first for perfomance reasons. Otherwise, the public encrypted sessionKey is used.
 * @return {Promise.<Object>} Resolves to the entity this function has been called on or an exception if the loading failed.
 */
tutao.entity.EntityHelper.prototype.loadSessionKey = function() {
	var self = this;
	if (!this._entity.ENCRYPTED || this._sessionKey != null) {
		return Promise.resolve(this._entity);
	}
	if (this._entity.getListEncSessionKey && this._entity.getListEncSessionKey()) { // check that it is a list element type and that the list key is set
		return tutao.entity.EntityHelper.getListKey(this._entity.getId()[0]).then(function(listKey) {
            self.setSessionKey(tutao.locator.aesCrypter.decryptKey(listKey, self._entity.getListEncSessionKey()));
            return self._entity;
		}).caught(function(e) {
            return self._loadSessionKeyOfSinglePermission();
        });
	} else {
		return this._loadSessionKeyOfSinglePermission();
	}
};

/**
 * Loads the session key from a single permission (no list key is used).
 * @return {Promise.<Object>} Resolves to the entity this function has been called on or an exception if the loading failed.
 * @private
 */
tutao.entity.EntityHelper.prototype._loadSessionKeyOfSinglePermission = function() {
    var self = this;
    //TODO (Performance) avoid to load elements from server if some are already cached.
    return tutao.rest.EntityRestInterface.loadAll(tutao.entity.sys.Permission, this._entity.__permissions).then(function(permissions, exception) {
        if (tutao.locator.userController.isInternalUserLoggedIn()) {
            self.setSessionKey(tutao.entity.EntityHelper._tryGetSymEncSessionKey(permissions));
            if (self._sessionKey != null) {
                return self._entity;
            }
            return self._tryGetPubEncSessionKey(permissions).then(function(sessionKey) {
                self.setSessionKey(sessionKey);
                if (sessionKey == null) {
                    throw new tutao.NotAuthorizedError("session key not found in permissions");
                } else {
                    return self._entity;
                }
            });
        } else {
            self.setSessionKey(tutao.entity.EntityHelper._tryGetSymEncSessionKey(permissions));
            if (self._sessionKey != null) {
                return self._entity;
            }
            return self._tryGetExternalSessionKey(permissions).then(function(sessionKey) {
                self.setSessionKey(sessionKey);
                return self._entity;
            });
        }
    });
};

/**
 * Loads the list key from a list permission.
 * @param {string} listId The id of the list.
 * @return {Promise.<Object>} Resolves to the listKey or an exception if the loading failed.
 */
tutao.entity.EntityHelper.getListKey = function(listId) {
    return this._getListKey(listId, tutao.rest.EntityRestInterface.GENERATED_MIN_ID );
};

tutao.entity.EntityHelper._getListKey = function(listId, startId) {
    var self = this;
    return tutao.entity.sys.Permission.loadRange(listId, startId, 1, false).then(function(permissions) {
        var listKey = tutao.entity.EntityHelper._tryGetSymEncSessionKey(permissions);
        if (listKey == null){
            if (permissions.length > 0){
                return self._getListKey(listId, permissions[permissions.length -1]);
            } else {
                throw new Error("no list permission found");
            }
        }
        return listKey;
    });
};


/**
 * Returns the session key of the entity.
 * @return {Object|null} The session key of this entity or null if the session key is not available.
 */
tutao.entity.EntityHelper.prototype.getSessionKey = function() {
	if (this._sessionKey) {
		return this._sessionKey;
	}
	if (this._isNewObject() && this._entity.ENCRYPTED) {
		this._sessionKey = tutao.locator.aesCrypter.generateRandomKey();
	} else {
		// the session key is loaded when loadSessionKey is called directly after the entity was received from the server.
		console.log("session key is missing");
		this._sessionKey = null;
	}
	return this._sessionKey;
};

/**
 * Sets the session key
 * @param {Object} sessionKey The session key to set.
 */
tutao.entity.EntityHelper.prototype.setSessionKey = function(sessionKey) {
	this._sessionKey = sessionKey;
};

/**
 * Provides the session key via an externally encrypted session key.
 * @param {Array.<tutao.entity.sys.Permission>} permissions The permissions of the user on this entity.
 * @return {Promise.<Object>} Resolves to null if no permission was found and the session key otherwise. Rejects, if decrypting the session key failed.
 */
tutao.entity.EntityHelper.prototype._tryGetExternalSessionKey = function(permissions) {
    var self = this;
	if (permissions.length == 0) {
		return Promise.reject(new Error("no permission found"));
	}
	// there should be only one permission
	var permission = permissions[0];
	if (permission.getType() != "5") {
		return Promise.reject(new Error("no external permission type: " + permission.getType()));
	}
	return this._loadBucketPermissions(permission.getBucket().getBucketPermissions()).then(function(bucketPermissions) {
		// find the bucket permission with the same group as the permission and external type
		var bucketPermission = null;
		for (var i = 0; i < bucketPermissions.length; i++) {
			if (bucketPermissions[i].getType() == "3" && permission.getGroup() == bucketPermissions[i].getGroup()) {
				bucketPermission = bucketPermissions[i];
				break;
			}
		}
		if (bucketPermission == null) {
			throw new Error("no corresponding bucket permission found");
		}
		var sessionKey;
        var bucketKey = tutao.locator.aesCrypter.decryptKey(tutao.locator.userController.getUserGroupKey(), bucketPermission.getSymEncBucketKey());
        sessionKey = tutao.locator.aesCrypter.decryptKey(bucketKey, permission.getBucketEncSessionKey());
        self._updateWithSymPermissionKey(permission, bucketPermission, tutao.locator.userController.getUserGroupKey(), sessionKey);
		return sessionKey;
	});
};

/**
 * Provides the session key via a symmetric encrypted session key.
 * @param {Array.<tutao.entity.sys.Permission>} permissions The permissions of the user on this entity.
 * @return {Object} Returns null if no permission was found and the session key otherwise.
 * @throw {tutao.crypto.CryptoError} If an error occurs during session key decryption.
 */
tutao.entity.EntityHelper._tryGetSymEncSessionKey = function(permissions) {
	var user = tutao.locator.userController.getLoggedInUser();
	for (var i = 0; i < permissions.length; i++) {
		if (permissions[i].getGroup() == user.getUserGroup().getGroup() && (permissions[i].getType() == "1" || permissions[i].getType() == "2")) {
			return tutao.locator.aesCrypter.decryptKey(tutao.locator.userController.getUserGroupKey(), permissions[i].getSymEncSessionKey());
		}
	}
	var memberships = user.getMemberships();
	for (var i = 0; i < permissions.length; i++) {
		for (var a = 0; a < memberships.length; a++) {
			if (permissions[i].getGroup() == memberships[a].getGroup() && (permissions[i].getType() == "1" || permissions[i].getType() == "2")) {
				var groupKey = tutao.locator.aesCrypter.decryptKey(tutao.locator.userController.getUserGroupKey(), memberships[a].getSymEncGKey());
				return tutao.locator.aesCrypter.decryptKey(groupKey, permissions[i].getSymEncSessionKey());
			}
		}
	}
	return null;
};

/**
 * Provides the session key via an asymmetric encrypted session key.
 * @param {Array.<tutao.entity.sys.Permission>} permissions The permissions of the user on this entity.
 * @return {Promise.<Object>} Resolves to null if no permission was found and the session key otherwise. Rejects if decrypting the session key failed.
 */
tutao.entity.EntityHelper.prototype._tryGetPubEncSessionKey = function(permissions) {
	var self = this;
	var user = tutao.locator.userController.getLoggedInUser();
    var groupKey;
	for (var i = 0; i < permissions.length; i++) {
		if (permissions[i].getGroup() == user.getUserGroup().getGroup() && permissions[i].getType() == "0") {
			groupKey = tutao.locator.userController.getUserGroupKey();
			return self._loadPublicBucketPermissionSessionKey(permissions[i], groupKey);
		}
	}
	var memberships = user.getMemberships();
	for (var i = 0; i < permissions.length; i++) {
		for (var a = 0; a < memberships.length; a++) {
			if (permissions[i].getGroup() == memberships[a].getGroup() && permissions[i].getType() == "0") {
                groupKey = tutao.locator.aesCrypter.decryptKey(tutao.locator.userController.getUserGroupKey(), memberships[a].getSymEncGKey());
				return self._loadPublicBucketPermissionSessionKey(permissions[i], groupKey);
			}
		}
	}
	return Promise.resolve(null);
};

/**
 * Updates the given public permission with the given symmetric key for faster access.
 * @param {tutao.entity.sys.Permission} permission The permission.
 * @param {tutao.entity.sys.BucketPermission} bucketPermission The bucket permission.
 * @param {Object} groupKey The symmetric group key.
 * @param {Object} sessionKey The symmetric session key.
 */
tutao.entity.EntityHelper.prototype._updateWithSymPermissionKey = function(permission, bucketPermission, groupKey, sessionKey) {
	var self = this;
	if (this._entity.getListEncSessionKey) {
		return tutao.entity.EntityHelper.getListKey(this._entity.getId()[0]).then(function(listKey) {
            self._entity.setListEncSessionKey(tutao.locator.aesCrypter.encryptKey(listKey, sessionKey));
            return self._entity.updateListEncSessionKey();
		}).caught(function(e) {
            console.log("this exception is ok for testing if another user is logged asynchronously (this method is not waiting executed synchronous)", e);
        });
	} else {
		var updateService = new tutao.entity.sys.UpdatePermissionKeyData();
		updateService.setPermission(permission.getId());
		updateService.setBucketPermission(bucketPermission.getId());
		updateService.setSymEncSessionKey(tutao.locator.aesCrypter.encryptKey(groupKey, sessionKey));
		updateService.setSymEncBucketKey(null);
		updateService.setBucketEncSessionKey(null);
		return updateService.setup({}, tutao.entity.EntityHelper.createAuthHeaders());
	}
};

/**
 * Downloads the list key and encrypts the session key of the instance with this key.
 * @param {string} listId The id of the list.
 * @return {Promise.<string>}
 */
tutao.entity.EntityHelper.prototype.createListEncSessionKey = function(listId) {
	var self = this;
	return tutao.entity.EntityHelper.getListKey(listId).then(function(listKey, exception) {
		return tutao.locator.aesCrypter.encryptKey(listKey, self.getSessionKey());
	});
};

/**
 * Loads the bucket permissions for the given bucket permission list id.
 * @param {string} bucketId The list id of the bucket permissions.
 * @return {Promise.<Array.<tutao.entity.sys.BucketPermission>>}
 */
tutao.entity.EntityHelper.prototype._loadBucketPermissions = function(bucketId) {
    //TODO (Performance) avoid to load elements from server if some are already cached.
    return tutao.rest.EntityRestInterface.loadAll(tutao.entity.sys.BucketPermission, bucketId);
};

/**
 * Loads the session key from the given public permission. Updates the permission on the server with the
 * symmetric encrypted session key.
 * @param {tutao.entity.sys.Permission} permission The permission that contains the bucket encrypted session key.
 * @param {Object} groupKey The symmetric group key of the owner group of the permission.
 * @return {Promise.<Object>} Resolves to the session key. Rejects if decrypting the session key failed or the group could not be loaded.
 */
tutao.entity.EntityHelper.prototype._loadPublicBucketPermissionSessionKey = function(permission, groupKey) {
	var self = this;
	return this._loadBucketPermissions(permission.getBucket().getBucketPermissions()).then(function(bucketPermissions) {
		// find the bucket permission with the same group as the permission and public type
		var bucketPermission = null;
		for (var i = 0; i < bucketPermissions.length; i++) {
			if (bucketPermissions[i].getType() == "2" && permission.getGroup() == bucketPermissions[i].getGroup()) {
				bucketPermission = bucketPermissions[i];
				break;
			}
		}
		if (bucketPermission == null) {
			throw new Error("no corresponding bucket permission found");
		}
		return tutao.entity.sys.Group.load(permission.getGroup()).then(function(group) {
			var privateKey = self._getPrivateKey(group, Number(bucketPermission.getPubKeyVersion()), groupKey);
            return new Promise(function(resolve, reject) {
                tutao.locator.rsaCrypter.decryptAesKey(privateKey, bucketPermission.getPubEncBucketKey(), function(bucketKeyHex, exception) {
                    if (exception) {
                        reject(exception);
                        return;
                    }
                    var sessionKey;
                    var bucketKey = tutao.locator.aesCrypter.hexToKey(bucketKeyHex);
                    sessionKey = tutao.locator.aesCrypter.decryptKey(bucketKey, permission.getBucketEncSessionKey());
                    self._updateWithSymPermissionKey(permission, bucketPermission, groupKey, sessionKey);
                    resolve(sessionKey);
                });
            });
		});
	});
};

/**
 * Provides the private key corresponding to the given key pair version from the given group.
 * @param {tutao.entity.sys.Group} group The group.
 * @param {number} version The version of the key pair.
 * @param {Object} symGroupKey The group key of the given group.
 * @return {Object} The private key.
 * @throws {tutao.InvalidDataError} If the private key could not be found or could not be decrypted.
 */
tutao.entity.EntityHelper.prototype._getPrivateKey = function(group, version, symGroupKey) {
	var keyPairs = group.getKeys();
	for (var i = 0; i < group.getKeys().length; i++) {
		if (Number(keyPairs[i].getVersion()) == version) {
            var privateKeyHex = tutao.locator.aesCrypter.decryptPrivateRsaKey(symGroupKey, keyPairs[i].getSymEncPrivKey());
            return tutao.locator.rsaCrypter.hexToKey(privateKeyHex);
		}
	}
	throw new tutao.InvalidDataError("private key with version" + version + " not found for group " + group.getId());
};

/**
 * Returns a map which contains the encrypted session key for post requests.
 * @param {tutao.entity.BucketData} bucketData The bucket for which the shared permission shall be created
 * @return {Object.<string, string>} The post permission map.
 */
tutao.entity.EntityHelper.prototype.createPostPermissionMap = function(bucketData) {
	// use the user group as owner for now
	var map = {};
	map[tutao.rest.ResourceConstants.GROUP_ID] = tutao.locator.userController.getUserGroupId();
	if (this._entity.ENCRYPTED) {
		var symEncSessionKey = tutao.locator.aesCrypter.encryptKey(tutao.locator.userController.getUserGroupKey(), this.getSessionKey());
		map[tutao.rest.ResourceConstants.SYM_ENC_SESSION_KEY] = tutao.util.EncodingConverter.base64ToBase64Url(symEncSessionKey);
		map[tutao.rest.ResourceConstants.BUCKET_ENC_SESSION_KEY] = tutao.util.EncodingConverter.base64ToBase64Url(tutao.locator.aesCrypter.encryptKey(bucketData.getBucketKey(), this.getSessionKey()));
	}
	map[tutao.rest.ResourceConstants.BUCKET_PERMISSION_LIST_ID] = bucketData.getBucketId();
	return map;
};

/**
 * Returns a map which contains the permission data for creating a list.
 * @param {tutao.entity.BucketData} bucketData The bucket for which the shared permission shall be created
 * @param {boolean} encrypted True if the type for which the list shall be created is encrypted, false otherwise.
 * @return {Object.<string, string>} The map.
 */
tutao.entity.EntityHelper.createPostListPermissionMap = function(bucketData, encrypted) {
	// user the user group as owner for now
	var listKey = tutao.locator.aesCrypter.generateRandomKey();
	var map = {};
	map[tutao.rest.ResourceConstants.GROUP_ID] = tutao.locator.userController.getUserGroupId();
	if (encrypted) {
		map[tutao.rest.ResourceConstants.SYM_ENC_LIST_KEY] = tutao.util.EncodingConverter.base64ToBase64Url(tutao.locator.aesCrypter.encryptKey(tutao.locator.userController.getUserGroupKey(), listKey));
		map[tutao.rest.ResourceConstants.BUCKET_ENC_LIST_KEY] = tutao.util.EncodingConverter.base64ToBase64Url(tutao.locator.aesCrypter.encryptKey(bucketData.getBucketKey(), listKey));
	}
	map[tutao.rest.ResourceConstants.BUCKET_PERMISSION_LIST_ID] = bucketData.getBucketId();
	return map;
};

/**
 * Returns a map which contains authentication data for the logged in user.
 * @return {Object.<string, string>} The user id map.
 */
tutao.entity.EntityHelper.createAuthHeaders = function() {
	var map = {};
    map[tutao.rest.ResourceConstants.USER_ID_PARAMETER_NAME] = tutao.locator.userController.getUserId();
	map[tutao.rest.ResourceConstants.AUTH_VERIFIER_PARAMETER_NAME] = tutao.locator.userController.getAuthVerifier();
	if (tutao.locator.userController.isExternalUserLoggedIn()) {
        map[tutao.rest.ResourceConstants.AUTH_TOKEN_PARAMETER_NAME] = tutao.locator.userController.getAuthToken();
	}
	return map;
};

/**
 * Converts the given aggregated type instances to a json string.
 * @param {Object|Array.<Object>} aggregates One or more aggregates.
 */
tutao.entity.EntityHelper.aggregatesToJsonData = function(aggregates) {
	if (!aggregates) {
		return null;
	} else if (aggregates instanceof Array) {
		var aggregateDataList = [];
		for (var i = 0; i < aggregates.length; i++) {
			aggregateDataList[i] = aggregates[i].toJsonData();
		}
		return aggregateDataList;
	} else {
		return aggregates.toJsonData();
	}
};

/**
 * Generates a random id for an aggregate.
 * @return {string} The id.
 */
tutao.entity.EntityHelper.generateAggregateId = function() {
	return tutao.util.EncodingConverter.base64ToBase64Url(tutao.util.EncodingConverter.hexToBase64(tutao.locator.randomizer.generateRandomData(4)));
};

/**
 * Loads the session keys for the given entities.
 * @param {Array.<Object>} entities. The entities to prepare.
 * @return {Promise.<Array.<Object>>} Resolves to the same entities which have been provided. Rejects if loading the session keys failed.
 */
tutao.entity.EntityHelper.loadSessionKeys = function(entities) {
    // always load sequentially (each) instead of in parallel (map), many server requests may be done in parallel if the key is not yet cached
    return Promise.each(entities, function(entity) {
        return entity._entityHelper.loadSessionKey();
    });
};

"use strict";

tutao.provide('tutao.entity.tutanota.TutanotaConstants');

tutao.entity.tutanota.TutanotaConstants.OPERATION_TYPE_CREATE = "0";
tutao.entity.tutanota.TutanotaConstants.OPERATION_TYPE_UPDATE = "1";
tutao.entity.tutanota.TutanotaConstants.OPERATION_TYPE_DELETE = "2";

tutao.entity.tutanota.TutanotaConstants.PHONE_NUMBER_TYPE_INVALID = "0";
tutao.entity.tutanota.TutanotaConstants.PHONE_NUMBER_TYPE_MOBILE = "1";
tutao.entity.tutanota.TutanotaConstants.PHONE_NUMBER_TYPE_FIXED_LINE = "2";
tutao.entity.tutanota.TutanotaConstants.PHONE_NUMBER_TYPE_OTHER = "3";
tutao.entity.tutanota.TutanotaConstants.PHONE_NUMBER_TYPE_UNKNOWN = "4";

tutao.entity.tutanota.TutanotaConstants.GROUP_TYPE_USER = "0";

tutao.entity.tutanota.TutanotaConstants.AREA_CONTACTS = "1";

tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_SYSTEM = "0";

tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_FREE = "1";

tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_STARTER = "2";

tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_PREMIUM = "3";

tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_EXTERNAL = "5";

tutao.entity.tutanota.TutanotaConstants.REGISTRATION_STATE_INITIAL = "0";

tutao.entity.tutanota.TutanotaConstants.REGISTRATION_STATE_CODE_SENT = "1";

tutao.entity.tutanota.TutanotaConstants.REGISTRATION_STATE_VERIFIED = "2";

/**
 * Id for the internal recipient type.
 */
tutao.entity.tutanota.TutanotaConstants.RECIPIENT_TYPE_INTERNAL = "0";

/**
 * Id for the external recipient type.
 */
tutao.entity.tutanota.TutanotaConstants.RECIPIENT_TYPE_EXTERNAL = "1";

/**
 * Id for the new type.
 */
tutao.entity.tutanota.TutanotaConstants.CONVERSATION_TYPE_NEW = "0";

/**
 * Id for the reply type.
 */
tutao.entity.tutanota.TutanotaConstants.CONVERSATION_TYPE_REPLY = "1";

/**
 * Id for the forward type.
 */
tutao.entity.tutanota.TutanotaConstants.CONVERSATION_TYPE_FORWARD = "2";

/**
 * The String to append to the beginning of a subject when replying on a mail.
 */
tutao.entity.tutanota.TutanotaConstants.CONVERSATION_REPLY_SUBJECT_PREFIX = "Re: ";

/**
 * The String to append to the beginning of a subject when forwarding a mail.
 */
tutao.entity.tutanota.TutanotaConstants.CONVERSATION_FORWARD_SUBJECT_PREFIX = "Fwd: ";

// mail states
/**
 * Id for the state draft.
 */
tutao.entity.tutanota.TutanotaConstants.MAIL_STATE_DRAFT = 0;

/**
 * Id for the state sent.
 */
tutao.entity.tutanota.TutanotaConstants.MAIL_STATE_SENT = 1;

/**
 * Id for the state received.
 */
tutao.entity.tutanota.TutanotaConstants.MAIL_STATE_RECEIVED = 2;

// mail addresses
/**
 * Id for a private email address in tutao.entity.tutanota.ContactMailAddress.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_MAIL_ADDRESS_TYPE_PRIVATE = "0";

/**
 * Id for a business email address in tutao.entity.tutanota.ContactMailAddress.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_MAIL_ADDRESS_TYPE_WORK = "1";

/**
 * Id for an other email address in tutao.entity.tutanota.ContactMailAddress.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_MAIL_ADDRESS_TYPE_OTHER = "2";

/**
 * Id for a custom email address in tutao.entity.tutanota.ContactMailAddress. The custom name can be specified by the user.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_MAIL_ADDRESS_TYPE_CUSTOM = "3";

/**
 * The names for the mail address types.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_MAIL_ADDRESS_TYPE_NAMES = function() {
	return [{ id: tutao.entity.tutanota.TutanotaConstants.CONTACT_MAIL_ADDRESS_TYPE_PRIVATE, name: tutao.locator.languageViewModel.get("private_label") },
     { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_MAIL_ADDRESS_TYPE_WORK, name: tutao.locator.languageViewModel.get("work_label") },
     { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_MAIL_ADDRESS_TYPE_OTHER, name: tutao.locator.languageViewModel.get("other_label") },
     { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_MAIL_ADDRESS_TYPE_CUSTOM, name: tutao.locator.languageViewModel.get("custom_label") }];
};

// phone numbers
/**
 * Id for a private phone number in tutao.entity.tutanota.PhoneNumber.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_PRIVATE = "0";

/**
 * Id for a business phone number in tutao.entity.tutanota.PhoneNumber.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_WORK = "1";

/**
 * Id for a mobile phone number in tutao.entity.tutanota.PhoneNumber.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_MOBILE = "2";

/**
 * Id for a fax number in tutao.entity.tutanota.PhoneNumber.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_FAX = "3";

/**
 * Id for an other phone number in tutao.entity.tutanota.PhoneNumber.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_OTHER = "4";

/**
 * Id for a custom phone number in tutao.entity.tutanota.PhoneNumber. The custom name can be specified by the user.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_CUSTOM = "5";

/**
 * The names for the phone number types.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_NAMES = function() {
	return [{ id: tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_PRIVATE, name: tutao.locator.languageViewModel.get("private_label") },
     { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_WORK, name: tutao.locator.languageViewModel.get("work_label") },
	 { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_MOBILE, name: tutao.locator.languageViewModel.get("mobile_label") },
	 { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_FAX, name: tutao.locator.languageViewModel.get("fax_label") },
	 { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_OTHER, name: tutao.locator.languageViewModel.get("other_label") },
	 { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_CUSTOM, name: tutao.locator.languageViewModel.get("custom_label") }];

};


// addresses
/**
 * Id for a private address in tutao.entity.tutanota.ContactAddress.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_ADDRESS_TYPE_PRIVATE = "0";

/**
 * Id for a business address in tutao.entity.tutanota.ContactAddress.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_ADDRESS_TYPE_WORK = "1";

/**
 * Id for an other address in tutao.entity.tutanota.ContactAddress.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_ADDRESS_TYPE_OTHER = "2";

/**
 * Id for a custom address in tutao.entity.tutanota.ContactAddress. The custom name can be specified by the user.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_ADDRESS_TYPE_CUSTOM = "3";

/**
 * The names for the address types.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_ADDRESS_TYPE_NAMES = function() {
	return [{ id: tutao.entity.tutanota.TutanotaConstants.CONTACT_ADDRESS_TYPE_PRIVATE, name: tutao.locator.languageViewModel.get("private_label") },
	 { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_ADDRESS_TYPE_WORK, name: tutao.locator.languageViewModel.get("work_label") },
	 { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_ADDRESS_TYPE_OTHER, name: tutao.locator.languageViewModel.get("other_label") },
	 { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_ADDRESS_TYPE_CUSTOM, name: tutao.locator.languageViewModel.get("custom_label") }];
};


// social ids
/**
 * Id for a twitter id in tutao.entity.tutanota.SocialId.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_TWITTER = "0";

/**
 * Id for a faceboot id in tutao.entity.tutanota.SocialId.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_FACEBOOK = "1";

/**
 * Id for a xing id in tutao.entity.tutanota.SocialId.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_XING = "2";

/**
 * Id for a linked in id in tutao.entity.tutanota.SocialId.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_LINKED_IN = "3";

/**
 * Id for an other social id in tutao.entity.tutanota.SocialId.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_OTHER = "4";

/**
 * Id for a custom social id in tutao.entity.tutanota.SocialId. The custom name can be specified by the user.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_CUSTOM = "5";

/**
 * The names for the social id types.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_NAMES = function() {
	return [{ id: tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_TWITTER, name: tutao.locator.languageViewModel.get("twitter_label") },
	 { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_FACEBOOK, name: tutao.locator.languageViewModel.get("facebook_label") },
	 { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_XING, name: tutao.locator.languageViewModel.get("xing_label") },
	 { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_LINKED_IN, name: tutao.locator.languageViewModel.get("linkedin_label") },
	 { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_OTHER, name: tutao.locator.languageViewModel.get("other_label") },
	 { id: tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_CUSTOM, name: tutao.locator.languageViewModel.get("custom_label") }];
};


/**
 * The URLs that are prefixed to the social id to create the link.
 */
tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_LINKS = ["https://twitter.com/", "https://www.facebook.com/", "https://www.xing.com/profile/", "https://www.linkedin.com/in/", null, null];

/**
 * The maximum size of a single attachment in bytes.
 */
tutao.entity.tutanota.TutanotaConstants.MAX_ATTACHMENT_SIZE = 1024 * 1024 * 25;

tutao.entity.tutanota.TutanotaConstants.SHARE_TYPE_MAIL_BOX = "0";
tutao.entity.tutanota.TutanotaConstants.SHARE_TYPE_CONTACT_LIST = "1";
tutao.entity.tutanota.TutanotaConstants.SHARE_TYPE_FILE_SYSTEM = "2";
tutao.entity.tutanota.TutanotaConstants.SHARE_TYPE_FILE = "3";

"use strict";

tutao.provide('tutao.tutanota.ctrl.AccountSettingsViewModel');

/**
 * Displays the account settings. This view model is created dynamically.
 * @constructor
 */
tutao.tutanota.ctrl.AccountSettingsViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

    var user = tutao.locator.userController.getLoggedInUser();

    this.records = [];
    this.records.push({ nameTextId: "accountType_label", infoTextId: null, valueObservable: ko.observable("") });
    this.records.push({ nameTextId: "mailAddress_label", infoTextId: null, valueObservable: ko.observable("") });
    this.records.push({ nameTextId: "mailName_label", infoTextId: "mailNameInfo_msg", valueObservable: ko.observable("") });
    this.showAddinLink = (user.getAccountType() == tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_STARTER);

    var self = this;
	var accountTypeNames = ["System", "Free", "Starter", "Premium", "Stream"];
	self.records[0].valueObservable("Tutanota " + accountTypeNames[Number(user.getAccountType())]);
	user.getUserGroup().loadGroupInfo().then(function(userGroup, exception) {
        self.records[1].valueObservable(userGroup.getMailAddress());
        self.records[2].valueObservable(userGroup.getName());
	}).caught(function(e) {
        self.records[1].valueObservable("?");
        self.records[2].valueObservable("?");
        throw e;
    });
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.AdminEditUserViewModel');

/**
 * Allows the admin to edit an existing user
 * @constructor
 * @param {tutao.tutanota.ctrl.AdminUserListViewModel} adminUserListViewModel The list view model.
 * @param {tutao.entity.sys.GroupInfo} userGroupInfo The userGroupInfo of the user to edit
 */
tutao.tutanota.ctrl.AdminEditUserViewModel = function(adminUserListViewModel, userGroupInfo) {
    /**@type {tutao.tutanota.ctrl.AdminUserListViewModel}*/
    this.adminUserListViewModel = adminUserListViewModel;
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	this.startId = ko.observable(tutao.rest.EntityRestInterface.GENERATED_MAX_ID);
    /**@type {tutao.entity.sys.GroupInfo}*/
	this.userGroupInfo = userGroupInfo;
	this.name = ko.observable(userGroupInfo.getName());
    var emptyPassword = "***";
    this.password = ko.observable(emptyPassword);
    this.passwordChanged = ko.computed(function() {
        return this.password() != emptyPassword;
    }, this);
    this.passwordFocused = ko.observable(false);
    this.passwordFocused.subscribe(function(newValue) {
        if (this.password() == emptyPassword && newValue) {
           this.password("");
        } else if (this.password() == "" && !newValue) {
            this.password(emptyPassword);
        }
    }, this);

	this.busy = ko.observable(false);
    this.saveStatus = ko.observable({type: "neutral", text: "emptyString_msg" });

    this.passwordChangeAllowed = ko.observable(false);
    this.deleteUserAllowed = ko.observable(false);
    var self = this;
    tutao.entity.sys.Group.load(userGroupInfo.getGroup()).then(function(userGroup) {
        if (userGroup.getType() == tutao.entity.tutanota.TutanotaConstants.GROUP_TYPE_USER) {
            tutao.entity.sys.User.load(userGroup.getUser()).then(function(user) {
                if (!self._isAdmin(user)) {
                    self.passwordChangeAllowed(true);
                    self.deleteUserAllowed(true);
                }
            });
        }
    });
};

/**
 * Checks if the given user is an admin.
 * @param {tutao.entity.sys.User} user The user to check.
 * @returns {boolean} True if the given user is an admin.
 * @private
 */
tutao.tutanota.ctrl.AdminEditUserViewModel.prototype._isAdmin = function(user) {
    var memberships = user.getMemberships();
    for (var i=0; i<memberships.length; i++) {
        if (memberships[i].getAdmin()) {
            return true;
        }
    }
    return false;
};

/**
 * Provides the status of the first entered new password.
 * @return {Object} The status containing type and text id.
 */
tutao.tutanota.ctrl.AdminEditUserViewModel.prototype.getPasswordStatus = function() {
    if (!this.passwordChanged()) {
        return { type: "neutral", text: "passwordNotChanged_msg" };
    } else if (this.getPasswordStrength() >= 80) {
        return { type: "valid", text: "passwordValid_msg" };
    } else {
        return { type: "neutral", text: "password1InvalidUnsecure_msg" };
    }
};

tutao.tutanota.ctrl.AdminEditUserViewModel.prototype.isChangeActionAllowed = function() {
    return (!this.passwordChanged() || this.isChangePasswordActionAllowed()) && !this.busy();
};

tutao.tutanota.ctrl.AdminEditUserViewModel.prototype.isChangePasswordActionAllowed = function() {
    return (this.passwordChangeAllowed() && this.passwordChanged() && this.password() != "");
};

tutao.tutanota.ctrl.AdminEditUserViewModel.prototype.save = function() {
    if (!this.isChangeActionAllowed()) {
        return;
    }
    this.busy(true);
	this.userGroupInfo.setName(this.name());
	this.saveStatus({type: "neutral", text: "save_msg" });
    var self = this;
	this.userGroupInfo.update().then(function() {
        if (self.isChangePasswordActionAllowed()) {
            return self._resetPassword().then(function(exception) {
                self.saveStatus({type: "valid", text: "pwChangeValid_msg" });
                self.adminUserListViewModel.updateUserGroupInfo();
                tutao.locator.settingsView.showChangeSettingsColumn();
            }).caught(function(exception) {
                self.saveStatus({type: "invalid", text: "passwordResetFailed_msg" });

            })
        } else {
            self.saveStatus({type: "neutral", text: "saved_msg" });
            self.adminUserListViewModel.updateUserGroupInfo();
            tutao.locator.settingsView.showChangeSettingsColumn();
        }
	}).caught(function(e) {
        self.saveStatus({type: "neutral", text: "emptyString_msg" });
        throw e;
    }).lastly(function() {
        self.busy(false);
    });
};

tutao.tutanota.ctrl.AdminEditUserViewModel.prototype._resetPassword = function() {
    var adminGroupKey = null;
    var memberships = tutao.locator.userController.getLoggedInUser().getMemberships();
    for (var i = 0; i < memberships.length; i++) {
        if (memberships[i].getAdmin()) {
            adminGroupKey = tutao.locator.aesCrypter.decryptKey(tutao.locator.userController.getUserGroupKey(), memberships[i].getSymEncGKey());
        }
    }
    if (adminGroupKey == null) {
        return Promise.reject(new tutao.entity.EntityRestException(new Error("could not find admin key")));
    }
    var self = this;
    return tutao.entity.sys.Group.load(self.userGroupInfo.getGroup()).then(function(userGroup, exception) {
        var userGroupKey = tutao.locator.aesCrypter.decryptKey(adminGroupKey, userGroup.getAdminGroupEncGKey());
        var hexSalt = tutao.locator.kdfCrypter.generateRandomSalt();
        return tutao.locator.kdfCrypter.generateKeyFromPassphrase(self.password(), hexSalt).then(function(userPassphraseKeyHex) {
            var userPassphraseKey = tutao.locator.aesCrypter.hexToKey(userPassphraseKeyHex);
            var pwEncUserGroupKey = tutao.locator.aesCrypter.encryptKey(userPassphraseKey, userGroupKey);
            var verifier = tutao.locator.shaCrypter.hashHex(userPassphraseKeyHex);

            var service = new tutao.entity.sys.ResetPasswordData();
            service.setUser(userGroup.getUser());
            service.setSalt(tutao.util.EncodingConverter.hexToBase64(hexSalt));
            service.setVerifier(verifier);
            service.setPwEncUserGroupKey(pwEncUserGroupKey);
            return service.setup({}, null);
        });
    });
};

tutao.tutanota.ctrl.AdminEditUserViewModel.prototype.cancel = function() {
    if (this.busy()) {
        return;
    }
    this.adminUserListViewModel.removeSelection();
    tutao.locator.settingsView.showChangeSettingsColumn();
};

tutao.tutanota.ctrl.AdminEditUserViewModel.prototype.deleteUser = function() {
    if (this.busy()) {
        return;
    }
    var self = this;
    this.userGroupInfo.loadGroup().then(function(group) {
        var restore = self.userGroupInfo.getDeleted() != null;
        new tutao.entity.sys.UserDataDelete()
            .setUser(group.getUser())
            .setRestore(restore)
            .erase({}, null).then(function(deleteUserReturn) {
                self.adminUserListViewModel.updateUserGroupInfo();
                tutao.locator.settingsView.showChangeSettingsColumn();
            });
    });
};

tutao.tutanota.ctrl.AdminEditUserViewModel.prototype.getDeleteButtonText = function() {
    return this.userGroupInfo.getDeleted() == null ? 'delete_action': 'undelete_action';
};

/**
 * Provides the password strength in %.
 * @return {Number} The strength of the password.
 */
tutao.tutanota.ctrl.AdminEditUserViewModel.prototype.getPasswordStrength = function() {
    return tutao.tutanota.util.PasswordUtils.getPasswordStrength(this.password(), []);
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.AdminNewUser');

/**
 * A new user that should be added to an existing customer
 * @constructor
 */
tutao.tutanota.ctrl.AdminNewUser = function () {
    this.mailAddressPrefix = ko.observable("");
    this.mailAddressStatus = ko.observable({ type: "neutral", text: "mailAddressNeutral_msg"});
    this.mailAddressPrefix.subscribe(this._verifyMailAddress, this);
    this.name = ko.observable("");
    this.password = ko.observable(tutao.tutanota.util.PasswordUtils.generatePassword(10));
    this.state = ko.observable(tutao.tutanota.ctrl.AdminNewUser.STATE_NONE);
    this.domain = ko.observable(tutao.locator.userController.getDomain());
};

tutao.tutanota.ctrl.AdminNewUser.prototype._verifyMailAddress = function(newValue) {
    var self = this;
    var cleanedValue = newValue.toLowerCase().trim();
    if (self.mailAddressPrefix().length < 1) {
        self.mailAddressStatus({ type: "invalid", text: "mailAddressInvalid_msg"});
        return;
    } else if (!self.isValidMailAddress()) {
        self.mailAddressStatus({ type: "invalid", text: "mailAddressInvalid_msg"});
        return;
    }

    self.mailAddressStatus({ type: "invalid", text: "mailAddressBusy_msg"});

    setTimeout(function() {
        if (self.mailAddressPrefix() == newValue) {
            tutao.entity.sys.DomainMailAddressAvailabilityReturn.load(new tutao.entity.sys.DomainMailAddressAvailabilityData().setMailAddress(cleanedValue + "@" + self.domain()), [], tutao.entity.EntityHelper.createAuthHeaders()).then(function(domainMailAddressAvailabilityReturn) {
                if (self.mailAddressPrefix() == newValue) {
                    if (domainMailAddressAvailabilityReturn.getAvailable()) {
                        self.mailAddressStatus({ type: "valid", text: "mailAddressAvailable_msg"});
                    } else {
                        self.mailAddressStatus({ type: "invalid", text: "mailAddressNA_msg"});
                    }
                }
            });
        }
    }, 500);
};

/**
 * Provides the status of the password.
 * @return {Object} The status containing type and text id.
 */
tutao.tutanota.ctrl.AdminNewUser.prototype.getPasswordStatus = function () {
    if (this.password() == "") {
        return { type: "neutral", text: "password1Neutral_msg" };
    } else if (this.getPasswordStrength() >= 80) {
        return { type: "valid", text: "passwordValid_msg" };
    } else if (this.password().trim().length < 1) {
        return { type: "invalid", text: "password1InvalidTooShort_msg" };
    } else {
        return { type: "neutral", text: "password1InvalidUnsecure_msg" };
    }
};

tutao.tutanota.ctrl.AdminNewUser.prototype.getPasswordStrength = function () {
    return tutao.tutanota.util.PasswordUtils.getPasswordStrength(this.password(), [])
};

tutao.tutanota.ctrl.AdminNewUser.prototype.isValidMailAddress = function () {
    return tutao.tutanota.util.Formatter.isMailAddress(this.getMailAddress());
};

tutao.tutanota.ctrl.AdminNewUser.prototype.getMailAddress = function () {
    return tutao.tutanota.util.Formatter.getCleanedMailAddress(this.mailAddressPrefix() + "@" + this.domain());
};


tutao.tutanota.ctrl.AdminNewUser.STATE_NONE = "";
tutao.tutanota.ctrl.AdminNewUser.STATE_IN_PROGRESS = "progress";
tutao.tutanota.ctrl.AdminNewUser.STATE_SUCCESS = "success";
tutao.tutanota.ctrl.AdminNewUser.STATE_FAILED = "failed";

tutao.tutanota.ctrl.AdminNewUser.prototype.isCreateAccountPossible = function() {
    return this.mailAddressStatus().type == "valid" &&
        this.getPasswordStatus().type != "invalid";
};

/**
 * Create the new user
 * @return {Promise.<>} Resolved when finished, rejected if the rest call failed.
 */
tutao.tutanota.ctrl.AdminNewUser.prototype.create = function () {
    var self = this;
    this.state(tutao.tutanota.ctrl.AdminNewUser.STATE_IN_PROGRESS);
    var adminUser = tutao.locator.userController.getLoggedInUser();
    var memberships = adminUser.getMemberships();
    var adminUserKey = tutao.locator.userController.getUserGroupKey();

    return adminUser.loadCustomer().then(function (customer) {
        // get the admin group and customer group keys via the group memberships of the admin user
        var adminGroupKey = null;
        var customerGroupKey = null;
        for (var i = 0; i < memberships.length; i++) {
            if (memberships[i].getAdmin()) {
                adminGroupKey = tutao.locator.aesCrypter.decryptKey(adminUserKey, memberships[i].getSymEncGKey());
            } else if (memberships[i].getGroup() === customer.getCustomerGroup()) {
                customerGroupKey = tutao.locator.aesCrypter.decryptKey(adminUserKey, memberships[i].getSymEncGKey());
            }
        }
        if (!adminGroupKey) {
            return Promise.reject(new Error("could not create customer, the adminGroupKey is null!"));
        }
        if (!customerGroupKey) {
            return Promise.reject(new Error("could not create customer, the customerGroupKey is null!"));
        }

        var hexSalt = tutao.locator.kdfCrypter.generateRandomSalt();
        return tutao.locator.kdfCrypter.generateKeyFromPassphrase(self.password(), hexSalt).then(function (userPassphraseKeyHex) {
            var userPassphraseKey = tutao.locator.aesCrypter.hexToKey(userPassphraseKeyHex);

            var userGroupsListKey = null;
            return tutao.entity.EntityHelper.getListKey(customer.getUserGroups()).then(function(userGroupsListKey) {
                return tutao.tutanota.ctrl.GroupData.generateGroupKeys(self.name(), self.getMailAddress(), userPassphraseKey, adminGroupKey, userGroupsListKey).spread(function (userGroupData, userGroupKey) {
                    /** @type tutao.entity.sys.UserData */
                    var userService = new tutao.entity.sys.UserData()
                        .setUserEncClientKey(tutao.locator.aesCrypter.encryptKey(userGroupKey, tutao.locator.aesCrypter.generateRandomKey()))
                        .setUserEncCustomerGroupKey(tutao.locator.aesCrypter.encryptKey(userGroupKey, customerGroupKey))
                        .setUserGroupData(userGroupData)
                        .setSalt(tutao.util.EncodingConverter.hexToBase64(hexSalt))
                        .setVerifier(tutao.locator.shaCrypter.hashHex(userPassphraseKeyHex))
                        .setMobilePhoneNumber("");

                    return userService.setup({}, null).then(function(userReturn, exception) {
                        return tutao.tutanota.ctrl.AdminNewUser.initGroup(userReturn.getUserGroup(), userGroupKey);
                    });
                });
            });
        });
    }).then(function() {
        self.state(tutao.tutanota.ctrl.AdminNewUser.STATE_SUCCESS);
    }).caught(function(e) {
        self.state(tutao.tutanota.ctrl.AdminNewUser.STATE_FAILED);
        throw e;
    });
};

/**
 * Initializes the given user group for Tutanota (creates mail box etc.). The admin must be logged in.
 * @param {string} groupId The group to initialize.
 * @param {Object} groupKey the group key.
 * @return {Promise.<>} Resolved when finished, rejected if the rest call failed.
 */
tutao.tutanota.ctrl.AdminNewUser.initGroup = function(groupId, groupKey) {
	var s = new tutao.entity.tutanota.InitGroupData();
	
	s.setGroupId(groupId);
    s.setGroupEncEntropy(tutao.locator.aesCrypter.encryptBytes(groupKey, tutao.util.EncodingConverter.hexToBase64(tutao.locator.randomizer.generateRandomData(32))));

	var mailShareBucketKey = tutao.locator.aesCrypter.generateRandomKey();
	var mailBoxSessionkey = tutao.locator.aesCrypter.generateRandomKey();
	s.setSymEncMailBoxSessionKey(tutao.locator.aesCrypter.encryptKey(groupKey, mailBoxSessionkey));
	s.setSymEncMailShareBucketKey(tutao.locator.aesCrypter.encryptKey(groupKey, mailShareBucketKey));
	s.setMailShareBucketEncMailBoxSessionKey(tutao.locator.aesCrypter.encryptKey(mailShareBucketKey, mailBoxSessionkey));

	var contactShareBucketKey = tutao.locator.aesCrypter.generateRandomKey();
	var contactListSessionkey = tutao.locator.aesCrypter.generateRandomKey();
	s.setSymEncContactListSessionKey(tutao.locator.aesCrypter.encryptKey(groupKey, contactListSessionkey));
	s.setSymEncContactShareBucketKey(tutao.locator.aesCrypter.encryptKey(groupKey, contactShareBucketKey));
	s.setContactShareBucketEncContactListSessionKey(tutao.locator.aesCrypter.encryptKey(contactShareBucketKey, contactListSessionkey));

	var fileShareBucketKey = tutao.locator.aesCrypter.generateRandomKey();
	var fileSystemSessionkey = tutao.locator.aesCrypter.generateRandomKey();
	s.setSymEncFileSystemSessionKey(tutao.locator.aesCrypter.encryptKey(groupKey, fileSystemSessionkey));
	s.setSymEncFileShareBucketKey(tutao.locator.aesCrypter.encryptKey(groupKey, fileShareBucketKey));
	s.setFileShareBucketEncFileSystemSessionKey(tutao.locator.aesCrypter.encryptKey(fileShareBucketKey, fileSystemSessionkey));

    var groupShareBucketKey = tutao.locator.aesCrypter.generateRandomKey();
    var externalGroupInfoListKey = tutao.locator.aesCrypter.generateRandomKey();
    s.setSymEncExternalGroupInfoListKey(tutao.locator.aesCrypter.encryptKey(groupKey, externalGroupInfoListKey));
    s.setSymEncGroupShareBucketKey(tutao.locator.aesCrypter.encryptKey(groupKey, groupShareBucketKey));
    s.setGroupShareBucketEncExternalGroupInfoListKey(tutao.locator.aesCrypter.encryptKey(groupShareBucketKey, externalGroupInfoListKey));

	return s.setup({}, tutao.entity.EntityHelper.createAuthHeaders());
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.AdminUserAddViewModel');

/**
 * Shows a list of all users of a company
 * @constructor
 */
tutao.tutanota.ctrl.AdminUserAddViewModel = function(adminUserListViewModel) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
    /**
     * @type {tutao.tutanota.ctrl.AdminUserListViewModel}
     */
    this.adminUserListViewModel = adminUserListViewModel;

    /**
     * @type {function(Array<tutao.tutanota.ctrl.AdminNewUser>=): Array<tutao.tutanota.ctrl.AdminNewUser>}
     */
	this.newUsers = ko.observableArray([]);
    this.createdUsers = ko.observableArray([]);
	this.addEmptyUser();
	
	this.isEditable = ko.observable(true);
	this.createStatus = ko.observable({type: "neutral", text: "emptyString_msg", params: {}});
	this.csvDialogVisible = ko.observable(false);
	this.csvData = ko.observable("name,mail.address,securePassword (optional)");
	this.csvData.subscribe(function(newValue) {
		this.csvImportStatus({type: "neutral", text: "emptyString_msg"});
	}, this);
	this.csvImportStatus = ko.observable({type: "neutral", text: "emptyString_msg"});
};

tutao.tutanota.ctrl.AdminUserAddViewModel.prototype.addEmptyUser = function() {
	this.newUsers.push(new tutao.tutanota.ctrl.AdminNewUser());
};

tutao.tutanota.ctrl.AdminUserAddViewModel.prototype.openCsvDialog = function() {
	this.csvDialogVisible(true);
};

tutao.tutanota.ctrl.AdminUserAddViewModel.prototype.closeCsvDialog = function() {
	this.csvDialogVisible(false);
};

tutao.tutanota.ctrl.AdminUserAddViewModel.prototype.importCsv = function() {
	var lines = this.csvData().split(/\r\n|\r|\n/);
	var users = [];
	for (var i = 0; i < lines.length; i++) {
		var lineParts = lines[i].split(",");
		if (lineParts.length < 2) {
			this.csvImportStatus({type: "invalid", text: "importCsvInvalid_msg", params: {'$': i }});
			return;
		} else {
			var user = new tutao.tutanota.ctrl.AdminNewUser();
			user.name(lineParts[0]);
			user.mailAddressPrefix(lineParts[1].split("@")[0]);
			if (lineParts.length > 2) {
				user.password(lineParts[2]);
			}
			users.push(user);
		}
	}
	this.newUsers(users);
	this.csvDialogVisible(false);
};

tutao.tutanota.ctrl.AdminUserAddViewModel.prototype.cancel = function() {
    this.adminUserListViewModel.removeSelection();
    tutao.locator.settingsView.showChangeSettingsColumn();
};

tutao.tutanota.ctrl.AdminUserAddViewModel.prototype.isCreateAccountsPossible = function() {
    if (!this.isEditable()) {
        return false;
    }
    for(var i = 0; i < this.newUsers().length; i++) {
        if (!this.newUsers()[i].isCreateAccountPossible()) {
            return false;
        }
    }
    return true;
};

tutao.tutanota.ctrl.AdminUserAddViewModel.prototype.createAccounts = function() {
    if (!this.isCreateAccountsPossible()) {
        // TODO (timely) search in html for "css: { disabled:", replace with sth like knockout enabled-binding and remove all statements like this
        return;
    }
    var self = this;
    this.isEditable(false);

    var count = this.newUsers().length;
    self.createStatus({type: "neutral", text: "createActionStatus_msg", params: {"${index}": count - this.newUsers().length, "${count}": count}});
    if (self.newUsers().length > 0) {
        return Promise.each(self.newUsers(), function(newUser) {
            self.createStatus({type: "neutral", text: "createActionStatus_msg", params: {"${index}": count - self.newUsers().length, "${count}": count}});
            return newUser.create().then(function() {
                self.createdUsers.push(self.newUsers.shift());
            });
        }).then(function() {
            self.addEmptyUser();
            self.isEditable(true);
            self.createStatus({type: "valid", text: "createActionSuccess_msg"});
            self.adminUserListViewModel.update();
        }).caught(function(exception) {
            self.isEditable(true);
            self.createStatus({type: "invalid", text: "createActionFailed_msg"});
            throw exception;
        });
    }
};
"use strict";

tutao.provide('tutao.tutanota.ctrl.AdminUserListViewModel');

/**
 * Shows a list of all users of a company
 * @constructor
 */
tutao.tutanota.ctrl.AdminUserListViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	this.startId = ko.observable(tutao.rest.EntityRestInterface.GENERATED_MAX_ID);
    // @type {}
	this.userGroups = ko.observableArray([]);
	this.editing = ko.observable(null);
	this._selectedDomElements = [];
	this.newViewModel = ko.observable(null);
	this.changeAccountsAllowed = !tutao.locator.userController.isLoggedInUserFreeAccount();
    this.update();
	
};

tutao.tutanota.ctrl.AdminUserListViewModel.prototype.showSelected = function() {
	var self = this;
	this._loadUserGroupEntries(this.upperBoundId(), true).then(function(userGroupList) {
		self.userGroups(userGroupList);
	});
};

tutao.tutanota.ctrl.AdminUserListViewModel.prototype.editUser = function(userGroup, event) {
	this.newViewModel(null);
	this.editing(new tutao.tutanota.ctrl.AdminEditUserViewModel(this, userGroup));
	tutao.tutanota.gui.unselect(this._selectedDomElements);
	this._selectedDomElements = [event.currentTarget];
	tutao.tutanota.gui.select(this._selectedDomElements);
    tutao.locator.settingsView.showChangeSettingsDetailsColumn();
};


tutao.tutanota.ctrl.AdminUserListViewModel.prototype.removeSelection = function() {
	this.editing(null);
    this.newViewModel(null);
	tutao.tutanota.gui.unselect(this._selectedDomElements);
	this._selectedDomElements = [];
};

tutao.tutanota.ctrl.AdminUserListViewModel.prototype.updateUserGroupInfo = function() {
    if (this.editing()) {
        // update the saved instance in our list
        var self = this;
        tutao.entity.sys.GroupInfo.load(this.editing().userGroupInfo.getId()).then(function(updatedUserGroupInfo) {
            var savedIndex = self.userGroups.indexOf(self.editing().userGroupInfo);
            self.userGroups.splice(savedIndex, 1);
            self.userGroups.splice(savedIndex, 0, updatedUserGroupInfo);

            // Update user group info for the logged in user.
            if (tutao.util.ArrayUtils.arrayEquals( tutao.locator.userController.getUserGroupInfo().getId(),updatedUserGroupInfo.getId()) ){
                tutao.locator.userController._userGroupInfo = updatedUserGroupInfo;
            }
            self.editing(null);
        })
    }
};

tutao.tutanota.ctrl.AdminUserListViewModel.prototype.createAccounts = function() {
	this.editing(null);
	this.newViewModel(new tutao.tutanota.ctrl.AdminUserAddViewModel(this));
    tutao.locator.settingsView.showChangeSettingsDetailsColumn();
};

tutao.tutanota.ctrl.AdminUserListViewModel.prototype.update = function () {
    var self = this;
    this._loadUserGroupEntries(this.startId(), true).then(function(groups) {
        self.userGroups([]);
        self.userGroups(groups);
    });
};

/**
 * Loads a maximum of 1000 entries beginning with the entry with a smaller id than upperBoundId 
 * @param {string} boundId The boundary id (base64 encoded)
 * @param {boolean} reverse If the entries shall be loaded reverse.
 * @return {Promise.<Array.<tutao.entity.sys.GroupInfo>>} Resolves to the the list of user group infos when finished, rejected if the rest call failed.
 */
tutao.tutanota.ctrl.AdminUserListViewModel.prototype._loadUserGroupEntries = function(boundId, reverse) {
	return tutao.locator.userController.getLoggedInUser().loadCustomer().then(function(customer) {
        return tutao.entity.sys.GroupInfo.loadRange(customer.getUserGroups(), boundId, 1000, reverse);
	});
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.c');

/**
 * @constructor
 */
tutao.tutanota.ctrl.AppCacheListener = function() {
    tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
    this._progressDialog = tutao.locator.progressDialogModel;
    this._appCache = window.applicationCache;
    this._dummyProgress = 0;
    this._initListeners();
};

/**
 * Inits all needed listeners for appcache events.
 * @private
 */
tutao.tutanota.ctrl.AppCacheListener.prototype._initListeners = function() {

    // An update was found. The browser is fetching resources.
    this._appCache.addEventListener('downloading', this._handleDownloadEvent, false);

    // The manifest returns 404 or 410, the download failed, or the manifest changed while the download was in progress.
    this._appCache.addEventListener('error', this._handleCacheError, false);

    // Fired for each resource listed in the manifest as it is being fetched.
    this._appCache.addEventListener('progress', this._handleProgressEvent, false);

    // Fired when the manifest resources have been newly redownloaded. Called by Firefox for initial download instead of "cached"
    this._appCache.addEventListener('updateready', this._handleUpdateReady, false);

    // The resources have been downloaded initially. In Firefox, "updateready" is called instead.
    this._appCache.addEventListener('cached', this._handleCachedEvent, false);
};

tutao.tutanota.ctrl.AppCacheListener.prototype._handleDownloadEvent = function(event) {
    this._dummyProgress = 0;
    console.log("downloading");
    this._progressDialog.open("applicationUpdate_label");
};

tutao.tutanota.ctrl.AppCacheListener.prototype._handleProgressEvent = function(event) {
    if (event.lengthComputable) {
        this._progressDialog.updateProgress(event.loaded / event.total * 100);
    } else {
        if (this._dummyProgress < 100) {
            this._dummyProgress++;
        }
        this._progressDialog.updateProgress(this._dummyProgress);
    }
};

tutao.tutanota.ctrl.AppCacheListener.prototype._handleCachedEvent = function(event) {
    console.log("cached");
    this._progressDialog.close();
};

tutao.tutanota.ctrl.AppCacheListener.prototype._handleUpdateReady = function(event) {
    console.log("update ready");
    try {
        // Firefox throws an exception when "updateready" was called for the inital download (instead of "cached") and then swapCache() is called, so we have to catch the exception to be able to close the progress dialog.
        this._appCache.swapCache();
        this._progressDialog.close();
        window.location.reload();
    } catch (e) {
        this._progressDialog.close();
    }
};

tutao.tutanota.ctrl.AppCacheListener.prototype._handleCacheError = function(event) {
    console.log("cache error");
    this._progressDialog.close();
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.AttachmentDialogViewModel');

/**
 * The ViewModel for the safari legacy download.
 * @constructor
 */
tutao.tutanota.ctrl.AttachmentDialogViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

	this.filename = ko.observable("");
    this.mimeType = ko.observable("");
    this.blobUrl = ko.observable("");
    this.textId = ko.observable(null);
	this.dialogVisible = ko.observable(false);
    this._resolve = null;

};


tutao.tutanota.ctrl.AttachmentDialogViewModel.prototype.showDialog = function(filename, pMimeType, pBlobUrl, textId) {
	this.filename(filename);
    this.mimeType(pMimeType);
    this.blobUrl(pBlobUrl);
    this.textId(textId);
    var self = this;
    return new Promise(function(resolve, reject) {
        self._resolve = resolve;

        var attachmentDialog = $("#attachmentDialog").get(0);
        var lastElement = document.getElementById("attachmentObject");

        if (lastElement) {
            attachmentDialog.removeChild(lastElement);
        }

        //
        self.dialogVisible(true);

        var objectElement = document.createElement("div");
        objectElement.setAttribute( "text", "cannot show file");

        if ( self.isImageType()){
            var objectElement = document.createElement("img");
            objectElement.setAttribute("id", "attachmentObject");
            objectElement.setAttribute("src", pBlobUrl);
        } else if (self.isVideoType() ){
            var objectElement = document.createElement("video");
            objectElement.setAttribute("id", "attachmentObject");
            objectElement.setAttribute("src", pBlobUrl);
            objectElement.setAttribute("controls", "true");
        } else if (self.isTextType() ){
            var objectElement = document.createElement("iframe");
            objectElement.setAttribute("id", "attachmentObject");
            objectElement.setAttribute("src", pBlobUrl);
        }
        attachmentDialog.appendChild(objectElement);
    });
};



tutao.tutanota.ctrl.AttachmentDialogViewModel.prototype.closeDialog = function() {
	this.dialogVisible(false);
    this._resolve();
};

tutao.tutanota.ctrl.AttachmentDialogViewModel.prototype.isVideoType = function() {
    return this.mimeType().indexOf("video") != -1;
};

tutao.tutanota.ctrl.AttachmentDialogViewModel.prototype.isImageType = function() {
    return this.mimeType().indexOf("image")!= -1;
};

tutao.tutanota.ctrl.AttachmentDialogViewModel.prototype.isTextType = function() {
    return this.mimeType().indexOf("text")!= -1;
};






"use strict";

tutao.provide('tutao.tutanota.ctrl.Button');

/**
 * Defines a button.
 * @constructor
 * @param {string} labelTextId The label visible on the button.
 * @param {number} priority The higher the value the higher the priority. Priority 0 buttons are only in the more menu.
 * @param {function} clickListener Is called when the button is clicked.
 * @param {function=} isVisible The button is displayed, if this function returns true
 * @param {boolean=} directClick True if the click event shall not be deferred by a setTimeout (needed to avoid alert/confirm popup bugs).
 * @param {string=} id The id to set for the button.
 * @param {string=} imageClass If set, the according image will be displayed
 * @param {string=} imageAltTextId alt text for the optional image
 */
tutao.tutanota.ctrl.Button = function (labelTextId, priority, clickListener, isVisible, directClick, id, imageClass, imageAltTextId) {
    tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
    this.labelTextId = labelTextId;

    this._priority = priority;
    this._clickListener = clickListener;
    this._directClick = directClick;
    this.id = id;
    this.isVisible = isVisible ? isVisible : function () {
        return true;
    };
    this.imageClass = imageClass;
    this.imageAltTextId = imageAltTextId;
};

/**
 * Provides the priority of the button.
 * @return {number} 0 or positive number value.
 */
tutao.tutanota.ctrl.Button.prototype.getPriority = function () {
    return this._priority;
};

/**
 * Executes the click functionality.
 * @param {Object} vm The view model.
 * @param {Event} event The click event.
 */
tutao.tutanota.ctrl.Button.prototype.click = function (vm, event) {
    if (this._directClick) {
        // needed e.g. for opening a file chooser because a setTimeout in between would not work
        this._clickListener();
    } else {
        var self = this;
        // setTimeout because otherwise problems with alert/confirm dialogs appear
        setTimeout(function () {
            self._clickListener();
        }, 0);
    }
};


tutao.tutanota.ctrl.Button.prototype.getImageAltTextId = function () {
    return this.imageAltTextId;
};

tutao.tutanota.ctrl.Button.prototype.getLabelTextId = function () {
    return this.labelTextId;
};


"use strict";

tutao.provide('tutao.tutanota.ctrl.ButtonBarViewModel');

// - move gui part to custom binding
// - width adaption when scrollbar appears/disappears

/**
 * Defines a button bar.
 *
 * @constructor
 * @param {Array.<tutao.tutanota.ctrl.Button>} buttons An array containing any number of tutao.tutanota.ctrl.Button instances.
 * @param {string=} moreButtonText The text for the more button.
 * @param {function(Element):number=} measureFunction A function that returns the width of the buttons dom element including margins.
 *                                          This function should only be provided if the buttons are no standard-buttons
 */
tutao.tutanota.ctrl.ButtonBarViewModel = function(buttons,moreButtonText, measureFunction) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

    if(!moreButtonText) {
        moreButtonText = "dots_label";
    }
    this.moreButton = new tutao.tutanota.ctrl.Button(moreButtonText, 100, this.switchMore, null, false, "moreAction",  "more", moreButtonText);
    if (measureFunction) {
        this._getSingleButtonWidth = measureFunction;
    }

    // only show buttons that are not hidden
    this.allButtons = ko.computed(function() {
        return ko.utils.arrayFilter(buttons, function(button) {
            if (button) { // on IE8, the arrayFilter might be called with undefined parameters
                return button.isVisible();
            } else {
                return false;
            }

        });
    });
	this.moreButtons = ko.observableArray(); // the buttons that will be shown in more menu
	this.visibleButtons = ko.observableArray(); // the buttons that are visible in button bar
    this.moreVisible = ko.observable(false);
    this.domButtonBar = ko.observable(null); // is set via domInit binding to the buttonBar div
    this.maxWidth = 0;
    this.widthSubscription = null;

	this.allButtons.subscribe(function() {
		this.updateVisibleButtons();
	}, this);

    this._widthInterval = null;
};

/**
 * Should be called after the buttonbar became visible for the first time.
 */
tutao.tutanota.ctrl.ButtonBarViewModel.prototype.init = function() {
    var self = this;
    this.domButtonBar.subscribe(function () {
        self._initWidth();
    })
};
tutao.tutanota.ctrl.ButtonBarViewModel.prototype._initWidth = function() {
    this.maxWidth = $(this.domButtonBar()).width();
    if (this.maxWidth == 0) {
        setTimeout(this._initWidth, 10);
    } else {
        this.updateVisibleButtons();
    }
};


/**
 *
 * @param {Array} buttons
 * @returns {number}
 */
tutao.tutanota.ctrl.ButtonBarViewModel.prototype.getButtonsWidth = function(buttons) {
    var buttonWidth = 0;
    for(var i=0; i< buttons.length; i++) {
        buttonWidth += this._getSingleButtonWidth(buttons[i]);
    }
    return buttonWidth;
};


tutao.tutanota.ctrl.ButtonBarViewModel.prototype.updateVisibleButtons = function() {
    if (!this.widthSubscription) {
        this.widthSubscription = tutao.locator.viewManager.windowWidthObservable.subscribe( function() {
            setTimeout(this.updateVisibleButtons, 0); // the column width is not yet updated when the window width changes, so use a timeout
        }, this);
    }

    // the maxWidth might be 0 if the domButtonBar is not yet in the dom. in this case all visible buttons are removed by the filter and we have to make sure another trigger comes later
    this.maxWidth = $(this.domButtonBar()).width();

    var visibleButtonList = [].concat(this.allButtons());
    var moreButtonList = [];
    if (this.maxWidth < this.getButtonsWidth(visibleButtonList)){
        visibleButtonList.push(this.moreButton);
        this._filterButtons(visibleButtonList, moreButtonList);
    }
    this.visibleButtons(visibleButtonList);
    this.moreButtons(moreButtonList);

    this.visibleButtons.reverse();
};

/**
 *
 * @param {Array} visibleButtonList
 * @param {Array} moreButtonList
 * @private
 */
tutao.tutanota.ctrl.ButtonBarViewModel.prototype._filterButtons = function(visibleButtonList, moreButtonList) {
    if ( this.maxWidth < this.getButtonsWidth(visibleButtonList)){
        var buttonIndex = this._getLowestPriorityButtonIndex(visibleButtonList);
        if ( buttonIndex >= 0){
            var removedButtons = visibleButtonList.splice(buttonIndex, 1);
            moreButtonList.splice(0, 0, removedButtons[0]);
            this._filterButtons(visibleButtonList, moreButtonList);
        }
    }
};


/**
 *
 * @param {Array} buttonList
 * @return {Number} button index
 * @private
 */
tutao.tutanota.ctrl.ButtonBarViewModel.prototype._getLowestPriorityButtonIndex = function(buttonList) {
    var lowestPriority = 1000;
    var buttonIndex = -1;
    for(var i=0; i< buttonList.length; i++ ){
        var currentButton = buttonList[i];
        if (currentButton.getPriority() < lowestPriority){
            lowestPriority = currentButton.getPriority();
            buttonIndex = i;
        }
    }
    return buttonIndex;
};


tutao.tutanota.ctrl.ButtonBarViewModel.prototype.hasMoreButton = function() {
    return this.moreButtons.length != 0;
};

tutao.tutanota.ctrl.ButtonBarViewModel.prototype._showMore = function() {
    tutao.locator.modalPageBackgroundViewModel.show(this.hideMore);
    this.moreVisible(true);
};

tutao.tutanota.ctrl.ButtonBarViewModel.prototype.hideMore = function() {
    this.moreVisible(false);
};

tutao.tutanota.ctrl.ButtonBarViewModel.prototype.switchMore = function() {
    if ( this.moreVisible()){
        this.hideMore();
    }else{
        this._showMore();
    }
};

/**
 * @param {tutao.tutanota.ctrl.Button} button The button to measure
 * @return {number} The width including the margin of the button
 */
tutao.tutanota.ctrl.ButtonBarViewModel.prototype._getSingleButtonWidth = function (button) {
    var measureButton = $("button#measureButton");
    measureButton.text(tutao.lang(button.getLabelTextId()));
    return measureButton.outerWidth(true);
};
"use strict";

tutao.provide('tutao.tutanota.ctrl.ChangePasswordViewModel');

/**
 * Handles changing the users password. This view model is created dynamically.
 * @constructor
 */
tutao.tutanota.ctrl.ChangePasswordViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

	this.overallState = ko.observable(null);

	this.oldPassword = ko.observable("");
	this.oldPassword.subscribe(this._oldPasswordUpdated, this);
	this.oldPasswordStatus = ko.observable({ type: "neutral", text: "oldPasswordNeutral_msg" }); 
	this.password1 = ko.observable("");
	this.password2 = ko.observable("");

	this.changePasswordStatus = ko.observable({ type: "neutral", text: "emptyString_msg" });
	this.changePasswordButtonTextId = ko.observable(null);

	var s = new tutao.tutanota.util.StateMachine();
	this.state = s;
	s.addState("EnterPasswords",    {});
	s.addState("ActivatePassword",  {}, this._activateNewPassword);
	s.addState("PasswordActivated", {});
	s.addState("FinishNoSuccess",   {});

    s.addTransition("EnterPasswords", "userConfirm", "ActivatePassword");
    s.addTransition("ActivatePassword", "serverError", "EnterPasswords");
	s.addTransition("ActivatePassword", "activationOk", "PasswordActivated");
	
    this.changePasswordStatus({ type: "neutral", text: "emptyString_msg" });
    this.changePasswordButtonTextId("pwChangeButtonChangePw_action");
    this.overallState("allowed");
};

/**
 * Must be called when the old password was changed (directly after each character).
 */
tutao.tutanota.ctrl.ChangePasswordViewModel.prototype._oldPasswordUpdated = function() {
	this.oldPasswordStatus({ type: "neutral", text: "oldPasswordNeutral_msg" });
};

/**
 * Provides the password strength in %.
 * @return {Number} The strength of the password.
 */
tutao.tutanota.ctrl.ChangePasswordViewModel.prototype.getPasswordStrength = function() {
	return tutao.tutanota.util.PasswordUtils.getPasswordStrength(this.password1(), [tutao.locator.userController.getMailAddress(), tutao.locator.userController.getUserGroupInfo().getName()]);
};

/**
 * Provides the status of the first entered new password.
 * @return {Object} The status containing type and text id.
 */
tutao.tutanota.ctrl.ChangePasswordViewModel.prototype.getPassword1Status = function() {
	if (this.password1() == "") {
		return { type: "neutral", text: "password1Neutral_msg" };
	} else if (this.password1() == this.oldPassword()) {
		return { type: "invalid", text: "password1InvalidSame_msg" };
	} else if (this.getPasswordStrength() >= 80) {
		return { type: "valid", text: "passwordValid_msg" };
	} else {
		return { type: "invalid", text: "password1InvalidUnsecure_msg" };
	}
};

/**
 * Provides the status of the second entered new password.
 * @return {Object} The status containing type and text id.
 */
tutao.tutanota.ctrl.ChangePasswordViewModel.prototype.getPassword2Status = function() {
	if (this.password2() == "") {
		return { type: "neutral", text: "password2Neutral_msg" };
	} else if (this.password1() == this.password2()) {
		return { type: "valid", text: "passwordValid_msg" };
	} else {
		return { type: "invalid", text: "password2Invalid_msg" };
	}
};

/**
 * Provides the information if the user may press the confirm button.
 * @return {boolean} True if the button can be presse, false otherwise.
 */
tutao.tutanota.ctrl.ChangePasswordViewModel.prototype.confirmPossible = function() {
	if (this.state.getState() == 'EnterPasswords') {
		return (this.oldPasswordStatus().type == "valid" && this.getPassword1Status().type == "valid" && this.getPassword2Status().type == "valid");
	} else {
		return false;
	}
};

/**
 * Called when the confirm button is clicked by the user. Triggers the next state in the state machine.
 */
tutao.tutanota.ctrl.ChangePasswordViewModel.prototype.confirm = function() {
	if (this.confirmPossible()) {
		this.state.event("userConfirm");
	}
};

/**
 * Checks the entered old password and updates the password status.
 */
tutao.tutanota.ctrl.ChangePasswordViewModel.prototype.checkOldPassword = function() {
	var self = this;
	if (this.oldPassword().trim() == "") {
		this.oldPasswordStatus({ type: "neutral", text: "oldPasswordNeutral_msg" });
	} else {
		this.oldPasswordStatus({ type: "neutral", text: "check_msg" });
		tutao.locator.kdfCrypter.generateKeyFromPassphrase(self.oldPassword(), tutao.locator.userController.getHexSalt()).then(function(hexKey) {
			var v = tutao.util.EncodingConverter.base64ToBase64Url(tutao.locator.shaCrypter.hashHex(hexKey));
			if(v == tutao.locator.userController.getAuthVerifier()) {
				self.oldPasswordStatus({ type: "valid", text: "passwordValid_msg" });
			} else {
				self.oldPasswordStatus({ type: "invalid", text: "oldPasswordInvalid_msg" });
			}
		});
	}
};

/**
 * Activates the new password.
 */
tutao.tutanota.ctrl.ChangePasswordViewModel.prototype._activateNewPassword = function() {
	this.changePasswordStatus({ type: "neutral", text: "emptyString_msg" });
	var self = this;
	var hexSalt = tutao.locator.kdfCrypter.generateRandomSalt();
	tutao.locator.kdfCrypter.generateKeyFromPassphrase(self.password1(), hexSalt).then(function(userPassphraseKeyHex) {
		var userPassphraseKey = tutao.locator.aesCrypter.hexToKey(userPassphraseKeyHex);
		var pwEncUserGroupKey = tutao.locator.aesCrypter.encryptKey(userPassphraseKey, tutao.locator.userController.getUserGroupKey());
		var verifier = tutao.locator.shaCrypter.hashHex(userPassphraseKeyHex);
		
		var service = new tutao.entity.sys.ChangePasswordData();
		service.setSalt(tutao.util.EncodingConverter.hexToBase64(hexSalt));
		service.setVerifier(verifier);
		service.setPwEncUserGroupKey(pwEncUserGroupKey);
		return service.setup({}, null).then(function(dummy) {
            tutao.locator.userController.passwordChanged(userPassphraseKeyHex, hexSalt);
            self.changePasswordStatus({ type: "valid", text: "pwChangeValid_msg" });
            self.state.event("activationOk");
		}).caught(tutao.TooManyRequestsError, function(exception) {
            self.changePasswordStatus({ type: "invalid", text: "pwChangeInvalidTooManyVerifyAttempts_msg" });
            self.state.event("activationTooManyAttempts");
        }).caught(function(e) {
            self.state.event("serverError");
            throw e;
        });
	});
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.ComposingMail');

/**
 * This class represents a mail that is currently written. It contains mail, body and other editing fields.
 * @param {string} conversationType The conversationType.
 * @param {string?} previousMessageId The message id of the mail that the new mail is a reply to or that is forwarded. Null if this is a new mail.
 * @constructor
 * @implements {tutao.tutanota.ctrl.bubbleinput.BubbleHandler}
 */
tutao.tutanota.ctrl.ComposingMail = function(conversationType, previousMessageId) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

	this.composerSubject = ko.observable("");
	this.subjectFieldFocused = ko.observable(false);
    // @type {function(tutao.tutanota.util.DataFile|tutao.entity.tutanota.File=):tutao.tutanota.util.DataFile|tutao.entity.tutanota.File=}
	this._attachments = ko.observableArray();
	this.currentlyDownloadingAttachment = ko.observable(null); // null or a DataFile

	this.toRecipientsViewModel = new tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel(this);
	this.ccRecipientsViewModel = new tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel(this);
	this.bccRecipientsViewModel = new tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel(this);

	this.secure = ko.observable(true);
	this.conversationType = conversationType;
	this.previousMessageId = previousMessageId;
	this.previousMailListColumnVisible = tutao.locator.mailView.isMailListColumnVisible();

	this.busy = ko.observable(false);
    this.busy.subscribe(function(newBusy) {
        this.toRecipientsViewModel.setEnabled(!newBusy);
        this.ccRecipientsViewModel.setEnabled(!newBusy);
        this.bccRecipientsViewModel.setEnabled(!newBusy);
    }, this);

	this.directSwitchActive = true;

	this.mailBodyLoaded = ko.observable(true);

    var self = this;
    var notBusy = function() {
        return !self.busy();
    };
	this.buttons = [
			        new tutao.tutanota.ctrl.Button("attachFiles_action", 9, this.attachSelectedFiles, notBusy, true, "composer_attach"),
			        new tutao.tutanota.ctrl.Button("send_action", 10, this.sendMail, notBusy, false, "composer_send"),
			        new tutao.tutanota.ctrl.Button("dismiss_action", 8, function () {
                        self.cancelMail(false);
                    }, notBusy, false, "composer_cancel")
			        ];
	this.buttonBarViewModel = new tutao.tutanota.ctrl.ButtonBarViewModel(this.buttons);
    this.buttonBarViewModel.init();

    tutao.locator.passwordChannelViewModel.init();
};

/**
 * The maximum attachments size for unsecure external recipients.
 */
tutao.tutanota.ctrl.ComposingMail.MAX_EXTERNAL_ATTACHMENTS_SIZE = 26214400;

/**
 * @param {string} bodyText The unsanitized body text. May be an empty string.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.setBody = function(bodyText) {
    tutao.locator.mailView.setComposingBody(bodyText);
};

/**
 * Provides the information if this composing mail shall be switched away directly without sliding animation.
 * When sending this mail or canceling without another mail selected, this returns false.
 * @return {boolean} True if yes, false otherwise.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.isDirectSwitchActive = function() {
	return this.directSwitchActive;
};

tutao.tutanota.ctrl.ComposingMail.prototype.showCcAndBcc = function() {
	return (this.ccRecipientsViewModel.bubbles().length > 0 || this.bccRecipientsViewModel.bubbles().length > 0 || this.ccRecipientsViewModel.inputActive() || this.bccRecipientsViewModel.inputActive());
};

tutao.tutanota.ctrl.ComposingMail.prototype.getCcFieldLabel = function() {
	return (this.showCcAndBcc()) ? tutao.locator.languageViewModel.get("cc_label") : tutao.locator.languageViewModel.get("ccBcc_label");
};

/**
 * Switches the confidentiality for this mail.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.switchSecurity = function() {
	if (!this.secure() || this.containsExternalRecipients()) {
		this.secure(!this.secure());
	}
};

/**
 * Sends the new mail.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.sendMail = function() {
	var self = this;
	var invalidRecipients = (this.toRecipientsViewModel.inputValue() !== "") || (this.ccRecipientsViewModel.inputValue() !== "") || (this.bccRecipientsViewModel.inputValue() !== "");
	if (!invalidRecipients && this.toRecipientsViewModel.bubbles().length === 0 && this.ccRecipientsViewModel.bubbles().length === 0 && this.bccRecipientsViewModel.bubbles().length === 0) {
		// setTimeout is needed because fastClick would call the event twice otherwise
		setTimeout(function() {
			tutao.tutanota.gui.alert(tutao.locator.languageViewModel.get("noRecipients_msg"));
		}, 0);
		return;
	}
	if (invalidRecipients) {
		setTimeout(function() {
			tutao.tutanota.gui.alert(tutao.locator.languageViewModel.get("invalidRecipients_msg"));
		}, 0);
		return;
	}
	if (this.composerSubject().length === 0) {
		setTimeout(function() {
			tutao.tutanota.gui.alert(tutao.locator.languageViewModel.get("noSubject_msg"));
		}, 0);
		return;
	}

    return this._resolveRecipients().then(function() {
        var unsecureRecipients = self._containsUnsecureRecipients();
        if (self.secure() && unsecureRecipients) {
            setTimeout(function() {
                var message = "noPasswordChannels_msg";
                if ( !tutao.locator.passwordChannelViewModel.isAutoTransmitPasswordAllowed() ){
                    message = "noPreSharedPassword_msg";
                }
                tutao.tutanota.gui.alert(tutao.locator.languageViewModel.get(message));
                tutao.locator.mailView.showPasswordChannelColumn();
            }, 0);
            return;
        }
        if (self.secure() && self._containsInvalidPhoneNumber()) {
            setTimeout(function() {
                tutao.tutanota.gui.alert(tutao.locator.languageViewModel.get("invalidPasswordChannels_msg"));
                tutao.locator.mailView.showPasswordChannelColumn();
            }, 0);
            return;
        }

        if (!self.secure()) {
            var attachmentsSize = 0;
            for (var i = 0; i < self._attachments().length; i++) {
                attachmentsSize += self._attachments()[i].getSize();
            }
            if (attachmentsSize > tutao.tutanota.ctrl.ComposingMail.MAX_EXTERNAL_ATTACHMENTS_SIZE) {
                setTimeout(function() {
                    tutao.tutanota.gui.alert(tutao.locator.languageViewModel.get("maxSizeExceeded_msg", { "$": tutao.tutanota.util.Formatter.formatFileSize(tutao.tutanota.ctrl.ComposingMail.MAX_EXTERNAL_ATTACHMENTS_SIZE) }));
                }, 0);
                return;
            }
        }

        var secureExternalRecipients = tutao.locator.passwordChannelViewModel.getSecureExternalRecipients();

        // check if a pre-shared password is not strong enough
        var onePresharedPasswordNotStrongEnough = false;
        for (var i = 0; i < secureExternalRecipients.length; i++) {
            var presharedPassword = secureExternalRecipients[i].getEditableContact().presharedPassword();
            if (presharedPassword != null && tutao.locator.passwordChannelViewModel.getPasswordStrength(secureExternalRecipients[i]) < 80) {
                onePresharedPasswordNotStrongEnough = true;
                break;
            }
        }

        if (!onePresharedPasswordNotStrongEnough || tutao.tutanota.gui.confirm(tutao.locator.languageViewModel.get("presharedPasswordNotStrongEnough_msg"))) {
            return self._updateContactInfo(self.getAllComposerRecipients()).then(function() {
                self._freeBubbles();

                var senderName = "";
                if (tutao.locator.userController.isInternalUserLoggedIn()) {
                    senderName = tutao.locator.userController.getUserGroupInfo().getName();
                }

                var facade = null;
                if (tutao.locator.userController.isExternalUserLoggedIn()) {
                    facade = tutao.tutanota.ctrl.SendMailFromExternalFacade;
                } else if (unsecureRecipients) {
                    facade = tutao.tutanota.ctrl.SendUnsecureMailFacade;
                } else {
                    facade = tutao.tutanota.ctrl.SendMailFacade;
                }

                // the mail is sent in the background
                self.busy(true);
                self.directSwitchActive = false;

                var propertyLanguage = tutao.locator.mailBoxController.getUserProperties().getNotificationMailLanguage();
                var selectedLanguage = tutao.locator.passwordChannelViewModel.getNotificationMailLanguage();
                var promise = Promise.resolve();
                if ( selectedLanguage != propertyLanguage){
                    tutao.locator.mailBoxController.getUserProperties().setNotificationMailLanguage(selectedLanguage);
                    promise = tutao.locator.mailBoxController.getUserProperties().update();
                }

                return promise.then(function () {
                    return facade.sendMail(self.composerSubject(), tutao.locator.mailView.getComposingBody(), senderName, self.getComposerRecipients(self.toRecipientsViewModel),
                        self.getComposerRecipients(self.ccRecipientsViewModel), self.getComposerRecipients(self.bccRecipientsViewModel),
                        self.conversationType, self.previousMessageId, self._attachments(), tutao.locator.passwordChannelViewModel.getNotificationMailLanguage()).then(function(senderMailElementId, exception) {
                            tutao.locator.mailView.fadeFirstMailOut();
                            setTimeout(function() {
                                tutao.locator.mailViewModel.removeFirstMailFromConversation();
                                self._restoreViewState(tutao.locator.mailViewModel.isConversationEmpty());
                                if (tutao.locator.userController.isExternalUserLoggedIn()) {
                                    // external users do not download mails automatically, so download the sent email now
                                    tutao.entity.tutanota.Mail.load([tutao.locator.mailBoxController.getUserMailBox().getMails(), senderMailElementId]).then(function(mail, exception) {
                                        tutao.locator.mailListViewModel.updateOnNewMails([mail]);
                                    });
                                }
                            }, 500);
                        });
                }).caught(tutao.RecipientsNotFoundError, function(exception) {
                    self.busy(false);
                    var notFoundRecipients = exception.getRecipients();
                    var recipientList = "";
                    for (var i = 0; i < notFoundRecipients.length; i++) {
                        recipientList += notFoundRecipients[i] + "\n";
                    }
                    tutao.tutanota.gui.alert( tutao.lang("invalidRecipients_msg") + "\n" + recipientList );
                    console.log("recipients not found", exception);
                }).lastly(function() {
                    self.busy(false);
                });

            });
        } else{
            tutao.locator.mailView.showPasswordChannelColumn();
        }
    })
};

/**
 * Try to cancel creating this new mail. The user is asked if it shall be cancelled if he has already entered text.
 * @param {boolean} directSwitch True if the cancelled mail should be hidden immediately because another mail was selected.
 * @return {boolean} True if the mail was cancelled, false otherwise.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.cancelMail = function(directSwitch) {
    // if the email is currently, sent, do not cancel the email.
    if (this.busy()) {
        return false;
    }
	var body = tutao.locator.mailView.getComposingBody();
	var confirm = (this.composerSubject() !== "" ||
            (body !== "" && body !== "<br>") ||
			this.toRecipientsViewModel.inputValue() !== "" ||
			this.toRecipientsViewModel.bubbles().length != 0 ||
			this.ccRecipientsViewModel.inputValue() !== "" ||
			this.ccRecipientsViewModel.bubbles().length != 0 ||
			this.bccRecipientsViewModel.inputValue() !== "" ||
			this.bccRecipientsViewModel.bubbles().length != 0);
	if (!confirm || tutao.tutanota.gui.confirm(tutao.locator.languageViewModel.get("deleteMail_msg"))) {
		if (!directSwitch) {
			this.directSwitchActive = false;
		}

		this._freeBubbles();

		//an async animation is shown when the mail is removed. We have to wait for it.
		var self = this;
		tutao.locator.mailViewModel.removeFirstMailFromConversation();
		setTimeout(function() {
			self._restoreViewState(tutao.locator.mailViewModel.isConversationEmpty());
		}, 500);
		return true;
	} else {
		return false;
	}
};

/**
 * if no mail was selected -> show mail list column
 * if mail was selected (if showLastSelected == true) and conversation column visible -> show last mail
 * if mail was selected and mail list column visible -> show last mail, show mail list column
 * @param {boolean} showLastSelected true, if the last selected mail shall be shown.
 */
tutao.tutanota.ctrl.ComposingMail.prototype._restoreViewState = function(showLastSelected) {
	if (showLastSelected) {
		tutao.locator.mailListViewModel.selectPreviouslySelectedMail();
	}
	if (this.previousMailListColumnVisible) {
		tutao.locator.mailView.showDefaultColumns();
	}
};

/**
 * Calles deleted() on each bubble in each bubble input field to free the contained editable contact.
 */
tutao.tutanota.ctrl.ComposingMail.prototype._freeBubbles = function() {
	for (var i = 0; i < this.toRecipientsViewModel.bubbles().length; i++) {
		this.bubbleDeleted(this.toRecipientsViewModel.bubbles()[i]);
	}
	for (var i = 0; i < this.ccRecipientsViewModel.bubbles().length; i++) {
		this.bubbleDeleted(this.ccRecipientsViewModel.bubbles()[i]);
	}
	for (var i = 0; i < this.bccRecipientsViewModel.bubbles().length; i++) {
		this.bubbleDeleted(this.bccRecipientsViewModel.bubbles()[i]);
	}
};

/**
 * Returns an array of RecipientInfos from the given BubbleInputViewModel.
 * @param {tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel} recipientsViewModel The view model to get the recipients from.
 * @return {Array.<tutao.tutanota.ctrl.RecipientInfo>} The recipient infos.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.getComposerRecipients = function(recipientsViewModel) {
	var r = [];
	for (var i = 0; i < recipientsViewModel.bubbles().length; i++) {
		r.push(recipientsViewModel.bubbles()[i].entity);
	}
	return r;
};

/**
 * Returns an array of RecipientInfos containing all to, cc and bcc recipientsInfos.
 * @return {Array.<tutao.tutanota.ctrl.RecipientInfo>} The recipient infos.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.getAllComposerRecipients = function() {
	return this.getComposerRecipients(this.toRecipientsViewModel)
		.concat(this.getComposerRecipients(this.ccRecipientsViewModel))
		.concat(this.getComposerRecipients(this.bccRecipientsViewModel));
};

/**
 * Add a recipient to the "to" recipients.
 * @param {tutao.tutanota.ctrl.RecipientInfo} recipientInfo The recipient info.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.addToRecipient = function(recipientInfo) {
	this.toRecipientsViewModel.addBubble(this._createBubbleFromRecipientInfo(recipientInfo));
};

/**
 * Add a recipient to the "cc" recipients.
 * @param {tutao.tutanota.ctrl.RecipientInfo} recipientInfo The recipient info.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.addCcRecipient = function(recipientInfo) {
	this.ccRecipientsViewModel.addBubble(this._createBubbleFromRecipientInfo(recipientInfo));
};

/**
 * Returns if there are unsecure recipients among the current recipients.
 * @return {boolean} True if there are unsecure recipients among the given recipients, false otherwise.
 */
tutao.tutanota.ctrl.ComposingMail.prototype._containsUnsecureRecipients = function() {
	if (!this.secure()) {
		return true;
	}
	var r = this.getAllComposerRecipients();
	for (var i = 0; i < r.length; i++) {
		if (!r[i].isSecure()) {
			return true;
		}
	}
	return false;
};

/**
 * Tries to resolve unknown recipients if there are any
 * @return {Promise.<>} Resolves, if all unknown recipients have been resolved.
 */
tutao.tutanota.ctrl.ComposingMail.prototype._resolveRecipients = function() {
    return Promise.each(this.getAllComposerRecipients(), function(/* tutao.tutanota.ctrl.RecipientInfo */recipientInfo) {
        return recipientInfo.resolveType();
    });
};

tutao.tutanota.ctrl.ComposingMail.prototype._containsInvalidPhoneNumber = function() {
	if (!this.secure()) {
		return false;
	}
	var r = this.getAllComposerRecipients();
	for (var i = 0; i < r.length; i++) {
		if (tutao.locator.passwordChannelViewModel.containsInvalidNotSavedNumbers(r[i])) {
			return true;
		}
	}
	return false;
};

/**
 * Returns true if this mail shall (also) be sent to external recipients in a secure way. Returns false if not yet known for some recipients.
 * @return {boolean}
 */
tutao.tutanota.ctrl.ComposingMail.prototype.composeForSecureExternalRecipients = function() {
	if (this.secure()) {
		return this.containsExternalRecipients();
	} else {
		return false;
	}
};


/**
 * Returns true if this mail contains external recipients.
 * @return {boolean}
 */
tutao.tutanota.ctrl.ComposingMail.prototype.containsExternalRecipients = function() {
	var r = this.getAllComposerRecipients();
	for (var i = 0; i < r.length; i++) {
		if (r[i].isExternal()) {
			return true;
		}
	}
	return false;
};

/**
 * Offers the user to download the given data file which was added to this mail.
 * @param {tutao.tutanota.util.DataFile} dataFile The file to download.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.downloadNewAttachment = function(dataFile) {
    if (this.busy()) {
        return;
    }
	var self = this;
	// do not allow a new download as long as another is running
	if (this.currentlyDownloadingAttachment()) {
		return;
	}
	this.currentlyDownloadingAttachment(dataFile);
	tutao.tutanota.util.FileUtils.provideDownload(dataFile).then(function() {
		self.currentlyDownloadingAttachment(null);
	});
};

/**
 * Removes the given data file from the attachments.
 * @param {tutao.tutanota.util.DataFile} dataFile The file to remove.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.removeAttachment = function(dataFile) {
    if (this.busy()) {
        return;
    }
	this._attachments.remove(dataFile);
};

/**
 * Called when local files are dragged across the composed mail.
 * @param {tutao.tutanota.ctrl.ComposingMail} data The mail.
 * @param {Event} e The event.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.handleDragOver = function(data, e) {
    if (this.busy()) {
        return;
    }
    e.originalEvent.stopPropagation();
    e.originalEvent.preventDefault();
    e.originalEvent.dataTransfer.dropEffect = 'copy';
};

/**
 * Called when local files are dropped onto the composed mail.
 * @param {tutao.tutanota.ctrl.ComposingMail} data The mail.
 * @param {Event} e The event.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.attachDroppedFiles = function(data, e) {
    if (this.busy()) {
        return;
    }
    e.originalEvent.stopPropagation();
    e.originalEvent.preventDefault();
    this.attachFiles(e.originalEvent.dataTransfer.files);
};

/**
 * Called when the user shall choose a file from the file system.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.attachSelectedFiles = function() {
	var self = this;
	tutao.tutanota.util.FileUtils.showFileChooser().then(function(fileList) {
		self.attachFiles(fileList);
	});
};

/**
 * Attaches the files in the given FileList.
 * @param {FileList} fileList The files to attach.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.attachFiles = function(fileList) {
	var tooBigFiles = [];
	var self = this;
	for (var i = 0; i < fileList.length; i++) {
		if (fileList[i].size > tutao.entity.tutanota.TutanotaConstants.MAX_ATTACHMENT_SIZE) {
			tooBigFiles.push(fileList[i].name);
		} else {
			tutao.tutanota.util.FileUtils.readLocalFile(fileList[i]).then(function(dataFile, exception) {
				self._attachments.push(dataFile);
			}).caught(function(exception) {
                tutao.tutanota.gui.alert(tutao.lang("couldNotAttachFile_msg"));
                console.log(exception);
            });
		}
	}
	if (tooBigFiles.length > 0) {
		tutao.tutanota.gui.alert(tutao.locator.languageViewModel.get("tooBigAttachment_msg") + tooBigFiles.join(", "));
	}
};

/**
 * Provides the image that shall be shown in the attachment.
 * @param {tutao.tutanota.util.DataFile} dataFile The file.
 * @return {String} The name of the image.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.getAttachmentImage = function(dataFile) {
	var busy = (dataFile == this.currentlyDownloadingAttachment());
	return tutao.tutanota.util.FileUtils.getFileTypeImage(dataFile.getName(), busy);
};

/************** implementation of tutao.tutanota.ctrl.bubbleinput.BubbleHandler **************/

/** @inheritDoc */
tutao.tutanota.ctrl.ComposingMail.prototype.getSuggestions = function(text) {
	text = text.trim().toLowerCase();
	var contactWrappers = tutao.tutanota.ctrl.ComposingMail._getContacts();
	var sugs = [];
	if (text === "") { // do not display any suggestions when nothing has been entered
		return sugs;
	}
	for (var i = 0; i < contactWrappers.length; i++) {
		var contact = contactWrappers[i].getContact();
		var addAllMailAddresses = (text == "" ||
				tutao.util.StringUtils.startsWith(contact.getFirstName().toLowerCase(), text) ||
				tutao.util.StringUtils.startsWith(contact.getLastName().toLowerCase(), text) ||
				tutao.util.StringUtils.startsWith(contactWrappers[i].getFullName().toLowerCase(), text));
		for (var a = 0; a < contact.getMailAddresses().length; a++) {
			var mailAddress = contact.getMailAddresses()[a].getAddress().toLowerCase();
			if (addAllMailAddresses || tutao.util.StringUtils.startsWith(mailAddress, text)) {
				var suggestionText = contactWrappers[i].getFullName() + " <" + mailAddress + ">";
				sugs.push(new tutao.tutanota.ctrl.bubbleinput.Suggestion({ contactWrapper: contactWrappers[i], mailAddress: mailAddress }, suggestionText));
			}
		}
	}
	return sugs;
};

/** @inheritDoc */
tutao.tutanota.ctrl.ComposingMail.prototype.createBubbleFromSuggestion = function(suggestion) {
	var recipientInfo = new tutao.tutanota.ctrl.RecipientInfo(suggestion.id.mailAddress, suggestion.id.contactWrapper.getFullName(), suggestion.id.contactWrapper);
    recipientInfo.resolveType().caught(tutao.ConnectionError, function(e) {
        // we are offline but we want to show the dialog only when we click on send.
    });
	return this._createBubbleFromRecipientInfo(recipientInfo);
};

/** @inheritDoc */
tutao.tutanota.ctrl.ComposingMail.prototype.createBubblesFromText = function(text) {
    var bubbles = [];
    var separator = (text.indexOf(";") != -1) ? ";" : ",";
    var textParts = text.split(separator);
    for (var i=0; i<textParts.length; i++) {
        var part = textParts[i].trim();
        if (part.length == 0) {
            continue;
        }
        var recipientInfo = this.getRecipientInfoFromText(part);
        recipientInfo.resolveType().caught(tutao.ConnectionError, function(e) {
            // we are offline but we want to show the dialog only when we click on send.
        });
        if (!recipientInfo) {
            // if one recipient is invalid, we do not return any valid ones because all invalid text would be deleted
            return [];
        }
        bubbles.push(this._createBubbleFromRecipientInfo(recipientInfo));
    }
	return bubbles;
};

/**
 * Creates a bubble from a recipient info.
 * @param {tutao.tutanota.ctrl.RecipientInfo} recipientInfo The recipientInfo.
 * @return {tutao.tutanota.ctrl.bubbleinput.Bubble} The bubble.
 */
tutao.tutanota.ctrl.ComposingMail.prototype._createBubbleFromRecipientInfo = function(recipientInfo) {
    var state = ko.computed(function() {
        if (recipientInfo.getRecipientType() == tutao.tutanota.ctrl.RecipientInfo.TYPE_UNKNOWN) {
            return "unknownRecipient";
        } else if (this.secure() || recipientInfo.getRecipientType() == tutao.tutanota.ctrl.RecipientInfo.TYPE_INTERNAL) {
            return "secureRecipient";
        } else {
            return "unsecureRecipient";
        }
    }, this);
	return new tutao.tutanota.ctrl.bubbleinput.Bubble(recipientInfo, ko.observable(recipientInfo.getDisplayText()), ko.observable(recipientInfo.getMailAddress()), state, true);
};

/**
 * Retrieves a RecipientInfo instance from a text. The text may be a contact name, contact mail address or other mail address.
 * @param {string} text The text to create a RecipientInfo from.
 * @return {tutao.tutanota.ctrl.RecipientInfo} The recipient info or null if the text is not valid data.
 */
tutao.tutanota.ctrl.ComposingMail.prototype.getRecipientInfoFromText = function(text) {
	text = text.trim();
	if (text == "") {
		return null;
	}
	var nameAndMailAddress = tutao.tutanota.util.Formatter.stringToNameAndMailAddress(text);

	var contactWrappers = tutao.tutanota.ctrl.ComposingMail._getContacts();
	for (var i = 0; i < contactWrappers.length; i++) {
		if (nameAndMailAddress) {
			if (contactWrappers[i].hasMailAddress(nameAndMailAddress.mailAddress)) {
				var name = (nameAndMailAddress.name != "") ? nameAndMailAddress.name : contactWrappers[i].getFullName();
                return new tutao.tutanota.ctrl.RecipientInfo(nameAndMailAddress.mailAddress, name, contactWrappers[i]);
			}
		} else {
			if (contactWrappers[i].getFullName() == text && contactWrappers[i].getContact().getMailAddresses().length == 1) {
                return new tutao.tutanota.ctrl.RecipientInfo(contactWrappers[i].getContact().getMailAddresses()[0].getAddress(), text, contactWrappers[i]);
			}
		}
	}
	if (!nameAndMailAddress) {
		return null;
	} else {
        return new tutao.tutanota.ctrl.RecipientInfo(nameAndMailAddress.mailAddress, nameAndMailAddress.name, null);
	}
};

/**
 * Provides all contacts of the logged in user.
 * @return {Array.<tutao.entity.tutanota.ContactWrapper>} All contacts of the logged in user.
 */
tutao.tutanota.ctrl.ComposingMail._getContacts = function() {
	return tutao.locator.contactListViewModel.getRawContacts();
};

/** @inheritDoc */
tutao.tutanota.ctrl.ComposingMail.prototype.bubbleDeleted = function(bubble) {
	// notify the recipient info to stop editing the contact
	bubble.entity.setDeleted();
};

/** @inheritDoc */
tutao.tutanota.ctrl.ComposingMail.prototype.buttonClick = function() {
	// we do not show a button
};

/** @inheritDoc */
tutao.tutanota.ctrl.ComposingMail.prototype.buttonCss = function() {
	// we do not show a button
	return null;
};


/**
 * Updates the contact informations of all recipients if they have been modified.
 * @param {Array.<tutao.tutanota.ctrl.RecipientInfo>} recipients List of recipients.
 * @private
 * @return {Promise} Resolves when all contacts have been updated
 */
tutao.tutanota.ctrl.ComposingMail.prototype._updateContactInfo = function (recipients) {
    return Promise.each(recipients, function(/*tutao.tutanota.ctrl.RecipientInfo*/currentRecipient) {
        // Changes of contact data must be checked before calling EditableContact.update(),
        var contactDataChanged = currentRecipient.hasPasswordChanged() || currentRecipient.hasPhoneNumberChanged();
        currentRecipient.getEditableContact().update();
        if (currentRecipient.isExistingContact()) {
            //only update if phone numbers or passwords have changed
            if ( contactDataChanged ){
                return currentRecipient.getEditableContact().getContact().update();
            }
        } else {
            // external users have no contact list.
            if (tutao.locator.mailBoxController.getUserContactList() != null) {
                return currentRecipient.getEditableContact().getContact().setup(tutao.locator.mailBoxController.getUserContactList().getContacts());
            }
        }
    })
};




"use strict";

tutao.provide('tutao.tutanota.ctrl.ContactCsvConverter');

/**
 * Converts a csv string into an array of contacts.
 * @param {string} csvString The csv data containing the contacts to import.
 * @param {tutao.tutanota.ctrl.ContactCsvHandler} handler Gets called for each csv value with 
 * the scv column name, value and contact to be filled. If the handler returns false, the parsing is cancelled.
 * @return {Array.<tutao.entity.tutanota.Contact>} The contacts parsed from csv.
 */
tutao.tutanota.ctrl.ContactCsvConverter.csvToContacts = function(csvString, handler) {
	var array = tutao.tutanota.util.CsvConverter.csvToArray(csvString);
	if (array == null) {
		return null;
	}
	var contacts = [];
	var names = array[0];
	for (var i=1; i<array.length; i++) {
		var c = tutao.entity.tutanota.ContactWrapper.createEmptyContactWrapper().getContact(); // initializes default values
		if (array[i].length != names.length) {
			return null;
		}
		handler.startContact(c);
		for (var a=1; a<names.length; a++) {
			if (names[a] != "") {
				if (!handler.addField(c, names[a], array[i][a])) {
					return null;
				}
			}
		}
		
		if (!handler.finishContact(c)) {
			return null;
		}
		contacts.push(c);
	}
	return contacts;
};

/**
 * Converts an array of contacts to a csv string.
 * @param {Array.<tutao.entity.tutanota.Contact>} contacts The contacts to convert.
 * @param {tutao.tutanota.ctrl.ContactCsvHandler} handler Gets called for each 
 * contact getting passed the contact and a handler function receiving each field for the csv line (name and value).
 * If handler returns false, the contact creation is cancelled.
 * @return {Array.<tutao.entity.tutanota.Contact>} The contacts parsed from csv.
 */
tutao.tutanota.ctrl.ContactCsvConverter.contactsToCsv = function(contacts, handler) {
	var array = [];
	var names = []; // is filled in the first handler call
	array.push(names);
	for (var i=0; i<contacts.length; i++) {
		var line = [];
		var success = handler.getContactFields(contacts[i], function(name, value) {
			if (i == 0) {
				// collect the names
				names.push(name);
			} else {
				// to do make sure the name is correct
			}
			line.push(value);
			
		});
		if (!success) {
			return null;
		} else {
			array.push(line);
		}
	}
	return tutao.tutanota.util.CsvConverter.arrayToCsv(array);
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.ContactCsvHandler');

/**
 * @interface
 */
tutao.tutanota.ctrl.ContactCsvHandler = function() {};

/**
 * For csv to contact import.
 */
tutao.tutanota.ctrl.ContactCsvHandler.prototype.startContact = function(contact) {};

/**
 * For csv to contact import.
 */
tutao.tutanota.ctrl.ContactCsvHandler.prototype.addField = function(contact, name, value) {};

/**
 * For csv to contact import.
 */
tutao.tutanota.ctrl.ContactCsvHandler.prototype.finishContact = function(contact) {};

/**
 * For contact to csv export.
 * @param {function(string,string)):boolean} fieldReceiver Must be called for each field in the contact in the correct order.
 */
tutao.tutanota.ctrl.ContactCsvHandler.prototype.getContactFields = function(contact, fieldReceiver) {};

"use strict";

tutao.provide('tutao.tutanota.ctrl.ContactListViewModel');

/**
 * The list of contact headers on the left.
 * The context of all methods is re-bound to this for allowing the ViewModel to be called from event Handlers that might get executed in a different context.
 * @constructor
 * @implements {tutao.tutanota.ctrl.bubbleinput.BubbleHandler}
 */
tutao.tutanota.ctrl.ContactListViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

	/* the currently selected dom elements for contacts */
	this._selectedDomElements = [];
	/* the contacts corresponding to the currently selected dom elements */
	this._selectedContacts = [];

	this._multiSelect = false;

	// the list of contact ids as result of the currently active search query.
	this.currentSearchResult = [];

	// the current search string
	this.searchString = ko.observable("");

	// ===== SEARCH ========

	this.bubbleInputViewModel = new tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel(this);
	this.buttonCss = ko.computed(function() {
		if (this.bubbleInputViewModel.inputValue().trim() || this.bubbleInputViewModel.bubbles().length > 0) {
			return 'cancel';
		} else {
			return 'search';
		}
	},this);
	this.bubbleInputViewModel.bubbles.subscribe(function() {
		this.search();
	}, this);

	// ===== SEARCH ========

	// contains observables with ContactWrappers
	this.contacts = ko.observableArray();
	this.buttons = ko.observableArray();

    // @type {?Array.<tutao.entity.tutanota.ContactWrapper>}
    this._rawContacts = [];

};

/**
 * Initialize the ContactListViewModel. Registers an event listener on the contact list to get updates.
 * @return {Promise.<>} Resolves when finished
 */
tutao.tutanota.ctrl.ContactListViewModel.prototype.init = function() {
    var eventTracker = new tutao.event.PushListEventTracker(tutao.entity.tutanota.Contact, tutao.locator.mailBoxController.getUserContactList().getContacts(), "Contact");
    eventTracker.addObserver(this.updateOnNewContacts);
    eventTracker.observeList(tutao.rest.EntityRestInterface.GENERATED_MIN_ID);
};

tutao.tutanota.ctrl.ContactListViewModel.prototype.getRawContacts = function() {
  return this._rawContacts;
};

/**
 * Called when new contacts are downloaded by the event tracker.
 * @param {Array.<tutao.entity.tutanota.Contact>} contacts The new contacts.
 * @return {Promise.<>} Resolved when finished, rejected if the rest call failed.
 */
tutao.tutanota.ctrl.ContactListViewModel.prototype.updateOnNewContacts = function(contacts) {
	for (var i = 0; i < contacts.length; i++) {
		this.currentSearchResult.push(contacts[i].getId()[1]);
        this._rawContacts.push(new tutao.entity.tutanota.ContactWrapper(contacts[i]));
    }
	return this._updateContactList();
};

/**
 * Updates the contact list according to the current search results.
 * @return {Promise.<>} Resolved when finished, rejected if the rest call failed.
 */
tutao.tutanota.ctrl.ContactListViewModel.prototype._updateContactList = function() {
	var self = this;
	self.unselectAll();

	var currentResult = tutao.util.ArrayUtils.getUniqueAndArray([this.currentSearchResult]);
	// sort the array by contact id descending
	currentResult.sort(function(a, b) {
		return (tutao.rest.EntityRestInterface.firstBiggerThanSecond(a, b)) ? -1 : 1;
	});
	var loadedContacts = [];
	return self._loadContacts(currentResult, loadedContacts, 0).then(function() {
        // sort contacts by name
        loadedContacts.sort(function(a, b) {
            return (a.getSortName() > b.getSortName());
        });

		// unregister the listeners
		for (var i = 0; i < self.contacts().length; i++) {
			self.contacts()[i]().getContact().unregisterObserver(self._contactChanged);
		}
		var observables = [];
		// register the listeners
		for (var i = 0; i < loadedContacts.length; i++) {
			var obs = ko.observable(loadedContacts[i]);
			loadedContacts[i].getContact().registerObserver(self._contactChanged, obs);
			observables.push(obs);
		}
		self.contacts(observables);
	});
};

tutao.tutanota.ctrl.ContactListViewModel.prototype._contactChanged = function(deleted, contact, id) {
	// id is the observable of the contact
	if (deleted) {
		// we can not directly call remove(id) because that removes all observables (due to knockout equality check implementation)
		this.contacts.remove(function(item) {
			return (item().getContact() == contact);
		});
	} else {
		id.valueHasMutated();
	}
};

/**
 * Loads the contacts with the given ids in the given order. Uses recursion to load all contacts.
 * @param {Array.<Array.<String>>} contactIds The ids of the contacts to load.
 * @param {Array.<tutao.entity.tutanota.ContactWrapper>} loadedContacts An array that contains all contacts that are loaded up to now.
 * @param {number} nextContact The index of the contact id in contactIds that shall be loaded next.
 * @return {Promise.<>} Resolved when finished, rejected if the rest call failed.
 */
tutao.tutanota.ctrl.ContactListViewModel.prototype._loadContacts = function(contactIds, loadedContacts, nextContact) {
    if (contactIds.length == 0) {
        return Promise.resolve();
    }
    var self = this;
	return tutao.entity.tutanota.Contact.load([tutao.locator.mailBoxController.getUserContactList().getContacts(), contactIds[nextContact]]).then(function(contact) {
        loadedContacts.push(new tutao.entity.tutanota.ContactWrapper(contact));
    }).lastly(function() {
        if (nextContact == contactIds.length - 1) {
            return Promise.resolve();
        } else {
            return self._loadContacts(contactIds, loadedContacts, nextContact + 1);
        }
    });
};

/**
 * Shows the given contact in the contact view.
 * @param {tutao.entity.tutanota.Contact} contact The contact to show.
 * @param {Object} event The event that triggered this call.
 */
tutao.tutanota.ctrl.ContactListViewModel.prototype.showContact = function(contact, event) {
	this._selectContact(contact, event.currentTarget);
	tutao.locator.contactViewModel.showContact(contact);
};

/**
 * Highlights the give contact.
 * @param {tutao.entity.tutanota.Contact} contact Contact to select.
 * @param {Object} domElement dom element of the contact.
 */
tutao.tutanota.ctrl.ContactListViewModel.prototype._selectContact = function(contact, domElement) {
	if (this._multiSelect) {
		// implement multi selection
	} else {
		tutao.tutanota.gui.unselect(this._selectedDomElements);
		this._selectedDomElements = [domElement];
		this._selectedContacts = [contact];
		tutao.tutanota.gui.select(this._selectedDomElements);
	}
};

/**
 * Deselects all contacts.
 */
tutao.tutanota.ctrl.ContactListViewModel.prototype.unselectAll = function() {
	tutao.tutanota.gui.unselect(this._selectedDomElements);
	this._selectedDomElements = [];
	this._selectedContacts = [];
	// do not remove the contact to avoid that new elements are removed
	// tutao.locator.contactViewModel.removeContact();
};

tutao.tutanota.ctrl.ContactListViewModel.prototype.importThunderbirdContactsAsCsv = function() {
	tutao.tutanota.util.FileUtils.showFileChooser().then(function(files) {
		if (files && files.length == 1 && tutao.util.StringUtils.endsWith(files.item(0).name, ".csv")) {
			tutao.tutanota.util.FileUtils.readLocalFileContentAsUtf8(files.item(0)).then(function(csv, exception) {
				var contacts = new tutao.tutanota.ctrl.ThunderbirdContactCsvConverter().csvToContacts(csv);
				if (!contacts) {
					console.log("import failed");
					return;
				}
				for (var i=0; i<contacts.length; i++) {
					contacts[i].setup(tutao.locator.mailBoxController.getUserContactList().getContacts(), function() {});
				}
			});
		} else {
			console.log("nothing imported");
		}
	});
};

/**
 * Performs a search according to the current search words and updates the contact list accordingly.
 * @return {Promise.<>} Resolved when finished, rejected if the rest call failed.
 */
tutao.tutanota.ctrl.ContactListViewModel.prototype.search = function() {
};

/**
 * Called when the search button is clicked.
 */
tutao.tutanota.ctrl.ContactListViewModel.prototype.searchButtonClick = function() {
};

/**
 * Called when the search button is clicked.
 */
tutao.tutanota.ctrl.ContactListViewModel.prototype.cancelButtonClick = function() {
};

/**
 * Updates from the search field.
 * @param {Array.<Bubble>} bubbles The bubbles to put into the search field.
 * @param {string} currentTextElement The search field content as text.
 */
tutao.tutanota.ctrl.ContactListViewModel.prototype.update = function(bubbles, currentTextElement) {
};

/**
 * Requests for validity from the search field.
 * @param {string} text The text to validate.
 * @return {Object<text, colorId>} The validated text and color id.
 */
tutao.tutanota.ctrl.ContactListViewModel.prototype.validateBubbleText = function(text) {
};

/************** implementation of tutao.tutanota.ctrl.bubbleinput.BubbleHandler **************/

/** @inheritDoc */
tutao.tutanota.ctrl.ContactListViewModel.prototype.getSuggestions = function(text) {
	return [];
};

/** @inheritDoc */
tutao.tutanota.ctrl.ContactListViewModel.prototype.createBubbleFromSuggestion = function(suggestion) {
	return null;
};

/** @inheritDoc */
tutao.tutanota.ctrl.ContactListViewModel.prototype.createBubblesFromText = function(text) {
	return [new tutao.tutanota.ctrl.bubbleinput.Bubble(null, ko.observable(text), ko.observable(null), ko.observable('default'), false)];
};

/** @inheritDoc */
tutao.tutanota.ctrl.ContactListViewModel.prototype.bubbleDeleted = function(bubble) {
	// nothing to do
};

/** @inheritDoc */
tutao.tutanota.ctrl.ContactListViewModel.prototype.buttonClick = function() {
	this.bubbleInputViewModel.bubbles.removeAll();
	this.bubbleInputViewModel.inputValue("");
	this.search();
};

/** @inheritDoc */
tutao.tutanota.ctrl.ContactListViewModel.prototype.buttonCss = function() {
    return null;
};
"use strict";

tutao.provide('tutao.tutanota.ctrl.ContactViewModel');

/**
 * The contact on the right.
 * @constructor
 */
tutao.tutanota.ctrl.ContactViewModel = function () {
    tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

    this.contactWrapper = ko.observable(null);
    this.editableContact = null;

    var self = this;
    var isState = function (state) {
        return function () {
            return self.mode() == state;
        };
    };
    this.contactWrapper.subscribe(function (previousValue) {
        // only init the button bar when we set a contactWrapper for the first time
        if (previousValue != null) {
            return;
        }
        this.buttons = [
            new tutao.tutanota.ctrl.Button("edit_action", 10, self.editContact, isState(tutao.tutanota.ctrl.ContactViewModel.MODE_SHOW)),
            new tutao.tutanota.ctrl.Button("delete_action", 9, self._deleteContact, isState(tutao.tutanota.ctrl.ContactViewModel.MODE_SHOW)),

            new tutao.tutanota.ctrl.Button("save_action", 10, self._saveContact, isState(tutao.tutanota.ctrl.ContactViewModel.MODE_NEW)),
            new tutao.tutanota.ctrl.Button("dismiss_action", 9, function () {
                self.contactWrapper().stopEditingContact(self);
                self.removeContact();
            }, isState(tutao.tutanota.ctrl.ContactViewModel.MODE_NEW)),

            new tutao.tutanota.ctrl.Button("save_action", 10, self._saveContact, isState(tutao.tutanota.ctrl.ContactViewModel.MODE_EDIT)),
            new tutao.tutanota.ctrl.Button("dismiss_action", 9, function () {
                self.contactWrapper().stopEditingContact(self);
                self._showContact(self.contactWrapper());
            }, isState(tutao.tutanota.ctrl.ContactViewModel.MODE_EDIT))
        ];

        this.buttonBarViewModel = new tutao.tutanota.ctrl.ButtonBarViewModel(this.buttons);
    }, this, "beforeChange");

    this.mode = ko.observable(tutao.tutanota.ctrl.ContactViewModel.MODE_NONE);
    this.showPresharedPassword = ko.observable(false);
    this.showAutoTransmitPassword = ko.observable(false);
};

tutao.tutanota.ctrl.ContactViewModel.MODE_NONE = 0;
tutao.tutanota.ctrl.ContactViewModel.MODE_SHOW = 1;
tutao.tutanota.ctrl.ContactViewModel.MODE_EDIT = 2;
tutao.tutanota.ctrl.ContactViewModel.MODE_NEW = 3;

/**
 * Removes the currently visible contact. TODO (timely) make private if not used from outside.
 */
tutao.tutanota.ctrl.ContactViewModel.prototype.removeContact = function () {
    this.mode(tutao.tutanota.ctrl.ContactViewModel.MODE_NONE);
    this.contactWrapper(null);
    tutao.locator.contactView.showContactListColumn();
};

/**
 * Asks the user to cancel the current editing mode.
 */
tutao.tutanota.ctrl.ContactViewModel.prototype._keepNewOrEditMode = function () {
    if (this.mode() == tutao.tutanota.ctrl.ContactViewModel.MODE_NEW) {
        if (!tutao.tutanota.gui.confirm(tutao.locator.languageViewModel.get("discardContact_msg"))) {
            return true;
        }
        this.contactWrapper().stopEditingContact(this);
    } else if (this.mode() == tutao.tutanota.ctrl.ContactViewModel.MODE_EDIT) {
        var text = tutao.locator.languageViewModel.get("discardContactChanges_msg");
        if (this.contactWrapper().getFullName() != "") {
            text = tutao.locator.languageViewModel.get("discardContactChangesFor_msg", {"$": this.contactWrapper().getFullName()});
        }
        if (!tutao.tutanota.gui.confirm(text)) {
            return true;
        }
        this.contactWrapper().stopEditingContact(this);
    }
    return false;
};

/**
 * Set the contact that shall be shown. Asks the user to cancel any editing contact.
 * @param {tutao.entity.tutanota.ContactWrapper} contactWrapper The contact.
 */
tutao.tutanota.ctrl.ContactViewModel.prototype.showContact = function (contactWrapper) {
    if (this._keepNewOrEditMode()) {
        return;
    }
    this._showContact(contactWrapper);
};

/**
 * Set the contact that shall be shown. Removes editing contacts if existing.
 * @param {tutao.entity.tutanota.ContactWrapper} contactWrapper The contact.
 */
tutao.tutanota.ctrl.ContactViewModel.prototype._showContact = function (contactWrapper) {
    var self = this;
    this.contactWrapper(contactWrapper);
    this.editableContact = null;

    this.mode(tutao.tutanota.ctrl.ContactViewModel.MODE_SHOW);
    tutao.locator.contactView.showContactColumn();
};

/**
 * Create a new contact.
 */
tutao.tutanota.ctrl.ContactViewModel.prototype.newContact = function () {
    if (this._keepNewOrEditMode()) {
        return;
    }

    var self = this;
    this.contactWrapper(tutao.entity.tutanota.ContactWrapper.createEmptyContactWrapper());
    this.editableContact = this.contactWrapper().startEditingContact(this);
    if (this.mode() == tutao.tutanota.ctrl.ContactViewModel.MODE_NEW || this.mode() == tutao.tutanota.ctrl.ContactViewModel.MODE_EDIT) {
        // switch to MODE_NONE to make knockout recognize the new fields
        this.mode(tutao.tutanota.ctrl.ContactViewModel.MODE_NONE);
    }
    this.mode(tutao.tutanota.ctrl.ContactViewModel.MODE_NEW);
    tutao.locator.contactView.showContactColumn();
};

/**
 * Edit the given contact. If any editing contact is already existing, the user is asked to cancel that contact.
 * @param {tutao.entity.tutanota.ContactWrapper} contactWrapper The contact to edit.
 * @return {Boolean} True if the contact can be edited, false otherwise.
 */
tutao.tutanota.ctrl.ContactViewModel.prototype.tryToShowAndEditContact = function (contactWrapper) {
    if (this.mode() == tutao.tutanota.ctrl.ContactViewModel.MODE_EDIT && this.contactWrapper().getContact() == contactWrapper.getContact()) {
        // we are already editing the contact
        return true;
    }
    if (this._keepNewOrEditMode()) {
        return false;
    }
    this._showContact(contactWrapper);
    this.editContact();
    return true;
};

/**
 * Edit a contact.
 * @precondition A contact is currently visible.
 */
tutao.tutanota.ctrl.ContactViewModel.prototype.editContact = function () {
    var self = this;
    this.editableContact = this.contactWrapper().startEditingContact(this);
    this.mode(tutao.tutanota.ctrl.ContactViewModel.MODE_EDIT);
    tutao.locator.contactView.showContactColumn();
};

/**
 * Saves the currently edited contact.
 */
tutao.tutanota.ctrl.ContactViewModel.prototype._saveContact = function () {
    // we have to reset the pre-shared password to null if none is set
    // Disable reset of pre-shared password for free users because automatic password transfer is disabled.
    if (this.editableContact.presharedPassword() == "" && !tutao.locator.userController.isLoggedInUserFreeAccount()) {
        this.editableContact.presharedPassword(null);
    }
    this.editableContact.update();
    var promise;
    if (this.mode() == tutao.tutanota.ctrl.ContactViewModel.MODE_NEW) {
        promise = this.contactWrapper().getContact().setup(tutao.locator.mailBoxController.getUserContactList().getContacts());
    } else if (this.mode() == tutao.tutanota.ctrl.ContactViewModel.MODE_EDIT) {
        promise = this.contactWrapper().getContact().update();
    }
    var self = this;
    promise.then(function() {
        self.contactWrapper().stopEditingContact(this);
        self._showContact(self.contactWrapper());
    })
};

/**
 * Deletes the currently shown contact.
 */
tutao.tutanota.ctrl.ContactViewModel.prototype._deleteContact = function () {
    var self = this;
    if (tutao.tutanota.gui.confirm(tutao.locator.languageViewModel.get("deleteContact_msg"))) {
        this.contactWrapper().getContact().erase().then(function() {
            self.removeContact();
        });
    }
};

/**
 * Opens the mail view to send a mail to the given mail address. If a mail is already edited, the user is asked to cancel that mail.
 * @param {tutao.entity.tutanota.ContactMailAddress} contactMailAddress The recipients mail address.
 */
tutao.tutanota.ctrl.ContactViewModel.prototype.sendMail = function (contactMailAddress) {
    var recipient = new tutao.tutanota.ctrl.RecipientInfo(contactMailAddress.getAddress(), this.contactWrapper().getFullName(), this.contactWrapper());
    recipient.resolveType().caught(tutao.ConnectionError, function(e) {
        // we are offline but we want to show the dialog only when we click on send.
    });
    tutao.locator.navigator.newMail(recipient);
};

/**
 * Provides the URL to access the given social service.
 * @param {tutao.entity.tutanota.ContactSocialId} contactSocialId The social id of the service.
 * @return {string} The URL.
 */
tutao.tutanota.ctrl.ContactViewModel.prototype.getSocialIdUrl = function (contactSocialId) {
    var url = tutao.entity.tutanota.TutanotaConstants.CONTACT_SOCIAL_ID_TYPE_LINKS[contactSocialId.getType()];
    if (url == null) {
        return null;
    } else {
        return url + contactSocialId.getSocialId();
    }
};

/**
 * Provides an URL pointing to the given address in google maps.
 * @param {tutao.entity.tutanota.ContactAddress} contactAddress The address to point to.
 * @return {string} The URL.
 */
tutao.tutanota.ctrl.ContactViewModel.prototype.getMapUrl = function (contactAddress) {
    var url = "https://maps.google.com/?q=";
    var query = contactAddress.getAddress();
    query = query.replace(/\n/g, ", ");
    return url + query;
};

/**
 * Returns the text to display for the pre-shared password.
 * @return {string} The text to display.
 */
tutao.tutanota.ctrl.ContactViewModel.prototype.getPresharedPasswordText = function () {
    return (this.showPresharedPassword()) ? this.contactWrapper().getContact().getPresharedPassword() : "*****";
};

/**
 * Returns the text to display for the SMS password.
 * @return {string} The text to display.
 */
tutao.tutanota.ctrl.ContactViewModel.prototype.getAutoTransmitPasswordText = function () {
    return (this.showAutoTransmitPassword()) ? this.contactWrapper().getContact().getAutoTransmitPassword() : "*****";
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.DisplayedMail');

/**
 * This class represents a mail that is currently displayed.
 * @param {tutao.entity.tutanota.Mail} mail The mail.
 * @constructor
 */
tutao.tutanota.ctrl.DisplayedMail = function (mail) {
    tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
    this.mail = mail;


    this.bodyText = ko.observable(""); // contains the sanitized body
    this.bodyTextWithoutQuotation = ko.observable("");
    this.bodyTextQuotation = ko.observable("");
    this.bodyTextQuotationVisible = ko.observable(false);
    this.mailBodyLoaded = ko.observable(false);

    this.attachments = ko.observableArray(); // contains Files
    this.currentlyDownloadingAttachment = ko.observable(null); // null or a File

    this._loadBody();
    this._loadAttachments();

    var self = this;
    var isExternalAnswerPossible = function () {
        return tutao.locator.userController.isExternalUserLoggedIn() && self.mail.getState() == tutao.entity.tutanota.TutanotaConstants.MAIL_STATE_RECEIVED && tutao.tutanota.util.ClientDetector.getSupportedType() != tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_IE && tutao.tutanota.util.ClientDetector.getSupportedType() != tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_ANDROID;
    };
    var isExternalExportPossible = function () {
        // legacy_ie does not support internally used arraybuffers, legacy_safari does not support download, legacy_android does not support download.
        // we deactivate export for mobile browsers generally because it is useless
        return tutao.tutanota.util.ClientDetector.isSupported() && !tutao.tutanota.util.ClientDetector.isMobileDevice() && tutao.locator.userController.isExternalUserLoggedIn();
    };
    var isInternalUserLoggedIn = function() {
        return tutao.locator.userController.isInternalUserLoggedIn();
    };
    var showReplyAll = function () {
        return tutao.locator.userController.isInternalUserLoggedIn() && self.mail.getToRecipients().length + self.mail.getCcRecipients().length + self.mail.getBccRecipients().length > 1;
    };
    var trashed = function () {
        return self.mail.getTrashed();
    };
    var untrashed = function () {
        return !self.mail.getTrashed();
    };
    var trashText = self.mail.getTrashed() ? "undelete_action" : "delete_action";
    this.buttons = [
        // external
        new tutao.tutanota.ctrl.Button("replyConfidential_action", 10, function () {
            tutao.locator.mailViewModel.replyMail(self);
        }, isExternalAnswerPossible, false, "replyConfidentialAction"),

        new tutao.tutanota.ctrl.Button("export_action", 7, function () {
            tutao.locator.mailViewModel.exportMail(self);
        }, isExternalExportPossible, false, "exportAction"),

        // internal
        new tutao.tutanota.ctrl.Button("reply_action", 10, function () {
            tutao.locator.mailViewModel.replyMail(self);
        }, isInternalUserLoggedIn, false, "replyAction"),

        new tutao.tutanota.ctrl.Button("replyAll_action", 7, function () {
            tutao.locator.mailViewModel.replyAllMail(self);
        }, showReplyAll, false, "replayAllAction"),

        new tutao.tutanota.ctrl.Button("forward_action", 6, function () {
            tutao.locator.mailViewModel.forwardMail(self);
        }, isInternalUserLoggedIn, false, "forwardAction"),

        // all
        new tutao.tutanota.ctrl.Button("undelete_action", 9, function () {
            tutao.locator.mailViewModel.deleteMail(self);
        }, trashed, false, "undeleteMailAction"),

		new tutao.tutanota.ctrl.Button("finalDelete_action", 8, function () {
            tutao.locator.mailViewModel.finalDeleteMail(self);
        }, trashed, false, "finalDeleteMailAction"),
		
		new tutao.tutanota.ctrl.Button("delete_action", 8, function () {
            tutao.locator.mailViewModel.deleteMail(self);
        }, untrashed, false, "deleteMailAction"),
    ];
    this.buttonBarViewModel = new tutao.tutanota.ctrl.ButtonBarViewModel(this.buttons);
    this.buttonBarViewModel.init();
};

tutao.tutanota.ctrl.DisplayedMail.prototype.toggleQuotationVisible = function () {
    this.bodyTextQuotationVisible(!this.bodyTextQuotationVisible());
};

/**
 * Loads the mail body.
 */
tutao.tutanota.ctrl.DisplayedMail.prototype._loadBody = function () {
    var self = this;
//	setTimeout(function() {
    self.mail.loadBody().then(function (body) {
        self.bodyText(tutao.locator.htmlSanitizer.sanitize(body.getText()));
        var split = tutao.locator.mailView.splitMailTextQuotation(self.bodyText());
        self.bodyTextWithoutQuotation(split.text);
        self.mailBodyLoaded(true);
        self.bodyTextQuotation(split.quotation);
		// use setTimeout here to make sure the gui is updated
        setTimeout(function() {
            tutao.locator.mailView.addSubmitCheckToMailBody();
        }, 0);
    }).caught(function(e) {
        self.bodyText("error while loading");
        throw e;
    });
//	},1000);
};

/**
 * Loads the attached files.
 */
tutao.tutanota.ctrl.DisplayedMail.prototype._loadAttachments = function () {
    var self = this;
    //TODO (timely) implement loading of multiple LET instances
    for (var i = 0; i < this.mail.getAttachments().length; i++) {
        tutao.entity.tutanota.File.load(this.mail.getAttachments()[i]).then(function (file, exception) {
            if (!exception) {
                self.attachments.push(file);
            } else {
                console.log(exception);
            }
        });
    }
};

/**
 * Offers the user to download the given attachment.
 * @param {tutao.entity.tutanota.File} file The file to download.
 */
tutao.tutanota.ctrl.DisplayedMail.prototype.downloadAttachment = function (file) {
    // do not allow a new download as long as another is running
    if (this.currentlyDownloadingAttachment()) {
        return;
    }
    var self = this;
    this.currentlyDownloadingAttachment(file);
    tutao.tutanota.ctrl.FileFacade.readFileData(file).then(function (dataFile, exception) {
        return tutao.tutanota.util.FileUtils.provideDownload(dataFile);
    }).lastly(function (e) {
        self.currentlyDownloadingAttachment(null);
    });
};

/**
 * Provides the image that shall be shown in the attachment.
 * @param {tutao.entity.tutanota.File} file The file.
 * @return {String} The name of the image.
 */
tutao.tutanota.ctrl.DisplayedMail.prototype.getAttachmentImage = function (file) {
    var busy = (file == this.currentlyDownloadingAttachment());
    return tutao.tutanota.util.FileUtils.getFileTypeImage(file.getName(), busy);
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.DropDownViewModel');

/**
 * Displays a drop down with a custom value. If the custom value is selected, the drop down is replaced by a text field.
 *
 * Always use with the dropdown-template (see index.html).
 *
 * @param {function(): Array.<Object.<string,string>>} optionsFunction Contains an array of Objects which should contain the two attributes 'id' and 'name',
 * wrapped in a function to allow dynamic language changes.
 * @param {function(): *} selectedIdObservable The observable that holds the selectedId.
 * @param {*} customId The id of the custom value.
 * @param {function(): *} customValueObservable The observable that holds the custom value.
 * @return {tutao.tutanota.ctrl.DropDownViewModel}
 */
tutao.tutanota.ctrl.DropDownViewModel = function(optionsFunction, selectedIdObservable, customId, customValueObservable) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

	// the options in the dropdown list
	this.options = ko.computed(function() {
		return optionsFunction();
	});
	// the observable that holds the selected item
	this.selectedIdObservable = selectedIdObservable;
	// the item in the dropdown list which when selected makes the text field appear
	this.customId = customId;
	// the observable that holds the custom value from the text field
	this.customValueObservable = customValueObservable;

	this.selectedId = ko.computed({
		read: function() {
			return this.selectedIdObservable();
		},
		write: function(value) {
			// not clear why the value may be null
			if (!value) {
				return;
			}
			this.selectedIdObservable(value);
			if (value === this.customId) {
				// set focus to the input field, because it was just made visible
				this.inputActive(true);
			}
		},
		owner: this
	});

	// indicates if the dropdown list has the focus
	this.selectActive = ko.observable(false);

	// indicates if the input has the focus
	this.inputActive = ko.observable(false);
	this.inputActive.subscribe(function(active) {
		if (!active) {
			if (customValueObservable() === "") {
				this.selectedIdObservable("0");
			}
		}
	}, this);

};

/**
 * @return {boolean} true, if the select item is visible, false otherwise.
 */
tutao.tutanota.ctrl.DropDownViewModel.prototype.selectVisible = function() {
	return (this.selectedIdObservable() !== this.customId);
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.ExternalLoginViewModel');

/**
 * The ViewModel for the externalLogin-template.
 * @constructor
 */
tutao.tutanota.ctrl.ExternalLoginViewModel = function() {
	var self = this;
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

	this.userId = null;
	this.mailListId = null;
	this.mailId = null;
	this.saltHex = null;

	// for authentication as long as verifier is not available
	this.saltHash = null;

	this.phoneNumbers = ko.observableArray();
	this.phoneNumbers.subscribe(function() {
		this.resetPasswordStatus();
	}, this);

	this.sendPasswordStatus = ko.observable({ type: "neutral", text: "emptyString_msg" });
	this.smsLocked = ko.observable(false);

	this.errorMessageId = ko.observable(null);

	this.password = ko.observable("");
	this.password.subscribe(function() {
		this.resetPasswordStatus();
	}, this);
	this.passphraseFieldFocused = ko.observable(false);
	this.symKeyForPasswordTransmission = null;
	this.autoAuthenticationId = ko.observable(null);
	this.autoAuthenticationId.subscribe(function(newAutoAuthenticationId) {
		this.retrievePassword();
	}, this);
	this._showingMail = false;
	

	// if the window width is small, just show the logo without "Tutanota" to save space
	this.muchSpace = ko.observable(tutao.tutanota.gui.getWindowWidth() >= 640);
	tutao.tutanota.gui.addWindowResizeListener(function(width, height) {
		self.muchSpace(tutao.tutanota.gui.getWindowWidth() >= 640);
	});

	// the device token is removed locally if it is not stored on the server (any more), see setup()
	this.deviceToken = null;
	this.storePassword = ko.observable(false);
	this.autoLoginActive = false;
	
	var s = new tutao.tutanota.util.StateMachine();
	this.state = s;
	s.addState("EnterPassword",         {});
	s.addState("SendingSms",            {});
	s.addState("CheckingPassword",      {});
	s.addState("FinishTooManyAttempts", {});
	s.addState("FinishShowMail",        {});

	s.addTransition("EnterPassword", "sendSms", "SendingSms");
	s.addTransition("SendingSms", "sendSmsFinished", "EnterPassword");
	s.addTransition("EnterPassword", "checkPassword", "CheckingPassword");
	s.addTransition("CheckingPassword", "passwordInvalid", "EnterPassword");
	s.addTransition("CheckingPassword", "passwordValid", "FinishShowMail");
	s.addTransition("CheckingPassword", "passwordTooManyAttempts", "FinishTooManyAttempts");

	this.sendSmsStatus = ko.observable({ type: "neutral", text: "emptyString_msg" });
	this.sentSmsNumberId = ko.observable(null); // the id of the number aggregate to which the last SMS was sent
	this.showMailStatus = ko.observable({ type: "neutral", text: "emptyString_msg" });
	this.passwordStatus = ko.observable();
	this.resetPasswordStatus();
};

tutao.tutanota.ctrl.ExternalLoginViewModel.prototype.resetPasswordStatus = function() {
	if (this.phoneNumbers().length == 0) {
		this.passwordStatus({ type: "neutral", text: "enterPresharedPassword_msg" });
	} else {
		this.passwordStatus({ type: "neutral", text: "enterSmsPassword_msg" });
	}
};

/**
 * Initializes the view model with a set of provided parameters and retrieves the phone numbers from the server.
 * @param {bool} allowAutoLogin Indicates if auto login is allowed (not allowed if logout was clicked)
 * @param {String} authInfo The id of the external user and the salt as base64Url concatenated.
 * @return {Promise.<>} Resolved when finished, rejected if failed.
 */
tutao.tutanota.ctrl.ExternalLoginViewModel.prototype.setup = function(allowAutoLogin, authInfo) {
	var self = this;
	// split mailRef to get user id and salt
	try {
        var userIdLength = tutao.rest.EntityRestInterface.GENERATED_MIN_ID.length;
        self.userId = authInfo.substring(0, userIdLength);
        self.saltHex = tutao.util.EncodingConverter.base64ToHex(tutao.util.EncodingConverter.base64UrlToBase64(authInfo.substring(userIdLength)));
        self.saltHash = tutao.util.EncodingConverter.base64ToBase64Url(tutao.locator.shaCrypter.hashHex(self.saltHex));
	} catch (e) {
		this.errorMessageId("invalidLink_msg");
		return Promise.reject();
	}

	// TODO (timely) show a spinner until now, switch to the view just after the data has been retrieved.
	// call PassworChannelService to get the user id and password channels
	return tutao.entity.tutanota.PasswordChannelReturn.load({}, self._getAuthHeaders()).then(function(passwordChannelReturn) {
		if (allowAutoLogin) {
			self.autoLoginActive = true;
			return self._tryAutoLogin().caught(function(e) {
                self.phoneNumbers(passwordChannelReturn.getPhoneNumberChannels());
                if (self.phoneNumbers().length == 1) {
                    self.sendPasswordStatus({ type: "neutral", text: "clickNumber_msg" });
                } else {
                    self.sendPasswordStatus({ type: "neutral", text: "chooseNumber_msg" });
                }
            }).lastly(function() {
                self.autoLoginActive = false;
            });
		} else {
			self.phoneNumbers(passwordChannelReturn.getPhoneNumberChannels());
			if (self.phoneNumbers().length == 1) {
				self.sendPasswordStatus({ type: "neutral", text: "clickNumber_msg" });
			} else {
				self.sendPasswordStatus({ type: "neutral", text: "chooseNumber_msg" });
			}
            return Promise.resolve();
		}
	}).caught(tutao.AccessExpiredError, function(e) {
        self.errorMessageId("expiredLink_msg");
    }).caught(tutao.NotAuthenticatedError, function(e) {
        self.errorMessageId("invalidLink_msg");
    }).caught(tutao.BadRequestError, function(e) {
        self.errorMessageId("invalidLink_msg");
    });
};

/**
 * Loads the device key.
 * @return {Promise.<Object>} Resolves to the device key, rejected if loading the device key failed.
 */
tutao.tutanota.ctrl.ExternalLoginViewModel.prototype._loadDeviceKey = function() {
	var params = {};
	return tutao.entity.sys.AutoLoginDataReturn.load(new tutao.entity.sys.AutoLoginDataGet()
        .setUserId(this.userId)
        .setDeviceToken(this.deviceToken), params, null).then(function(autoLoginDataReturn) {
			var deviceKey = tutao.locator.aesCrypter.hexToKey(tutao.util.EncodingConverter.base64ToHex(autoLoginDataReturn.getDeviceKey()));
			return deviceKey;
	});
};

/**
 * Tries to login the user automatically.
 * @return {Promise.<>} Resolved when finished, rejected if auto login failed.
 */
tutao.tutanota.ctrl.ExternalLoginViewModel.prototype._tryAutoLogin = function() {
	var self = this;
	this.deviceToken = tutao.tutanota.util.LocalStore.load('deviceToken_' + this.userId);
	var deviceEncPassword = tutao.tutanota.util.LocalStore.load('deviceEncPassword_' + this.userId);
	if (this.deviceToken == null || deviceEncPassword == null) {
		return Promise.reject(new Error("no device token or password available"));
	}
	return this._loadDeviceKey().then(function(deviceKey) {
		var password = null;
		try {
			password = tutao.locator.aesCrypter.decryptUtf8(deviceKey, deviceEncPassword);
		} catch (e) { //tutao.tutadb.crypto.CryptoException
			return Promise.reject(e);
		}
		return self._tryLogin(password);
	}).caught(tutao.NotAuthenticatedError, function(exception) {
        // device is not authenticated by server, so delete the device token locally
        tutao.tutanota.util.LocalStore.remove('deviceToken_' + self.userId);
        self.deviceToken = null;
        throw exception;
    });
};

/**
 * Unlocks the send SMS button after 60s.
 */
tutao.tutanota.ctrl.ExternalLoginViewModel.prototype._allowSmsAfterDelay = function() {
	var self = this;
	setTimeout(function() {
		self.smsLocked(false);
		self.sendSmsStatus({ type: "neutral", text: "emptyString_msg" });
		self.sendPasswordStatus({ type: "neutral", text: "smsResent_msg" });
	}, 60000);
};

/**
 * Provides the status for sending an SMS for a given mobile phone number.
 * @param {string} numberId The aggregate id of the number.
 * @return {Object} Status object with type and text.
 */
tutao.tutanota.ctrl.ExternalLoginViewModel.prototype.getSendSmsStatus = function(numberId) {
	if (this.sentSmsNumberId() == numberId) {
		return this.sendSmsStatus();
	} else {
		return { type: "neutral", text: "emptyString_msg" };
	}
};

/**
 * Provides the information if sending an SMS is allowed (button is enabled).
 * @return {boolean} True if allowed, false otherweise.
 */
tutao.tutanota.ctrl.ExternalLoginViewModel.prototype.sendSmsAllowed = function() {
	return (!this.smsLocked() && this.state.getState() == "EnterPassword");
};

/**
 * Sends the password message to the provided phone number.
 * @param {tutao.entity.tutanota.PasswordChannelPhoneNumber} phoneNumber The phone number so send the SMS to.
 */
tutao.tutanota.ctrl.ExternalLoginViewModel.prototype.sendSms = function(phoneNumber) {
	if (!this.sendSmsAllowed()) {
		return;
	}
	// reuse the transmission password to allow receiving the key if the SMS was requested a second time, but the SMS link of the first SMS was clicked
	if (this.symKeyForPasswordTransmission == null) {
        if (tutao.locator.randomizer.isReady()) {
            this.symKeyForPasswordTransmission = tutao.locator.aesCrypter.generateRandomKey();
        } else {
            // it must be created from Math.random() because the Randomizer is not yet fully initialized. Nevertheless this is no security problem because the server knows the password anyway.
            var hex = "";
            for (var i=0; i<16; i++) {
                var r = Math.floor(Math.random() * 256).toString(16);
                if (r.length == 1) {
                    r = "0" + r;
                }
                hex += r;
            }
            this.symKeyForPasswordTransmission = tutao.locator.aesCrypter.hexToKey(hex);
        }
	}
	
	var self = this;
	var service = new tutao.entity.tutanota.PasswordMessagingData()
        .setLanguage(tutao.locator.languageViewModel.getCurrentLanguage())
	    .setNumberId(phoneNumber.getId())
	    .setSymKeyForPasswordTransmission(tutao.locator.aesCrypter.keyToBase64(this.symKeyForPasswordTransmission));
	var map = {};
	this.sentSmsNumberId(phoneNumber.getId());
	this.state.event("sendSms");
	this.sendSmsStatus({ type: "neutral", text: "sendingSms_msg" });
	service.setup(map, this._getAuthHeaders()).then(function(passwordMessagingReturn, exception) {
        self.autoAuthenticationId(passwordMessagingReturn.getAutoAuthenticationId());
        self.sendSmsStatus({ type: "valid", text: "smsSent_msg" });
        self.passphraseFieldFocused(true);
        self.smsLocked(true);
        self._allowSmsAfterDelay();
		self.state.event("sendSmsFinished");
	}).caught(tutao.TooManyRequestsError, function(exception) {
            self.sendSmsStatus({ type: "invalid", text: "smsSentOften_msg" });
            self.smsLocked(true);
    }).caught(tutao.AccessExpiredError, function(e) {
        self.errorMessageId("expiredLink_msg");
    }).caught(tutao.InternalServerError, function() {
        self.sendSmsStatus({ type: "invalid", text: "smsError_msg" });
    });
};

/**
 * Verifies that the password length is valid
 * @return {boolean} true, if the password is valid.
 */
tutao.tutanota.ctrl.ExternalLoginViewModel.prototype.isPasswordLengthValid = function() {
	return this.phoneNumbers().length == 0 || this.password().length === tutao.tutanota.util.PasswordUtils.MESSAGE_PASSWORD_LENGTH;
};

/**
 * Provides the information if showing the email is allowed (button is enabled).
 * @return {boolean} True if allowed, false otherweise.
 */
tutao.tutanota.ctrl.ExternalLoginViewModel.prototype.showMailAllowed = function() {
	return (this.isPasswordLengthValid() && this.state.getState() == "EnterPassword");
};

/**
 * Switches to the mailView and displays the mail if the provided password is correct.
 */
tutao.tutanota.ctrl.ExternalLoginViewModel.prototype.checkEnteredPassword = function() {
	if (!this.showMailAllowed()) {
		return;
	}
	this._tryLogin(this.password());
};

/**
 * Must be called after password entry. Loads the communication key via ExternalMailReference, initializes the users mailbox and shows the mails.
 * @param {string} password The password to try the login with.
 * @return {Promise.<>} Resolved when finished, rejected if failed.
 */
tutao.tutanota.ctrl.ExternalLoginViewModel.prototype._tryLogin = function(password) {
    var self = this;
    self.state.event("checkPassword");
    self.passwordStatus({ type: "neutral", text: "emptyString_msg" });
    self.showMailStatus({ type: "neutral", text: "loadingMail_msg" });
    return tutao.locator.userController.loginExternalUser(self.userId, password, self.saltHex).then(function() {
        self.state.event("passwordValid");
        return tutao.locator.mailBoxController.initForUser().then(function(exception) {
            return tutao.locator.loginViewModel.loadEntropy().then(function() {
                return self._storePasswordIfPossible(password).then(function() {
                    // no indexing for external users
                    tutao.locator.replace('dao', new tutao.db.DummyDb);
                    self._showingMail = true;
                    tutao.locator.navigator.mail();
                });
            });
        });
    }).caught(tutao.AccessExpiredError, function(e) {
            self.errorMessageId("expiredLink_msg");
    }).caught(tutao.NotAuthenticatedError, function(e) {
        self.state.event("passwordInvalid");
        self.passwordStatus({ type: "invalid", text: "invalidPassword_msg" });
        self.showMailStatus({ type: "neutral", text: "emptyString_msg" });
    });
};

/**
 * Stores the password locally if chosen by user.
 * @param {string} password The password to store.
 * @return {Promise.<>} Resolved when finished, rejected if failed.
 */
tutao.tutanota.ctrl.ExternalLoginViewModel.prototype._storePasswordIfPossible = function(password) {
	var self = this;
	// if auto login is active, the password is already stored and valid
	if (!self.autoLoginActive && self.storePassword()) {
		if (!self.deviceToken) {
			// register the device and store the encrypted password
			var deviceService = new tutao.entity.sys.AutoLoginDataReturn();
			var deviceKey = tutao.locator.aesCrypter.generateRandomKey();
			deviceService.setDeviceKey(tutao.util.EncodingConverter.hexToBase64(tutao.locator.aesCrypter.keyToHex(deviceKey)));
			return deviceService.setup({}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(autoLoginPostReturn) {
				if (tutao.tutanota.util.LocalStore.store('deviceToken_' + self.userId, autoLoginPostReturn.getDeviceToken())) {
					var deviceEncPassword = tutao.locator.aesCrypter.encryptUtf8(deviceKey, password);
					tutao.tutanota.util.LocalStore.store('deviceEncPassword_' + self.userId, deviceEncPassword);
				}
			}).caught(function (e) {
                // do nothing
            });
		} else {
			// the device is already registered, so only store the encrypted password
			return self._loadDeviceKey().then(function(deviceKey, exception) {
				var deviceEncPassword = tutao.locator.aesCrypter.encryptUtf8(deviceKey, password);
				tutao.tutanota.util.LocalStore.store('deviceEncPassword_' + self.userId, deviceEncPassword);
			}).caught(function (e) {
                // do nothing
            });
		}
	} else if (!self.autoLoginActive && !self.storePassword()) {
		// delete any stored password
		if (tutao.tutanota.util.LocalStore.contains('deviceToken_' + self.userId)) {
			tutao.tutanota.util.LocalStore.remove('deviceToken_' + self.userId);
			tutao.tutanota.util.LocalStore.remove('deviceEncPassword_' + self.userId);
		}
		return Promise.resolve();
	} else {
        return Promise.resolve();
	}
};

tutao.tutanota.ctrl.ExternalLoginViewModel.prototype.retrievePassword = function() {
    if (this._showingMail) {
		return;
	}
    var input = new tutao.entity.tutanota.PasswordRetrievalData()
        .setAutoAuthenticationId(this.autoAuthenticationId());
	var self = this;
	tutao.entity.tutanota.PasswordRetrievalReturn.load(input, {}, this._getAuthHeaders()).then(function(passwordRetrievalReturn) {
		if (passwordRetrievalReturn.getTransmissionKeyEncryptedPassword() == "") {
			self.retrievePassword(); // timeout, retry to get the password immediately
		} else if (!self._showingMail){
			var password;
			try {
				// no initialization vector because it must fit into an SMS
				password = tutao.locator.aesCrypter.decryptUtf8Index(self.symKeyForPasswordTransmission, passwordRetrievalReturn.getTransmissionKeyEncryptedPassword());
			} catch (e) {
				self.state.event("passwordInvalid");
				self.passwordStatus({ type: "invalid", text: "invalidPassword_msg" });
				self.showMailStatus({ type: "neutral", text: "emptyString_msg" });
				return;
			}
			self._tryLogin(password);
		}
	}).caught(function(exception) {
        self.sendPasswordStatus({ type: "invalid", text: "smsError_msg" });
        throw exception;
    });
};

/**
 * Creates the parameter map for authenticating with the remote services.
 * @return {Object.<String, String>} the parameters.
 */
tutao.tutanota.ctrl.ExternalLoginViewModel.prototype._getAuthHeaders = function() {
	var headers = {};
	headers[tutao.rest.ResourceConstants.USER_ID_PARAMETER_NAME] = this.userId;
	headers[tutao.rest.ResourceConstants.AUTH_TOKEN_PARAMETER_NAME] = this.saltHash;
	return headers;
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.FeedbackViewModel');

/**
 * The ViewModel for the feedback wizard.
 * @constructor
 */
tutao.tutanota.ctrl.FeedbackViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

	this.message = ko.observable("");
    this.stack = ko.observable("");
	this.showDialog = ko.observable(false);

    var self = this;
    this.isErrorDialog = ko.computed(function() {
        if (self.stack()) {
            return true;
        } else {
            return false;
        }
    });
    this.title = ko.computed(function() {
        if (self.isErrorDialog()) {
            return "errorReport_label";
        } else {
            return "feedback_label";
        }
    });
    this.infoMessage = ko.computed(function() {
        if (self.isErrorDialog()) {
            return "feedbackErrorInfo_msg";
        } else {
            return "feedbackInfo_msg";
        }
    });
};

/**
 * @param {string=} stack
 */
tutao.tutanota.ctrl.FeedbackViewModel.prototype.open = function(stack) {
    if (stack) {
        this.stack(stack);
    } else {
        this.stack("");
    }
    this.message("");
    this.showDialog(true);
};

tutao.tutanota.ctrl.FeedbackViewModel.prototype.close = function() {
    this.showDialog(false);
};

tutao.tutanota.ctrl.FeedbackViewModel.prototype.sendFeedback = function() {
    var self = this;
    var attachments = [];
    var facade;
    var previousMessageId;
    if (tutao.locator.userController.isExternalUserLoggedIn()) {
        facade = tutao.tutanota.ctrl.SendMailFromExternalFacade;
        previousMessageId = ""; // dummy value for feedback mail
    } else {
        facade = tutao.tutanota.ctrl.SendMailFacade;
        previousMessageId = null;
    }
    var message = this.message()
        + "\n\n User agent: \n" + navigator.userAgent;
    if (this.isErrorDialog()) {
        message += "\n\n Stacktrace: \n" + this.stack();
    }
    message = message.split("\n").join("<br>");
    var recipient = new tutao.tutanota.ctrl.RecipientInfo("support@tutao.de", "");
    recipient.resolveType().then(function() {
        return facade.sendMail("Feedback", message, "", [recipient], [], [], tutao.entity.tutanota.TutanotaConstants.CONVERSATION_TYPE_NEW, previousMessageId, attachments, "de");
    }).then(function() {
        self.close();
    });
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.FileFacade');

/**
 * Creates a new file on the server in the user file system.
 * @param {tutao.tutanota.util.DataFile} dataFile The data file.
 * @param {Object} sessionKey The session key used to encrypt the file.
 * @return {Promise.<Array.<String>>} Resolves to the id of the created File, rejected if failed.
 */
tutao.tutanota.ctrl.FileFacade.createFile = function(dataFile, sessionKey) {
	return tutao.tutanota.ctrl.FileFacade.uploadFileData(dataFile, sessionKey).then(function(fileDataId) {
        // create file
        var fileService = new tutao.entity.tutanota.CreateFileData();
        fileService._entityHelper.setSessionKey(sessionKey);
        fileService.setFileName(dataFile.getName())
            .setMimeType(dataFile.getMimeType())
            .setParentFolder(null)
            .setFileData(fileDataId);

        var fileListId = tutao.locator.mailBoxController.getUserFileSystem().getFiles();
        return fileService._entityHelper.createListEncSessionKey(fileListId).then(function(listEncSessionKey) {
            return fileService.setGroup(tutao.locator.userController.getUserGroupId())
                .setListEncSessionKey(listEncSessionKey)
                .setup({}, null)
                .then(function(createFileReturn) {
                var fileId = createFileReturn.getFile();
                return fileId;
            });
        });
	});
};

/**
 * Creates a new file data instance on the server and uploads the data from the given DataFile to it.
 * @param {tutao.tutanota.util.DataFile} dataFile The data file.
 * @param {Object} sessionKey The session key used to encrypt the file.
 * @return {Promise.<String>} Resolves to the id of the created FileData, rejected if failed.
 */
tutao.tutanota.ctrl.FileFacade.uploadFileData = function(dataFile, sessionKey) {
	var fileData = new tutao.entity.tutanota.FileDataDataPost();
    return new Promise(function(resolve, reject) {
        tutao.locator.aesCrypter.encryptArrayBuffer(sessionKey, dataFile.getData(), function(encryptedData, exception) {
            if (exception) {
                reject(exception);
            }
            // create file data
            fileData.setSize(dataFile.getSize().toString())
                .setGroup(tutao.locator.userController.getUserGroupId());

            resolve(fileData.setup({}, null).then(function(fileDataPostReturn) {
                // upload file data
                var fileDataId = fileDataPostReturn.getFileData();
                var putParams = { fileDataId: fileDataId };
                putParams[tutao.rest.ResourceConstants.SW_VERSION_PARAMETER] = tutao.entity.tutanota.FileDataDataReturn.MODEL_VERSION;
                return tutao.locator.restClient.putBinary(tutao.rest.EntityRestClient.createUrl(tutao.entity.tutanota.FileDataDataReturn.PATH, null, null, putParams), tutao.entity.EntityHelper.createAuthHeaders(), encryptedData).then(function() {
                    return fileDataId;
                });
            }));
        })
    });
};

/**
 * Loads the content of a file from the server and provides it as DataFile.
 * @param {tutao.entity.tutanota.File} file The File.
 * @return {Promise.<tutao.tutanota.util.DataFile>} Resolves to the read DataFile, rejected if loading failed.
 */
tutao.tutanota.ctrl.FileFacade.readFileData = function(file) {
    var fileParams = new tutao.entity.tutanota.FileDataDataGet()
        .setFile(file.getId())
        .setBase64(tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_IE);
	var params = {};
	params[tutao.rest.ResourceConstants.GET_BODY_PARAM] = encodeURIComponent(JSON.stringify(fileParams.toJsonData()));
	var headers = tutao.entity.EntityHelper.createAuthHeaders();
	return tutao.locator.restClient.getBinary(tutao.rest.EntityRestClient.createUrl(tutao.entity.tutanota.FileDataDataReturn.PATH, null, null, params), headers).then(function(data) {
        return new Promise(function(resolve, reject) {
            if (typeof data === "string") {
                // LEGACY variant for IE8/9 which uses an Array instead of ArrayBuffer
                tutao.locator.aesCrypter.decryptBase64(file._entityHelper._sessionKey, data, file.getSize(), function(decryptedData, exception) {
                    if (exception) {
                        reject(exception);
                    } else {
                        resolve(new tutao.tutanota.util.DataFile(decryptedData, file));
                    }
                });
            } else {
                tutao.locator.aesCrypter.decryptArrayBuffer(file._entityHelper._sessionKey, data, file.getSize(), function(decryptedData, exception) {
                    if (exception) {
                        reject(exception);
                    } else {
                        resolve(new tutao.tutanota.util.DataFile(decryptedData, file));
                    }
                });
            }
        });
	});
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.FileViewModel');

/**
 * The view model for the file system.
 * The context of all methods is re-bound to this for allowing the ViewModel to be called from event Handlers that might get executed in a different context.
 * @constructor
 */
tutao.tutanota.ctrl.FileViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

	this.buttons = ko.observableArray();
	this.sentAttachments = ko.observableArray();
	this.receivedAttachments = ko.observableArray();
	this.currentlyDownloadingFile = ko.observable(null);
};

tutao.tutanota.ctrl.FileViewModel.prototype.init = function() {
	var self = this;
	tutao.entity.tutanota.File.loadRange(tutao.locator.mailBoxController.getUserMailBox().getReceivedAttachments(), tutao.rest.EntityRestInterface.GENERATED_MIN_ID, 100, false).then(function(files) {
		self.receivedAttachments(files);
		return tutao.entity.tutanota.File.loadRange(tutao.locator.mailBoxController.getUserMailBox().getSentAttachments(), tutao.rest.EntityRestInterface.GENERATED_MIN_ID, 100, false).then(function(files) {
			self.sentAttachments(files);
		});
	});
};

tutao.tutanota.ctrl.FileViewModel.prototype.getFileTypeImage = function(file) {
	return tutao.tutanota.util.FileUtils.getFileTypeImage(file.getName(), false);
};

tutao.tutanota.ctrl.FileViewModel.prototype.newFolder = function() {
	console.log("I want a new folder");
};

tutao.tutanota.ctrl.FileViewModel.prototype.downloadFile = function(file) {
	var self = this;
	// do not allow a new download as long as another is running
	if (this.currentlyDownloadingFile()) {
		return;
	}
	this.currentlyDownloadingFile(file);
	tutao.tutanota.ctrl.FileFacade.readFileData(file).then(function(dataFile) {
		return tutao.tutanota.util.FileUtils.provideDownload(dataFile);
	}).lastly(function() {
        self.currentlyDownloadingFile(null);
    });
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.FontViewModel');

tutao.tutanota.ctrl.FontViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	var self = this;

	this.fonts = ko.observableArray(["DejaVu Sans", "Helvetica", "Droid Sans", "News Cycle", "Ubuntu Condensed", "Open Sans", "Yanone Kaffeesatz", "Oswald", "Source Sans Pro", "lucida grande", "tahoma"]);
	this.font = ko.observable("DejaVu Sans");
	this.font.subscribe(function() {
		$("body, input, button, select, textarea").css("font-family", self.font());
	});
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.GroupData');

/**
 * @param {string} name
 *            the name of the group.
 * @param {string} mailAddr
 * @param {Object} userKey
 *            the symmetric user key used for encrypting the symmetric group key for group
 *            memberships.
 * @param {Object} adminGroupKey
 *            the key of the admin group, used to encrypt the symmetric group key for the admin group.
 * @param {Object} listKey
 *            the key of the list, used to encrypt all regular data of the group (e.g. name)
 * @return {Promise.<[tutao.entity.sys.CreateGroupData, Object]>}>} Resolves to an array which contains the tutao.entity.sys.CreateGroupData instance and the userGroupKey, rejected if failed.
 */
tutao.tutanota.ctrl.GroupData.generateGroupKeys = function(name, mailAddr, userKey, adminGroupKey, listKey) {
	var symGroupKey = tutao.locator.aesCrypter.generateRandomKey();
    return new Promise(function(resolve, reject) {
        tutao.locator.rsaCrypter.generateKeyPair(function(keyPair, exception) {
            if (exception) {
                reject(exception);
            } else {
                var sessionKey = tutao.locator.aesCrypter.generateRandomKey();

                var groupData = new tutao.entity.sys.CreateGroupData()
                    .setEncryptedName(tutao.locator.aesCrypter.encryptUtf8(sessionKey, name))
                    .setMailAddress(mailAddr)
                    .setPubKey(tutao.util.EncodingConverter.hexToBase64(tutao.locator.rsaCrypter.keyToHex(keyPair.publicKey)))
                    .setSymEncPrivKey(tutao.locator.aesCrypter.encryptPrivateRsaKey(symGroupKey, tutao.locator.rsaCrypter.keyToHex(keyPair.privateKey)));

                if (userKey != null) {
                    groupData.setSymEncGKey(tutao.locator.aesCrypter.encryptKey(userKey, symGroupKey));
                }
                if (adminGroupKey != null) {
                    groupData.setAdminEncGKey(tutao.locator.aesCrypter.encryptKey(adminGroupKey, symGroupKey));
                } else {
                    // this is the adminGroup
                    groupData.setAdminEncGKey(tutao.locator.aesCrypter.encryptKey(symGroupKey, symGroupKey));
                }

                groupData.setListEncSessionKey(tutao.locator.aesCrypter.encryptKey(listKey, sessionKey));

                resolve([groupData, symGroupKey]);
            }
        });
    });

};
"use strict";

tutao.provide('tutao.tutanota.ctrl.LanguageViewModel');

/**
 * Provides all localizations of strings on our gui.
 * @constructor
 */
tutao.tutanota.ctrl.LanguageViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	var lang = null; // tutao.tutanota.util.LocalStore.load('language');
	if (!lang) {
		lang = tutao.tutanota.util.ClientDetector.getDefaultLanguage();
	}
	this._current = ko.observable(lang);
};

/**
 * Provides the current language, one of "en" and "de"
 * @return {string} The current language.
 */
tutao.tutanota.ctrl.LanguageViewModel.prototype.getCurrentLanguage = function() {
	return this._current();
};

/**
 * Sets the current language.
 * @param {string} lang The language to set, one of "en" and "de".
 */
tutao.tutanota.ctrl.LanguageViewModel.prototype.setCurrentLanguage = function(lang) {
	if (lang != "en" && lang != "de") {
		throw new Error("invalid language: " + lang);
	}
	// tutao.tutanota.util.LocalStore.store('language', lang);
	this._current(lang);
};

/**
 * Provides the text with the given id and the given params in the currently selected language.
 * @param {string} id One of the ids defined in tutao.tutanota.ctrl.LanguageViewModel.en or tutao.tutanota.ctrl.LanguageViewModel.de.
 * @param {Object<String,String>=} params An object whose property keys are the strings that shall be replaced by the corresponding property value in the text.
 * @return {string} The text.
 */
tutao.tutanota.ctrl.LanguageViewModel.prototype.get = function(id, params) {
	if (id == null) {
		return "";
	}
	var text = tutao.tutanota.ctrl.LanguageViewModel[this._current()][id];
	if (!text) {
		throw new Error("no translation found for id " + id);
	}
	if (params instanceof Object) {
		for (var param in params) {
			text = text.replace(param, params[param]);
		}
	}
	return text;
};

/**
 * Returns all translations in pretty-printed form.
 */
tutao.tutanota.ctrl.LanguageViewModel.prototype.allTranslationsAsJson = function() {
	return JSON.stringify({de: tutao.tutanota.ctrl.LanguageViewModel.de, en: tutao.tutanota.ctrl.LanguageViewModel.en}, null, 2)
};

/**
 * Defines the English translations of all texts in Tutanota.
 * The actual identifier is in camel case and the type is appended by an underscore.
 * Types: label, action, msg, title, alt, placeholder
 */
tutao.tutanota.ctrl.LanguageViewModel.en = {
	// soft-hyphen: \u00AD
		
	// mail
	deleteMail_msg:	"Delete new email without saving?",
	tooBigAttachment_msg: "The following files could not be attached because their size exceeds 25 MB: ",
	received_action: "Received",
	receivedMail_alt: "Received email",
	receivedMails_alt: "Received emails",
	sent_action: "Sent",
	sentMail_alt: "Sent email",
	sentMails_alt: "Sent emails",
	trash_action: "Trash",
	trashedMail_alt: "Deleted email",
	trashedMails_alt: "Deleted emails",
	mailWithAttachment_alt: "Email with attachment",
	meNominative_label: "Me",
	meDativ_label: "Me",
	meAccusative_label: "Me",
	from_label: "From",
	to_label: "To",
	cc_label: "Cc",
	bcc_label: "Bcc",
	ccBcc_label: "B/Cc",
	closedLock_alt: 'Closed lock',
	openedLock_alt: 'Open lock',
	attachFiles_action: "Attach files",
	removeAttachment_alt: "Remove attachment",
	passwordTransmission_label: "Password transmission",
	atLeastOneMobileNumber_label: "At least one mobile phone number or an agreed password is needed for each external recipient.",
    preSharedPasswordNeeded_label: "Please enter an agreed password for each external recipient.",
    autoTransmitPasswordDeactivated_label: "Password transmission by text message is currently not supported.",
	secureMail_title: 'Email is encrypted for external recipients.',
	unsecureMail_title: 'Email is not encrypted for external recipients.',
	noRecipients_msg: 'Please enter the email address of your recipient.',
	invalidRecipients_msg: 'Please correct the invalid email addresses\n in the recipient fields.',
	noSubject_msg: 'Please enter a subject.',
	noPasswordChannels_msg: 'Please provide a mobile phone number or an agreed password for all external recipients.',
    noPreSharedPassword_msg: 'Please provide an agreed password for all external recipients.',
	invalidPasswordChannels_msg: 'Please check the password channels again for invalid phone numbers.',
	maxSizeExceeded_msg: "The maximum message size of $ to insecure external recipients is exceeded.",
	send_action: "Send",
	reply_action: "Reply",
	replyAll_action: "Reply all",
	forward_action: "Forward",
	replyConfidential_action: "Reply confidentially",
    export_action: "Export",
    deleteTrash_action: "Delete all",
	by_label: "by",
	date_label: "Date",
	subject_label: "Subject",
	showQuotation_action: "+ Quotes",
	hideQuotation_action: "- Quotes",
	legacyNoReplyIe_msg: "This Internet Explorer is an old version and does not support replying to or exporting of emails. If you need this feature, please update or use one of the following browsers:",
	legacyNoAttachmentsIeMobile_msg: "Internet Explorer mobile does not support downloading attachments or attaching files to emails. If you need these features, please use one of the following browsers:",
	legacyNoReplyAndroid_msg: "The Android browser does not support replying to emails or saving attachments to disk. Still some file types can be displayed in the browser. Please use one of the following browsers otherwise:",
	legacyDownloadNotPossible_msg: "Safari does not support exporting emails or saving attachments to disk. Still some file types can be displayed in the browser. Please use one of the following browsers otherwise:",
	clickToSave_label: "Click to save",
	confidential_action: "Confidential",
	nonConfidential_action: "Not confidential",
    confidentialStatus_msg: "This message is sent end-to-end encrypted.",
    nonConfidentialStatus_msg: "This message is not sent end-to-end encrypted.",
	noMails_msg: "There are no emails in this list.",
	noMail_msg: "No email selected.",
	addMobileNumber_msg: "Add an additional mobile phone number.",
	setPresharedPassword_action: "Set agreed password",
	presharedPassword_label: "Agreed password",
	mobileNumberNotValid_msg: "Invalid format.",
	fromAddressBook_label: "From address book: ",
	presharedPasswordNotStrongEnough_msg: "At least one of the entered passwords is not secure enough. Send the email anyway?",
    showAttachment_label: "Display attachment",
	saveDownloadNotPossibleSafariDesktop_msg: "Safari does not support saving attachments to disk. Still some file types can be displayed in the browser by clicking the link above. Please use Mozilla Firefox or Google Chrome otherwise.",
	saveDownloadNotPossibleSafariMobile_msg: "Safari does not support saving attachments to disk. Still some file types can be displayed in the browser by clicking the link above. Please use a desktop browser otherwise.",
	saveDownloadNotPossibleAndroid_msg: "The native Android browser does not support saving attachments to disk. Still some file types can be displayed in the browser by clicking the link above. Please install Google Chrome or Opera otherwise.",
	saveDownloadNotPossibleIe_msg: "The mobile Internet Explorer does not support saving or displaying attachments. Please use a desktop browser for these features.",
	addAttachmentNotPossibleIe_msg: "The mobile Internet Explorer does not support adding attachments to emails. Please use a desktop browser for this feature.",
    removeRecipient_alt: "Remove recipient",
	couldNotAttachFile_msg: "The file could not be loaded.",
    changeNotificationMailLanguage_msg: "Language of notification email:",
    reallySubmitContent_msg: "Do you really want to send the entered data to an external site?",
    search_title: "Search",
	loadMoreMails_action: "Load more emails",
    confirmDeleteTrash_msg: "Do you really want to delete all mails from the trash?",

    //invitation
    invitationMailSubject_msg: "Your invitation to Tutanota Free",
    invitationMailBody_msg: "Hello!<br><br>I would like to invite you to Tutanota. Tutanota is a free email service that encrypts emails automatically. This way others cannot eavesdrop on us and we can communicate confidentially.<br><br>Please take a minute to sign up:<br><a href=\"https://app.tutanota.de/#register\">https://app.tutanota.de/#register</a><br><br>I am looking forward to receiving your first encrypted email!<br><br>Cheers,<br>$",

	// contact
	discardContact_msg: "Discard new contact?",
	discardContactChanges_msg: "Discard contact modifications?",
	discardContactChangesFor_msg: "Discard contact modifications for $?",
	deleteContact_msg: "Are you sure you want to delete this contact?",
	private_label: "Private",
	mobile_label: "Mobile",
	fax_label: "Fax",
	work_label: "Work",
	other_label: "Other",
	custom_label: "Custom",
	twitter_label: "Twitter",
	facebook_label: "Facebook",
	xing_label: "Xing",
	linkedin_label: "Linked in",
	email_label: "Email",
	phone_label: "Phone",
	address_label: "Address",
	social_label: "Social",
	comment_label: "Comment",
	birthday_alt: "Birthday",
	contactImage_alt: "Picture",
	removePhoneNumber_alt: "Remove phone number",
	removeMailAddress_alt: "Delete this email address",
	removeAddress_alt: "Delete this address",
	removeSocial_alt: "Delete this social id",
	sendMail_alt: "Send email to this address",
	callNumber_alt: "Call this number",
	showAddress_alt: "Show this address in google maps",
	openSocial_alt: "Open this social account",
	firstName_placeholder: "First name",
	lastName_placeholder: "Last name",
	birthdayWithFormat_placeholder: "Birthday (dd.mm.yyyy)",
	company_placeholder: "Company",
	title_placeholder: "Title",
	noContacts_msg: "There are no contacts in this list.",
	noContact_msg: "No contact selected.",
	passwordsHeading_label: "Passwords:",
	presharedPasswordHeading_label: "Agreed:",
	autoTransmitPasswordHeading_label: "Text message:",
	showPassword_alt: "Keep button pressed to show the password.",

	// settings
	accountSettings_action: "Account",
	securitySettings_action: "Security",
	changePasswordSettings_action: "Change password",
	adminUserList_action: "User management",
	adminUserAdd_action: "Add user",
	action_label: "Action",
	edit_label: "Edit",
	editUser_label: "Edit user",
	save_msg: "Saving data ...",
    saved_msg: "Saved successfully!",
	state_label: "State",
	create_action: "Create",
    createActionSuccess_msg: "All accounts have been created successfully.",
    createActionFailed_msg: "Failed to create an account. Please try again later.",
    createActionStatus_msg: "Creating users... Finished ${index} of ${count} accounts.",
	import_action: "Import",
	importCsv_label: "Import CSV data",
	importCsvInvalid_msg: "The CSV data is invalid (line $).",
	successfullyCreatedUsers_msg: "The following users have been created successfully. Please note down the passwords carefully and provide them to the users.",
    deleted_label: "Deleted",
    created_label: "Created",
	addinInfoText_msg: "Download the Outlook Addin for Tutanota Starter here. Updates are automatically installed when Outlook starts.",

	// account settings
	accountType_label: "Account type",
	mailName_label: "Sender name",
	mailNameInfo_msg: "This name is shown to the recipients of your emails.",

	// security settings
	lastSuccessfulLogin_label: "Last successful login",
	lastSuccessfulLoginInfo_msg: "The time of your last successful login before the current one.",
	failedLogins_label: "Failed logins",
	failedLoginsInfo_msg: "The number of failed login attempts since your last successful login.",

	// change password
	passwordValid_msg: "Password ok.",
	oldPassword_label: "Old password",
	oldPasswordNeutral_msg: "Please enter your old password.",
	oldPasswordInvalid_msg: "Incorrect password.",
	newPassword_label: "New password",
	securePasswords_link: "https://en.wikipedia.org/wiki/Password_strength#Guidelines_for_strong_passwords",
	password1Neutral_msg: "Please enter a password.",
	password1InvalidSame_msg: "The new password is the same as the old one.",
	password1InvalidUnsecure_msg: "Password is not secure enough.",
    password1InvalidTooShort_msg: "Password is too short.",
	password2Neutral_msg: "Please confirm your password here.",
	password2Invalid_msg: "Confirmed password is different.",
	verificationCode_msg: "You will receive the verification code via text message.",
	code_label: "Verification code",
	pwChangeValid_msg: "Password was changed.",
	pwChangeInvalidTooManyVerifyAttempts_msg: "Number of allowed attempts exceeded. Please try again later.",
	pwChangeInvalidTooManyChangeAttempts_msg: "Your password was changed too often. Please try again later.",
	pwChangeButtonSendCode_action: "Send code",
	pwChangeButtonChangePw_action: "Change password",
	serverNotReachable_msg: "Could not reach server, looks like you are offline. Please try again later.",
    outdatedClient_msg: "Please update Tutanota. The currently installed version is too old and not supported any longer.",
    unknownError_msg: "An unexpected error occured. Please try again later.",
	passwordNotChanged_msg: "The password was not changed.",
    passwordResetFailed_msg: "An error occurred. The password was not changed.",
	notePassword_msg: "Please note down the password carefully and provide it to the user.",
    changePasswordNotSupported_msg: "For security reasons password change is not supported on mobile devices.",

	// general
	emptyString_msg: "\u2008", // an empty string or normal whitespace makes a label collapse, so enter this invisible character
	save_action: "Save",
	dismiss_action: "Cancel",
	cancel_action: "Cancel",
	edit_action: "Edit",
	delete_action: "Delete",
	undelete_action: "Restore",
    finalDelete_action: "Delete",
	print_action: "Print",
	back_action: "Back",
	ok_action: "Ok",
	monthNames_label: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
	weekDays_label: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
	yesterday_label: "yesterday",
	busy_alt: "Busy",
	close_alt: "Close",
	german_alt: "Deutsch",
	english_alt: "English",
	check_msg: "Checking...",
	add_action: "Add", // also used by outlook addin
	remove_action: "Remove", // also used by outlook addin
	notFound404_msg: "Sorry, but the page you are looking for has not been found. Try checking the URL for errors and hit the refresh button of your browser.",
    loading_msg: "Loading...",
    show_action: "Show",
    applicationUpdate_label: "Loading Tutanota...",
    leavePageConfirmation_msg: "Do you really want to leave Tutanota?",
    loadMore_action: "Load more",

	// code verification
	codeNeutralEnterCode_msg: "Please enter the verification code.",
	codeValid_msg: "Code format ok.",
	codeInvalid_msg: "Incorrect code. Please check again.",

	// external login
	receiveMsg_label: "Receive message",
	invalidLink_msg: "Sorry, this link is not valid.",
	expiredLink_msg: "Sorry, this link is not valid anymore. You should have received a new notification email with the currently valid link. Previous links are deactivated for security reasons.",
	sendSms_action: "Send text message",
	smsError_msg: "Could not send text message.",
	smsSent_msg: "The text message should arrive in the next 60s.",
	smsResent_msg: "If no text message has arrived you can resend it now.",
	smsSentOften_msg: "Too many sent text messages. Please ask the sender of the message to resend it.",
	invalidPassword_msg: "Invalid password. Please check it again.",
	showMail_action: "Show mailbox",
	chooseNumber_msg: "Please click on one of the \"Send SMS\" buttons below. The Tutanota password for your mailbox will be sent to the given number (maximum of three text messages).",
	clickNumber_msg: "Please click on the \"Send SMS\" button below. The Tutanota password for your mailbox will be sent to the given number (maximum of three text messages).",
	storePassword_action: "Store password in browser",
	enterPresharedPassword_msg: "Please enter the password which you have agreed upon with the sender.",
	sendingSms_msg: "Sending SMS...",
	onlyPrivateComputer_msg: "Only choose this option if you are using a private computer. Otherwise the password is requested with each access.",
	loadingMail_msg: "Loading mailbox...",
	enterSmsPassword_msg: "Please enter the password that has been transmitted via text message here or click on the link within the text message.",

	// login
	welcome_msg: "Login",
	afterRegistration_msg: "Congratulations and welcome aboard! You are now a member of the Tutanota family. Login - and enjoy!",
	loginFailedOften_msg: "Too many failed login attempts. Please try again later.",
	loginFailed_msg: "Invalid login credentials. Please try again.",
	login_action: "Log in",
	login_msg: "Logging in.",
	mailAddress_label: "Email address",
	socialMedia_label: "If you like us, like us:",

	// header
	logo_alt: "Tutanota logo",
	featureNotAvailable_msg: "This feature will be available in 2014!",
	new_label: "New",
	emails_label: "Emails",
	emails_alt: "Emails",
	newMail_alt: "New Email",
	contacts_label: "Contacts",
	contacts_alt: "Contacts",
	newContact_alt: "New Contact",
	newFolder_alt: "New Folder",
	files_alt: "Files",
	files_label: "Files",
	calendar_label: "Calendar",
	calendar_alt: "Calendar",
	tasks_label: "Tasks",
	tasks_alt: "Tasks",
	feedback_label: "Feedback",
	feedback_alt: "Feedback",
	logout_label: "Logout",
	logout_alt: "Logout",
	settings_label: "Settings",
	settings_alt: "Settings",
    register_label: "Register",
    register_alt: "Register",
    invite_label: "Invite",
    invite_alt: "Invite",
    more_label: "More",
    dots_label: "...",

    //admin
    logs_label: "logs",
    db_label: "db",
    monitor_label: "monitor",
    config_label: "config",
    customers_label: "customers",

	// not supported
	for_label: "for",
	oldBrowser_msg: "Oh! We are sorry. Unfortunately, you are using an outdated browser. Please upgrade to the latest version of one of the following browsers:",
	unsupportedBrowser_msg: "Oh! We are sorry. Unfortunately, your browser is not supported. Please use one of the following browsers:",
	browserNoKeygen_msg: "Thank you for choosing Tutanota as your future mail client. During the registration process secure keys are being generated. Unfortunately the key generation needs more performance than your currently used browser or device may provide. Please use one of the following browsers on a desktop or laptop computer:",
	thanks_msg: "Thank you for your cooperation.\nYour team from Tutanota",
	claim_label: "Tutanota - mail. done. right.",

	// registration
    regLinkInvalid_msg: "Sorry, this registration link is not valid.",
    regDisabledFree_msg: "The number of Tutanota Free users is limited and registration currently disabled. Please follow us here, to get notified as soon as registration is possible again:",
    regDisabledStarter_msg: "The number of Tutanota Starter users is limited and registration currently disabled. Please signup here, to get notified as soon as registration is possible again:",
	registrationHeadline_msg: "Tutanota Registration",
    registrationHeadlineBeta_msg: "Tutanota Beta Registration",
    registrationSubHeadline1_msg: "Verify domain (step 1 of 2)",
    registrationSubHeadline2_msg: "Enter registration data (step 2 of 2)",
	company_label: "Company",
	domain_label: "Domain",
    currentMailAddress_label: "Your mail address",
    currentMailAddressAdmin_label: "Mail address of the administrator",
	companyNameNeutral_msg: "Please enter company name.",
	companyNameValid_msg: "Company name ok.",
	verifyingCode_msg: "Verifying code. Please wait.",
	sendingSms_alt: "Sending SMS. Please wait.",
	creatingAccount_alt: "Creating account. Please wait.",
	domainInfo_msg: "Please confirm, that you are allowed to administer this domain.",
	loginNameInfo_msg: "Your name.",
    loginNameInfoAdmin_msg: "Optional: the user's name.",
    loginNameInfoFree_msg: "Optional: This name is shown to recipients of your emails.",
	mobileNumberInfo_msg: "Please include a '+' and your <a href=\"https://en.wikipedia.org/wiki/List_of_mobile_phone_codes_by_country\" target=\"_blank\">country code</a>, .e.g +4917012345678. Your mobile phone number is needed to authorize you when you want to change your password.",
	mobileNumberNeutral_msg: "Please enter your mobile phone number.",
	mobileNumberValid_msg: "Mobile phone number looks ok.",
	mobileNumberInvalid_msg: "Mobile phone number is not valid.",
    mobileNumberNoCountryCode_msg: "Country code is missing, e.g. +49 for Germany.",
    currentMailAddressInfo_msg: "This address will be used for verifying that you are the owner or administrator of this domain.\nHint: Use a postmaster@<your_domain> or hostmaster@<your_domain> address to be able to register immediately (automatic verification). A manual verification is needed for all other addresses, which may take up to one work day.",
	mailAddressInfo_msg: "This will be your new mail address. Register with a unique name. First come, first serve. At least four letters required.",
    mailAddressInfoBusiness_msg: "This is your email address.",
    mailAddressInfoAdmin_msg: "The user's mail address.",
	mailAddressNeutral_msg: "Please enter mail address.",
    mailAddressValid_msg: "Mail address is valid.",
	mailAddressInvalid_msg: "Mail address is not valid.",
	mailAddressAvailable_msg: "Email address is available.",
	mailAddressNA_msg: "Email address is not available.",
    mailAddressDelay_msg: "Too many requests, please try again later.",
	mailAddressBusy_msg: "Verifying email address...",
	pwStrength_title: "This shows the security level of your entered password.",
	goodPassphrase_action: "How to find a good password?",
    passwordImportance_msg: "Please store this password in a secure place. We are not able to restore your password or to reset your account because all of your data is end-to-end encrypted.",
    termsAndConditionsStarter_label: "I have read and agree to the <a href=\"https://tutanota.de/#!termsstarter\" target=\"_blank\" data-bind=\"tabindex=\"-1\">general terms and conditions</a> and the <a href=\"https://tutanota.de/#!privacy\" target=\"_blank\" data-bind=\"tabindex=\"-1\">privacy policy</a>.",
    termsAndConditionsFree_label: "I have read and agree to the <a href=\"https://tutanota.de/#!termsfree\" target=\"_blank\" data-bind=\"tabindex=\"-1\">general terms and conditions</a> and the <a href=\"https://tutanota.de/#!privacy\" target=\"_blank\" data-bind=\"tabindex=\"-1\">privacy policy</a>.",
    join_action: "Join",
	joinNeutral_msg: "Join to receive your personal verification code via SMS for verifying your mobile phone number.",
	joinRunning_msg: "A SMS is being sent...",
	joinFailure_msg: "Sorry, we could not send the SMS. Please try again later.",
    joinAccountLimitReached_msg: "Sorry, we could not send the SMS. The account limit is reached.",
    verifyDomain_action: "Verify domain",
	verifyDomainNeutral_msg: "Send email to verify domain",
	verifyDomainRunning_msg: "An email is being sent for verifying your domain...",
	verifyDomainMailSent_msg: "A short email has been sent to \"$1\" for verifying that you are the owner of \"$2\".\n\nJust click on the link within the received email and you will be able to finish your Tutanota registration within a few minutes.",
	verifyDomainStaffInformed_msg: "Our sales team has been informed about your interest in Tutanota Starter and and is going to verify your domain \"$2\".\n\nThis manual verification step usually takes a few hours. You will be informed by email to \"$1\" as soon as the verification process is done.",
	codeInputInfo_msg: "The code was sent to $.",
	createAccount_action: "Create account",
	createAccountRunning_msg: "Account is being created...",
	createAccountTooManyAttempts_msg: "Too many wrong attempts. Please try again later.",
    createAccountTooManyAccountsError_msg: "Sorry, but the maximum number of accounts is reached.",
	createAccountInfo_msg: "Depending on your computer's individual performance it may take some minutes to generate your secure keys.",
    createAccountInfoMobile_msg: "On mobile devices it may take several minutes to generate your secure keys. If it takes too long, please use a desktop computer for registration.",
	name_label: "Name",
    nameAdmin_label: "Name of the administrator",
	mobileNumber_label: "Mobile phone number",
	desiredAddress_label: "Desired email address",
	password_label: 'Password',
	repeatedPassword_label: 'Repeat password',
	registrationCodeInput_label: "Verification code",
	progress_msg: "Progress",
	terms_label: "Confirmation",
	termsAcceptedNeutral_msg: "Please accept the terms & conditions.",

	// feedback
	errorReport_label: "Oh no!",
    errorReportDescription_msg: "An unexpected error occured. Please tell us what happened and we will fix the problem as soon as possible.",
    screenshot_label: "Attach screenshot",
    feedbackInfo_msg: "The message and your browser identifier are sent encrypted to support@tutao.de.",
    feedbackErrorInfo_msg: "The message, error details and your browser identifier are sent encrypted to support@tutao.de.",
    faq_msg: "If you have a question about Tutanota, please check the <a target=\"_blank\" href=\"https://tutanota.de/#!faq\">FAQ</a> first.",

	// outlook
	tutanotaStarter_label: "Tutanota Starter for Microsoft Outlook",
	version_label: "Version:",
	tutanotaWebClientColon_label: "Tutanota Webapp:",
	tutanotaWebClient_label: "Tutanota Webapp",
	help_label: "Get help:",
	sendLogFile_action: "Send log file via email",
	info_label: "Info",
	changePassword_label: "Change password",
	account_label: "User",
	selectAddress_label: "Please select email address",
	passwordNeutral_msg: "Your Tutanota password.",
	savePassword_label: "Remember",
	savePassword_msg: "Store the password and do not ask me again for it.",
	confidentialDefault_label: "Confidential default",
	confidentialDefault_msg: "Send new messages confidentially by default.",
	noConnection_msg: "You are offline. A connection to Tutanota could not be established.",
	loginAction_msg: "You will only receive secure Tutanota emails after logging in.",
	presharedPasswordAndStrength_msg: "Password strength:",
	confidentiality_label: "Confidentiality",
	confidentialityOffline_msg: "You are offline and this message will not be sent confidentially. Click to send a confidential message.",
	confidentialityDisabled_msg: "This message will not be sent confidentially. Click to send a confidential message.",
	confidentialityEnabled_msg: "This message will be sent confidentially.",
	localMailBegin_msg: "This message has been sent confidentially with <a href=\"http://tutanota.com\">Tutanota</a> to the following recipients:",
	technicalError_msg: "A technical error occured. Please try again later. Inform your administrator if this error occurs again.",
	invalidSwVersion_msg: "Your Tutanota addin has to be updated. When you restart Outlook the new version will automatically be downloaded and installed.",
	accountDeactivated_msg: "Unfortunately, your Tutanota account was deactivated. Please contact your administrator.",
	sending_msg: 'Your message is being encrypted and sent.',
	sendingFailed_msg: 'Could not send the message. Please try again later.',
	savingFailed_msg: 'The message has been sent successfully but could not be stored into your sent messages folder.',
	outlookVersionNotSupported_msg: 'Unfortunately, Tutanota does not support this version of Outlook. Please use Oulook 2010 or Outlook 2013.',
	invalidAttachment_msg: "This email can not be sent via Tutanota because it contains an unsupported attachment.",
	showInAddressBook_alt: "Edit contact",
	testPhaseExpired_msg: "The free testing phase has expired and the sending of confidential emails has been deactivated. Please contact your administrator.",
	autoTransmitPassword_label: "Automatic passwort exchange via text message",
	setMobileNumber_msg: "Please enter mobile phone number.",
	mobileNumberValidFormat_msg: "Format ok.",
	invalidPasswordChannel_msg: "Please enter a valid mobile phone number or a strong password for the following recipient: ",
	passwortChannelColumnHeading_label: "Tutanota",
	passwordChannelColumnInfoInternal_msg: "This message is being encrypted and sent confidentially via Tutanota. All recipients use Tutanota so you do not need to exchange any passwords.",
	passwordChannelColumnInfoExternal_msg: "This message is being encrypted and sent confidentially via Tutanota. Please enter a mobile phone number or an agreed password for each external recipient.",
	passwordChannelColumnInfoMixed_msg: "This message is being encrypted and sent confidentially via Tutanota. Please enter a mobile phone number or an agreed password only for the external recipients listed below.",
	messageNotStored_msg: "A confidential email has been received with Tutanota but could not be stored on your mail server. Would you like to send the log files for analysis to Tutao GmbH?",
	errorNotification_label: "Error notification",
    notificationMailSignature_label:  "Signature",
    notificationMailSignatureNone_msg:  "<none>",
	notificationMailSignature_msg: "This signature will be used for all notification emails to external recipients.",
    notificationMailSignatureSubject_msg: "Confidential email from $1",
    notificationMailSignatureMessage_msg: "<p style=\"font-family:'Calibri',sans-serif\">Hello,</p><p style=\"font-family:'Calibri',sans-serif\">I have sent a confidential email to you. For that I am using <a href='https://tutanota.de/#!info'>Tutanota</a>, the reviewed and certified service from Germany for encrypted emails. You can read this email - and all already exchanged ones - by simply clicking the following link:</p><p style=\"font-family:'Calibri',sans-serif\"><a href='$1'>Show email</a></p><p style=\"font-family:'Calibri',sans-serif\">This email was automatically generated for sending the link. The link stays valid until you receive a new confidential email from me.</p><p style=\"font-family:'Calibri',sans-serif\">Kind regards<br/>$2</p>",
    signatureConfigFailure_msg: "There is no valid email signature configuration for notification emails to external recipients. Would you like to send the notification email without a signature?",
    unsupportedMailFeature_msg: "You have selected a read receipt, voting options or a deferred delivery time. Unfortunately, these functions are not yet supported by Tutanota. Would you like to send the email anyway?"
};

tutao.tutanota.ctrl.LanguageViewModel.de = {
	// mail
	deleteMail_msg:	"Neue E-Mail verwerfen ohne zu speichern?",
	tooBigAttachment_msg: "Die folgenden Dateien konnten nicht angehängt werden, da sie größer als 25 MB sind: ",
	received_action: "Empfangen",
	receivedMail_alt: "Empfangene E-Mail",
	receivedMails_alt: "Empfangene E-Mails",
	sent_action: "Gesendet",
	sentMail_alt: "Gesendete E-Mail",
	sentMails_alt: "Gesendete E-Mails",
	trash_action: "Papierkorb",
	trashedMail_alt: "Gelöschte E-Mail",
	trashedMails_alt: "Gelöschte E-Mails",
	mailWithAttachment_alt: "E-Mail mit Anhang",
	meNominative_label: "Ich",
	meDativ_label: "Mir",
	meAccusative_label: "Mich",
	from_label: "Von",
	to_label: "An",
	cc_label: "Cc",
	bcc_label: "Bcc",
	ccBcc_label: "B/Cc",
	closedLock_alt: 'Geschlossenes Schloss',
	openedLock_alt: 'Offenes Schloss',
	attachFiles_action: "Dateien anhängen",
	removeAttachment_alt: "Anhang entfernen",
	passwordTransmission_label: "Passwortübertragung",
	atLeastOneMobileNumber_label: "Für jeden externen Empfänger ist mindestens eine deutsche Mobilfunknummer oder ein vereinbartes Passwort notwendig.",
    preSharedPasswordNeeded_label: "Bitte geben sie für jeden externen Empfänger ein vereinbartes Passwort an.",
    autoTransmitPasswordDeactivated_label: "Die Passwortübertragung per SMS wird zur Zeit nicht unterstützt.",
	secureMail_title: 'Die E-Mail wird für alle externen Empfänger verschlüsselt.',
	unsecureMail_title: 'Die E-Mail wird unverschlüsselt an externe Empfänger gesendet.',
	noRecipients_msg: 'Sie müssen mindestens einen Empfänger angeben.',
	invalidRecipients_msg: 'Bitte korrigieren Sie die ungültigen E-Mail-Adressen der Empfänger.',
	noSubject_msg: 'Bitte geben Sie einen Betreff für die E-Mail an.',
	noPasswordChannels_msg: 'Bitte geben Sie eine Mobilfunknummer oder ein vereinbartes Passwort für jeden externen Empfänger an.',
    noPreSharedPassword_msg: 'Bitte geben Sie ein vereinbartes Passwort für jeden externen Empfänger an.',
	invalidPasswordChannels_msg: 'Bitte überprüfen Sie die Mobilfunknummern auf Gültigkeit.',
	maxSizeExceeded_msg: "Die maximale Größe von $ für unsichere Nachrichten an externe Empfänger wurde überschritten.",
	send_action: "Absenden",
	reply_action: "Antworten",
	replyAll_action: "Allen antworten",
	forward_action: "Weiterleiten",
	replyConfidential_action: "Vertraulich antworten",
    export_action: "Exportieren",
    deleteTrash_action: "Leeren",
	by_label: "von",
	date_label: "Datum",
	subject_label: "Betreff",
	showQuotation_action: "+ Details",
	hideQuotation_action: "- Details",
	legacyNoReplyIe_msg: "Dies ist eine alte Version des Internet Explorer und unterstützt nicht das Antworten auf oder das Exportieren von E-Mails. Falls Sie diese Funktionalität benötigen, aktualisieren Sie Ihren Browser oder verwenden Sie einen der folgenden:",
    legacyNoAttachmentsIeMobile_msg: "Internet Explorer auf Windows Phone unterstützt leider nicht das Herunterladen von Anhängen oder das Anhängen von Dateien an E-Mails. Falls Sie diese Funktionalität benötigen, verwenden Sie bitte einen der folgenden Browser:",
    legacyNoReplyAndroid_msg: "Der Android-Browser unterstützt nicht das Antworten auf E-Mails sowie das Abspeichern von Anhängen. Manche Dateitypen können aber im Browser angezeigt werden. Bitte verwenden Sie andernfalls einen der folgenden Browser:",
    legacyDownloadNotPossible_msg: "Leider unterstützt Safari nicht das Exportieren von E-Mails oder das Abspeichern von Anhängen. Manche Dateitypen können aber im Browser angezeigt werden. Bitte verwenden Sie andernfalls einen der folgenden Browser:",
	clickToSave_label: "Klicken zum speichern",
	confidential_action: "Vertraulich",
	nonConfidential_action: "Nicht vertraulich",
    confidentialStatus_msg: "Diese Nachricht wird Ende-zu-Ende verschlüsselt.",
    nonConfidentialStatus_msg: "Diese Nachricht wird nicht Ende-zu-Ende verschlüsselt.",
	noMails_msg: "Keine E-Mails in dieser Liste.",
	noMail_msg: "Keine E-Mail ausgewählt.",
	addMobileNumber_msg: "Zusätzliche Mobilfunknummer eingeben.",
	setPresharedPassword_action: "Vereinbartes Passwort setzen",
	presharedPassword_label: "Vereinbartes Passwort",
	mobileNumberNotValid_msg: "Format ist nicht gültig.",
	fromAddressBook_label: "Aus Adressbuch: ",
	presharedPasswordNotStrongEnough_msg: "Mindestens eines der eingegebenen Passwörter ist nicht sicher genug. Wollen Sie die E-Mail trotzdem senden?",
    showAttachment_label: "Anhang anzeigen",
    saveDownloadNotPossibleSafariDesktop_msg: "Leider unterstützt Safari nicht das Abspeichern von Anhängen. Manche Dateitypen können aber im Browser durch Klicken auf den obigen Link angezeigt werden. Bitte verwenden Sie andernfalls Mozilla Firefox oder Google Chrome.",
    saveDownloadNotPossibleSafariMobile_msg: "Leider unterstützt Safari nicht das Abspeichern von Anhängen. Manche Dateitypen können aber im Browser durch Klicken auf den obigen Link angezeigt werden. Bitte verwenden Sie andernfalls einen Desktop-Browser.",
    saveDownloadNotPossibleAndroid_msg: "Leider unterstützt der Android-Browser nicht das Abspeichern von Anhängen. Manche Dateitypen können aber im Browser durch Klicken auf den obigen Link angezeigt werden. Bitte installieren Sie andernfalls Google Chrome oder Opera.",
    saveDownloadNotPossibleIe_msg: "Leider unterstützt der mobile Internet Explorer nicht das Abspeichern oder Anzeigen von Anhängen. Bitte verwenden Sie dafür einen Desktop-Browser.",
    addAttachmentNotPossibleIe_msg: "Leider unterstützt der mobile Internet Explorer nicht das Anhängen von Dateien an E-Mails. Bitte verwenden Sie dafür einen Desktop-Browser.",
    removeRecipient_alt: "Empfänger entfernen",
    couldNotAttachFile_msg: "Die Datei konnte leider nicht geladen werden.",
    changeNotificationMailLanguage_msg: "Sprache der Benachrichtigungs-E-Mail:",
    reallySubmitContent_msg: "Wollen Sie die eingegebenen Daten wirklich an eine externe Seite senden?",
    search_title: "Suche",
	loadMoreMails_action: "Weitere E-Mails laden",
    confirmDeleteTrash_msg: "Möchtest du wirklich alle E-Mails aus dem Papierkorb löschen?",

    //invitation
    invitationMailSubject_msg: "Einladung zu Tutanota Free",
    invitationMailBody_msg: "Hallo!<br><br>Ich möchte dich gern zu Tutanota einladen. Tutanota ist ein kostenloser E-Mail-Service, mit dem wir automatisch verschlüsselt kommunizieren können. So haben Dritte keine Möglichkeit uns zu belauschen und wir können vertraulich miteinander kommunizieren.<br><br>In einer Minute hast Du Dich hier registriert:<br><a href=\"https://app.tutanota.de/#register\">https://app.tutanota.de/#register</a><br><br>Ich freue mich auf deine erste verschlüsselte E-Mail!<br><br>Liebe Grüße<br>$",

	// contact
	discardContact_msg: "Neuen Kontakt verwerfen?",
	discardContactChanges_msg: "Änderungen an Kontakt verwerfen?",
	discardContactChangesFor_msg: "Änderungen an Kontakt \"$\" verwerfen?",
	deleteContact_msg: "Möchten Sie den Kontakt tatsächlich löschen?",
	private_label: "Privat",
	mobile_label: "Mobil",
	fax_label: "Fax",
	work_label: "Arbeit",
	other_label: "Anderes",
	custom_label: "Eigenes",
	twitter_label: "Twitter",
	facebook_label: "Facebook",
	xing_label: "Xing",
	linkedin_label: "Linked in",
	email_label: "E-Mail",
	phone_label: "Telefon",
	address_label: "Adresse",
	social_label: "Soziale Netzwerke",
	comment_label: "Kommentar",
	birthday_alt: "Geburtstag",
	contactImage_alt: "Foto dieses Kontakts",
	removePhoneNumber_alt: "Telefonnummer löschen",
	removeMailAddress_alt: "E-Mail-Adresse löschen",
	removeAddress_alt: "Adresse löschen",
	removeSocial_alt: "Link auf dieses Profil löschen",
	sendMail_alt: "E-Mail an diese Adresse senden",
	callNumber_alt: "Diese Telefonnummer anrufen",
	showAddress_alt: "Diese Adresse in Google Maps anzeigen",
	openSocial_alt: "Profil des Nutzers öffnen",
	firstName_placeholder: "Vorname",
	lastName_placeholder: "Nachname",
	birthdayWithFormat_placeholder: "Geburtstag (tt.mm.jjjj)",
	company_placeholder: "Firma",
	title_placeholder: "Titel",
	noContacts_msg: "Keine Kontakte in der Liste.",
	noContact_msg: "Kein Kontakt ausgewählt.",
	passwordsHeading_label: "E-Mail-Passwörter:",
	presharedPasswordHeading_label: "Vereinbart:",
	autoTransmitPasswordHeading_label: "SMS:",
	showPassword_alt: "Button gedrückt halten, um das Passwort anzuzeigen.",
	
	// settings
	accountSettings_action: "Account",
	securitySettings_action: "Sicherheit",
	changePasswordSettings_action: "Passwort ändern",
	adminUserList_action: "Benutzerverwaltung",
	adminUserAdd_action: "Benutzer hinzufügen",
	action_label: "Aktion",
	edit_label: "Bearbeiten",
	editUser_label: "Benutzer bearbeiten",
	save_msg: "Die Daten werden gespeichert ...",
	saved_msg: "Die Daten wurden erfolgreich gespeichert.",
	state_label: "Zustand",
	create_action: "Hinzufügen",
	createActionSuccess_msg: "Alle Accounts wurden erfolgreich angelegt.",
    createActionFailed_msg: "Ein Account konnte nicht angelegt werden. Bitte versuchen Sie es später erneut.",
    createActionStatus_msg: "Accounts werden angelegt... Es sind ${index} von ${count} erstellt.",
	import_action: "Importieren",
	importCsv_label: "CSV-Daten importieren",
	importCsvInvalid_msg: "Die CSV-Daten sind ungültig (Zeile $).",
    successfullyCreatedUsers_msg: "Die folgenden Benutzer wurden erfolgreich angelegt. Bitte notieren Sie sich die Passwörter gut und geben Sie sie an die Benutzer weiter.",
    deleted_label: "Gelöscht",
    created_label: "Erstellt",
    addinInfoText_msg: "Hier können Sie das Outlook-Addin für Tutanota Starter herunterladen. Neue Versionen werden automatisch beim Starten von Outlook installiert.",

	// account settings
	accountType_label: "Account-Typ",
	mailName_label: "Absendername",
	mailNameInfo_msg: "Dieser Name wird Empfängern Ihrer E-Mails angezeigt.",
	
	// security settings
	lastSuccessfulLogin_label: "Letzter erfolgreicher Login",
	lastSuccessfulLoginInfo_msg: "Der Zeitpunkt des letzten erfolgreichen Logins vor dem aktuellen Login.",
	failedLogins_label: "Fehlgeschlagene Logins",
	failedLoginsInfo_msg: "Die Anzahl fehlgeschlagener Login-Versuche seit dem letzten erfolgreichen Login.",
	
	// change password
	passwordValid_msg: "Passwort ok.",
	oldPassword_label: "Altes Passwort",
	oldPasswordNeutral_msg: "Bitte altes Passwort eingeben.",
	oldPasswordInvalid_msg: "Passwort nicht korrekt.",
	newPassword_label: "Neues Passwort",
	securePasswords_link: "http://de.wikipedia.org/wiki/Passwortsicherheit#Wahl_sicherer_Passw.C3.B6rter",
	password1Neutral_msg: "Bitte ein Passwort eingeben.",
	password1InvalidSame_msg: "Neues und altes Passwort sind identisch.",
	password1InvalidUnsecure_msg: "Das Passwort ist nicht sicher genug.",
    password1InvalidTooShort_msg: "Das Passwort ist zu kurz.",
	password2Neutral_msg: "Bitte Passwort wiederholen.",
	password2Invalid_msg: "Passwörter sind nicht identisch.",
	verificationCode_msg: "Der Bestätigungscode wird Ihnen per SMS zugesendet.",
	code_label: "Bestätigungscode",
	pwChangeValid_msg: "Passwort wurde geändert.",
	pwChangeInvalidTooManyVerifyAttempts_msg: "Anzahl erlaubter Versuche überschritten. Bitte versuchen Sie es es später erneut.",
	pwChangeInvalidTooManyChangeAttempts_msg: "Das Passwort wurde zu häufig geändert. Bitte versuchen Sie es es später erneut.",
	pwChangeButtonSendCode_action: "Code senden",
	pwChangeButtonChangePw_action: "Passwort ändern",
	serverNotReachable_msg: "Der Server konnte nicht erreicht werden, sie sind offline. Bitte versuchen Sie es es später erneut.",
    outdatedClient_msg: "Bitte aktualisieren Sie Tutanota. Die aktuell installierte Version ist zu alt und wird nicht länger unterstützt.",
    unknownError_msg: "Es ist ein unerwarteter Fehler aufgetreten. Bitte versuchen Sie es später erneut.",
    passwordNotChanged_msg: "Das Passwort ist nicht geändert.",
    passwordResetFailed_msg: "Es ist ein Fehler aufgetreten. Das Passwort wurde nicht geändert.",
    notePassword_msg: "Bitte notieren Sie sich das Passwort gut und geben Sie es an den Benutzer weiter.",
    changePasswordNotSupported_msg: "Aus Sicherheitsgründen wird die Passwortänderung auf mobilen Geräten nicht unterstützt.",

	// general
	emptyString_msg: "\u2008",
	save_action: "Speichern",
	dismiss_action: "Verwerfen",
	cancel_action: "Abbrechen",
	edit_action: "Ändern",
	delete_action: "Löschen",
	undelete_action: "Wiederherstellen",
    finalDelete_action: "Löschen",
	print_action: "Drucken",
	back_action: "Zurück",
	ok_action: "OK",
	monthNames_label: ["Jan", "Feb", "Mär", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
	weekDays_label: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
	yesterday_label: "gestern",
	busy_alt: "Bitte warten...",
	close_alt: "Schließen",
	german_alt: "Deutsch",
	english_alt: "English",
	check_msg: "Überprüfe...",
	add_action: "Hinzufügen",
	remove_action: "Entfernen",
	notFound404_msg: "Leider konnte die von Ihnen aufgerufene Seite nicht gefunden werden. Bitte prüfen Sie die URL nach Fehlern und aktualisieren die aktuelle Seite.",
    loading_msg: "Lade...",
    show_action: "Öffne",
    applicationUpdate_label: "Tutanota wird geladen...",
    leavePageConfirmation_msg: "Wollen Sie Tutanota wirklich schließen?",
    loadMore_action: "Weitere laden",

	// code verification
	codeNeutralEnterCode_msg: "Bitte den Bestätigungscode eingeben.",
	codeValid_msg: "Code-Format ok.",
	codeInvalid_msg: "Der Code ist nicht korrekt, bitte überprüfen Sie ihn erneut.",

	// external login
	receiveMsg_label: "Nachricht empfangen",
	invalidLink_msg: "Leider ist dieser Link ungültig.",
	expiredLink_msg: "Leider ist dieser Link nicht mehr gültig. Sie sollten eine neue Benachrichtigungs-E-Mail mit einem aktuellen Link von diesem Absender bekommen haben. Vorhergehende Links werden aus Sicherheitsgründen deaktiviert.",
	sendSms_action: "Sende SMS",
	smsError_msg: "Die SMS konnte nicht gesendet werden.",
	smsSent_msg: "Die SMS sollte innerhalb von 60s ankommen.",
	smsResent_msg: "Wenn die SMS nicht angekommen ist, dann können Sie diese nun erneut senden.",
	smsSentOften_msg: "Es wurden zu viele SMS versendet. Fragen Sie den Sender der Nachricht, ob er Ihnen diese erneut zukommen lassen kann.",
	invalidPassword_msg: "Das Passwort ist leider ungültig.",
	showMail_action: "Mailbox anzeigen",
	chooseNumber_msg: "Bitte klicken Sie auf einen der \"Sende SMS\"-Buttons. Das Tutanota-Passwort für Ihre Mailbox wird an die angegebene Mobilfunknummer versendet (maximal drei SMS).",
	clickNumber_msg: "Bitte klicken Sie auf den \"Sende SMS\"-Button. Das Tutanota-Passwort für Ihre Mailbox wird an die angegebene Mobilfunknummer versendet (maximal drei SMS).",
	storePassword_action: "Passwort im Browser speichern",
	enterPresharedPassword_msg: "Bitte geben Sie das mit dem Absender vereinbarte Passwort ein.",
	sendingSms_msg: "SMS wird gesendet...",
	onlyPrivateComputer_msg: "Wählen Sie diese Option nur, wenn Sie einen privaten Computer verwenden. Ansonsten wird das Passwort bei jedem Zugriff abgefragt.",
	loadingMail_msg: "Lade Mailbox...",
	enterSmsPassword_msg: "Bitte geben Sie hier das per SMS übertragene Passwort ein oder klicken Sie auf den Link in der SMS.",

	// login
	welcome_msg: "Login",
	afterRegistration_msg: "Herzlich Willkommen und viel Spaß als Mitglied der Tutanota-Familie!",
	loginFailedOften_msg: "Es sind zu viele Login-Versuche fehlgeschlagen. Bitte versuchen Sie es später erneut.",
	loginFailed_msg: "Ungültige E-Mail-Adresse oder Passwort. Bitte versuchen Sie es erneut.",
	login_action: "Anmelden",
	login_msg: 'Sie werden eingeloggt.',
	mailAddress_label: "E-Mail-Adresse",
    socialMedia_label: "Folge uns für Updates:",

	// header
	logo_alt: "Tutanota-Logo",
	featureNotAvailable_msg: "Diese Funktion wird in 2014 verfügbar sein!",
	new_label: "Neu",
	emails_label: "E-Mails",
	emails_alt: "E-Mails",
	newMail_alt: "Neue E-Mail",
	contacts_label: "Kontakte",
	contacts_alt: "Kontakte",
	newContact_alt: "Neuer Kontakt",
	newFolder_alt: "Neuer Ordner",
	files_alt: "Dateien",
	files_label: "Dateien",
	calendar_label: "Kalender",
	calendar_alt: "Kalender",
	tasks_label: "Aufgaben",
	tasks_alt: "Aufgaben",
	feedback_label: "Feedback",
	feedback_alt: "Feedback",
	logout_label: "Abmelden",
	logout_alt: "Abmelden",
	settings_label: "Einstellungen",
	settings_alt: "Einstellungen",
    register_label: "Registrieren",
    register_alt: "Registrieren",
    invite_label: "Einladen",
    invite_alt: "Einladen",
    more_label: "Mehr",
    dots_label: "...",

    //admin
    logs_label: "logs",
    db_label: "db",
    monitor_label: "monitor",
    config_label: "config",
    customers_label: "customers",

	// not supported
	for_label: "für",
	oldBrowser_msg: "Oh, das tut uns leid. Sie verwenden eine veraltete Version Ihres Browsers. Bitte nutzen Sie die aktuelle Version einer der folgenden Browser:",
	unsupportedBrowser_msg: "Oh! Das tut uns leid. Sie verwenden einen nicht unterstützten Browser. Bitte nutzen Sie einen der folgenden Browser:",
	browserNoKeygen_msg: "Lieber Interessent von Tutanota, während der Registrierung werden Schlüssel erzeugt. Die Erzeugung dieser Schlüssel benötigt mehr Rechenleistung als Ihr momentan verwendetes Gerät bereitstellt. Daher registrieren Sie sich bitte am besten auf einem Desktoprechner oder Laptop und verwenden dabei einen der folgenden Browser:",
	thanks_msg: "Vielen Dank für Ihr Verständnis.\nIhr Team von Tutanota",

	// registration
    regLinkInvalid_msg: "Es tut uns leid, dieser Registrierungslink ist nicht gültig.",
    regDisabledFree_msg: "Die Anzahl an Registrierungen für Tutanota Free ist limitiert und im Moment leider nicht möglich. Bitte folge uns hier, um eine Benachrichtigung zu erhalten sobald weitere Registrierungen möglich sind:",
    regDisabledStarter_msg: "Die Anzahl an Registrierungen für Tutanota Starter ist limitiert und im Moment leider nicht möglich. Bitte melden Sie sich hier an, um eine Benachrichtigung zu erhalten sobald weitere Registrierungen möglich sind:",
	claim_label: "Tutanota - einfach. sicher. mailen.",
	registrationHeadline_msg: "Tutanota Registrierung",
    registrationHeadlineBeta_msg: "Tutanota Beta Registrierung",
    registrationSubHeadline1_msg: "Domain-Prüfung (Schritt 1 von 2)",
    registrationSubHeadline2_msg: "Registrierungsdaten eingeben (Schritt 2 von 2)",
	company_label: "Firma",
	domain_label: "Domain",
    currentMailAddress_label: "Ihre E-Mail-Adresse",
    currentMailAddressAdmin_label: "E-Mail-Adresse des Administrators",
	companyNameNeutral_msg: "Bitte Firmennamen eingeben.",
	companyNameValid_msg: "Firmenname ok.",
	verifyingCode_msg: "Der Code wird überprüft. Bitte haben Sie einen Moment Geduld.",
	sendingSms_alt: "SMS wird gesendet. Bitte haben Sie einen Moment Geduld.",
	creatingAccount_alt: "Ihr Account wird angelegt. Bitte haben Sie einen Moment Geduld.",
    domainInfo_msg: "Hiermit bestätigen Sie, dass Sie diese Domain verwalten dürfen.",
	loginNameInfo_msg: "Ihr Vor- und Nachname.",
    loginNameInfoAdmin_msg: "Optional: Der Name des Benutzers.",
    loginNameInfoFree_msg: "Optional: Dieser Name wird Empfängern Ihrer E-Mails angezeigt.",
	mobileNumberInfo_msg: "Bitte mit <a href=\"https://de.wikipedia.org/wiki/L%C3%A4ndervorwahlliste_sortiert_nach_L%C3%A4ndern\" target=\"_blank\">Ländervorwahl</a> eingeben, z.B. +4917012345678. Ihre Mobilfunknummer wird zur Autorisierung benötigt, wenn Sie Ihr Passwort ändern möchten.",
	mobileNumberNeutral_msg: "Bitte Mobilfunknummer eingeben.",
	mobileNumberValid_msg: "Mobilfunknummer ok.",
	mobileNumberInvalid_msg: "Ungültige Mobilfunknummer.",
    mobileNumberNoCountryCode_msg: "Ländervorwahl fehlt, z.B. +49 für Deutschland.",
    currentMailAddressInfo_msg: "Diese E-Mail-Adresse wird genutzt, um zu prüfen, dass Ihnen die Domain gehört oder Sie diese verwalten dürfen.\nTipp: Benutzen Sie eine der Adressen postmaster@<Ihre_Domain> oder hostmaster@<Ihre_Domain>, um die Registrierung sofort fortzusetzen (automatische Prüfung). Eine manuelle Prüfung wird für alle anderen Adressen durchgeführt und kann bis zu einem Werktag benötigen.",
	mailAddressInfo_msg: "Dies wird Ihre neue E-Mail-Adresse. Es werden mindestens vier Buchstaben benötigt.",
    mailAddressInfoBusiness_msg: "Ihre vorhandene E-Mail-Adresse.",
    mailAddressInfoAdmin_msg: "Die E-Mail-Adresse des Benutzers.",
	mailAddressNeutral_msg: "Bitte E-Mail-Adresse eingeben.",
    mailAddressValid_msg: "Die E-Mail-Adresse ist gültig.",
	mailAddressInvalid_msg: "Ungültige E-Mail-Adresse.",
	mailAddressAvailable_msg: "E-Mail-Adresse ist verfügbar.",
	mailAddressNA_msg: "E-Mail-Adresse ist bereits vergeben.",
    mailAddressDelay_msg: "Zu viele Anfragen, bitte später erneut versuchen.",
	mailAddressBusy_msg: "E-Mail-Adresse wird überprüft...",
	pwStrength_title: "Zeigt den Sicherheitsgrad des verwendeten Passworts an",
	goodPassphrase_action: "Wie finde ich ein gutes Passwort?",
    passwordImportance_msg: "Bitte bewahren Sie dieses Passwort an einem sicheren Ort auf. Wir können das Passwort nicht wiederherstellen oder den Account zurücksetzen, da Ihre Daten Ende-zu-Ende verschlüsselt gespeichert werden.",
	termsAndConditionsStarter_label: "Ich habe die <a href=\"https://tutanota.de/#!termsstarter\" target=\"_blank\" data-bind=\"tabindex=\"-1\">Allgemeinen Geschäftsbedingungen</a> und die <a href=\"https://tutanota.de/#!privacy\" target=\"_blank\" data-bind=\"tabindex=\"-1\">Datenschutzerklärung</a> gelesen und erkenne diese an.",
    termsAndConditionsFree_label: "Ich habe die <a href=\"https://tutanota.de/#!termsfree\" target=\"_blank\" data-bind=\"tabindex=\"-1\">Allgemeinen Geschäftsbedingungen</a> und die <a href=\"https://tutanota.de/#!privacy\" target=\"_blank\" data-bind=\"tabindex=\"-1\">Datenschutzerklärung</a> gelesen und erkenne diese an.",
	join_action: "Fortfahren",
	joinNeutral_msg: "Sie erhalten anschließend per SMS einen Bestätigungscode für die angegebene Mobilfunknummer.",
	joinRunning_msg: "Die SMS wird gesendet...",
	joinFailure_msg: "Leider konnte die SMS nicht gesendet werden. Bitte versuchen Sie es später erneut.",
    joinAccountLimitReached_msg: "Leider konnte die SMS nicht gesendet werden. Die maximale Anzahl Accounts ist erreicht.",
    verifyDomain_action: "Domain prüfen",
    verifyDomainNeutral_msg: "E-Mail zur Prüfung der Domain zusenden.",
    verifyDomainRunning_msg: "Die E-Mail zur Prüfung Ihrer Domain wird Ihnen zugesendet...",
    verifyDomainMailSent_msg: "Eine kurze E-Mail wurde an \"$1\" gesendet, um zu prüfen, dass Sie der Besitzer der Domain \"$2\" sind.\n\nDie E-Mail enthält einen Bestätigungslink. Klicken Sie auf diesen, um die Registrierung innerhalb von wenigen Minuten abzuschließen.",
    verifyDomainStaffInformed_msg: "Unser Vertriebsteam wurde über Ihr Interesse informiert und wird Ihre Domain \"$2\" innerhalb der nächsten Stunden prüfen.\n\nSobald die Prüfung abgeschlossen ist, werden wir Sie umgehend per E-Mail an \"$1\" informieren.",
	codeInputInfo_msg: "Der Code wurde gesendet an $.",
	createAccount_action: "Account anlegen",
	createAccountRunning_msg: "Account wird erstellt...",
	createAccountTooManyAttempts_msg: "Zu viele falsche Versuche. Bitte versuchen Sie es später erneut.",
    createAccountTooManyAccountsError_msg: "Leider ist die maximale Anzahl Accounts erreicht.",
	createAccountInfo_msg: "Abhängig von der Geschwindigkeit Ihres Computers kann es einige Minuten dauern, bis Ihre sicheren Schlüssel erzeugt werden.",
    createAccountInfoMobile_msg: "Auf mobilen Geräten kann es mehrere Minuten dauern bis Ihre sicheren Schlüssel erzeugt sind. Falls es Ihnen zu lange dauert, bitten wir Sie für die Registrierung einen Desktoprechner zu verwenden.",
	name_label: "Name",
    nameAdmin_label: "Name des Administrators",
	mobileNumber_label: "Mobilfunknummer",
	desiredAddress_label: "Gewünschte E-Mail-Adresse",
	password_label: 'Passwort',
	repeatedPassword_label: 'Passwort wiederholen',
	registrationCodeInput_label: "Bestätigungscode",
	progress_msg: "Fortschritt",
	terms_label: "Bestätigung",
	termsAcceptedNeutral_msg: "Bitte akzeptieren Sie die AGB.",

	// feedback
	errorReport_label: "Oh nein!",
    errorReportDescription_msg: "Ein unerwarteter Fehler ist aufgetreten. Bitte beschreiben Sie die von Ihnen ausgeführten Schritte und wir werden das Problem so schnell wie möglich beheben.",
	screenshot_label: "Screenshot mitsenden",
    feedbackInfo_msg: "Die Nachricht wird zusammen mit der Browser-Kennung verschlüsselt an support@tutao.de gesendet.",
    feedbackErrorInfo_msg: "Die Nachricht wird zusammen mit der Browser-Kennung und Fehlerdetails verschlüsselt an support@tutao.de gesendet.",
    faq_msg: "Wenn du eine Frage zu Tutanota hast, schau doch bitte zuerst in den <a target=\"_blank\" href=\"https://tutanota.de/#!faq\">FAQ</a> nach.",

	// outlook
	tutanotaStarter_label: "Tutanota Starter für Microsoft Outlook",
	version_label: "Version:",
	tutanotaWebClientColon_label: "Tutanota Webapp:",
	tutanotaWebClient_label: "Tutanota Webapp",
	help_label: "Hilfe erhalten Sie unter:",
	sendLogFile_action: "Log-Datei per E-Mail senden",
	info_label: "Info",
	changePassword_label: "Passwort ändern",
	account_label: "Benutzer",
	selectAddress_label: "Bitte E-Mail-Adresse auswählen",
	passwordNeutral_msg: "Ihr Tutanota-Passwort.",
	savePassword_label: "Speichern",
	savePassword_msg: "Das Passwort dauerhaft speichern und nicht erneut danach fragen.",
	confidentialDefault_label: "Vertraulich als Standard",
	confidentialDefault_msg: "Neue E-Mails werden standardmäßig vertraulich versendet.",
	noConnection_msg: "Sie sind offline: Es konnte keine Verbindung zu Tutanota hergestellt werden.",
	loginAction_msg: "Nach dem Login können Sie sichere Nachrichten versenden und empfangen.",
	presharedPasswordAndStrength_msg: "Passwortstärke:",
	confidentiality_label: "Vertraulichkeit",
	confidentialityOffline_msg: "Sie sind offline und diese Nachricht wird nicht vertraulich versendet. Klicken Sie, um die Nachricht vertraulich zu senden.",
	confidentialityDisabled_msg: "Diese Nachricht wird nicht vertraulich versendet. Klicken Sie, um die Nachricht vertraulich zu senden.",
	confidentialityEnabled_msg: "Diese Nachricht wird vertraulich versendet.",
	localMailBegin_msg: "Diese Nachricht wurde mit <a href=\"http://tutanota.de\">Tutanota</a> sicher an folgende Empfänger übertragen:",
	technicalError_msg: "Es ist ein technischer Fehler aufgetreten. Bitte versuchen Sie es später noch einmal. Wenden Sie sich an Ihren Administrator, falls der Fehler erneut auftreten sollte.",
	invalidSwVersion_msg: "Ihr Tutanota-Addin muss aktualisiert werden. Wenn Sie Outlook neu starten wird die neue Version automatisch heruntergeladen und installiert.",
	accountDeactivated_msg: "Ihr Tutanota-Account wurde leider deaktiviert. Bitte wenden Sie sich an Ihren Administrator.",
	sending_msg: 'Ihre Nachricht wird verschlüsselt und gesendet.',
	sendingFailed_msg: 'Die Nachricht konnte nicht gesendet werden. Bitte versuchen Sie es später noch einmal.',
	savingFailed_msg: 'Die Nachricht wurde erfolgreich versendet, konnte allerdings nicht in Ihrem Ordner für gesendete Nachrichten gespeichert werden.',
	outlookVersionNotSupported_msg: 'Diese Outlook-Version wird leider nicht von Tutanota unterstützt. Bitte verwenden Sie Outlook 2010 oder Outlook 2013.',
	invalidAttachment_msg: "Diese E-Mail kann leider nicht mit Tutanota gesendet werden, da sie einen nicht unterstützten Anhang enthält.",
	showInAddressBook_alt: "Kontakt bearbeiten",
	testPhaseExpired_msg: "Die kostenfreie Testphase ist abgelaufen, daher ist das Senden von vertraulichen E-Mails deaktiviert worden. Bitte wenden Sie sich an Ihren Administrator.",
	autoTransmitPassword_label: "Automatisches Passwort per SMS",
	setMobileNumber_msg: "Bitte Mobilfunknummer eingeben.",
	mobileNumberValidFormat_msg: "Format ok.",
	invalidPasswordChannel_msg: "Bitte geben Sie eine gültige Mobilfunknummer oder ein ausreichend starkes Passwort für den folgenden Empfänger an: ",
	passwortChannelColumnHeading_label: "Tutanota",
	passwordChannelColumnInfoInternal_msg: "Diese Nachricht wird mit Tutanota verschlüsselt und vertraulich versendet. Da alle Empfänger bei Tutanota registriert sind, ist ein Passwortaustausch nicht notwendig.",
    passwordChannelColumnInfoExternal_msg: "Diese Nachricht wird mit Tutanota verschlüsselt und vertraulich versendet. Bitte geben Sie für jeden externen (nicht bei Tutanota registrierten) Empfänger eine Mobilfunknummer oder ein vereinbartes Passwort an.",
    passwordChannelColumnInfoMixed_msg: "Diese Nachricht wird mit Tutanota verschlüsselt und vertraulich versendet. Bitte geben Sie nur für die unten aufgelisteten externen (nicht bei Tutanota registrierten) Empfänger eine Mobilfunknummer oder ein vereinbartes Passwort an.",
	messageNotStored_msg: "Eine mit Tutanota vertraulich empfangene E-Mail konnte nicht auf Ihrem Mail-Server abgespeichert werden. Wollen Sie die Log-Dateien zur Analyse an die Tutao GmbH senden?",
	errorNotification_label: "Fehlerbenachrichtigung",
    notificationMailSignature_label:  "Signatur",
    notificationMailSignatureNone_msg:  "<keine>",
    notificationMailSignature_msg: "Diese Signatur wird für Benachrichtigungs-E-Mails an externe Empfänger verwendet.",
    notificationMailSignatureSubject_msg: "Vertrauliche Nachricht von $1",
    notificationMailSignatureMessage_msg: "<p style=\"font-family:'Calibri',sans-serif\">Guten Tag,</p><p style=\"font-family:'Calibri',sans-serif\">ich habe Ihnen gerade eine vertrauliche Nachricht gesendet. Daf&uuml;r benutze ich <a href='https://tutanota.de/#!info'>Tutanota</a>, den gepr&uuml;ften und zertifizierten Service aus Deutschland f&uuml;r verschl&uuml;sselte E-Mails. Diese und alle bisher ausgetauschten Nachrichten k&ouml;nnen Sie ganz einfach &uuml;ber den folgenden Link abrufen:</p><p style=\"font-family:'Calibri',sans-serif\"><a href='$1'>Nachricht anzeigen</a></p><p style=\"font-family:'Calibri',sans-serif\">Diese E-Mail wurde für die &Uuml;bermittlung des Links automatisch erzeugt. Der Link bleibt g&uuml;ltig, bis ich Ihnen eine neue vertrauliche Nachricht sende.</p><p style=\"font-family:'Calibri',sans-serif\">Mit freundlichen Gr&uuml;&szlig;en<br/>$2</p>",
    signatureConfigFailure_msg: "Es ist keine gültige E-Mail-Signatur für die Benachrichtigungs-E-Mails an externe Empfänger konfiguriert. Wollen Sie die Benachrichtigungs-E-Mail ohne Signatur senden?",
    unsupportedMailFeature_msg: "Sie haben eine Lesebestätigung, Abstimmungsschaltflächen oder eine verzögerte Übermittlung der E-Mail ausgewählt. Diese Funktionen werden von Tutanota leider noch nicht unterstützt. Wollen Sie die E-Mail trotzdem senden?"
};


"use strict";

tutao.provide('tutao.tutanota.ctrl.LegacyDownloadViewModel');

/**
 * The ViewModel for the safari legacy download.
 * @constructor
 */
tutao.tutanota.ctrl.LegacyDownloadViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

	this.filename = ko.observable("");
    this.blobUrl = ko.observable("");
    this.textId = ko.observable(null);
	this.dialogVisible = ko.observable(false);
    this._resolve = null;

};

tutao.tutanota.ctrl.LegacyDownloadViewModel.prototype.showDialog = function(filename, blobUrl, textId) {
	this.filename(filename);
    this.blobUrl(blobUrl);
    this.textId(textId);
    this.dialogVisible(true);

    var self = this;
    return new Promise(function(resolve, reject) {
        self._resolve = resolve;
    })
};

tutao.tutanota.ctrl.LegacyDownloadViewModel.prototype.closeDialog = function() {
	this.dialogVisible(false);
    this._resolve();
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.LoginViewModel');

/**
 * The ViewModel for the Login template.
 * @constructor
 */
tutao.tutanota.ctrl.LoginViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

	this.welcomeTextId = ko.observable("welcome_msg");
	this.welcomeText = ko.computed(function() {
		return tutao.locator.languageViewModel.get(this.welcomeTextId());
	}, this, {deferEvaluation: true});

	this.mailAddress = ko.observable("");
	var address = tutao.tutanota.util.LocalStore.load('userMailAddress');
	if (address) {
		this.mailAddress(address);
	}
	this.mailAddressFieldFocused = ko.observable(false);
	this.passphrase = ko.observable("");
	this.passphraseFieldFocused = ko.observable(false);

	var emptyString = "\u2008"; // an empty string or normal whitespace makes the label collapse, so enter this invisible character
	this.loginStatus = ko.observable({ type: "neutral", text: "emptyString_msg" });
	this.loginOngoing = ko.observable(false);

	this.mailAddress.subscribe(function(newValue) {
	    this.loginStatus({ type: "neutral", text: "emptyString_msg" });
	}, this);
	this.passphrase.subscribe(function(newValue) {
	    this.loginStatus({ type: "neutral", text: "emptyString_msg" });
	}, this);
	
	this.loginPossible = ko.computed(function() {
		return (!this.loginOngoing());
	}, this);
};

/**
 * Sets the focus when the view is shown.
 */
tutao.tutanota.ctrl.LoginViewModel.prototype.activate = function() {
	var self = this;
	setTimeout(function() {
		if (self.mailAddress() == "") {
			self.mailAddressFieldFocused(true);
		} else {
			self.passphraseFieldFocused(true);
		}
	}, 0);
};

/**
 * Sets the given mail address as login mail address.
 * @param {string} mailAddress The mail address.
 */
tutao.tutanota.ctrl.LoginViewModel.prototype.setMailAddress = function(mailAddress) {
	this.mailAddress(mailAddress);
};

/**
 * Sets the id of the welcome text that shall be shown (see tutao.tutanota.ctrl.LanguageViewModel).
 * @param {string} id The id of the welcome text.
 */
tutao.tutanota.ctrl.LoginViewModel.prototype.setWelcomeTextId = function(id) {
	this.welcomeTextId(id);
};

/**
 * Logs a user into the system:
 * <ul>
 *   <li>Sets the logged in user on the UserController
 *   <li>Initializes the DBFacade for the user
 *   <li>Switches to the MailView
 * </ul>
 * @return {Promise.<>} Resolves when finished, rejected if failed.
 */
tutao.tutanota.ctrl.LoginViewModel.prototype.login = function() {
	var self = this;
	if (!this.loginPossible()) {
		return;
	}
	this.loginOngoing(true);
	// in private browsing mode in mobile safari local storage is not available and throws an exception
	this.passphraseFieldFocused(false);
	tutao.tutanota.util.LocalStore.store('userMailAddress', this.mailAddress());
	return tutao.locator.userController.loginUser(self.mailAddress(), self.passphrase()).then(function () {
        self.passphrase("");
    }).then(function() {
        return self.postLoginActions();
    }).caught(tutao.AccessBlockedError, function() {
        self.loginStatus({ type: "invalid", text: "loginFailedOften_msg" });
    }).caught(tutao.NotAuthenticatedError, function(exception) {
        self.loginStatus({ type: "invalid", text: "loginFailed_msg" });
    }).caught(tutao.AccessDeactivatedError, function() {
        self.loginStatus({ type: "invalid", text: "loginFailed_msg" });
    }).lastly(function() {
        self.loginOngoing(false);
    });
};

tutao.tutanota.ctrl.LoginViewModel.prototype.postLoginActions = function () {
    var self = this;
    return tutao.locator.mailBoxController.initForUser().then(function() {
        // this should be the user id instead of the name later
        return new Promise(function(resolve, reject) {
            tutao.locator.dao.init("Tutanota_" + self.mailAddress(), resolve);
        });
    }).then(function () {
        return self.loadEntropy();
    }).then(function() {
        // load all contacts to have them available in cache, e.g. for RecipientInfos
        return tutao.locator.contactListViewModel.init();
    }).then(function() {
        tutao.locator.eventBus.connect(false);
        tutao.locator.navigator.mail();
    });
};

/**
 * Loads entropy from the last logout. Fetches missing entropy if none was stored yet and stores it.
 * @return {Promise.<>} Resolves when finished, rejected if failed.
 */
tutao.tutanota.ctrl.LoginViewModel.prototype.loadEntropy = function() {
    var self = this;
    return new Promise(function(resolve, reject) {
        try  {
            var groupEncEntropy = tutao.locator.mailBoxController.getUserProperties().getGroupEncEntropy();
            if (!groupEncEntropy) {
                tutao.locator.entropyCollector.fetchMissingEntropy(function() {
                    self.storeEntropy();
                    resolve();
                });
            } else {
                var entropy = tutao.locator.aesCrypter.decryptBytes(tutao.locator.userController.getUserGroupKey(), groupEncEntropy);
                tutao.locator.entropyCollector.addStaticEntropy(entropy);
                resolve();
            }
        } catch (exception) {
            reject(exception);
        }
    });
};

/**
 * Stores entropy from the randomizer for the next login.
 */
tutao.tutanota.ctrl.LoginViewModel.prototype.storeEntropy = function() {
    var groupEncEntropy = tutao.locator.aesCrypter.encryptBytes(tutao.locator.userController.getUserGroupKey(), tutao.util.EncodingConverter.hexToBase64(tutao.locator.randomizer.generateRandomData(32)));
    tutao.locator.mailBoxController.getUserProperties().setGroupEncEntropy(groupEncEntropy);
    tutao.locator.mailBoxController.getUserProperties().update();
};

tutao.tutanota.ctrl.LoginViewModel.prototype.createAccount = function() {
    tutao.locator.navigator.register();
};
"use strict";

tutao.provide('tutao.tutanota.ctrl.MailBoxController');

/**
 * The MailBoxController is responsible for caching the user's mail list id in
 * order to avoid that for accessing the mail list id the mail box has to be
 * loaded again.
 *
 * @constructor
 */
tutao.tutanota.ctrl.MailBoxController = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	this._mailBox = null;
	this._contactList = null;
	this._fileSystem = null;
	this._shares = null;
    this._properties = null;
};

/**
 * Initializes the MailBoxController for the logged in user. This must be called
 * whenever another user logs in. Loads the user's mail list id, contact list id
 * and file list id.
 * @return {Promise.<>} Resolved when finished, rejected if failed.
 */
tutao.tutanota.ctrl.MailBoxController.prototype.initForUser = function() {
	var self = this;
    return this._loadMailBox().then(function(mailBox) {
        return self.loadTutanotaProperties();
    }).then(function() {
        // external users only have a mailbox
        if (tutao.locator.userController.isExternalUserLoggedIn()) {
            return Promise.resolve();
        } else {
            return Promise.join(
                self._loadFileSystem(),
                self._loadContactList(),
                self._loadShares());
        }
    });
};

/**
 * Loads the mailbox for the logged in user's user group.
 *
 * @return {Promise.<>} Resolved when finished, rejected if failed.
 */
tutao.tutanota.ctrl.MailBoxController.prototype._loadMailBox = function() {
	var self = this;
	var rootId = [tutao.locator.userController.getUserGroupId(), tutao.entity.tutanota.MailBox.ROOT_INSTANCE_ID];
	return tutao.entity.sys.RootInstance.load(rootId).then(function(root) {
        return tutao.entity.tutanota.MailBox.load(root.getReference()).then(function(mailBox) {
            self._mailBox = mailBox;
            return mailBox;
        });
	});
};

/**
 * Loads the contacts list id for the logged in user's user group.
 *
 * @return {Promise.<>} Resolved when finished, rejected if failed.
 */
tutao.tutanota.ctrl.MailBoxController.prototype._loadContactList = function() {
	var self = this;
	var rootId = [tutao.locator.userController.getUserGroupId(), tutao.entity.tutanota.ContactList.ROOT_INSTANCE_ID];
	return tutao.entity.sys.RootInstance.load(rootId).then(function(root) {
        return tutao.entity.tutanota.ContactList.load(root.getReference()).then(function(contactList) {
            self._contactList = contactList;
        });
	});
};

/**
 * Loads the file list id for the logged in user's user group.
 *
 * @return {Promise.<>} Resolved when finished, rejected if failed.
 */
tutao.tutanota.ctrl.MailBoxController.prototype._loadFileSystem = function() {
	var self = this;
	var rootId = [tutao.locator.userController.getUserGroupId(), tutao.entity.tutanota.FileSystem.ROOT_INSTANCE_ID];
	return tutao.entity.sys.RootInstance.load(rootId).then(function(root) {
        return tutao.entity.tutanota.FileSystem.load(root.getReference()).then(function(fileSystem, exception) {
            self._fileSystem = fileSystem;
        });
	});
};

/**
 * Loads the shares instance for the logged in user's user group.
 *
 * @return {Promise.<>} Resolved when finished, rejected if failed.
 */
tutao.tutanota.ctrl.MailBoxController.prototype._loadShares = function() {
	var self = this;
	var rootId = [tutao.locator.userController.getUserGroupId(), tutao.entity.sys.Shares.ROOT_INSTANCE_ID];
	return tutao.entity.sys.RootInstance.load(rootId).then(function(root) {
        return tutao.entity.sys.Shares.load(root.getReference()).then(function(shares) {
            self._shares = shares;
        });
	});
};


/**
 * Loads the TutanotaProperties instance for the logged in user's user group.
 *
 * @return {Promise.<>} Resolved when finished, rejected if failed.
 */
tutao.tutanota.ctrl.MailBoxController.prototype.loadTutanotaProperties = function() {
    var self = this;
    var rootId = [tutao.locator.userController.getUserGroupId(), tutao.entity.tutanota.TutanotaProperties.ROOT_INSTANCE_ID];
    return tutao.entity.sys.RootInstance.load(rootId).then(function(root) {
        return tutao.entity.tutanota.TutanotaProperties.load(root.getReference()).then(function(properties) {
            self._properties = properties;
        });
    });
};

/**
 * Provides the mail box of the logged in user.
 *
 * @return {tutao.entity.tutanota.MailBox} The mail box.
 */
tutao.tutanota.ctrl.MailBoxController.prototype.getUserMailBox = function() {
	return this._mailBox;
};

/**
 * Provides the bucket data for the mailbox of the logged in user.
 *
 * @return {tutao.entity.BucketData} The bucket data.
 */
tutao.tutanota.ctrl.MailBoxController.prototype.getUserMailBoxBucketData = function() {
	return new tutao.entity.BucketData(this._mailBox.getShareBucketId(), tutao.locator.aesCrypter.decryptKey(tutao.locator.userController.getUserGroupKey(), this._mailBox.getSymEncShareBucketKey()));
};

/**
 * Provides the contact list of the logged in user.
 *
 * @return {tutao.entity.tutanota.ContactList} The contact list.
 */
tutao.tutanota.ctrl.MailBoxController.prototype.getUserContactList = function() {
	return this._contactList;
};

/**
 * Provides the bucket data for the contact list of the logged in user.
 *
 * @return {tutao.entity.BucketData} The bucket data.
 */
tutao.tutanota.ctrl.MailBoxController.prototype.getUserContactListBucketData = function() {
	return new tutao.entity.BucketData(this._contactList.getShareBucketId(), tutao.locator.aesCrypter.decryptKey(tutao.locator.userController.getUserGroupKey(), this._contactList.getSymEncShareBucketKey()));
};

/**
 * Provides the file system of the logged in user.
 *
 * @return {tutao.entity.tutanota.FileSystem} The file system.
 */
tutao.tutanota.ctrl.MailBoxController.prototype.getUserFileSystem = function() {
	return this._fileSystem;
};

/**
 * Provides the bucket data for the file system of the logged in user.
 *
 * @return {tutao.entity.BucketData} The bucket data.
 */
tutao.tutanota.ctrl.MailBoxController.prototype.getUserFileSystemBucketData = function() {
	return new tutao.entity.BucketData(this._fileSystem.getShareBucketId(), tutao.locator.aesCrypter.decryptKey(tutao.locator.userController.getUserGroupKey(), this._fileSystem.getSymEncShareBucketKey()));
};

/**
 * Provides the shares instance of the logged in user.
 *
 * @return {tutao.entity.sys.Shares} The shares instance.
 */
tutao.tutanota.ctrl.MailBoxController.prototype.getUserShares = function() {
	return this._shares;
};
/**
 * Provides the TutanotaProperties instance of the logged in user.
 *
 * @return {tutao.entity.tutanota.TutanotaProperties} The TutanotaProperties instance.
 */
tutao.tutanota.ctrl.MailBoxController.prototype.getUserProperties = function() {
    return this._properties;
};
//"use strict";

tutao.provide('tutao.tutanota.ctrl.MailListViewModel');

/**
 * The list of mail headers on the left.
 * The context of all methods is re-bound to this for allowing the ViewModel to be called from event Handlers that might get executed in a different context.
 * @constructor
 * @implements {tutao.tutanota.ctrl.bubbleinput.BubbleHandler}
 */
tutao.tutanota.ctrl.MailListViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

	/* the currently selected dom elements for mails */
	this._selectedDomElements = [];
	/* the mails corresponding to the currently selected dom elements */
	this._selectedMails = [];
	this._lastSelectedMail = {}; // map from tag to last selected mail; stored to make visible when a new mail was sent/canceled

	this._multiSelect = false;

	// the list of mail ids as result of the currently active search query. if null, there is no search query active.
	this.currentSearchResult = null;

	this._currentActiveSystemTag = ko.observable(tutao.tutanota.ctrl.TagListViewModel.RECEIVED_TAG_ID);
	// the list of mail ids as result of the currently active tag filters. if null, there is no filter set. each tag has one entry in the array.
	this.currentTagFilterResult = [];
	this.currentTagFilterResult[tutao.tutanota.ctrl.TagListViewModel.RECEIVED_TAG_ID] = [];
	this.currentTagFilterResult[tutao.tutanota.ctrl.TagListViewModel.SENT_TAG_ID] = [];
	this.currentTagFilterResult[tutao.tutanota.ctrl.TagListViewModel.TRASHED_TAG_ID] = [];

	this.tagToMailAttributeIdMapping = [];
	this.tagToMailAttributeIdMapping[tutao.tutanota.ctrl.TagListViewModel.RECEIVED_TAG_ID] = tutao.entity.tutanota.Mail.prototype.STATE_ATTRIBUTE_ID;
	this.tagToMailAttributeIdMapping[tutao.tutanota.ctrl.TagListViewModel.SENT_TAG_ID] = tutao.entity.tutanota.Mail.prototype.STATE_ATTRIBUTE_ID;
	this.tagToMailAttributeIdMapping[tutao.tutanota.ctrl.TagListViewModel.TRASHED_TAG_ID] = tutao.entity.tutanota.Mail.prototype.TRASHED_ATTRIBUTE_ID;

	this.tagToMailAttributeMapping = [];
	this.tagToMailAttributeMapping[tutao.tutanota.ctrl.TagListViewModel.RECEIVED_TAG_ID] = "_state";
	this.tagToMailAttributeMapping[tutao.tutanota.ctrl.TagListViewModel.SENT_TAG_ID] = "_state";
	this.tagToMailAttributeMapping[tutao.tutanota.ctrl.TagListViewModel.TRASHED_TAG_ID] = "_trashed";

	this.tagToMailAttributeValueMapping = [];
	this.tagToMailAttributeValueMapping[tutao.tutanota.ctrl.TagListViewModel.RECEIVED_TAG_ID] = tutao.entity.tutanota.TutanotaConstants.MAIL_STATE_RECEIVED;
	this.tagToMailAttributeValueMapping[tutao.tutanota.ctrl.TagListViewModel.SENT_TAG_ID] = tutao.entity.tutanota.TutanotaConstants.MAIL_STATE_SENT;
	this.tagToMailAttributeValueMapping[tutao.tutanota.ctrl.TagListViewModel.TRASHED_TAG_ID] = true;   // trashed = true

    this._tagMoreAvailable = [];
    this._tagMoreAvailable[tutao.tutanota.ctrl.TagListViewModel.RECEIVED_TAG_ID] = ko.observable(true);
    this._tagMoreAvailable[tutao.tutanota.ctrl.TagListViewModel.SENT_TAG_ID] = ko.observable(true);
    this._tagMoreAvailable[tutao.tutanota.ctrl.TagListViewModel.TRASHED_TAG_ID] = ko.observable(true);

	// ===== SEARCH ========

	this.bubbleInputViewModel = new tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel(this);

	this.bubbleInputViewModel.bubbles.subscribe(function() {
		//this.search();
	}, this);

	// ===== SEARCH ========

	this.mails = ko.observableArray();

	// the mail id (Array.<string>) of the email that shall be shown when init() is called
	this.mailToShow = null;
    this.loading = ko.observable(false);
    this.deleting = ko.observable(false);

    this.searchBarVisible = ko.observable(false);
    this.searchButtonVisible = ko.observable(false);

    this.actionBarVisible = ko.computed( function() {
        return !this.deleting() && (this.isDeleteTrashButtonVisible() || this.searchButtonVisible());
    },this);

    this.buttons = [];
    this.buttons.push(new tutao.tutanota.ctrl.Button("deleteTrash_action", 10, this._deleteTrash, this.isDeleteTrashButtonVisible, false, "deleteTrashAction"));
    this.buttonBarViewModel = new tutao.tutanota.ctrl.ButtonBarViewModel(this.buttons);
    // this is a workaround:
    // the action bar visibility depends on the visibility of the delete trash button
    // the visible buttons in the button bar view model can only be calculated if the action bar is visible and in the dom
    // to make sure the button bar view model gets notified as late as possible, notify it when the action bar is made visible with a timeout
    this.actionBarVisible.subscribe(function(value) {
        if (value) {
            var self = this;
            setTimeout(function() {
                self.buttonBarViewModel.updateVisibleButtons();
            }, 0);
        }
    }, this);

    this.showSpinner = ko.computed(function () {
        return this.deleting();
    }, this);

    this.moreAvailable = ko.computed(function() {
        return this._tagMoreAvailable[this._currentActiveSystemTag()]();
    }, this);

    this.stepRangeCount = 25;
};


/**
 * Initialize the MailListViewModel:
 * <ul>
 *   <li>Load the Mails to display from the server
 *   <li>register as an observer to the mail list
 * </ul>
 */
tutao.tutanota.ctrl.MailListViewModel.prototype.init = function() {
    var self = this;
    if (tutao.tutanota.util.ClientDetector.isMobileDevice()){
        this.stepRangeCount = 25;
    } else {
        this.stepRangeCount = 200;
    }
    this.searchButtonVisible(tutao.locator.dao.isSupported() && tutao.locator.viewManager.isInternalUserLoggedIn());
    return this.loadMoreMails().then(function() {
        if (tutao.locator.userController.isExternalUserLoggedIn()) {
            if (self.mailToShow) {
                return tutao.entity.tutanota.Mail.load(self.mailToShow).then(function(mail) {
                    self.selectMail(mail);
                });
            } else {
                if (self.mails().length > 0) {
                    self.selectMail(self.mails()[0]);
                }
                return Promise.resolve();
            }
        } else {
            var eventTracker = new tutao.event.PushListEventTracker(tutao.entity.tutanota.Mail, tutao.locator.mailBoxController.getUserMailBox().getMails(), "Mail");
            eventTracker.addObserver(self.updateOnNewMails);
            eventTracker.observeList(tutao.rest.EntityRestInterface.GENERATED_MAX_ID);
            return Promise.resolve();
        }
    });
};


tutao.tutanota.ctrl.MailListViewModel.prototype.loadMoreMails = function() {
    var self = this;

    if (this.loading() || this.deleting()) {
        return Promise.resolve();
    }
    this.loading(true);
    var tagId = self._currentActiveSystemTag();
    var lowestId = tutao.rest.EntityRestInterface.GENERATED_MAX_ID;
    if (this.currentTagFilterResult[tagId].length > 0) {
        lowestId = this.currentTagFilterResult[tagId][this.currentTagFilterResult[tagId].length -1];
    }
    //return Promise.delay(5000).then(function(){
        return self._loadMoreMails(0, lowestId, tagId).lastly(function(){
            self.loading(false);
        });
    //});
};

tutao.tutanota.ctrl.MailListViewModel.prototype._loadMoreMails = function(alreadyLoadedForTagCount, startId, tagId) {
    var self = this;
    return tutao.entity.tutanota.Mail.loadRange(tutao.locator.mailBoxController.getUserMailBox().getMails(), startId, self.stepRangeCount, true).then(function(mails) {
        self._tagMoreAvailable[tagId](mails.length == self.stepRangeCount);
        for (var i = 0; i < mails.length; i++) {
            if (tagId == self._getTagForMail(mails[i])) {
                var elementId = tutao.rest.EntityRestInterface.getElementId(mails[i]);
                self.currentTagFilterResult[tagId].push(elementId);
                alreadyLoadedForTagCount++;
                if (tagId == self._currentActiveSystemTag()) {
					// Do not push elements to observable array to increase performance. ValueHasMutated is called later
                    self.mails().push(mails[i]);
                }
            }
            if (alreadyLoadedForTagCount == self.stepRangeCount) {
                // we may have loaded more mails, but we have already added enough for the current tag list, so stop now
                break;
            }
        }
        if ((alreadyLoadedForTagCount < self.stepRangeCount) && self._tagMoreAvailable[tagId]()) {
            var startId = tutao.rest.EntityRestInterface.getElementId(mails[mails.length-1]);
            return self._loadMoreMails(alreadyLoadedForTagCount, startId, tagId);
        } else {
			// Notify about list changes
            self.mails.valueHasMutated();
            return Promise.resolve();
        }
    });
};


/**
 * Provides the string to show in the mail list of the given mail for the sender/recipient field.
 * @param {tutao.entity.tutanota.Mail} mail The mail.
 * @return {string} The string.
 */
tutao.tutanota.ctrl.MailListViewModel.getListSenderOrRecipientString = function(mail) {
	var label = null;
	if (mail.getState() == tutao.entity.tutanota.TutanotaConstants.MAIL_STATE_SENT) {
		var allRecipients = mail.getToRecipients().concat(mail.getCcRecipients()).concat(mail.getBccRecipients());
		if (allRecipients[0].getAddress() == tutao.locator.userController.getMailAddress()) {
			label = tutao.locator.languageViewModel.get("meNominative_label");
		} else if (allRecipients[0].getName() != "") {
			label = allRecipients[0].getName();
		} else {
			label = allRecipients[0].getAddress();
		}
		if (allRecipients.length > 1) {
			label += ", ...";
		}
	} else if (mail.getState() == tutao.entity.tutanota.TutanotaConstants.MAIL_STATE_RECEIVED) {
		if (mail.getSender().getAddress() == tutao.locator.userController.getMailAddress()) {
			label = tutao.locator.languageViewModel.get("meNominative_label");
		} else if (mail.getSender().getName() != "") {
			label = mail.getSender().getName();
		} else {
			label = mail.getSender().getAddress();
		}
	}
	return label;
};

/**
 * Called when a different tag was activated. Updates the mail list accordingly.
 * @param {number} tagId Id of the changed tag.
 * @return {Promise.<>} Resolved when finished, rejected if failed.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype.systemTagActivated = function(tagId) {
    var self = this;
	this.unselectAll();
	this._currentActiveSystemTag(tagId);
    return this._updateMailList().then(function() {
        tutao.locator.mailView.showDefaultColumns();
        // load more mails if there are not enough shown for this tag
        if (self.moreAvailable() && self.currentTagFilterResult[tagId].length < self.stepRangeCount) {
            return self.loadMoreMails();
        } else {
            return Promise.resolve();
        }
    });
};


tutao.tutanota.ctrl.MailListViewModel.prototype.isDeleteTrashButtonVisible = function() {
     return this._currentActiveSystemTag() == tutao.tutanota.ctrl.TagListViewModel.TRASHED_TAG_ID && this.mails().length > 0;
};


/**
 * Updates the mail list according to the current search and tag filter results.
 * @return {Promise.<>} Resolved when finished, rejected if failed.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype._updateMailList = function() {
	var self = this;

	// collect all id arrays that need to be combined to get the list of mails to show
	var idsToCombine;
	if (this.currentSearchResult == null) {
		idsToCombine = [this.currentTagFilterResult[this._currentActiveSystemTag()]];
	} else {
		idsToCombine = [this.currentTagFilterResult[this._currentActiveSystemTag()], this.currentSearchResult];
	}


	var currentResult = tutao.util.ArrayUtils.getUniqueAndArray(idsToCombine);
	// sort the array by mail id descending
	currentResult.sort(function(a, b) {
		return (tutao.rest.EntityRestInterface.firstBiggerThanSecond(a, b)) ? -1 : 1;
	});
	var loadedMails = [];

	return self._loadMails(currentResult, loadedMails, 0).then(function() {
		self.mails(loadedMails);
		self.selectPreviouslySelectedMail();
	});
};

/**
 * Selects the mail that has been selected before for the current tag.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype.selectPreviouslySelectedMail = function() {
	var lastSelected = this.getLastSelectedMail();
	if (lastSelected) {
		this.selectMail(lastSelected);
	} else {
		tutao.locator.mailViewModel.hideConversation();
	}
};

/**
 * Loads the mails with the given ids in the given order. Uses recoursion to load all mails.
 * @param {Array.<Array.<String>>} mailIds The ids of the mails to load.
 * @param {Array.<tutao.entity.tutanota.Mail>} loadedMails An array that contains all mails that are loaded up to now.
 * @param {number} nextMail The index of the mail id in mailIds that shall be loaded next.
 * @return {Promise.<Array.<tutao.entity.tutanota.Mail>} Resolves to the loaded mails, rejected if failed.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype._loadMails = function(mailIds, loadedMails, nextMail) {
	if (mailIds.length == 0) {
		return Promise.resolve();
	}
	var self = this;
	return tutao.entity.tutanota.Mail.load([tutao.locator.mailBoxController.getUserMailBox().getMails(), mailIds[nextMail]]).then(function(mail) {
        loadedMails.push(mail);
	}).lastly(function(e) {
        // move on, even if an exception occured.
        if (nextMail != mailIds.length - 1) {
            return self._loadMails(mailIds, loadedMails, nextMail + 1);
        }
    });
};


/**
 * This method gets invoked if new mails have been received from the server.
 * @param {Array.<Mail>} mails The mails that are new.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype.updateOnNewMails = function(mails) {
	for (var i = 0; i < mails.length; i++) {
        var mailTagId = this._getTagForMail(mails[i]);
        this.currentTagFilterResult[mailTagId].unshift(mails[i].getId()[1]);
        if (this._currentActiveSystemTag() == mailTagId) {
            this.mails.unshift(mails[i]);
        }
	}
};

tutao.tutanota.ctrl.MailListViewModel.prototype._getTagForMail = function(mail) {
    for (var tagId = 0; tagId < this.currentTagFilterResult.length; tagId++) {
        var mailAttribute = this.tagToMailAttributeMapping[tagId];
        var mailTagValue = mail[mailAttribute];
        if (this.tagToMailAttributeValueMapping[tagId] == mailTagValue) {
            return tagId;
        }
    }
    throw new Error("no tag found for mail " + mail.getId()[0] + "/" + mail.getId()[1]);
};

/**
 * Shows the mail with the given index in the mail view. If the index does not exist, the first index is shown.
 * If no mail exists, no mail is shown.
 * @param index The index to show.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype.showIndex = function(index) {
	if (this.mails().length == 0) {
		return;
	}
	if (index < 0) {
		index = 0;
	} else if (index >= this.mails().length) {
		index = this.mails().length - 1;
	}
	this.selectMail(this.mails()[index]);
};

/**
 * Shows the given mail in the mail view but does not switch to the conversation column.
 * @param mail The mail to show.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype.selectMail = function(mail) {
	this._selectMail(mail, tutao.locator.mailView.getMailListDomElement(mail), false);
};

/**
 * Shows the given mail in the mail view and switches to the conversation column.
 * @param mail The mail to show.
 * @param {Event} event The click event.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype.selectMailAndSwitchToConversationColumn = function(mail, event) {
	this._selectMail(mail, event.currentTarget, true);
};

/**
 * Selects the given mail and shows it in the conversation column. Switches to the conversation column depending on the switchToConversationColumn param.
 * @param {tutao.entity.tutanota.Mail} mail Mail to select.
 * @param {Object} domElement dom element of the mail.
 * @param {boolean} switchToConversationColumn True if we shall switch.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype._selectMail = function(mail, domElement, switchToConversationColumn) {
	if (!tutao.locator.mailViewModel.tryCancelAllComposingMails()) {
		return;
	}
	if (mail.getUnread()) {
		mail.setUnread(false);
		mail.update();
	}

	if (this._multiSelect) {
	} else {
		if (this._selectedMails.length > 0 && mail == this._selectedMails[0]) {
			tutao.locator.mailView.fadeConversation();
			tutao.locator.mailView.showConversationColumn();
		} else {
			tutao.tutanota.gui.unselect(this._selectedDomElements);
			this._selectedDomElements = [domElement];
			this._selectedMails = [mail];
			tutao.tutanota.gui.select(this._selectedDomElements);
			tutao.locator.mailViewModel.hideConversation();
			if (switchToConversationColumn) {
				tutao.locator.mailView.showConversationColumn(function() {
					tutao.locator.mailViewModel.showMail(mail);
				});
			} else {
				tutao.locator.mailViewModel.showMail(mail);
			}
		}
	}
};

/**
 * Provides the information if a mail is selected.
 * @return {boolean} True if a mail is selected, false otherwise.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype.isMailSelected = function() {
	return (this._selectedMails.length != 0);
};

/**
 * Deselects all mails and remembers the last selected mail.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype.unselectAll = function() {
	if (this._selectedMails.length == 1) {
		this._lastSelectedMail[this._currentActiveSystemTag()] = this._selectedMails[0];
	}
	tutao.tutanota.gui.unselect(this._selectedDomElements);
	this._selectedDomElements = [];
	this._selectedMails = [];
};

/**
 * Provides the last selected mail or null if none was selected.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype.getLastSelectedMail = function() {
	if (this._lastSelectedMail[this._currentActiveSystemTag()] && this.mails.indexOf(this._lastSelectedMail[this._currentActiveSystemTag()]) != -1) {
		return this._lastSelectedMail[this._currentActiveSystemTag()];
	} else {
		return null;
	}
};

/**
 * Trashes/untrashes all the given mails. updates the mail list view accordingly.
 * @param {Array.<Array<String>>} mailIds The mails to delete finally.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype.finallyDeleteMails = function(mailIds) {
    var self = this;
    var service = new tutao.entity.tutanota.DeleteMailData();
    tutao.util.ArrayUtils.addAll(service.getMails(), mailIds);
    return service.erase({}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(deleteMailReturn) {
        for (var i=0; i<mailIds.length; i++) {
            tutao.util.ArrayUtils.remove(self.currentTagFilterResult[tutao.tutanota.ctrl.TagListViewModel.TRASHED_TAG_ID], mailIds[i][1]);
        }
        self.unselectAll();
        return self._updateMailList();
    });
};


/**
 * Executes the delete trash functionality.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype._deleteTrash = function() {
    if (this.loading() || this.deleting()) {
        return Promise.resolve();
    }

    var self = this;
    if (tutao.tutanota.gui.confirm(tutao.lang('confirmDeleteTrash_msg'))) {
        this.deleting(true);
        // we want to delete all mails in the trash, not only the visible ones, so load them now. load reverse to avoid caching errors
        return tutao.rest.EntityRestInterface.loadAllReverse(tutao.entity.tutanota.Mail, tutao.locator.mailBoxController.getUserMailBox().getMails()).then(function(allMails) {
            var mailsToDelete = [];
            for (var i = 0; i < allMails.length; i++) {
                if (allMails[i].getTrashed()) {
                    mailsToDelete.push(allMails[i].getId());
                }
            }
            return self.finallyDeleteMails(mailsToDelete);
        }).lastly(function() {
            self.deleting(false);
        });
    } else {
        return Promise.resolve();
    }
};


/**
 * Trashes/untrashes all the given mails. updates the mail list view accordingly.
 * @param {Array.<tutao.entity.tutanota.Mail>} mails The mails to delete or undelete.
 * @param {boolean} trash If true, the mail is trashed, otherwise it is untrashed.
 * @return {window.Promise.<>} Resolved when finished.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype.trashMail = function(mails, trash) {
	return this._trashNextMail(mails, 0, trash, false);
};

/**
 * @protected
 * Trashes/untrashes all mails passed as first argument.
 * @param {Array.<tutao.entity.tutanota.Mail>} mails The mails to trash.
 * @param {number} index The index of the first mail to trash.
 * @param {boolean} trash If true, the mail is trashed, otherwise it is untrashed.
 * @param {boolean} attributeChanged Indicates if a trash attribute of any mail was changed so far.
 * When all selected mails are finished, if any was trashed/untrashed, this value is true.
 * @return {window.Promise.<>} Resolved when finished.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype._trashNextMail = function(mails, index, trash, attributeChanged) {
	var self = this;
	var mail = mails[index];
	if (mail.getTrashed() != trash) {
		mail.setTrashed(trash);
		mail.update();
        return new window.Promise(function(resolve, reject) {
            try  {
                // make the icon in the gui visible/invisible if the mail stays in the list. currently it doesn't
                // update the filter results
                for (var tagId = 0; tagId < self.currentTagFilterResult.length; tagId++) {
                    if ((tagId == tutao.tutanota.ctrl.TagListViewModel.TRASHED_TAG_ID) == trash) {
                        // we need to add the mail id if it is the correct state value
                        if (mail[self.tagToMailAttributeMapping[tagId]] == self.tagToMailAttributeValueMapping[tagId]) {
                            self.currentTagFilterResult[tagId].push(mail.getId()[1]);
                        }
                    } else {
                        // we need to remove the mail id
                        tutao.util.ArrayUtils.remove(self.currentTagFilterResult[tagId], mail.getId()[1]);
                    }
                }

                if (index == mails.length - 1) {
                    // when the mails are removed from the list select the first mail if multiple mails have been trashed and
                    // select the next mail if one mail has been trashed
                    var nextSelectedIndex = 0;
                    if (mails.length == 1) {
                        nextSelectedIndex = self.mails.indexOf(mails[index]);
                    }
                    self.unselectAll();
                    resolve(self._updateMailList().then(function() {
                        self.showIndex(nextSelectedIndex);
                    }));
                } else {
                    resolve(self._trashNextMail(mails, ++index, trash, true));
                }
            } catch (exception) {
                reject(exception);
            }
        });

	} else {
		if (index == mails.length - 1) {
			// when the mails are removed from the list select the first mail if multiple mails have been trashed and
			// select the next mail if one mail has been trashed
			var nextSelectedIndex = 0;
			if (mails.length == 1) {
				nextSelectedIndex = self.mails.indexOf(mails[index]);
			}
			self.unselectAll();
			return self._updateMailList().then(function() {
				self.showIndex(nextSelectedIndex);
			});
		} else {
			return self._trashNextMail(mails, ++index, trash, attributeChanged);
		}
	}
};

/**
 * Requests for validity from the search field.
 * @param {string} text The text to validate.
 * @return {Object<text, colorId>} The validated text and color id.
 */
tutao.tutanota.ctrl.MailListViewModel.prototype.validateBubbleText = function(text) {
	return {text: text, colorId: 0};
};

tutao.tutanota.ctrl.MailListViewModel.prototype.showSearchBar = function() {
    this.searchBarVisible(true);
};

tutao.tutanota.ctrl.MailListViewModel.prototype.hideSearchBar = function() {
    this.searchBarVisible(false);
};




/************** implementation of tutao.tutanota.ctrl.bubbleinput.BubbleHandler **************/

/** @inheritDoc */
tutao.tutanota.ctrl.MailListViewModel.prototype.getSuggestions = function(text) {
	return [];
};

/** @inheritDoc */
tutao.tutanota.ctrl.MailListViewModel.prototype.createBubbleFromSuggestion = function(suggestion) {
	return null;
};

/** @inheritDoc */
tutao.tutanota.ctrl.MailListViewModel.prototype.createBubblesFromText = function(text) {
	return [new tutao.tutanota.ctrl.bubbleinput.Bubble(null, ko.observable(text), ko.observable(null), ko.observable('default'), false)];
};

/** @inheritDoc */
tutao.tutanota.ctrl.MailListViewModel.prototype.bubbleDeleted = function(bubble) {
	// nothing to do
};

/** @inheritDoc */
tutao.tutanota.ctrl.MailListViewModel.prototype.buttonClick = function() {
    if ( this.buttonCss() == 'search'){
        this.hideSearchBar();
    }else {
        this.bubbleInputViewModel.bubbles.removeAll();
        this.bubbleInputViewModel.inputValue("");
        //this.search();
    }
};

tutao.tutanota.ctrl.MailListViewModel.prototype.buttonCss = function() {
    if (this.bubbleInputViewModel.inputValue().trim() || this.bubbleInputViewModel.bubbles().length > 0) {
        return 'cancel';
    } else {
        return 'search';
    }
};



"use strict";

tutao.provide('tutao.tutanota.ctrl.MailViewModel');

/**
 * The mails in the conversation on the right.
 * @constructor
 */
tutao.tutanota.ctrl.MailViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

	this.conversation = ko.observableArray();
	this.showSpinner = ko.observable(false);
	this.conversationLoaded = ko.computed(function() {
		for (var i = 0; i < this.conversation().length; i++) {
			if (!this.conversation()[i].mailBodyLoaded()) {
				return false;
			}
		}
		return (this.conversation().length > 0);
	}, this);
	this.oldState = null;
	this.conversationLoaded.subscribe(function(loaded) {
		if (this.oldState && this.oldState == loaded) {
			return;
		} else {
			this.oldState = loaded;
		}
		if (loaded) {
			this.showSpinner(false);
			tutao.locator.mailView.fadeConversationIn(function() {});
		} else {
			tutao.locator.mailView.hideConversation();
		}
	}, this);
};

/**
 * Shows the given mail in its conversation.
 * @param {tutao.entity.tutanota.Mail} mail The mail to show.
 */
tutao.tutanota.ctrl.MailViewModel.prototype.showMail = function(mail) {
	var self = this;
	var mails = [];
	this._setConversation([mail]);
    mail.loadConversationEntry();
    /* We currently don't display the whole conversation but will do this later
	// we just load the conversation because we need it later (to get it synchronous)
	tutao.entity.tutanota.ConversationEntry.loadRange(mail.getConversationEntry()[0], tutao.rest.EntityRestInterface.GENERATED_MIN_ID, tutao.rest.EntityRestInterface.MAX_RANGE_COUNT, false, function(conversationEntries, exception) {
		if (exception) {
			console.log("conversation could not be loaded");
		}
	});
	tutao.entity.tutanota.ConversationEntry.loadRange(mail.getConversationEntry()[0], tutao.rest.EntityRestInterface.GENERATED_MIN_ID, tutao.rest.EntityRestInterface.MAX_RANGE_COUNT, false, function(conversationEntries, exception) {
		if (exception) {
			console.log("conversation could not be loaded");
			self._setConversation([mail]);
		} else {
			mail.loadConversationEntry(function(ce, exception) {
				if (!exception) {
					self._loadNextMails(ce, mails, function() {
						self._setConversation(mails);
					});
				} else {
					console.log(exception);
				}
			});
		}
	});*/
};

/**
 * Loads the mail of the given conversation entry (if existing) and puts it into mails. Then triggers loading the
 * previous mail.
 * @param {tutao.entity.tutanota.ConversationEntry} conversationEntry The conversation entry to start loading from.
 * @param {Array.<tutao.entity.tutanota.Mail>} mails The result list with all loaded mails.
 * @return {Promise.<>} Resolves when all mails have been loaded.
 */
tutao.tutanota.ctrl.MailViewModel.prototype._loadNextMails = function(conversationEntry, mails) {
	var self = this;
	// there might be no mail for this user, so skip it in that case
	if (conversationEntry.getMail()) {
		return conversationEntry.loadMail().then(function(mail) {
    		mails.push(mail);
			return self._loadNextMailsLoadPrevious(conversationEntry, mails);
		}).caught(function(exception) {
            console.log(exception);
        });
	} else {
		return self._loadNextMailsLoadPrevious(conversationEntry, mails);
	}
};

/**
 * Loads the previous conversation entry of the given conversation entry. Then triggers loading the
 * the mail from that conversation entry.
 * @param {tutao.entity.tutanota.ConversationEntry} conversationEntry The conversation entry to load the previous from.
 * @param {Array.<tutao.entity.tutanota.Mail>} mails The result list with all loaded mails.
 * @return {Promise.<>} Resolves when all mails have been loaded.
 */
tutao.tutanota.ctrl.MailViewModel.prototype._loadNextMailsLoadPrevious = function(conversationEntry, mails) {
	var self = this;
	if (conversationEntry.getPrevious()) {
		return conversationEntry.loadPrevious().then(function(nextCe, exception) {
			return self._loadNextMails(nextCe, mails);
		}).caught(function(exception) {
            console.log(exception);
        });
	} else {
		return Promise.resolve();
	}
};

/**
 * Hides any visible conversation.
 */
tutao.tutanota.ctrl.MailViewModel.prototype.hideConversation = function() {
	this.conversation.removeAll();
};

/**
 * Removes the first mail from the conversation.
 */
tutao.tutanota.ctrl.MailViewModel.prototype.removeFirstMailFromConversation = function() {
	this.conversation.shift();
};

/**
 * Adds a mail to the conversation as first mail.
 * @param {tutao.tutanota.ctrl.DisplayedMail|tutao.tutanota.ctrl.ComposingMail} mail The mail to insert.
 */
tutao.tutanota.ctrl.MailViewModel.prototype.addFirstMailToConversation = function(mail) {
	this.conversation.unshift(mail);
};

/**
 * Shows the conversation in the mail view. Loads the mail body text asynchronously.
 * @param {Array.<tutao.tutanot.entity.Mail>} conversation The list of mails to show.
 */
tutao.tutanota.ctrl.MailViewModel.prototype._setConversation = function(conversation) {
	var self = this;
	self.conversation.removeAll();

    // only show the spinner after 200ms if the conversation has not been loaded till then
    setTimeout(function() {
        if (!self.conversationLoaded()) {
            self.showSpinner(true);
        }
    }, 200);

    return Promise.map(conversation, function(mail) {
        self.conversation.push(new tutao.tutanota.ctrl.DisplayedMail(mail));
        return new Promise(function(resolve, reject) {
            setTimeout(resolve, 0); // pause after decrypting each mail for rotating the spinner (won't do this otherwise).
        });
    });
};

/**
 * Provides a ContactWrapper for the given mail address or null if none was found.
 * @param {string} mailAddress The mail address.
 * @return {tutao.entity.tutanota.ContactWrapper} The contact wrapper.
 */
tutao.tutanota.ctrl.MailViewModel.prototype._findContactByMailAddress = function(mailAddress) {
	var contactWrappers = tutao.tutanota.ctrl.ComposingMail._getContacts();
	for (var i = 0; i < contactWrappers.length; i++) {
		if (contactWrappers[i].hasMailAddress(mailAddress)) {
			return contactWrappers[i];
		}
	}
	return null;
};

/**
 * @param {tutao.tutanota.ctrl.RecipientInfo=} recipientInfo Optional recipient info as recipient.
 * @return {Promise.<boolean>}
 */
tutao.tutanota.ctrl.MailViewModel.prototype.newMail = function(recipientInfo) {
	var recipients = (recipientInfo) ? [recipientInfo] : [];
	return this._createMail(tutao.entity.tutanota.TutanotaConstants.CONVERSATION_TYPE_NEW, "", recipients, [], null);
};

/**
 * Lets the user write a reply mail to the given displayed mail.
 * @param {tutao.tutanota.ctrl.DisplayedMail} displayedMail The mail we want to reply to.
 */
tutao.tutanota.ctrl.MailViewModel.prototype.replyMail = function(displayedMail) {
	var infoLine = tutao.tutanota.util.Formatter.formatFullDateTime(displayedMail.mail.getSentDate()) + " " + tutao.lang("by_label") + " " + displayedMail.mail.getSender().getAddress() + ":";
	var body = "<br><br>" + infoLine + "<br><br><blockquote class=\"tutanota_quote\">" + displayedMail.bodyText() + "</blockquote>";
	var recipient;
	if (tutao.locator.userController.isExternalUserLoggedIn()) {
		// TODO (story: delete user) check that the recipient is actually internal (i.e. not unregistered)
		recipient = new tutao.tutanota.ctrl.RecipientInfo(displayedMail.mail.getSender().getAddress(), displayedMail.mail.getSender().getName(), this._findContactByMailAddress(displayedMail.mail.getSender().getAddress()), false);
	} else {
		recipient = new tutao.tutanota.ctrl.RecipientInfo(displayedMail.mail.getSender().getAddress(), displayedMail.mail.getSender().getName(), this._findContactByMailAddress(displayedMail.mail.getSender().getAddress()));
	}
    recipient.resolveType().caught(tutao.ConnectionError, function(e) {
        // we are offline but we want to show the dialog only when we click on send.
    });
	this._createMail(tutao.entity.tutanota.TutanotaConstants.CONVERSATION_TYPE_REPLY, tutao.entity.tutanota.TutanotaConstants.CONVERSATION_REPLY_SUBJECT_PREFIX + displayedMail.mail.getSubject(), [recipient], [], displayedMail, body);
};

/**
 * Lets the user write a reply mail to the sender and all of the recipients of the given displayed mail.
 * @param {tutao.tutanota.ctrl.DisplayedMail} displayedMail The mail we want to reply to.
 */
tutao.tutanota.ctrl.MailViewModel.prototype.replyAllMail = function(displayedMail) {
	var infoLine = tutao.tutanota.util.Formatter.formatFullDateTime(displayedMail.mail.getSentDate()) + " " + tutao.lang("by_label") + " " + displayedMail.mail.getSender().getAddress() + ":";
	var body = "<br><br>" + infoLine + "<br><br><blockquote class=\"tutanota_quote\">" + displayedMail.bodyText() + "</blockquote>";
	var toRecipients = [new tutao.tutanota.ctrl.RecipientInfo(displayedMail.mail.getSender().getAddress(), displayedMail.mail.getSender().getName(), this._findContactByMailAddress(displayedMail.mail.getSender().getAddress()))];
	var ccRecipients = [];
	var oldRecipients = displayedMail.mail.getToRecipients().concat(displayedMail.mail.getCcRecipients());
	for (var i = 0; i < oldRecipients.length; i++) {
		if (oldRecipients[i].getAddress() != tutao.locator.userController.getMailAddress()) {
			ccRecipients.push(new tutao.tutanota.ctrl.RecipientInfo(oldRecipients[i].getAddress(), oldRecipients[i].getName(), this._findContactByMailAddress(oldRecipients[i].getAddress())));
		}
	}
    var allRecipients = toRecipients.concat(ccRecipients);
    Promise.each(allRecipients, function(/*tutao.tutanota.ctrl.RecipientInfo*/recipient) {
        recipient.resolveType();
    }).caught(tutao.ConnectionError, function(e) {
        // we are offline but we want to show the dialog only when we click on send.
    });
	this._createMail(tutao.entity.tutanota.TutanotaConstants.CONVERSATION_TYPE_REPLY, tutao.entity.tutanota.TutanotaConstants.CONVERSATION_REPLY_SUBJECT_PREFIX + displayedMail.mail.getSubject(), toRecipients, ccRecipients, displayedMail, body);
};

/**
 * Lets the user write a mail forwarding the given displayed mail.
 * @param {tutao.tutanota.ctrl.DisplayedMail} displayedMail The mail we want to forward.
 */
tutao.tutanota.ctrl.MailViewModel.prototype.forwardMail = function(displayedMail) {
	var infoLine = tutao.lang("date_label") + ": " + tutao.tutanota.util.Formatter.formatFullDateTime(displayedMail.mail.getSentDate()) + "<br>";
	infoLine += tutao.lang("from_label") + ": " + displayedMail.mail.getSender().getAddress() + "<br>";
	if (displayedMail.mail.getToRecipients().length > 0) {
		infoLine += tutao.lang("to_label") + ": " + displayedMail.mail.getToRecipients()[0].getAddress();
		for (var i = 1; i < displayedMail.mail.getToRecipients().length; i++) {
			infoLine += ", " + displayedMail.mail.getToRecipients()[i].getAddress();
		}
		infoLine += "<br>";
	}
	if (displayedMail.mail.getCcRecipients().length > 0) {
		infoLine += tutao.lang("cc_label") + ": " + displayedMail.mail.getCcRecipients()[0].getAddress();
		for (var i = 1; i < displayedMail.mail.getCcRecipients().length; i++) {
			infoLine += ", " + displayedMail.mail.getCcRecipients()[i].getAddress();
		}
		infoLine += "<br>";
	}
	infoLine += tutao.lang("subject_label") + ": " + displayedMail.mail.getSubject();
	var body = "<br><br>" + infoLine + "<br><br><blockquote class=\"tutanota_quote\">" + displayedMail.bodyText() + "</blockquote>";
    var self = this;
	this._createMail(tutao.entity.tutanota.TutanotaConstants.CONVERSATION_TYPE_FORWARD, tutao.entity.tutanota.TutanotaConstants.CONVERSATION_FORWARD_SUBJECT_PREFIX + displayedMail.mail.getSubject(), [], [], displayedMail, body).then(function() {
        self.getComposingMail()._attachments(displayedMail.attachments());
    });
};

/**
 * Opens an export dialog that shows how the mail can be exported to Outlook, Thunderbird and the Filesystem.
 * @param {tutao.tutanota.ctrl.DisplayedMail} displayedMail The mail we want to export.
 */
tutao.tutanota.ctrl.MailViewModel.prototype.exportMail = function(displayedMail) {
    return tutao.tutanota.util.Exporter.toEml(displayedMail).then(function(eml) {
        var buffer = tutao.util.EncodingConverter.asciiToArrayBuffer(eml);
        var tmpFile = new tutao.entity.tutanota.File();
        var filename = displayedMail.mail.getSubject();
        if (filename.trim().length == 0) {
            filename = "unnamed";
        }
        tmpFile.setName(filename + ".eml");
        tmpFile.setMimeType("message/rfc822");
        tmpFile.setSize(String(buffer.byteLength));
        tutao.tutanota.util.FileUtils.provideDownload(new tutao.tutanota.util.DataFile(buffer, tmpFile));
    });
};

/**
 * Lets the user write a mail.
 * @param {string} conversationType The conversation type (REPLY or FORWARD). See TutanotaConstants.
 * @param {string} subject The subject for the mail.
 * @param {Array.<tutao.tutanota.ctrl.RecipientInfo>} toRecipients The recipient infos that shall appear as to recipients in the mail.
 * @param {Array.<tutao.tutanota.ctrl.RecipientInfo>} ccRecipients The recipient infos that shall appear as cc recipients in the mail.
 * @param {tutao.tutanota.ctrl.DisplayedMail=} previousMail The previous mail to be visible below the new mail. Null if no previous mail shall be visible.
 * @param {string} bodyText The text to insert into the mail body.
 * @return {Promise<boolean>} resolves to true, if the new mail has been created, to false otherwise
 */
tutao.tutanota.ctrl.MailViewModel.prototype._createMail = function(conversationType, subject, toRecipients, ccRecipients, previousMail, bodyText) {
	var self = this;

	if (!self.tryCancelAllComposingMails()) {
		return false;
	}

	// any selected mails in the mail list shall be deselected
	tutao.locator.mailListViewModel.unselectAll();

    var mailCreatedPromise;
	if (previousMail) {
		for (var i = 0; i < this.conversation().length; i++) {
			if (this.conversation()[i] == previousMail) {
				this.conversation.splice(0, i); // remove all mails up to the selected
				break;
			}
		}

        var previousMessageId = null;
		mailCreatedPromise = previousMail.mail.loadConversationEntry().then(function(ce) {
            previousMessageId = ce.getMessageId();
        }).caught(function(e) {
            console.log("could not load conversation entry", e);
        }).then(function() {
            // the conversation key may be null if the mail was e.g. received from an external via smtp
            var mail = new tutao.tutanota.ctrl.ComposingMail(conversationType, previousMessageId);
            self.conversation([mail]);
            mail.setBody(bodyText);
        });
	} else {
        mailCreatedPromise = Promise.resolve();
		this.conversation([new tutao.tutanota.ctrl.ComposingMail(conversationType, null)]);
	}

    return mailCreatedPromise.then(function() {
        self.getComposingMail().composerSubject(subject);
        for (var i = 0; i < toRecipients.length; i++) {
            self.getComposingMail().addToRecipient(toRecipients[i]);
        }
        for (var i = 0; i < ccRecipients.length; i++) {
            self.getComposingMail().addCcRecipient(ccRecipients[i]);
        }

        //	not needed currently as we scroll the complete window when editing a mail
        tutao.locator.mailView.showConversationColumn();


        // uncomment for test sending html emails (also switch to composeBodyTextArea in index.html)
        //self.editor = new Quill('div.composeBody', {theme: 'snow'});
        //self.editor.addModule('toolbar', {
        //    container: '#toolbar-toolbar'     // Selector for toolbar container
        //});
        ////TODO (story send html email): test on mobiles and move to view
        //	this.editor = new wysihtml5.Editor("composeBodyTextArea", { // id of textarea element
        //		toolbar:      null, // id of toolbar element
        //		parserRules:  wysihtml5ParserRules // defined in parser rules set
        //	});
        //	var onChange = function() {
        //		self.conversation()[0].composerBody($("#composeBodyTextArea").val());
        //	};
        //	this.editor.on("change", onChange);

        return true;
    });

};

/**
 * Finally deletes this mail.
 * @param {tutao.tutanota.ctrl.DisplayedMail} displayedMail The mail we want to delete finally.
 * @return {window.Promise} The promise.
 */
tutao.tutanota.ctrl.MailViewModel.prototype.finalDeleteMail = function(displayedMail) {
    return tutao.locator.mailListViewModel.finallyDeleteMails([displayedMail.mail.getId()]);
};

/**
 * Deletes or undeletes the given displayed mail.
 * @param {tutao.tutanota.ctrl.DisplayedMail} displayedMail The mail we want to delete/undelete.
 */
tutao.tutanota.ctrl.MailViewModel.prototype.deleteMail = function(displayedMail) {
	tutao.locator.mailListViewModel.trashMail([displayedMail.mail], !displayedMail.mail.getTrashed());
};

/**
 * If a composing mail is open, asks the user to cancel that mail.
 * @return {boolean} True if no composing mail is open any more, false otherwise.
 */
tutao.tutanota.ctrl.MailViewModel.prototype.tryCancelAllComposingMails = function() {
	if (this.conversation().length == 0) {
		return true;
	} else if (this.isComposingState()) {
		return (this.getComposingMail().cancelMail(true));
	} else {
		return true;
	}
};

/**
 * Provides the information if a composing mail is open.
 * @return {Boolean} True, if we are composing an E-Mail right now.
 */
tutao.tutanota.ctrl.MailViewModel.prototype.isComposingState = function() {
	return (this.conversation().length > 0 && this.conversation()[0] instanceof tutao.tutanota.ctrl.ComposingMail);
};

/**
 * Provides the composing mail, if existing in the conversation.
 * @return {tutao.tutanota.ComposingMail} The composing mail.
 */
tutao.tutanota.ctrl.MailViewModel.prototype.getComposingMail = function() {
	if (!this.isComposingState()) {
		throw new Error("RuntimeException: not in composing state");
	}
	return this.conversation()[0];
};

/**
 * Provides the information if a composing mail is open and secure external recipients have been selected.
 * @return {Boolean} True if secure external recipients have been selected, false otherwise.
 */
tutao.tutanota.ctrl.MailViewModel.prototype.isComposingMailToSecureExternals = function() {
	return (this.isComposingState() && this.getComposingMail().composeForSecureExternalRecipients());
};

/**
 * Returns true if no conversation (i.e. no mail) is shown.
 * @return {Boolean} True if no conversation is shown, false otherwise.
 */
tutao.tutanota.ctrl.MailViewModel.prototype.isConversationEmpty = function() {
	return (this.conversation().length == 0);
};

/**
 * @param {tutao.entity.tutanota.MailAddress} the MailAddress
 * @param {string} meId The id of the text that should be used if the mailAddress is the current user
 * @returns {string} The label for this MailAddress
 */
tutao.tutanota.ctrl.MailViewModel.prototype.getLabel = function(mailAddress, meId) {
    if (mailAddress.getAddress() == tutao.locator.userController.getMailAddress()) {
        return tutao.locator.languageViewModel.get(meId);
    } else if (mailAddress.getName() == "") {
        return mailAddress.getAddress();
    } else {
        return mailAddress.getName();
    }
};

/**
 * Created by bdeterding on 07.05.14.
 */
"use strict";

tutao.provide('tutao.tutanota.ctrl.ModalPageBackgroundViewModel');

/**
 * The ViewModel for the feedback wizard.
 * @constructor
 */
tutao.tutanota.ctrl.ModalPageBackgroundViewModel = function() {
    tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
    this.visible = ko.observable(false);
    this.closeListener = null;
    var self = this;

    $(window.document).click(function(event){
        if(!$(event.target).parent().is('.buttonBarMoreMenu')){
            self._hide();
        }
    });
};

/**
 * Shows a transparent background receiving the next click event.
 * @param {function()} closeListener
 */
tutao.tutanota.ctrl.ModalPageBackgroundViewModel.prototype.show = function(closeListener) {
    this.closeListener = closeListener;
    this.visible(true);
};


/**
 * Hides the background and informs the close listener.
 */
tutao.tutanota.ctrl.ModalPageBackgroundViewModel.prototype._hide = function() {
    this.visible(false);
    if (this.closeListener != null){
        this.closeListener();
    }
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.Navigator');

// written for knockout and more active. Page bindings and params come into index.html
tutao.tutanota.ctrl.Navigator = function() {
    tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	this.clientSupported = (tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_SUPPORTED);
	this.externalClientSupported = this.clientSupported || (tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_IE) || (tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_SAFARI) || (tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_ANDROID) || (tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_IE_MOBILE);
	this.mailRef = null; // the mail reference for an external user
	this._allowAutoLogin = true; // indicates if auto login allowed. needs to be disabled if logout is clicked 
};

/**
 * Displays the not supported view if this client is not supported
 * @return {boolean} true, if this client is supported
 */
tutao.tutanota.ctrl.Navigator.prototype.verifyClientSupported = function() {
	if (!this.clientSupported) {
		tutao.locator.viewManager.select(tutao.locator.notSupportedView);
		return false;
	} else {
		return true;
	}
};

/**
 * Displays the not supported view if this client is not supported
 * @return {boolean} true, if this client is supported
 */
tutao.tutanota.ctrl.Navigator.prototype.verifyExternalClientSupported = function() {
	if (!this.externalClientSupported) {
		tutao.locator.viewManager.select(tutao.locator.notSupportedView);
		return false;
	} else {
		return true;
	}
};

tutao.tutanota.ctrl.Navigator.prototype.logout = function(autoLoginAllowed, storeEntropy) {
    if (storeEntropy){
        tutao.locator.loginViewModel.storeEntropy();
    }
	this._login(autoLoginAllowed);
};

tutao.tutanota.ctrl.Navigator.prototype._login = function(autoLoginAllowed) {
    this._allowAutoLogin = autoLoginAllowed;
    if (this.mailRef == null) {
        location.replace("#login");
    } else {
        location.replace("#mail/" + this.mailRef); // an external user was logged in, we redirect him to his login page
    }
};

tutao.tutanota.ctrl.Navigator.prototype.notSupported = function() {
	location.replace("#notSupported");
};

tutao.tutanota.ctrl.Navigator.prototype.mail = function() {
    if ( tutao.locator.navigator.mailRef != null){
        location.replace("#box/" + tutao.locator.navigator.mailRef);
    }else{
        location.replace("#box");
    }
};

/**
 * @param {tutao.tutanota.ctrl.RecipientInfo=} recipient
 * @return {Promise}
 */
tutao.tutanota.ctrl.Navigator.prototype.newMail = function(recipient) {
    var self = this;
	return tutao.locator.mailViewModel.newMail(recipient).then(function () {
        self.mail();
    });
};

tutao.tutanota.ctrl.Navigator.prototype.contact = function() {
	location.replace("#contact");
};

tutao.tutanota.ctrl.Navigator.prototype.newContact = function() {
	tutao.locator.contactViewModel.newContact();
	this.contact();
};

tutao.tutanota.ctrl.Navigator.prototype.settings = function() {
	location.replace("#settings");
};

tutao.tutanota.ctrl.Navigator.prototype.register = function() {
    location.replace("#register");
};

/**
 * Switches to the provided view, if the user is authenticated. Otherwise, switches to the LoginView
 * @param {tutao.tutanota.ctrl.View} view The view to switch to.
 */
tutao.tutanota.ctrl.Navigator.prototype.authenticateAndSwitchToView = function(view) {
	/* TODO (story mobile support) for ios 7: to make sliding work, we need to open a new window on login and close the current.
	var type = tutao.tutanota.util.ClientDetector.getDeviceType();
	if (window.history.length > 1 && (type == tutao.tutanota.util.ClientDetector.DEVICE_TYPE_IPHONE || type == tutao.tutanota.util.ClientDetector.DEVICE_TYPE_IPAD)) {
		alert("open");
		window.open(window.location.href, "_blank")
	}*/
	if (tutao.locator.userController.isInternalUserLoggedIn() || tutao.locator.userController.isExternalUserLoggedIn()) {
		tutao.locator.viewManager.select(view);
	} else {
		console.log("User not authenticated, switching to login view.");
		this._login(true);
	}
};

tutao.tutanota.ctrl.Navigator.prototype.setup = function() {
	var self = this;
	// configure all routes
    Path.map("#registerstarter").to(function() {
        if (tutao.locator.userController.isInternalUserLoggedIn() || tutao.locator.userController.isExternalUserLoggedIn()) {
            tutao.tutanota.Bootstrap.init();
        }
        if (self.verifyClientSupported()) {
            tutao.locator.viewManager.select(tutao.locator.registrationVerifyDomainView, {});
        }
    });

	Path.map("#register(/:parameters)").to(function() {
		if (tutao.locator.userController.isInternalUserLoggedIn() || tutao.locator.userController.isExternalUserLoggedIn()) {
			tutao.tutanota.Bootstrap.init();
		}
		if (self.verifyClientSupported()) {
			if (this.params["parameters"]) {
				var parameters = self.getQueryParams(this.params["parameters"]);
				tutao.locator.viewManager.select(tutao.locator.registrationView, parameters);
			} else {
				tutao.locator.viewManager.select(tutao.locator.registrationView, {});
			}
		}
	});

	Path.map("#login").to(function() {
        tutao.locator.navigator.mailRef = null;
		if (tutao.locator.userController.isInternalUserLoggedIn() || tutao.locator.userController.isExternalUserLoggedIn()) {
			tutao.tutanota.Bootstrap.init();
		}
		if (self.verifyClientSupported()) {
			// provide allowAutoLogin to loginViewModel here as soon as device management is running
			tutao.locator.viewManager.select(tutao.locator.loginView);
		}
	});

	Path.map("#notSupported").to(function() {
		tutao.locator.viewManager.select(tutao.locator.notSupportedView);
	});

	Path.map("#mail/:mailRef").to(function() {
		if (tutao.locator.userController.isInternalUserLoggedIn() || tutao.locator.userController.isExternalUserLoggedIn()) {
			tutao.tutanota.Bootstrap.init();
		}
		if (self.verifyExternalClientSupported()) {
			// the mail reference must not be set on self, but on tutao.locator.navigator because it was replaced in Bootstrap
			tutao.locator.navigator.mailRef = this.params["mailRef"];
			tutao.locator.externalLoginViewModel.setup(self._allowAutoLogin, tutao.locator.navigator.mailRef).then(function() {
				tutao.locator.viewManager.select(tutao.locator.externalLoginView);
			});
		}
	});
	
	Path.map("#contact").to(function() {
		self.authenticateAndSwitchToView(tutao.locator.contactView);
	});

	Path.map("#box").to(function() {
		self.authenticateAndSwitchToView(tutao.locator.mailView);
	});

    Path.map("#box/:mailRef").to(function() {
        tutao.locator.navigator.mailRef = this.params["mailRef"];
        self.authenticateAndSwitchToView(tutao.locator.mailView)
    });


	Path.map("#file").to(function() {
		self.authenticateAndSwitchToView(tutao.locator.fileView);
	});
	
	Path.map("#settings").to(function() {
		self.authenticateAndSwitchToView(tutao.locator.settingsView);
	});
	
	Path.rescue(function() {
		tutao.locator.viewManager.select(tutao.locator.notFoundView);
	});

	if (this.clientSupported) {
		Path.root("#login");
	} else {
		Path.root("#notSupported");
	}
	Path.listen();

};

tutao.tutanota.ctrl.Navigator.prototype.getQueryParams = function(query) {
    var vars = query.split('&');
    var map = {};
    for (var i = 0; i < vars.length; i++) {
        var pair = vars[i].split('=');
        map[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return map;
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.PasswordChannelViewModel');

/**
 * The configuration for the password message for secure external recipients.
 * @constructor
 */
tutao.tutanota.ctrl.PasswordChannelViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
    this.germanSelected = ko.observable(true);
};

tutao.tutanota.ctrl.PasswordChannelViewModel.prototype.init = function(){
    var currentLanguage = tutao.locator.mailBoxController.getUserProperties().getNotificationMailLanguage();

    if (currentLanguage == null ){
        currentLanguage = tutao.locator.languageViewModel.getCurrentLanguage();
    }
    this.germanSelected("de" == currentLanguage);
};


/**
 * Returns a array of external recipients.
 * @return {Array.<tutao.tutanota.ctrl.RecipientInfo>} the array of external recipients.
 */
    tutao.tutanota.ctrl.PasswordChannelViewModel.prototype.getSecureExternalRecipients = function() {
	var externalRecipients = [];
	if (tutao.locator.mailViewModel.isComposingMailToSecureExternals()) {
		var allRecipients = tutao.locator.mailViewModel.getComposingMail().getAllComposerRecipients();
		for (var i = 0; i < allRecipients.length; i++) {
			if (allRecipients[i].isExternal()) {
               externalRecipients.push(allRecipients[i]);
			}
		}
	}
	return externalRecipients;
};

/**
 * Provides the information if the given phone number is a saved mobile number. If the number only exists in the editable contact, but not
 * in the underlying contact (i.e. it was not saved), then false is returned. Additionally an observer is registered which triggers an update
 * of bindings to this function if the contact is saved, i.e. if the returned information might not be valid any more).
 * @param {tutao.entity.tutanota.ContactPhoneNumberEditable} editablePhoneNumber The phone number to check.
 * @param {tutao.tutanota.ctrl.RecipientInfo} recipientInfo The editable contact which contains the editablePhoneNumber.
 * @return {Boolean} True if the given number is saved in the contact and is a mobile number, false otherwise.
 * @precondition (recipientInfo.isExternal() == true), otherwise there is no editable contact in the recipient info
 */
tutao.tutanota.ctrl.PasswordChannelViewModel.prototype.isSavedMobileNumber = function(editablePhoneNumber, recipientInfo) {
	// observe contact updates by registering an observer on the lastUpdatedTimestamp
	recipientInfo.getEditableContact().lastUpdatedTimestamp();
	var savedPhoneNumbers = recipientInfo.getEditableContact().getContact().getPhoneNumbers();
	for (var i = 0; i < savedPhoneNumbers.length; i++) {
		var number = savedPhoneNumbers[i];
		if (number.getNumber() == editablePhoneNumber.number() && number.getType() == editablePhoneNumber.type() && number.getCustomTypeName() == editablePhoneNumber.customTypeName()) {
			return tutao.tutanota.ctrl.RecipientInfo.isValidMobileNumber(editablePhoneNumber.number());
		}
	}
	return false;
};

/**
 * Provides the information if the given phone number is not saved, i.e. only exists in the editable contact but not in the underlying contact.
 * Additionally an observer is registered which triggers an update
 * of bindings to this function if the contact is saved, i.e. if the returned information might not be valid any more).
 * @param {tutao.entity.tutanota.ContactPhoneNumberEditable} editablePhoneNumber The phone number to check.
 * @param {tutao.tutanota.ctrl.RecipientInfo} recipientInfo The editable contact which contains the editablePhoneNumber.
 * @return {Boolean} True if the given number is not saved in the contact, false otherwise.
 * @precondition (recipientInfo.isExternal() == true), otherwise there is no editable contact in the recipient info
 */
tutao.tutanota.ctrl.PasswordChannelViewModel.prototype.isNotSavedNumber = function(editablePhoneNumber, recipientInfo) {
	// observe contact updates by registering an observer on the lastUpdatedTimestamp
	recipientInfo.getEditableContact().lastUpdatedTimestamp();
	var savedPhoneNumbers = recipientInfo.getEditableContact().getContact().getPhoneNumbers();
	for (var i = 0; i < savedPhoneNumbers.length; i++) {
		var number = savedPhoneNumbers[i];
		if (number.getNumber() == editablePhoneNumber.number() && number.getType() == editablePhoneNumber.type() && number.getCustomTypeName() == editablePhoneNumber.customTypeName()) {
			return false;
		}
	}
	return true;
};

/**
 * Provides the information if any of the recipientInfo's editable contact's newly added phone numbers are not mobile phone numbers.
 * @param {tutao.tutanota.ctrl.RecipientInfo} recipientInfo The recipient info to check.
 * @return {Boolean} True if any non-saved non-mobile phone numbers exist in the given recipient info, false otherwise.
 */
tutao.tutanota.ctrl.PasswordChannelViewModel.prototype.containsInvalidNotSavedNumbers = function(recipientInfo) {
	if (!recipientInfo.isExternal()) {
		return false;
	}
	var editablePhoneNumbers = recipientInfo.getEditableContact().phoneNumbers();
	for (var i = 0; i < editablePhoneNumbers.length; i++) {
		if (this.isNotSavedNumber(editablePhoneNumbers[i], recipientInfo) && !tutao.tutanota.ctrl.RecipientInfo.isValidMobileNumber(editablePhoneNumbers[i].number())) {
			return true;
		}
	}
	return false;
};

/**
 * Edit the given recipient contact. If a different contact is already edited, the user is asked to cancel that one.
 * @param {tutao.tutanota.ctrl.RecipientInfo} recipientInfo The contact from this recipient info shall be edited.
 */
tutao.tutanota.ctrl.PasswordChannelViewModel.prototype.editRecipient = function(recipientInfo) {
	// show the currently editing contact to the user even if he does not want to discard the changes
	// if we should decide not to show the editing contact, separate the tryToShowAndEditContact functionality
	// into cancelling the editing contact and showing the new one. in between the view must be switched, because the touch composing mode
	// must not be enabled as soon as the wrong view is visible.
	tutao.locator.navigator.contact();
	tutao.locator.contactView.showContactColumn();
	// the setTimeout is needed because otherwise the contact view is not necessarily shown
	setTimeout(function() {
		if (!tutao.locator.contactViewModel.tryToShowAndEditContact(recipientInfo.getContactWrapper())) {
			tutao.locator.navigator.mail();
		}
	}, 0);
};

tutao.tutanota.ctrl.PasswordChannelViewModel.prototype.defineManualPassword = function(recipientInfo) {
	recipientInfo.getEditableContact().presharedPassword(""); // makes the text field appear for the sender to enter the password
};

tutao.tutanota.ctrl.PasswordChannelViewModel.prototype.removePresharedPassword = function(recipientInfo) {
	recipientInfo.getEditableContact().presharedPassword(null);
};

/**
 * Provides the pre-shared password strength in %. If no pre-shared password is set, 0 is returned. 
 * @param {tutao.tutanota.ctrl.RecipientInfo} recipientInfo The contact of which the preshared password shall be checked.
 * @return {Number} The strength of the password.
 */
tutao.tutanota.ctrl.PasswordChannelViewModel.prototype.getPasswordStrength = function(recipientInfo) {
	var password = recipientInfo.getEditableContact().presharedPassword();
	if (password) {		
		return tutao.tutanota.util.PasswordUtils.getPasswordStrength(password, [tutao.locator.userController.getMailAddress(), tutao.locator.userController.getUserGroupInfo().getName(), recipientInfo.getMailAddress(), recipientInfo.getName()]);
	} else {
		return 0;
	}
};


/**
 * Checks if the auto transmition of the password is allowed for the logged in user.
 * @return {boolean} True if the auto transmition is allowed.
 */
tutao.tutanota.ctrl.PasswordChannelViewModel.prototype.isAutoTransmitPasswordAllowed = function() {
	// Get the account type from the ViewManager because the login state is a ko observable to get notfied when the logged in user changes.
    return tutao.locator.viewManager.getLoggedInUserAccountType() === tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_PREMIUM;
};


/**
 * Checks if the auto transmition of the password is deactivated for the logged in user
 * @return {boolean} True if the auto transmition is deactivated.
 */
tutao.tutanota.ctrl.PasswordChannelViewModel.prototype.isAutoTransmitPasswordDeactivated = function() {
    // Get the account type from the ViewManager because the login state is a ko observable to get notfied when the logged in user changes.
    return tutao.locator.viewManager.getLoggedInUserAccountType() === tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_STARTER;
};

/**
 * Returns a translatable description of the password channel for the logged in user.
 *
 * @return {String} Description of the password channel.
 */
tutao.tutanota.ctrl.PasswordChannelViewModel.prototype.getPasswordChannelDescription = function() {
    if (this.isAutoTransmitPasswordAllowed()){
        return tutao.locator.languageViewModel.get('atLeastOneMobileNumber_label',[]);
    }else{
        var text = tutao.locator.languageViewModel.get('preSharedPasswordNeeded_label',[]);
        if ( this.isAutoTransmitPasswordDeactivated()){
            text += " " + tutao.locator.languageViewModel.get('autoTransmitPasswordDeactivated_label',[]);
        }
        return text;
    }
};

tutao.tutanota.ctrl.PasswordChannelViewModel.prototype.getNotificationMailLanguage = function() {
    if ( this.germanSelected()){
        return "de"
    }else {
       return "en";
    }
};
"use strict";

tutao.provide('tutao.tutanota.ctrl.ProgressDialogModel');

/**
 * The Model for the progress dialog. Only one progress dialog can be shown at any time because this view model is defined as singleton in the Locator.
 * @constructor
 */
tutao.tutanota.ctrl.ProgressDialogModel = function() {
    tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
    this.title = ko.observable(null);
    this.progress = ko.observable(0);
    this.showDialog = ko.observable(false);
};

/**
 * Shows the progress dialog.
 * @param {string} titleId The message id for the title.
 */
tutao.tutanota.ctrl.ProgressDialogModel.prototype.open = function(titleId) {
    this.title(titleId);
    this.progress(0);
    this.showDialog(true);
};

/**
 * Closes the progress dialog.
 */
tutao.tutanota.ctrl.ProgressDialogModel.prototype.close = function() {
    this.showDialog(false);
};

/**
 * Updates the progress in the dialog.
 * @param {number} progress Progress between 0 and 100.
 */
tutao.tutanota.ctrl.ProgressDialogModel.prototype.updateProgress = function(progress) {
    this.progress(progress);
};


"use strict";

tutao.provide('tutao.tutanota.ctrl.RecipientInfo');

/**
 * A recipient bubble represents a recipient from a contact or from a pure email address.
 * @param {string} mailAddress The email address to use as recipient.
 * @param {string} name The name that shall be used for the recipient.
 * @param {tutao.entity.tutanota.ContactWrapper=} contactWrapper The contact to use for recipient info.
 * @param {Boolean=} external Optional. True if the recipient is external, false otherwise. If not set, this information is requested from the server.
 * @constructor
 */
tutao.tutanota.ctrl.RecipientInfo = function(mailAddress, name, contactWrapper, external) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	this._mailAddress = mailAddress;
	this._name = name;
    this._type = ko.observable(tutao.tutanota.ctrl.RecipientInfo.TYPE_UNKNOWN);
	if (external === false || tutao.util.StringUtils.endsWith(this._mailAddress, "tutanota.de")) {
		this._type(tutao.tutanota.ctrl.RecipientInfo.TYPE_INTERNAL);
	} else if (external === true) {
        this._type(tutao.tutanota.ctrl.RecipientInfo.TYPE_EXTERNAL);
	}
	if (!contactWrapper) {
		this._contactWrapper = tutao.entity.tutanota.ContactWrapper.createEmptyContactWrapper();
	} else {
		this._contactWrapper = contactWrapper;
	}

    this._deleted = false;
    this._editableContact = null;

    this._createEditingContact();

    // query the server to find the recipient type
    var self = this;
};

/**
 * Not yet known if internal or external (server is currently queried).
 * @type {number}
 */
tutao.tutanota.ctrl.RecipientInfo.TYPE_UNKNOWN = 0;
/**
 * An internal recipient.
 * @type {number}
 */
tutao.tutanota.ctrl.RecipientInfo.TYPE_INTERNAL = 1;
/**
 * An external recipient.
 * @type {number}
 */
tutao.tutanota.ctrl.RecipientInfo.TYPE_EXTERNAL = 2;

tutao.tutanota.ctrl.RecipientInfo.prototype._createEditingContact = function() {
    this._editableContact = this._contactWrapper.startEditingContact(this);
    if (!this.isExistingContact()) {
        // prepare some contact information. it is only saved if the mail is sent securely
        // use the name or mail address to extract first and last name. first part is used as first name, all other parts as last name
        var nameData = [];
        var addr = this._mailAddress.substring(0, this._mailAddress.indexOf("@"));
        if (this._name != "") {
            nameData = this._name.split(" ");
        } else if (addr.indexOf(".") != -1) {
            nameData = addr.split(".");
        } else if (addr.indexOf("_") != -1) {
            nameData = addr.split("_");
        } else if (addr.indexOf("-") != -1) {
            nameData = addr.split("-");
        } else {
            nameData = [addr];
        }
        // first character upper case
        for (var i = 0; i < nameData.length; i++) {
            if (nameData[i].length > 0) {
                nameData[i] = nameData[i].substring(0, 1).toUpperCase() + nameData[i].substring(1);
            }
        }

        this._editableContact.firstName(nameData[0]);
        this._editableContact.lastName(nameData.slice(1).join(" "));

        var newma = new tutao.entity.tutanota.ContactMailAddress(this._contactWrapper.getContact());
        newma.setAddress(this._mailAddress);
        newma.setType(tutao.entity.tutanota.TutanotaConstants.CONTACT_MAIL_ADDRESS_TYPE_OTHER);
        newma.setCustomTypeName("");
        this._editableContact.mailAddresses.push(new tutao.entity.tutanota.ContactMailAddressEditable(newma));
    }
    // Ensure that external users always have a pre shared password to avoid using of automatic transfer password in SendMailFacade
    if ( tutao.locator.userController.isLoggedInUserFreeAccount() && this._editableContact.presharedPassword() == null){
        this._editableContact.presharedPassword("");
    }
};

/**
 * Must be called before this recipient info is deleted. Stops editing the contact.
 */
tutao.tutanota.ctrl.RecipientInfo.prototype.setDeleted = function() {
    this._deleted = true;
    this._contactWrapper.stopEditingContact(this);
};

/**
 * Provides the text to display for this recipient.
 * @return {string} The text.
 */
tutao.tutanota.ctrl.RecipientInfo.prototype.getDisplayText = function() {
	return (this._name == "") ? this._mailAddress : this._name;
};

/**
 * Provides the mail address of this recipient..
 * @return {string} The mail address.
 */
tutao.tutanota.ctrl.RecipientInfo.prototype.getMailAddress = function() {
	return this._mailAddress;
};

/**
 * Provides the name of this recipient. The name might be an empty string.
 * @return {string} The name.
 */
tutao.tutanota.ctrl.RecipientInfo.prototype.getName = function() {
	return this._name;
};

/**
 * Provides the contact of this recipient.
 * @return {tutao.entity.tutanota.ContactWrapper} The wrapped contact.
 */
tutao.tutanota.ctrl.RecipientInfo.prototype.getContactWrapper = function() {
	return this._contactWrapper;
};

/**
 * Provides the editable contact of this recipient.
 * @return {tutao.entity.tutanota.ContactEditable} The editable contact.
 */
tutao.tutanota.ctrl.RecipientInfo.prototype.getEditableContact = function() {
	return this._editableContact;
};

/**
 * Returns true if the contact in this recipient info is from the users contact list.
 * @return {boolean} True if the contact is already existing.
 */
tutao.tutanota.ctrl.RecipientInfo.prototype.isExistingContact = function() {
	return this._contactWrapper.getContact().getId() != null;
};

/**
 * Returns true if this recipient is secure. It is secure if it is internal or at least one valid password channel is available for an external. Unknown recipients are regarded as secure.
 * @return {boolean} If the recipient is secure.
 */
tutao.tutanota.ctrl.RecipientInfo.prototype.isSecure = function() {
	if (!this.isExternal()) {
		return true;
	}
	if (this._editableContact.presharedPassword() != null && this._editableContact.presharedPassword().trim() != "") {
		return true;
	}
	for (var i = 0; i < this._editableContact.phoneNumbers().length; i++) {
		if (tutao.tutanota.ctrl.RecipientInfo.isValidMobileNumber(this._editableContact.phoneNumbers()[i].number())) {
			return true;
		}
	}
	return false;
};

/**
 * Returns true if this recipient is an external recipient.
 * @return {boolean} If the recipient is external.
 */
tutao.tutanota.ctrl.RecipientInfo.prototype.isExternal = function() {
	return (this._type() == tutao.tutanota.ctrl.RecipientInfo.TYPE_EXTERNAL);
};

/**
 * Returns the recipient type, one of tutao.tutanota.ctrl.RecipientInfo.*.
 * @return {number} The recipient type.
 */
tutao.tutanota.ctrl.RecipientInfo.prototype.getRecipientType = function() {
    return this._type();
};

/**
 * Checks if the given phone number is a valid mobile number that can be used as password channel.
 * @param {string} number The number to check.
 * @return {Boolean} True if the number is a valid mobile number, false otherwise.
 */
tutao.tutanota.ctrl.RecipientInfo.isValidMobileNumber = function(number) {
	return tutao.tutanota.util.Formatter.isGermanMobilePhoneNumber(tutao.tutanota.util.Formatter.getCleanedPhoneNumber(number));
};

/**
 * Checks if the phone numbers of the recipient have been changed.
 * @returns {boolean} True if one of the phone numbers have been changed otherwise false
 */
tutao.tutanota.ctrl.RecipientInfo.prototype.hasPhoneNumberChanged = function() {
    var editedPhoneNumbers = this.getEditableContact().phoneNumbers();
    var originPhoneNumbers = this.getContactWrapper().getContact().getPhoneNumbers();

    if ( editedPhoneNumbers.length != originPhoneNumbers.length ){
        return true;
    }else{
        for ( var i=0; i< editedPhoneNumbers.length; i++ ){
            if ( editedPhoneNumbers[i].getContactPhoneNumber().getNumber() != originPhoneNumbers[i].getNumber()){
                return true;
            }
        }
    }
    return false;
};

/**
 * Checks if the pre shared password of this recipient has been changed,
 * @returns {boolean} True if the password has been changed.
 */
tutao.tutanota.ctrl.RecipientInfo.prototype.hasPasswordChanged = function() {
    var editedPassword = this.getEditableContact().presharedPassword();
    var originPassword = this.getContactWrapper().getContact().getPresharedPassword();
    return editedPassword != originPassword;
};

/**
 * @return {Promise} Resolves when the recipient type has been resolved
 */
tutao.tutanota.ctrl.RecipientInfo.prototype.resolveType = function () {
    var self = this;
    if (this._type() == tutao.tutanota.ctrl.RecipientInfo.TYPE_UNKNOWN) {
        return tutao.entity.sys.PublicKeyReturn.load(new tutao.entity.sys.PublicKeyData().setMailAddress(self.getMailAddress()), {}, null).then(function(publicKeyData) {
            // do not update any field if this recipient is already deleted, because this._type is subscribed above and might trigger editing a contact otherwise
            if (!self._deleted) {
                self._type(tutao.tutanota.ctrl.RecipientInfo.TYPE_INTERNAL);
            }
        }).caught(tutao.NotFoundError, function(e) {
            if (!self._deleted) {
                self._type(tutao.tutanota.ctrl.RecipientInfo.TYPE_EXTERNAL);
            }
        });
    } else {
        return Promise.resolve();
    }
};
"use strict";

tutao.provide('tutao.tutanota.ctrl.RegistrationDataListViewModel');

/**
 * Handles the registration data in Tutanota.
 * @constructor
 */
tutao.tutanota.ctrl.RegistrationDataListViewModel = function(systemInstance) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	this.registrationDataList = ko.observableArray();

	this.company = ko.observable("");
	this.domain = ko.observable("");
	this.accountTypes = [{id: '2', name: 'Starter'}, {id: '1', name: 'Free'}];
    this.language = ko.observable("de");
	this.selectedAccountType = ko.observable("");
	this.groupName = ko.observable("");
	this.mobilePhoneNumber = ko.observable("");
	this.phoneNumber = ko.observable("");
	this.mailAddress = ko.observable("");
	
	this._listId = ko.observable(systemInstance.getRegistrationDataList());

    this.loading = ko.observable(false);
    this.moreAvailable = ko.observable(true);
};

tutao.tutanota.ctrl.RegistrationDataListViewModel.STEP_RANGE_COUNT = 200;

tutao.tutanota.ctrl.RegistrationDataListViewModel.prototype.show = function() {
    this.registrationDataList([]);
    this.loadMore();
};


tutao.tutanota.ctrl.RegistrationDataListViewModel.prototype.loadMore = function() {
    var self = this;
    if (this.loading()) {
        return Promise.resolve();
    }
    this.loading(true);
    var lowestId = tutao.rest.EntityRestInterface.CUSTOM_MIN_ID;
    if (this.registrationDataList().length > 0) {
        var lastRegData = this.registrationDataList()[this.registrationDataList().length - 1];
        lowestId = tutao.rest.EntityRestInterface.getElementId(lastRegData);
    }

    return tutao.entity.sys.RegistrationData.loadRange(this._listId(), lowestId, tutao.tutanota.ctrl.RegistrationDataListViewModel.STEP_RANGE_COUNT, false).then(function(regData) {
        self.moreAvailable(regData.length == tutao.tutanota.ctrl.RegistrationDataListViewModel.STEP_RANGE_COUNT);
        for (var i = 0; i < regData.length; i++) {
            self.registrationDataList.push(regData[i]);
        }
    }).lastly(function(){
        self.loading(false);
    });
};
tutao.tutanota.ctrl.RegistrationDataListViewModel.prototype.reset = function() {
	this.company("");
	this.domain("");
	this.selectedAccountType("");
	this.groupName("");
	this.mobilePhoneNumber("");
	this.phoneNumber("");
	this.mailAddress("");
};

tutao.tutanota.ctrl.RegistrationDataListViewModel.prototype.getUrl = function(id) {
	return document.location.protocol + "//" + document.location.hostname + ":" + document.location.port + "/#register/" + tutao.rest.ResourceConstants.AUTH_TOKEN_PARAMETER_NAME + "=" + id;
};

tutao.tutanota.ctrl.RegistrationDataListViewModel.prototype.getAccountTypeName = function(typeId) {
	if (typeId == "1") {
		return "Free";
	} else if (typeId == "2") {
		return "Starter";
	} else if (typeId == "3") {
		return "Premium";
	} else if (typeId == "4") {
		return "Stream";
	}
};

tutao.tutanota.ctrl.RegistrationDataListViewModel.prototype.getStateName = function(stateId) {
	if (stateId == "0") {
		return "Initial";
    } else if (stateId == "1") {
		return "CodeSent";
	} else if (stateId == "2") {
		return "CodeVerified";
	} else if (stateId == "3") {
		return "Registered";
	}
};


/**
 * Adds a new registration data entry
 */
tutao.tutanota.ctrl.RegistrationDataListViewModel.prototype.add = function() {
	var regData = new tutao.entity.sys.RegistrationServiceData()
		.setAccountType(this.selectedAccountType())
        .setLanguage(this.language())
		.setCompany(this.company())
		.setDomain(this.domain())
		.setGroupName(this.groupName())
		.setMobilePhoneNumber(this.mobilePhoneNumber())
		.setMailAddress(this.mailAddress())
		.setState(tutao.entity.tutanota.TutanotaConstants.REGISTRATION_STATE_INITIAL);
	var self = this;
	var authToken = regData.setup({}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(registrationReturn) {
        // Workaround as re-loading a range does not work under all circumstances if the id is custom
        tutao.entity.sys.RegistrationData.load([self._listId(),registrationReturn.getAuthToken()]).then(function(element) {
            self.registrationDataList.push(element);
        });
        self.reset();
	});
	return false;
};

/**
 * removes a registration data entry
 */
tutao.tutanota.ctrl.RegistrationDataListViewModel.prototype.remove = function(element) {
	if (tutao.tutanota.gui.confirm("Really delete?")) {
		element.erase(function() {});
		this.registrationDataList.remove(element);
	}
	return false;
};

/**
 * sends the domain verification mail to the requesting user
 */
tutao.tutanota.ctrl.RegistrationDataListViewModel.prototype.sentDomainVerificationMail = function(element) {
    if (tutao.tutanota.gui.confirm("Really send domain verification mail?")) {
        var input = new tutao.entity.sys.RegistrationVerifyDomainDataPut()
            .setAuthToken(element.getId()[1]);
        input.update({}, null).then(function() {
            return tutao.entity.sys.RegistrationData.load(element.getId()).then(function(regData) {
                element.setDomainVerificationMailSentOn(regData.getDomainVerificationMailSentOn());
            });
        });
    }
    return false;
};



"use strict";

tutao.provide('tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel');

/**
 * The ViewModel for the pre-registration template.
 * @constructor
 */
tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

	this.domain = ko.observable("");
    this.domainFieldFocused = ko.observable(false);
	this.currentMailAddressPrefix = ko.observable("postmaster");
	this.currentMailAddressStatus = ko.observable({ type: "neutral", text: "mailAddressNeutral_msg"});
    this.currentMailAddressStatus = ko.computed(function() {
        if (this.currentMailAddressPrefix().trim() == "") {
            return { type: "neutral", text: "mailAddressNeutral_msg" };
        } else if (this.isValidMailAddress()) {
            return { type: "valid", text: "mailAddressValid_msg" };
        } else {
            return { type: "invalid", text: "mailAddressInvalid_msg" };
        }
    }, this);

    this.state = ko.observable(tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.PROCESS_STATE_NOT_RUNNING);

    this.verifyDomainStatus = ko.computed(function() {
        if (this.state() === tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.PROCESS_STATE_RUNNING) {
            return { type: "neutral", text: "verifyDomainRunning_msg" };
        } else {
            return { type: "neutral", text: "verifyDomainNeutral_msg" };
        }
    }, this);
};

tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.PROCESS_STATE_NOT_RUNNING = 0;
tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.PROCESS_STATE_RUNNING = 1;
tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.PROCESS_STATE_FINISHED = 2;
tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.PROCESS_STATE_DISABLED = 4;

/**
 * Sets the focus when the view is shown.
 */
tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.prototype.activate = function() {
	var self = this;
    var parameters = {};
    tutao.entity.sys.RegistrationConfigReturn.load(parameters, null).then(function(registrationConfigReturn) {
        if(registrationConfigReturn.getStarterEnabled()){
            setTimeout(function() {
                self.domainFieldFocused(true);
            }, 0);
        }else {
            self.state(tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.PROCESS_STATE_DISABLED);
        }
    });
};

tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.prototype.getRegistrationType = function() {
	return 'Starter';
};

tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.prototype.isValidMailAddress = function() {
	return tutao.tutanota.util.Formatter.isMailAddress(this.getMailAddress());
};
tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.prototype.getMailAddress = function () {
    return tutao.tutanota.util.Formatter.getCleanedMailAddress(this.currentMailAddressPrefix() + "@" + this.domain());
};

tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.prototype.getDomain = function () {
    return this.domain().trim().toLowerCase();
};


tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.prototype.isFormEditable = function() {
	return (this.state() != tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.PROCESS_STATE_RUNNING);
};

tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.prototype.isVerifyDomainPossible = function() {
    return this.isFormEditable()
        && this.currentMailAddressStatus().type == "valid";
};

tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.prototype.verifyDomain = function() {
    var self = this;
    if (!this.isVerifyDomainPossible()) {
        return;
    }
    self.state(tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.PROCESS_STATE_RUNNING);
    var data = new tutao.entity.sys.RegistrationVerifyDomainDataPost()
        .setLanguage(tutao.locator.languageViewModel.getCurrentLanguage())
        .setCurrentAdminMailAddress(this.getMailAddress())
        .setup({}, null).then(function(returnData, exception) {
            self.verificationMailSent = returnData.getMailSent();
            self.state(tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.PROCESS_STATE_FINISHED);
        }).caught(function(e) {
            self.state(tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.PROCESS_STATE_NOT_RUNNING);
            throw e;
        });
};

tutao.tutanota.ctrl.RegistrationVerifyDomainViewModel.prototype.getFinishedMessage = function() {
    if(this.currentMailAddressPrefix().trim().toLowerCase() == "postmaster"
        ||this.currentMailAddressPrefix().trim().toLowerCase() == "hostmaster") {
        return 'verifyDomainMailSent_msg';
    } else {
        return 'verifyDomainStaffInformed_msg';
    }
};






"use strict";

tutao.provide('tutao.tutanota.ctrl.RegistrationViewModel');

/**
 * The ViewModel for the registration template.
 * @constructor
 */
tutao.tutanota.ctrl.RegistrationViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

    this.pageStatus = ko.observable(tutao.tutanota.ctrl.RegistrationViewModel.PAGE_STATUS_LOADING);
    // if registration shall be deactivated for specific devices, use the following line
    // this.pageStatus(tutao.tutanota.ctrl.RegistrationViewModel.PAGE_STATUS_NOT_SUPPORTED);
	this.authToken = ko.observable("");
	this.accountType = ko.observable("0"); // set to invalid account type for indicating that the account type is not known
	this.companyName = ko.observable("");
	this.domain = ko.observable("tutanota.de");

	this.mobileNumber = ko.observable("");
    this.mobileNumberStatus = ko.observable({ type: "neutral", text: "mobileNumberNeutral_msg" });
    this.lastCheckedNumber = null;
    this.mobileNumber.subscribe(function(newValue) {
        if (newValue == "") {
            this.lastCheckedNumber = null;
            this.mobileNumberStatus({ type: "neutral", text: "mobileNumberNeutral_msg" });
        } else  if (newValue.substring(0, 1) != "+") {
            this.lastCheckedNumber = null;
            this.mobileNumberStatus({ type: "invalid", text: "mobileNumberNoCountryCode_msg" });
        } else if (this.lastCheckedNumber != newValue) {
            this.lastCheckedNumber = newValue;
            var cleaned = tutao.tutanota.util.Formatter.getCleanedPhoneNumber(newValue);
            if (cleaned == null) {
                this.mobileNumberStatus({ type: "invalid", text: "mobileNumberInvalid_msg" });
            } else {
                var self = this;
                tutao.entity.sys.PhoneNumberTypeReturn.load(new tutao.entity.sys.PhoneNumberTypeData().setPhoneNumber(cleaned), {}, []).then(function(result) {
                    if (result.getType() == tutao.entity.tutanota.TutanotaConstants.PHONE_NUMBER_TYPE_MOBILE || result.getType() == tutao.entity.tutanota.TutanotaConstants.PHONE_NUMBER_TYPE_UNKNOWN) {
                        self.mobileNumberStatus({ type: "valid", text: "mobileNumberValid_msg" });
                    } else {
                        self.mobileNumberStatus({ type: "invalid", text: "mobileNumberInvalid_msg" });
                    }
                });
            }
        }
    }, this);

	this.mailAddressPrefix = ko.observable("");
	this.mailAddressStatus = ko.observable({ type: "neutral", text: "mailAddressNeutral_msg"});

	this.password1 = ko.observable("");
	this.password2 = ko.observable("");
	this.termsAccepted = ko.observable(false);

	this.joinStatus = ko.observable({ type: "neutral", text: "joinNeutral_msg" });

	this._keyGenProgress = ko.observable(0);

	this._createAccountState = ko.observable(tutao.tutanota.ctrl.RegistrationViewModel.PROCESS_STATE_NOT_RUNNING);
    this._createAccountState.subscribe(function () {
        if (this._createAccountState() == tutao.tutanota.ctrl.RegistrationViewModel.PROCESS_STATE_RUNNING) {
            tutao.locator.progressDialogModel.open("createAccountRunning_msg");
        } else {
            tutao.locator.progressDialogModel.close();
        }

    }, this);

};

tutao.tutanota.ctrl.RegistrationViewModel.PAGE_STATUS_OK = 0;
tutao.tutanota.ctrl.RegistrationViewModel.PAGE_STATUS_INVALID_LINK = 1;
tutao.tutanota.ctrl.RegistrationViewModel.PAGE_STATUS_LOADING = 2;
tutao.tutanota.ctrl.RegistrationViewModel.PAGE_STATUS_NOT_SUPPORTED = 3;
tutao.tutanota.ctrl.RegistrationViewModel.PAGE_STATUS_DISABLED = 4;

tutao.tutanota.ctrl.RegistrationViewModel.PROCESS_STATE_NOT_RUNNING = 0;
tutao.tutanota.ctrl.RegistrationViewModel.PROCESS_STATE_RUNNING = 1;
tutao.tutanota.ctrl.RegistrationViewModel.PROCESS_STATE_FINISHED = 2;

tutao.tutanota.ctrl.RegistrationViewModel.MINIMUM_MAIL_ADDRESS_PREFIX_LENGTH = 4;

tutao.tutanota.ctrl.RegistrationViewModel.prototype.activate = function(authToken) {
    var self = this;

    if (this.pageStatus() == tutao.tutanota.ctrl.RegistrationViewModel.PAGE_STATUS_NOT_SUPPORTED) {
        return;
    }
    // setting the focus into the name field here with knockout focus binding results in too small scrollable registration div

    self._activate(authToken);
};

tutao.tutanota.ctrl.RegistrationViewModel.prototype._activate = function(authToken) {
    var self = this;
    if (authToken) {
        this.authToken(authToken);
        var params = {};
        params[tutao.rest.ResourceConstants.AUTH_ID_PARAMETER_NAME] = authToken;
        tutao.entity.sys.RegistrationServiceData.load(params, null).then(function(data) {
            self.accountType(data.getAccountType());
            if (self.accountType() == tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_FREE) {
                self.mailAddressPrefix.subscribe(self._verifyMailAddressFree, this);
            } else {
                self.mailAddressPrefix.subscribe(self._verifyMailAddressStarter, this);
            }
            self.domain(data.getDomain());
            self.companyName(data.getCompany());
            self.mailAddressPrefix(data.getMailAddress().substring(0, data.getMailAddress().indexOf("@")));
            self.mobileNumber(data.getMobilePhoneNumber());
            self.pageStatus(tutao.tutanota.ctrl.RegistrationViewModel.PAGE_STATUS_OK);
        }).caught(tutao.NotFoundError, function (exception) {
            self.pageStatus(tutao.tutanota.ctrl.RegistrationViewModel.PAGE_STATUS_INVALID_LINK);
        }).caught(tutao.BadRequestError, function (exception) {
            self.pageStatus(tutao.tutanota.ctrl.RegistrationViewModel.PAGE_STATUS_INVALID_LINK);
        });
    } else {
        var parameters = {};
        tutao.entity.sys.RegistrationConfigReturn.load(parameters, null).then(function(registrationConfigReturn) {
            if (registrationConfigReturn.getFreeEnabled()) {
                self.accountType(tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_FREE);
                self.mailAddressPrefix.subscribe(self._verifyMailAddressFree, self);
                self.pageStatus(tutao.tutanota.ctrl.RegistrationViewModel.PAGE_STATUS_OK);
            } else {
                self.pageStatus(tutao.tutanota.ctrl.RegistrationViewModel.PAGE_STATUS_DISABLED);
            }
        });

    }
};



tutao.tutanota.ctrl.RegistrationViewModel.prototype.getRegistrationType = function() {
    if (this.accountType() == tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_FREE) {
		return 'Free';
	} else if (this.accountType() == tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_STARTER) {
		return 'Starter';
	} else {
        return ''; // unknown account type
    }
};

tutao.tutanota.ctrl.RegistrationViewModel.prototype.isMobileNumberValid = function() {
    return (this.mobileNumberStatus().type == "valid");
};

tutao.tutanota.ctrl.RegistrationViewModel.prototype.isValidMailAddress = function() {
    return tutao.tutanota.util.Formatter.isMailAddress(this.getMailAddress());
};

/**
 * Provides the status of the first entered new password.
 * @return {Object} The status containing type and text id.
 */
tutao.tutanota.ctrl.RegistrationViewModel.prototype.getPassword1Status = function() {
	if (this.password1() == "") {
		return { type: "neutral", text: "password1Neutral_msg" };
	} else if (this.getPasswordStrength() >= 80) {
		return { type: "valid", text: "passwordValid_msg" };
	} else {
		return { type: "invalid", text: "password1InvalidUnsecure_msg" };
	}
};

/**
 * Provides the status of the second entered new password.
 * @return {Object} The status containing type and text id.
 */
tutao.tutanota.ctrl.RegistrationViewModel.prototype.getPassword2Status = function() {
	if (this.password2() == "") {
		return { type: "neutral", text: "password2Neutral_msg" };
	} else if (this.password1() == this.password2()) {
		return { type: "valid", text: "passwordValid_msg" };
	} else {
		return { type: "invalid", text: "password2Invalid_msg" };
	}
};

tutao.tutanota.ctrl.RegistrationViewModel.prototype.getPasswordStrength = function() {
	return tutao.tutanota.util.PasswordUtils.getPasswordStrength(this.password1(), [this.mailAddressPrefix(), this.companyName(), this.domain()]);
};

tutao.tutanota.ctrl.RegistrationViewModel.prototype.getTermsStatus = function() {
	if (!this.termsAccepted()) {
		return { type: "neutral", text: "termsAcceptedNeutral_msg" };
	} else {
		return { type: "valid", text: "emptyString_msg" };
	}
};

tutao.tutanota.ctrl.RegistrationViewModel.prototype.getKeyGenerationProgress = function() {
	return this._keyGenProgress();
};


// STEP 2

tutao.tutanota.ctrl.RegistrationViewModel.prototype.getCreateAccountState = function() {
	return this._createAccountState();
};

tutao.tutanota.ctrl.RegistrationViewModel.prototype.isCreateAccountPossible = function() {
    return  ((this._createAccountState() == tutao.tutanota.ctrl.RegistrationViewModel.PROCESS_STATE_NOT_RUNNING) &&
        (this.mailAddressStatus().type == "valid") &&
        (this.getPassword1Status().type == "valid") &&
        (this.getPassword2Status().type == "valid") &&
        this.termsAccepted());
};

tutao.tutanota.ctrl.RegistrationViewModel.prototype.isCreatingAccount = function() {
	return this._createAccountState() == tutao.tutanota.ctrl.RegistrationViewModel.PROCESS_STATE_RUNNING;
};

tutao.tutanota.ctrl.RegistrationViewModel.prototype.createAccount = function() {
    var self = this;
    if (!this.isCreateAccountPossible()) {
        return;
    }
    self._createAccountState(tutao.tutanota.ctrl.RegistrationViewModel.PROCESS_STATE_RUNNING);

	tutao.locator.entropyCollector.fetchMissingEntropy(function() {
		self._generateKeys().then(function() {
            tutao.locator.navigator.logout(false, false); // the user is still logged in at this moment. This is why the navigator will re-initialize the whole application.
            setTimeout(function() {
                tutao.locator.loginViewModel.setMailAddress(self.getMailAddress());
                tutao.locator.loginViewModel.setWelcomeTextId("afterRegistration_msg");
            }, 0);
        }).caught(tutao.TooManyRequestsError, function(e) {
            self._createAccountState(tutao.tutanota.ctrl.RegistrationViewModel.PROCESS_STATE_FINISHED);
            tutao.gui.showDialog()
            tutao.tutanota.gui.alert( tutao.lang("createAccountTooManyAttempts_msg" ));
        }).caught(tutao.LimitReachedError, function(e) {
            self._createAccountState(tutao.tutanota.ctrl.RegistrationViewModel.PROCESS_STATE_NOT_RUNNING);
            tutao.tutanota.gui.alert( tutao.lang("createAccountTooManyAccountsError_msg" ));
        }).lastly(function() {
            tutao.locator.progressDialogModel.progress(0);
            self._createAccountState(tutao.tutanota.ctrl.RegistrationViewModel.PROCESS_STATE_NOT_RUNNING);
        });
	});
};

/**
 *
 * @param {tutao.entity.sys.SystemKeysReturn} keyData
 * @returns {string} the group key for the current account type
 * @private
 */
tutao.tutanota.ctrl.RegistrationViewModel.prototype._getAccountGroupKey = function (keyData) {
    if (this.accountType() == tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_FREE) {
        return keyData.getFreeGroupKey();
    } else if (this.accountType() == tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_STARTER) {
        return keyData.getStarterGroupKey();
    } else {
        throw Error("Illegal account type");
    }
};

tutao.tutanota.ctrl.RegistrationViewModel.prototype._generateKeys = function() {
	var self = this;
	return tutao.entity.sys.SystemKeysReturn.load({}, null).then(function(keyData) {
		var systemAdminPubKeyBase64 = keyData.getSystemAdminPubKey();
		var systemAdminPubKeyVersion = keyData.getSystemAdminPubKeyVersion();

		var salt = tutao.locator.kdfCrypter.generateRandomSalt();
		return tutao.locator.kdfCrypter.generateKeyFromPassphrase(self.password1(), salt).then(function(userPassphraseKeyHex) {
			tutao.locator.progressDialogModel.progress(5);
			var userPassphraseKey = tutao.locator.aesCrypter.hexToKey(userPassphraseKeyHex);

            var adminGroupsListKey = tutao.locator.aesCrypter.generateRandomKey();
			return tutao.tutanota.ctrl.GroupData.generateGroupKeys("admin", "", null, null, adminGroupsListKey).spread(function(adminGroupData, adminGroupKey) {
				tutao.locator.progressDialogModel.progress(35);
                var userGroupsListKey = tutao.locator.aesCrypter.generateRandomKey();
				return tutao.tutanota.ctrl.GroupData.generateGroupKeys("", self.getMailAddress(), userPassphraseKey, adminGroupKey, userGroupsListKey).spread(function(userGroupData, userGroupKey) {
					tutao.locator.progressDialogModel.progress(65);
					// encrypt the admin key with the user key, because the user key was not available before
					adminGroupData.setSymEncGKey(tutao.locator.aesCrypter.encryptKey(userGroupKey, adminGroupKey));

                    var customerGroupsListKey = tutao.locator.aesCrypter.generateRandomKey();
					return tutao.tutanota.ctrl.GroupData.generateGroupKeys("customer", "", userGroupKey, adminGroupKey, customerGroupsListKey).spread(function(customerGroupData, customerGroupKey) {
						tutao.locator.progressDialogModel.progress(95);
                        var accountingInfoSessionKey = tutao.locator.aesCrypter.generateRandomKey();
						var accountingInfoBucketKey = tutao.locator.aesCrypter.generateRandomKey();

						var clientKey = tutao.locator.aesCrypter.generateRandomKey();

						var symEncAccountGroupKey = tutao.locator.aesCrypter.encryptKey(userGroupKey, tutao.locator.aesCrypter.hexToKey(tutao.util.EncodingConverter.base64ToHex(self._getAccountGroupKey(keyData))));

						var systemAdminPubKey = tutao.locator.rsaCrypter.hexToKey(tutao.util.EncodingConverter.base64ToHex(systemAdminPubKeyBase64));

                        return new Promise(function(resolve, reject) {
                            tutao.locator.rsaCrypter.encryptAesKey(systemAdminPubKey, tutao.locator.aesCrypter.keyToHex(accountingInfoBucketKey), function(systemAdminPubEncCustomerBucketKey, exception) {
                                tutao.locator.progressDialogModel.progress(97);
                                if (exception) {
                                    reject(exception);
                                    return;
                                }

                                var teamGroupsListKey = tutao.locator.aesCrypter.generateRandomKey();

                                var customerService = new tutao.entity.sys.CustomerData();
                                customerService.setAuthToken(self.authToken())
                                    .setCompany(self.companyName())
                                    .setDomain(self.domain())
                                    .setAdminGroupList(new tutao.entity.sys.CreateGroupListData(customerService)
                                        .setCustomerEncGroupInfoListKey(tutao.locator.aesCrypter.encryptKey(customerGroupKey, adminGroupsListKey))
                                        .setAdminEncGroupInfoListKey(tutao.locator.aesCrypter.encryptKey(adminGroupKey, adminGroupsListKey))
                                        .setCreateGroupData(adminGroupData))
                                    .setUserGroupList(new tutao.entity.sys.CreateGroupListData(customerService)
                                        .setCustomerEncGroupInfoListKey(tutao.locator.aesCrypter.encryptKey(customerGroupKey, userGroupsListKey))
                                        .setAdminEncGroupInfoListKey(tutao.locator.aesCrypter.encryptKey(adminGroupKey, userGroupsListKey))
                                        .setCreateGroupData(userGroupData))
                                    .setCustomerGroupList(new tutao.entity.sys.CreateGroupListData(customerService)
                                        .setCustomerEncGroupInfoListKey(tutao.locator.aesCrypter.encryptKey(customerGroupKey, customerGroupsListKey))
                                        .setAdminEncGroupInfoListKey(tutao.locator.aesCrypter.encryptKey(adminGroupKey, customerGroupsListKey))
                                        .setCreateGroupData(customerGroupData))
                                    .setTeamGroupList(new tutao.entity.sys.CreateGroupListData(customerService)
                                        .setCustomerEncGroupInfoListKey(tutao.locator.aesCrypter.encryptKey(customerGroupKey, teamGroupsListKey))
                                        .setAdminEncGroupInfoListKey(tutao.locator.aesCrypter.encryptKey(adminGroupKey, teamGroupsListKey)))

                                    .setAdminEncAccountingInfoSessionKey(tutao.locator.aesCrypter.encryptKey(adminGroupKey, accountingInfoSessionKey))
                                    .setUserEncClientKey(tutao.locator.aesCrypter.encryptKey(userGroupKey, clientKey))
                                    .setAccountingInfoBucketEncAccountingInfoSessionKey(tutao.locator.aesCrypter.encryptKey(accountingInfoBucketKey, accountingInfoSessionKey))
                                    .setSystemCustomerPubEncAccountingInfoBucketKey(systemAdminPubEncCustomerBucketKey)
                                    .setSystemCustomerPubKeyVersion(systemAdminPubKeyVersion)
                                    .setSalt(tutao.util.EncodingConverter.hexToBase64(salt))
                                    .setVerifier(tutao.locator.shaCrypter.hashHex(userPassphraseKeyHex))
                                    .setSymEncAccountGroupKey(symEncAccountGroupKey);

                                resolve(customerService.setup({}, null).then(function(adminUserData) {
                                    return tutao.locator.userController.loginUser(userGroupData.getMailAddress(), self.password1()).then(function() {
                                        //TODO (before release) create root instances and welcome mail before next login if it failed here
                                        return tutao.tutanota.ctrl.AdminNewUser.initGroup(adminUserData.getAdminUserGroup(), userGroupKey).then(function() {
                                            if (self.accountType() == tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_FREE) {
                                                new tutao.entity.tutanota.WelcomeMailData()
                                                    .setLanguage(tutao.locator.languageViewModel.getCurrentLanguage())
                                                    .setup({}, tutao.entity.EntityHelper.createAuthHeaders(), function() {});
                                            }
                                            tutao.locator.progressDialogModel.progress(100);
                                        });
                                    });
                                }));
                            });
                        });

					});
				});
			});
		});
	});
};

tutao.tutanota.ctrl.RegistrationViewModel.prototype._verifyMailAddressFree = function(newValue) {
	var self = this;
    var cleanedValue = newValue.toLowerCase().trim();
    if (self.mailAddressPrefix().length < tutao.tutanota.ctrl.RegistrationViewModel.MINIMUM_MAIL_ADDRESS_PREFIX_LENGTH) {
        self.mailAddressStatus({ type: "invalid", text: "mailAddressInvalid_msg"});
        return;
    } else if (!self.isValidMailAddress()) {
        self.mailAddressStatus({ type: "invalid", text: "mailAddressInvalid_msg"});
        return;
    }

    self.mailAddressStatus({ type: "invalid", text: "mailAddressBusy_msg"});

    setTimeout(function() {
        if (self.mailAddressPrefix() == newValue) {
            var params = [];
            tutao.entity.sys.MailAddressAvailabilityReturn.load(new tutao.entity.sys.MailAddressAvailabilityData().setMailAddress(cleanedValue + "@" + self.domain()), params, []).then(function(mailAddressAvailabilityReturn) {
                if (self.mailAddressPrefix() == newValue) {
                    if (mailAddressAvailabilityReturn.getAvailable()) {
                        self.mailAddressStatus({ type: "valid", text: "mailAddressAvailable_msg"});
                    } else {
                        self.mailAddressStatus({ type: "invalid", text: "mailAddressNA_msg"});
                    }
                }
            }).caught(tutao.AccessDeactivatedError, function (exception) {
                self.mailAddressStatus({ type: "invalid", text: "mailAddressDelay_msg"});
            });
        }
    }, 500);
};

tutao.tutanota.ctrl.RegistrationViewModel.prototype._verifyMailAddressStarter = function(newValue) {
    var cleanedValue = newValue.toLowerCase();
    if (this.isValidMailAddress()) {
        this.mailAddressStatus({ type: "valid", text: "mailAddressAvailable_msg"})
    } else {
        this.mailAddressStatus({ type: "invalid", text: "mailAddressInvalid_msg"});
    }
};

tutao.tutanota.ctrl.RegistrationViewModel.prototype.getMailAddress = function () {
    return tutao.tutanota.util.Formatter.getCleanedMailAddress(this.mailAddressPrefix() + "@" + this.domain());
};

tutao.tutanota.ctrl.RegistrationViewModel.prototype.isFormEditable = function() {
    return (this.getCreateAccountState() == tutao.tutanota.ctrl.RegistrationViewModel.PROCESS_STATE_NOT_RUNNING);
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.SecuritySettingsViewModel');

/**
 * Displays the security settings. This view model is created dynamically.
 * @constructor
 */
tutao.tutanota.ctrl.SecuritySettingsViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

	this.records = [];
	this.records.push({ nameTextId: "lastSuccessfulLogin_label", infoTextId: "lastSuccessfulLoginInfo_msg", valueObservable: ko.observable("") });
	this.records.push({ nameTextId: "failedLogins_label", infoTextId: "failedLoginsInfo_msg", valueObservable: ko.observable("") });
	
	var self = this;
	var user = tutao.locator.userController.getLoggedInUser();
	tutao.entity.sys.Login.loadRange(user.getSuccessfulLogins(), tutao.rest.EntityRestInterface.GENERATED_MAX_ID, 2, true).then(function(logins) {
		var loginTimestamp = 0;
		if (logins.length < 2) {
			self.records[0].valueObservable("-");
			loginTimestamp = 0;
		} else {
			self.records[0].valueObservable(tutao.tutanota.util.Formatter.formatFullDateTime(logins[1].getTime()));
			loginTimestamp = logins[1].getTime().getTime();
		}
		var successfulLoginId = tutao.util.EncodingConverter.timestampToGeneratedId(loginTimestamp);
		tutao.entity.sys.Login.loadRange(user.getFailedLogins(), successfulLoginId, 100, false).then(function(failedLogins) {
            self.records[1].valueObservable(failedLogins.length);
		}).caught(function(exception) {
            self.records[1].valueObservable("?");
        });
	}).caught(function(exception) {
        self.records[0].valueObservable("?");
    });
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.SendMailFacade');

/**
 * Sends a secure mail to internal and external recipients. For external recipients the password and password channels must be set.
 * @param {string} subject The subject of the mail.
 * @param {string} bodyText The bodyText of the mail.
 * @param {string} senderName The name of the sender that is sent together with the mail address of the sender.
 * @param {Array.<tutao.tutanota.ctrl.RecipientInfo>} toRecipients The recipients the mail shall be sent to.
 * @param {Array.<tutao.tutanota.ctrl.RecipientInfo>} ccRecipients The recipients the mail shall be sent to in cc.
 * @param {Array.<tutao.tutanota.ctrl.RecipientInfo>} bccRecipients The recipients the mail shall be sent to in bcc.
 * @param {string} conversationType See TutanotaConstants.
 * @param {string} previousMessageId The id of the message that this mail is a reply or forward to. Null if this is a new mail.
 * @param {Array.<tutao.tutanota.util.DataFile>} attachments The new files that shall be attached to this mail.
 * @param {string} language Notification mail language.
 * @return {Promise.<string, tutao.RecipientsNotFoundError>} Resolved finished with the id of the senders mail (only element id, no list id). Rejected with a
 * RecipientsNotFoundError if some of the recipients could not be found
 */
tutao.tutanota.ctrl.SendMailFacade.sendMail = function(subject, bodyText, senderName, toRecipients, ccRecipients, bccRecipients, conversationType, previousMessageId, attachments, language) {
	var accountType = tutao.locator.userController.getLoggedInUser().getAccountType();
	if ((accountType != tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_FREE) && (accountType != tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_PREMIUM) && (accountType != tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_STARTER)) {
		return Promise.reject(new Error("invalid account type"));
	}

    var aes = tutao.locator.aesCrypter;
    var groupKey = tutao.locator.userController.getUserGroupKey();
    var bucketKey = aes.generateRandomKey();
    var mailBoxKey = tutao.locator.mailBoxController.getUserMailBox()._entityHelper.getSessionKey();

    var service = new tutao.entity.tutanota.SendMailData();
    service.setLanguage(language)
        .setSubject(subject)
        .setBodyText(bodyText)
        .setSenderName(senderName)
        .setSenderNameUnencrypted(senderName)
        .setListEncSessionKey(aes.encryptKey(mailBoxKey, service._entityHelper.getSessionKey())) // for sender
        .setSymEncSessionKey(aes.encryptKey(groupKey, service._entityHelper.getSessionKey())) // for sender
        .setBucketEncSessionKey(aes.encryptKey(bucketKey, service._entityHelper.getSessionKey())); // for recipeints

    if (tutao.locator.userController.isInternalUserLoggedIn()) {
        service.setSharableEncSessionKey(aes.encryptKey(tutao.locator.mailBoxController.getUserMailBoxBucketData().getBucketKey(), service._entityHelper.getSessionKey())); // for sharing the mailbox
    } else {
        service.setSharableEncSessionKey(null);
    }
    service.setConversationType(conversationType);
    service.setPreviousMessageId(previousMessageId);

    return Promise.each(attachments, function(dataFile) {
        var attachment = new tutao.entity.tutanota.Attachment(service);
        return tutao.tutanota.ctrl.SendMailFacade.createAttachment(attachment, dataFile).then(function(fileSessionKey) {
            attachment.setListEncFileSessionKey(aes.encryptKey(mailBoxKey, fileSessionKey))
                .setBucketEncFileSessionKey(aes.encryptKey(bucketKey, fileSessionKey));

            service.getAttachments().push(attachment);
        });
    }).then(function() {
        return tutao.tutanota.ctrl.SendMailFacade._handleRecipients(service, toRecipients, ccRecipients, bccRecipients, bucketKey);
    });
};

/**
 * Uploads the given data files or sets the file if it is already existing files (e.g. forwarded files)
 * @param {tutao.entity.tutanota.Attachment|tutao.entity.tutanota.UnsecureAttachment|tutao.entity.tutanota.AttachmentFromExternal} attachment The attachment
 * @param {tutao.tutanota.util.DataFile|tutao.entity.tutanota.File} file The file or data file to upload.
 * @return {Promise.<Object>} Resolves to the session key of the file, rejects if failed.
 */
tutao.tutanota.ctrl.SendMailFacade.createAttachment = function(attachment, dataFile) {
    var aes = tutao.locator.aesCrypter;
    if (dataFile instanceof tutao.entity.tutanota.File) {
        var fileSessionKey = dataFile._entityHelper.getSessionKey();
        attachment.setFile(dataFile.getId());
        return Promise.resolve(fileSessionKey);
    } else if (dataFile instanceof tutao.tutanota.util.DataFile) {
        var fileSessionKey = tutao.locator.aesCrypter.generateRandomKey();
        return tutao.tutanota.ctrl.FileFacade.uploadFileData(dataFile, fileSessionKey).then(function (fileDataId) {
            attachment.setFileName(aes.encryptUtf8(fileSessionKey, dataFile.getName()))
                .setMimeType(aes.encryptUtf8(fileSessionKey, dataFile.getMimeType()))
                .setFileData(fileDataId);
            return fileSessionKey;
        });
    } else {
        return Promise.reject(new Error("illegal file type as attachment"))
    }
};

tutao.tutanota.ctrl.SendMailFacade._uploadAttachmentData = function(dataFile, sessionKey) {
    return tutao.tutanota.ctrl.FileFacade.uploadFileData(dataFile, sessionKey).then(function(fileDataId) {
        return tutao.entity.tutanota.FileData.load(fileDataId);
    });
};

/**
 * Handles all recipients.
 * @param {tutao.entity.tutanota.SendMailData} service The service data.
 * @param {Array.<tutao.tutanota.ctrl.RecipientInfo>} toRecipients The recipients the mail shall be sent to.
 * @param {Array.<tutao.tutanota.ctrl.RecipientInfo>} ccRecipients The recipients the mail shall be sent to in cc.
 * @param {Array.<tutao.tutanota.ctrl.RecipientInfo>} bccRecipients The recipients the mail shall be sent to in bcc.
 * @param {Object} bucketKey The bucket key.
 * @return {Promise.<string, tutao.RecipientsNotFoundError>} Resolved when finished with the id of
 * the senders mail (only element id, no list id). Rejects with an RecipientsNotFoundError if some of the recipients could not be found.
 */
tutao.tutanota.ctrl.SendMailFacade._handleRecipients = function(service, toRecipients, ccRecipients, bccRecipients, bucketKey) {
	//not found recipients are collected here. even if recipients are not found, all recipients are checked
	var notFoundRecipients = [];

    return Promise.map([{ 'recipientInfoList': toRecipients, 'serviceRecipientList': service.getToRecipients()},
                 { 'recipientInfoList': ccRecipients, 'serviceRecipientList': service.getCcRecipients()},
                 { 'recipientInfoList': bccRecipients, 'serviceRecipientList': service.getBccRecipients()}],
        function(recipientLists, index, arrayLength) {
        return Promise.each(recipientLists.recipientInfoList, function(recipientInfo) {
            var serviceRecipient = new tutao.entity.tutanota.Recipient(service);
            recipientLists.serviceRecipientList.push(serviceRecipient);
            return tutao.tutanota.ctrl.SendMailFacade.handleRecipient(recipientInfo, serviceRecipient, bucketKey, notFoundRecipients);
        });
    }).then(function() {
        if (notFoundRecipients.length > 0) {
            throw new tutao.RecipientsNotFoundError(notFoundRecipients);
        } else {
            var map = {};
            return service.setup(map, tutao.entity.EntityHelper.createAuthHeaders()).then(function(sendMailReturn) {
                return sendMailReturn.getSenderMail()[1];
            });
        }
    });
};

/**
 * @param {tutao.tutanota.ctrl.RecipientInfo} recipientInfo The recipientInfo to copy to recipient.
 * @param {tutao.entity.tutanota.Recipient} recipient The recipient to fill.
 * @param {Object} bucketKey The bucket key.
 * @param {Array.<String>} notFoundRecipients Collects all recipients that are not found.
 * @return {Promise.<>} Resolved when finished, rejected if an error occured
 */
tutao.tutanota.ctrl.SendMailFacade.handleRecipient = function(recipientInfo, recipient, bucketKey, notFoundRecipients) {
	recipient.setName(recipientInfo.getName());
	recipient.setMailAddress(recipientInfo.getMailAddress());

	// copy phone number and password information if this is an external contact
	// otherwise load the key information from the server
	if (recipientInfo.isExternal() && notFoundRecipients.length == 0) {
        // pre-shared password has prio
        var password = recipientInfo.getContactWrapper().getContact().getPresharedPassword();
        var preshared = true;
        if (password == null) {
            password = recipientInfo.getContactWrapper().getContact().getAutoTransmitPassword();
            preshared = false;
        }
        var promise = Promise.resolve();
        if (!preshared && password == "") {
            password = tutao.tutanota.util.PasswordUtils.generateMessagePassword();
            if (recipientInfo.isExistingContact()) {
                recipientInfo.getContactWrapper().getContact().setAutoTransmitPassword(password);
                promise = recipientInfo.getContactWrapper().getContact().update();
            }
        }
        //console.log(password);

        var saltHex = tutao.locator.kdfCrypter.generateRandomSalt();
        var saltBase64 = tutao.util.EncodingConverter.hexToBase64(saltHex);
        // TODO (story performance): make kdf async in worker
        return promise.then(function () {
            return tutao.locator.kdfCrypter.generateKeyFromPassphrase(password, saltHex).then(function(hexKey) {
                var passwordKey = tutao.locator.aesCrypter.hexToKey(hexKey);
                var passwordVerifier = tutao.locator.shaCrypter.hashHex(hexKey);
                return tutao.tutanota.ctrl.SendMailFacade.getExternalGroupKey(recipientInfo, passwordKey, passwordVerifier).then(function(externalUserGroupKey) {
                    recipient.setType(tutao.entity.tutanota.TutanotaConstants.RECIPIENT_TYPE_EXTERNAL);
                    recipient.setPubEncBucketKey(null);
                    recipient.setPubKeyVersion(null);
                    // the password is not sent to the server if it is pre-shared
                    if (!preshared) {
                        recipient.setAutoTransmitPassword(password);
                    }
                    recipient.setSymEncBucketKey(tutao.locator.aesCrypter.encryptKey(externalUserGroupKey, bucketKey));
                    recipient.setPasswordVerifier(passwordVerifier);
                    recipient.setSalt(saltBase64);  // starter accounts may not call this facade, so the salt is always sent to the server
                    recipient.setSaltHash(tutao.locator.shaCrypter.hashHex(saltHex));
                    recipient.setPwEncCommunicationKey(tutao.locator.aesCrypter.encryptKey(passwordKey, externalUserGroupKey));

                    if (!preshared) {
                        var numbers = recipientInfo.getContactWrapper().getContact().getPhoneNumbers();
                        var nbrOfValidNumbers = 0;
                        for (var a = 0; a < numbers.length; a++) {
                            var recipientNumber = tutao.tutanota.util.Formatter.getCleanedPhoneNumber(numbers[a].getNumber());
                            if (tutao.tutanota.ctrl.RecipientInfo.isValidMobileNumber(recipientNumber)) {
                                var number = new tutao.entity.tutanota.PasswordChannelPhoneNumber(recipient)
                                    .setNumber(recipientNumber);
                                recipient.getPasswordChannelPhoneNumbers().push(number);
                                nbrOfValidNumbers++;
                            }
                        }
                        if (nbrOfValidNumbers == 0) {
                            throw new Error("no valid password channels for recipient");
                        }
                    }
                });
            });
        });
	} else if (!recipientInfo.isExternal()) {
		recipient.setType(tutao.entity.tutanota.TutanotaConstants.RECIPIENT_TYPE_INTERNAL);

		// load recipient key information
		var parameters = {};
		return tutao.entity.sys.PublicKeyReturn.load(new tutao.entity.sys.PublicKeyData().setMailAddress(recipientInfo.getMailAddress()), parameters, null).then(function(publicKeyData) {
            if (notFoundRecipients.length == 0) {
				var publicKey = tutao.locator.rsaCrypter.hexToKey(tutao.util.EncodingConverter.base64ToHex(publicKeyData.getPubKey()));
				var hexBucketKey = tutao.locator.aesCrypter.keyToHex(bucketKey);
                return new Promise(function(resolve, reject) {
                    return tutao.locator.rsaCrypter.encryptAesKey(publicKey, hexBucketKey, function(encrypted, exception) {
                        if (exception) {
                            reject(exception);
                        } else {
                            recipient.setPubEncBucketKey(encrypted);
                            recipient.setPubKeyVersion(publicKeyData.getPubKeyVersion());
                            resolve();
                        }
                    });
                });
			}
		}).caught(tutao.NotFoundError, function(exception) {
            notFoundRecipients.push(recipient.getMailAddress());
        });
	}
};

/**
 * Checks that an external user instance with a mail box exists for the given recipient. If it does not exist, it is created. Returns the user group key of the external recipient.
 * @param {tutao.tutanota.ctrl.RecipientInfo} recipientInfo The recipient.
 * @param {Object} externalUserPwKey The external user's password key.
 * @param {string} verifier The external user's verifier.
 * @return {Promise.<Object>} Resolved to the the external user's group key, rejected if an error occured
 */
tutao.tutanota.ctrl.SendMailFacade.getExternalGroupKey = function(recipientInfo, externalUserPwKey, verifier) {
	var self = this;
	var groupRootId = [tutao.locator.userController.getUserGroupId(), tutao.entity.sys.GroupRoot.ROOT_INSTANCE_ID];
	return tutao.entity.sys.RootInstance.load(groupRootId).then(function(rootInstance) {
        return tutao.entity.sys.GroupRoot.load(rootInstance.getReference()).then(function(groupRoot) {
            var cleanedMailAddress = tutao.tutanota.util.Formatter.getCleanedMailAddress(recipientInfo.getMailAddress());
            var mailAddressId = tutao.rest.EntityRestInterface.stringToCustomId(cleanedMailAddress);
            return tutao.entity.sys.ExternalUserReference.load([groupRoot.getExternalUserReferences(), mailAddressId]).then(function(externalUserReference, exception) {
                return tutao.entity.sys.Group.load(externalUserReference.getUserGroup()).then(function(externalUserGroup, exception) {
                    return tutao.locator.aesCrypter.decryptKey(tutao.locator.userController.getUserGroupKey(), externalUserGroup.getAdminGroupEncGKey());
                });
            }).caught(tutao.NotFoundError, function(exception) {
                // it does not exist, so create it
                // load the list key of the ExternalRecipients list
                return tutao.entity.EntityHelper.getListKey(groupRoot.getExternalGroupInfos()).then(function(externalRecipientsListKey) {
                    return tutao.entity.EntityHelper.getListKey(groupRoot.getExternalGroupInfos()).then(function(externalGroupInfoListKey) {
                        var mailListKey = tutao.locator.aesCrypter.generateRandomKey();
                        var externalUserGroupKey = tutao.locator.aesCrypter.generateRandomKey();
                        var groupInfoSessionKey = tutao.locator.aesCrypter.generateRandomKey();
                        var clientKey = tutao.locator.aesCrypter.generateRandomKey();

                        var externalRecipientData = new tutao.entity.tutanota.ExternalUserData()
                            .setGroupEncMailListKey(tutao.locator.aesCrypter.encryptKey(externalUserGroupKey, mailListKey))
                            .setUserEncClientKey(tutao.locator.aesCrypter.encryptKey(externalUserGroupKey, clientKey))
                            .setVerifier(verifier)
                            .setExternalUserEncGroupInfoSessionKey(tutao.locator.aesCrypter.encryptKey(externalUserGroupKey, externalGroupInfoListKey))
                            .setGroupEncEntropy(tutao.locator.aesCrypter.encryptBytes(externalUserGroupKey, tutao.util.EncodingConverter.hexToBase64(tutao.locator.randomizer.generateRandomData(32))));
                        var userGroupData = new tutao.entity.tutanota.CreateExternalUserGroupData(externalRecipientData)
                            .setMailAddress(cleanedMailAddress)
                            .setAdminEncGKey(tutao.locator.aesCrypter.encryptKey(tutao.locator.userController.getUserGroupKey(), externalUserGroupKey))
                            .setEncryptedName(tutao.locator.aesCrypter.encryptUtf8(groupInfoSessionKey, recipientInfo.getName()))
                            .setGroupInfoListEncSessionKey(tutao.locator.aesCrypter.encryptKey(externalGroupInfoListKey, groupInfoSessionKey))
                            .setSymEncGKey(tutao.locator.aesCrypter.encryptKey(externalUserPwKey, externalUserGroupKey));
                        return externalRecipientData.setUserGroupData(userGroupData).setup([], null).then(function() {
                            return externalUserGroupKey;
                        });
                    });
                });
            });

        });
	});
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.SendMailFromExternalFacade');

/**
 * Sends a secure mail to internal and external recipients. For external recipients the password and password channels must be set.
 * @param {string} subject The subject of the mail.
 * @param {string} bodyText The bodyText of the mail.
 * @param {string} senderName The name of the sender that is sent together with the mail address of the sender.
 * @param {Array.<tutao.tutanota.ctrl.RecipientInfo>} toRecipients The recipients the mail shall be sent to.
 * @param {Array.<tutao.tutanota.ctrl.RecipientInfo>} ccRecipients The recipients the mail shall be sent to in cc.
 * @param {Array.<tutao.tutanota.ctrl.RecipientInfo>} bccRecipients The recipients the mail shall be sent to in bcc.
 * @param {string} conversationType See TutanotaConstants.
 * @param {string} previousMessageId The id of the message that this mail is a reply or forward to. Empty string if this is a new mail.
 * @param {Array.<tutao.tutanota.util.DataFile>} attachments The new files that shall be attached to this mail.
 * @param {string} language Notification mail language.
 * @return {Promise.<string, tutao.RecipientsNotFoundError>} Resolves to the senders mail id (only element id, no list id),
 * rejected with an RecipientsNotFoundError if some of the recipients could not be found.
 */
tutao.tutanota.ctrl.SendMailFromExternalFacade.sendMail = function(subject, bodyText, senderName, toRecipients, ccRecipients, bccRecipients, conversationType, previousMessageId, attachments, language) {
    var aes = tutao.locator.aesCrypter;
    var groupKey = tutao.locator.userController.getUserGroupKey();
    var senderBucketKey = aes.generateRandomKey();
    var recipientBucketKey = aes.generateRandomKey();

    var service = new tutao.entity.tutanota.SendMailFromExternalData();
    service.setLanguage(language)
        .setSubject(subject)
        .setBodyText(bodyText)
        .setSenderName(senderName)
        .setSenderBucketEncSessionKey(aes.encryptKey(senderBucketKey, service._entityHelper.getSessionKey()))
        .setRecipientBucketEncSessionKey(aes.encryptKey(recipientBucketKey, service._entityHelper.getSessionKey()))
        .setSenderSymEncBucketKey(aes.encryptKey(groupKey, senderBucketKey))
        .setPreviousMessageId(previousMessageId);

    return Promise.map(attachments, function(dataFile) {
        var attachment = new tutao.entity.tutanota.AttachmentFromExternal(service);
        return tutao.tutanota.ctrl.SendMailFacade.createAttachment(attachment, dataFile).then(function(fileSessionKey) {
            attachment.setSenderBucketEncFileSessionKey(aes.encryptKey(senderBucketKey, fileSessionKey))
                .setRecipientBucketEncFileSessionKey(aes.encryptKey(recipientBucketKey, fileSessionKey));
            service.getAttachments().push(attachment);
        });
    }).then(function() {
        var notFoundRecipients = [];
        var serviceRecipient = new tutao.entity.tutanota.Recipient(service);
        service.setToRecipient(serviceRecipient);
        return tutao.tutanota.ctrl.SendMailFacade.handleRecipient(toRecipients[0], serviceRecipient, recipientBucketKey, notFoundRecipients).then(function() {
            if (notFoundRecipients.length > 0) {
                throw new tutao.RecipientsNotFoundError(notFoundRecipients);
            } else {
                var map = {};
                return service.setup(map, tutao.entity.EntityHelper.createAuthHeaders()).then(function(sendMailFromExternalReturn) {
                    return sendMailFromExternalReturn.getSenderMail()[1];
                });
            }
        });
    });
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.SendUnsecureMailFacade');

/**
 * Sends a mail to tutanota and external recipients.
 * @param {string} subject The subject of the mail.
 * @param {string} bodyText The bodyText of the mail.
 * @param {string} senderName The name of the sender that is sent together with the mail address of the sender.
 * @param {Array.<tutao.tutanota.ctrl.RecipientInfo>} toRecipients The recipients the mail shall be sent to.
 * @param {Array.<tutao.tutanota.ctrl.RecipientInfo>} ccRecipients The recipients the mail shall be sent to in cc.
 * @param {Array.<tutao.tutanota.ctrl.RecipientInfo>} bccRecipients The recipients the mail shall be sent to in bcc.
 * @param {string} conversationType See TutanotaConstants.
 * @param {string} previousMessageId The id of the message that this mail is a reply or forward to. Empty string if this is a new mail.
 * @param {Array.<tutao.tutanota.util.DataFile>} attachments The new files that shall be attached to this mail.
 * @param {string} language Notification mail language.
 * @return {Promise.<string, tutao.RecipientsNotFoundError>} Resolves to the senders mail id (only element id, no list id),
 * rejected with an RecipientsNotFoundError if some of the recipients could not be found.
 */
tutao.tutanota.ctrl.SendUnsecureMailFacade.sendMail = function(subject, bodyText, senderName, toRecipients, ccRecipients, bccRecipients, conversationType, previousMessageId, attachments, language) {
	var aes = tutao.locator.aesCrypter;
	var groupKey = tutao.locator.userController.getUserGroupKey();
	var sharableKey = tutao.locator.mailBoxController.getUserMailBoxBucketData().getBucketKey();
	var mailBoxKey = tutao.locator.mailBoxController.getUserMailBox()._entityHelper.getSessionKey();
	var sessionKey = tutao.locator.aesCrypter.generateRandomKey();

	var service = new tutao.entity.tutanota.SendUnsecureMailData();
    service.setLanguage(language)
	    .setSubject(subject)
	    .setBodyText(bodyText)
	    .setSenderName(senderName)
	    .setConversationType(conversationType)
	    .setPreviousMessageId(previousMessageId)
	    .setMailSessionKey(tutao.util.EncodingConverter.hexToBase64(aes.keyToHex(sessionKey))) // for recipients
	    .setListEncSessionKey(aes.encryptKey(mailBoxKey, sessionKey)) // for sender
	    .setSymEncSessionKey(aes.encryptKey(groupKey, sessionKey)) // for sender
	    .setSharableEncSessionKey(aes.encryptKey(sharableKey, sessionKey)); // for sharing the mailbox

    return Promise.each(attachments, function(dataFile, index, number) {
        var attachment = new tutao.entity.tutanota.UnsecureAttachment(service);
        return tutao.tutanota.ctrl.SendMailFacade.createAttachment(attachment, dataFile).then(function(fileSessionKey) {
            attachment.setFileSessionKey(tutao.util.EncodingConverter.hexToBase64(aes.keyToHex(fileSessionKey)))
                .setListEncFileSessionKey(aes.encryptKey(mailBoxKey, fileSessionKey));

            service.getAttachments().push(attachment);
        });
    }).then(function() {
        for (var i = 0; i < toRecipients.length; i++) {
            var recipient = new tutao.entity.tutanota.UnsecureRecipient(service);
            recipient.setName(toRecipients[i].getName());
            recipient.setMailAddress(toRecipients[i].getMailAddress());
            service.getToRecipients().push(recipient);
        }
        for (var i = 0; i < ccRecipients.length; i++) {
            var recipient = new tutao.entity.tutanota.UnsecureRecipient(service);
            recipient.setName(ccRecipients[i].getName());
            recipient.setMailAddress(ccRecipients[i].getMailAddress());
            service.getCcRecipients().push(recipient);
        }
        for (var i = 0; i < bccRecipients.length; i++) {
            var recipient = new tutao.entity.tutanota.UnsecureRecipient(service);
            recipient.setName(bccRecipients[i].getName());
            recipient.setMailAddress(bccRecipients[i].getMailAddress());
            service.getBccRecipients().push(recipient);
        }
        var map = {};
        return service.setup(map, tutao.entity.EntityHelper.createAuthHeaders()).then(function(sendUnsecureMailReturn) {
            var mailElementId = sendUnsecureMailReturn.getSenderMail()[1];
            return mailElementId;
        });
    });
};
"use strict";

tutao.provide('tutao.tutanota.ctrl.SettingsViewModel');

/**
 * Handles the user settings in Tutanota.
 * @constructor
 */
tutao.tutanota.ctrl.SettingsViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
    this.adminUserListViewModel = ko.observable(null);

	this.displayed = ko.observable(tutao.tutanota.ctrl.SettingsViewModel.DISPLAY_ACCOUNT_SETTINGS);
	this.displayed.subscribe(function(displayed) {
		if (displayed == tutao.tutanota.ctrl.SettingsViewModel.DISPLAY_ADMIN_USER_LIST) {
			this.adminUserListViewModel(new tutao.tutanota.ctrl.AdminUserListViewModel());
		} else {
			this.adminUserListViewModel(null);
		}
	}, this);
};

tutao.tutanota.ctrl.SettingsViewModel.DISPLAY_ACCOUNT_SETTINGS = 0;
tutao.tutanota.ctrl.SettingsViewModel.DISPLAY_SECURITY_SETTINGS = 1;
tutao.tutanota.ctrl.SettingsViewModel.DISPLAY_CHANGE_PASSWORD = 2;
tutao.tutanota.ctrl.SettingsViewModel.DISPLAY_ADMIN_USER_LIST = 3;
tutao.tutanota.ctrl.SettingsViewModel.DISPLAY_NOTHING = 100;

/**
 * Provides all settings ids.
 * @return {Array.<Number>} The Settings ids.
 */
tutao.tutanota.ctrl.SettingsViewModel.prototype.getSettings = function() {
	var s = tutao.tutanota.ctrl.SettingsViewModel;
	var settings = [s.DISPLAY_ACCOUNT_SETTINGS, s.DISPLAY_SECURITY_SETTINGS, s.DISPLAY_CHANGE_PASSWORD];
	if (tutao.locator.userController.isLoggedInUserAdmin() ) {
		settings.push(s.DISPLAY_ADMIN_USER_LIST);
	}
	return settings;
};

/**
 * Provides the text id for the given setting.
 * @param {Number} settings One of tutao.tutanota.ctrl.SettingsViewModel.DISPLAY_*.
 * @return {String} text id for the setting number
 */
tutao.tutanota.ctrl.SettingsViewModel.prototype.getSettingsTextId = function(settings) {
	return ["accountSettings_action", "securitySettings_action", "changePasswordSettings_action", "adminUserList_action", "adminUserAdd_action"][settings];
};

/**
 * Shows the given settings.
 * @param {Number} settings One of tutao.tutanota.ctrl.SettingsViewModel.DISPLAY_*.
 */
tutao.tutanota.ctrl.SettingsViewModel.prototype.show = function(settings) {
	this.displayed(settings);
	tutao.locator.settingsView.showChangeSettingsColumn();
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.ShareFacade');

/**
 * Share a functional area with someone else.
 * @param {String} shareType One of tutao.entity.tutanota.TutanotaConstants.SHARE_TYPE_*;.
 * @param {String} shareholderMailAddress The mail address of the user that shall get the data shared (i.e. the shareholder).
 * @param {boolean} writePermission True if the shareholder shall get write permissions, false if he shall only get read permissions.
 * @return {Promise.<>} Resolves when finished, rejected if failed.
 */
tutao.tutanota.ctrl.ShareFacade.share = function(shareType, shareholderMailAddress, writePermission) {
	var shareService = new tutao.entity.sys.ShareData();
	shareService.setApp("tutanota");
	shareService.setShareType(shareType);
	shareService.setShareholderMailAddress(shareholderMailAddress);
	shareService.setWritePermission(writePermission);

	var instancePermissionList;
	var bucketId;
	var shareBucketKey;
	if (shareType == tutao.entity.tutanota.TutanotaConstants.SHARE_TYPE_MAIL_BOX) {
		instancePermissionList = tutao.locator.mailBoxController.getUserMailBox().getPermissions();
		bucketId = tutao.locator.mailBoxController.getUserMailBox().getShareBucketId();
		shareBucketKey = tutao.locator.mailBoxController.getUserMailBoxBucketData().getBucketKey();
	} else if (shareType == tutao.entity.tutanota.TutanotaConstants.SHARE_TYPE_CONTACT_LIST) {
		instancePermissionList = tutao.locator.mailBoxController.getUserContactList().getPermissions();
		bucketId = tutao.locator.mailBoxController.getUserContactList().getShareBucketId();
		shareBucketKey = tutao.locator.mailBoxController.getUserContactListBucketData().getBucketKey();
	} else if (shareType == tutao.entity.tutanota.TutanotaConstants.SHARE_TYPE_FILE_SYSTEM) {
		instancePermissionList = tutao.locator.mailBoxController.getUserFileSystem().getPermissions();
		bucketId = tutao.locator.mailBoxController.getUserFileSystem().getShareBucketId();
		shareBucketKey = tutao.locator.mailBoxController.getUserFileSystemBucketData().getBucketKey();
	} else {
		return Promise.reject(new Error("invalid share type: " + shareType));
	}

	shareService.setInstancePermissions(instancePermissionList);
	shareService.setBucket(bucketId);

	return tutao.tutanota.ctrl.ShareFacade.encryptKeyForGroup(shareholderMailAddress, shareBucketKey).then(function(keyData) {
		shareService.setPubEncBucketKey(keyData.pubEncKey)
		    .setPubKeyVersion(keyData.pubKeyVersion)
            .setOwnerGroupId(tutao.locator.userController.getUserGroupId());


		var headers = tutao.entity.EntityHelper.createAuthHeaders();
		var postParams = {};
		return shareService.setup(postParams, headers);
	});
};

/**
 * Encrypts a symmetric key with the public key of the group with the given mail address (internal user).
 * @param {String} mailAddress The mail address for which we want to get the key info.
 * @param {Object} keyToEncrypt The symmetric key to encrypt.
 * @return {Promise.<{pubEncKey:String,pubKeyVersion:Number}, tutao.RecipientsNotFoundError>} Resolves when finished, rejected if failed.
 */
tutao.tutanota.ctrl.ShareFacade.encryptKeyForGroup = function(mailAddress, keyToEncrypt) {
	//load recipient key information
	var parameters = {};
	return tutao.entity.sys.PublicKeyReturn.load(new tutao.entity.sys.PublicKeyData().setMailAddress(mailAddress), parameters, null).then(function(publicKeyData, exception) {
        var publicKey = tutao.locator.rsaCrypter.hexToKey(tutao.util.EncodingConverter.base64ToHex(publicKeyData.getPubKey()));
        var hexBucketKey = tutao.locator.aesCrypter.keyToHex(keyToEncrypt);
        return new Promise(function(resolve, reject) {
            tutao.locator.rsaCrypter.encryptAesKey(publicKey, hexBucketKey, function(encrypted, exception) {
                if (exception) {
                    reject(exception);
                } else {
                    resolve({ pubEncKey: encrypted, pubKeyVersion: publicKeyData.getPubKeyVersion() });
                }
            });
        });
	}).caught(tutao.NotFoundError, function(exception) {
        throw new tutao.RecipientsNotFoundError([mailAddress]);
    });
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.SwipeRecognizer');

/**
 * @constructor
 * A SwipeRecognizer can recognize swipe events like swipe in and out from left and right border of the screen. If
 * a listener is registered for these events, the listener is called.
 */
tutao.tutanota.ctrl.SwipeRecognizer = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

	this._listeners = {};

	// dummy values until setScreenSize is called
	this._screenWidth = 0;
	this._screenHeight = 0;

	this._startX = 0;
	this._startY = 0;
	this._currentX = 0;
	this._currentY = 0;
	this._notified = {};

	//TODO (timely) put this into the ctrl and feed the touch events from outside to make this class gui independent
	$("#tutanota").on("touchstart", this._touchStart);
	$("#tutanota").on("touchmove", this._touchMove);
	$("#tutanota").on("touchend", this._touchEnd);
	$("#tutanota").on("touchcancel", this._touchCancel);
};

/**
 * Id for the swipe in from left event.
 */
tutao.tutanota.ctrl.SwipeRecognizer.TYPE_LEFT_IN = 0;

/**
 * Id for the swipe out left event.
 */
tutao.tutanota.ctrl.SwipeRecognizer.TYPE_LEFT_OUT = 1;

/**
 * Id for the swipe in from right event.
 */
tutao.tutanota.ctrl.SwipeRecognizer.TYPE_RIGHT_IN = 2;

/**
 * Id for the swipe out right event.
 */
tutao.tutanota.ctrl.SwipeRecognizer.TYPE_RIGHT_OUT = 3;

/**
 * Id for the swipe right event.
 */
tutao.tutanota.ctrl.SwipeRecognizer.TYPE_RIGHT = 4;

/**
 * Id for the swipe left event.
 */
tutao.tutanota.ctrl.SwipeRecognizer.TYPE_LEFT = 5;


/**
 * @protected
 * The maximal distance the finger may move in vertical direction to still recognize the gesture as horizontal swipe in px.
 */
tutao.tutanota.ctrl.SwipeRecognizer._MAX_ORTHOGRAPIC_VARIATION = 60;

/**
 * @protected
 * The maximal distance from the border to the touch start position in px to recognize a swipe in.
 */
tutao.tutanota.ctrl.SwipeRecognizer._MAX_START_OFFSET_FOR_BORDER_IN = 50;

/**
 * @protected
 * The minimal distance from the border in px that the finger must move to recognize a swipe in.
 */
tutao.tutanota.ctrl.SwipeRecognizer._MIN_END_OFFSET_FOR_BORDER_IN = 40;

/**
 * @protected
 * Min slide distance to recognize a swipe in.
 */
tutao.tutanota.ctrl.SwipeRecognizer._MIN_SLIDE_DISTANCE_FOR_BORDER_IN = 20;

/**
 * @protected
 * The minimal touch start distance from the border in px to recognize a swipe out.
 */
tutao.tutanota.ctrl.SwipeRecognizer._MIN_START_OFFSET_FOR_BORDER_OUT = 30;

/**
 * @protected
 * The maximum touch start distance from the border in px to recognize a swipe out.
 */
tutao.tutanota.ctrl.SwipeRecognizer._MAX_START_OFFSET_FOR_BORDER_OUT = 450;

/**
 * @protected
 * The distance from the border in px that the finger must at least move (in border direction) to recognize a swipe out.
 */
tutao.tutanota.ctrl.SwipeRecognizer._MIN_END_OFFSET_FOR_BORDER_OUT = 10;

/**
 * @protected
 * The distance the finger must at least move to recognize a swipe left or swipe right.
 * Attention: do not use a value > 15 px, because in Chrome on Android only one touchmove event is sent in an otherwise (vertically) scrollable div and touchcancel afterwards. The touch distance is therefore not very big.
 * See https://code.google.com/p/android/issues/detail?id=5491, https://code.google.com/p/android/issues/detail?id=19827, https://code.google.com/p/chromium/issues/detail?id=150779
 */
tutao.tutanota.ctrl.SwipeRecognizer._MIN_SLIDE_DISTANCE = 15;

/**
 * @protected
 * The distance as percentage of the horizontal slide that the finger may slide vertically to still recognize a swipe left or swipe right.
 */
tutao.tutanota.ctrl.SwipeRecognizer._MAX_ORTHOGRAPIC_VARIATION_FACTOR = 0.2;

/**
 * Set the screen resolution. Must be called at least once before adding listeners and in case of browser window
 * resizing or tablet orientation changes.
 * @param {number} width The width of the browser screen.
 * @param {number} height The height of the browser screen.
 */
tutao.tutanota.ctrl.SwipeRecognizer.prototype.setScreenSize = function(width, height) {
	this._screenWidth = width;
	this._screenHeight = height;
};

/**
 * Registers a listener function that is called when the swipe event indicated by type occurs. It is only possible
 * to register one listener per type.
 * @param {number} type One of TYPE_LEFT_OUT, TYPE_LEFT_IN, TYPE_RIGHT_IN, TYPE_RIGHT_OUT.
 * @param {function()} listener This function is called as soon as the swipe event occurs.
 */
tutao.tutanota.ctrl.SwipeRecognizer.prototype.addSwipeListener = function(type, listener) {
	this._listeners[type] = listener;
};

/**
 * Receives the touchstart event from the browser.
 * @param {Object} event The event.
 * @protected
 */
tutao.tutanota.ctrl.SwipeRecognizer.prototype._touchStart = function(event) {
	event = event.originalEvent; // get the original event for the touch properties
	if (event.touches.length == 1) {
		this._startX = event.touches[0].pageX;
		this._startY = event.touches[0].pageY;
		this._currentX = this._startX;
		this._currentY = this._startY;
		this._notified = {};
	} else {
		this._cancel();
	}
};

/**
 * Receives the touchmove event from the browser.
 * @param {Object} event The event.
 * @protected
 */
tutao.tutanota.ctrl.SwipeRecognizer.prototype._touchMove = function(event) {
	event = event.originalEvent; // get the original event for the touch properties
	if (event.touches.length == 1) {
		this._currentX = event.touches[0].pageX;
		this._currentY = event.touches[0].pageY;
		this._tryRecognization();
	}
};

/**
 * Tries to recognize the registered swipe events and calls the corresponding listener if successful.
 * @protected
 */
tutao.tutanota.ctrl.SwipeRecognizer.prototype._tryRecognization = function() {
	var SR = tutao.tutanota.ctrl.SwipeRecognizer;
	// try to recognize a swipe
	/* border swipe detection is not used currently
    if (this._listeners[SR.TYPE_LEFT_IN] && !this._notified[SR.TYPE_LEFT_IN]) {
		if (this._startX <= SR._MAX_START_OFFSET_FOR_BORDER_IN &&
				(this._currentX > this._startX) &&
				(this._currentX >= SR._MIN_END_OFFSET_FOR_BORDER_IN) &&
				((this._currentX - this._startX) >= SR._MIN_SLIDE_DISTANCE_FOR_BORDER_IN) &&
				(Math.abs(this._currentY - this._startY) <= SR._MAX_ORTHOGRAPIC_VARIATION)) {
			this._notified[SR.TYPE_LEFT_IN] = true;
			this._listeners[SR.TYPE_LEFT_IN]();
		}
	}
	if (this._listeners[SR.TYPE_LEFT_OUT] && !this._notified[SR.TYPE_LEFT_OUT]) {
		if (this._startX <= SR._MAX_START_OFFSET_FOR_BORDER_OUT &&
				(this._startX >= SR._MIN_START_OFFSET_FOR_BORDER_OUT) &&
				(this._currentX < this._startX) &&
				(this._currentX <= SR._MIN_END_OFFSET_FOR_BORDER_OUT) &&
				(Math.abs(this._currentY - this._startY) <= SR._MAX_ORTHOGRAPIC_VARIATION)) {
			this._notified[SR.TYPE_LEFT_OUT] = true;
			this._listeners[SR.TYPE_LEFT_OUT]();
		}
	}
	if (this._listeners[SR.TYPE_RIGHT_IN] && !this._notified[SR.TYPE_RIGHT_IN]) {
		if (this._startX >= this._screenWidth - SR._MAX_START_OFFSET_FOR_BORDER_IN &&
				(this._currentX < this._startX) &&
				(this._currentX <= this._screenWidth - SR._MIN_END_OFFSET_FOR_BORDER_IN) &&
				((this._startX - this._currentX) >= SR._MIN_SLIDE_DISTANCE_FOR_BORDER_IN) &&
				(Math.abs(this._currentY - this._startY) <= SR._MAX_ORTHOGRAPIC_VARIATION)) {
			this._notified[SR.TYPE_RIGHT_IN] = true;
			this._listeners[SR.TYPE_RIGHT_IN]();
		}
	}
	if (this._listeners[SR.TYPE_RIGHT_OUT] && !this._notified[SR.TYPE_RIGHT_OUT]) {
		if (this._startX >= this._screenWidth - SR._MAX_START_OFFSET_FOR_BORDER_OUT &&
				(this._startX <= this._screenWidth - SR._MIN_START_OFFSET_FOR_BORDER_OUT) &&
				(this._currentX > this._startX) &&
				(this._currentX >= this._screenWidth - SR._MIN_END_OFFSET_FOR_BORDER_OUT) &&
				(Math.abs(this._currentY - this._startY) <= SR._MAX_ORTHOGRAPIC_VARIATION)) {
			this._notified[SR.TYPE_RIGHT_OUT] = true;
			this._listeners[SR.TYPE_RIGHT_OUT]();
		}
	}*/
    if (this._listeners[SR.TYPE_RIGHT] && !this._notified[SR.TYPE_RIGHT]) {
        if ((this._currentX >= this._startX + SR._MIN_SLIDE_DISTANCE) &&
            (Math.abs(this._currentY - this._startY) <= Math.abs(this._currentX - this._startX) * SR._MAX_ORTHOGRAPIC_VARIATION_FACTOR)) {
            this._notified[SR.TYPE_RIGHT] = true;
            this._listeners[SR.TYPE_RIGHT]();
        }
    }
    if (this._listeners[SR.TYPE_LEFT] && !this._notified[SR.TYPE_LEFT]) {
        if ((this._currentX <= this._startX - SR._MIN_SLIDE_DISTANCE) &&
            (Math.abs(this._currentY - this._startY) <= Math.abs(this._currentX - this._startX) * SR._MAX_ORTHOGRAPIC_VARIATION_FACTOR)) {
            this._notified[SR.TYPE_LEFT] = true;
            this._listeners[SR.TYPE_LEFT]();
        }
    }
};

/**
 * Receives the touchend event from the browser.
 * @param {Object} event The event.
 * @protected
 */
tutao.tutanota.ctrl.SwipeRecognizer.prototype._touchEnd = function(event) {
	event = event.originalEvent; // get the original event for the touch properties
	// not needed currently
};

/**
 * Receives the touchcancel event from the browser.
 * @param {Object} event The event.
 * @protected
 */
tutao.tutanota.ctrl.SwipeRecognizer.prototype._touchCancel = function(event) {
	event = event.originalEvent; // get the original event for the touch properties
	// not needed currently
};

/**
 * Cancels all current touch gestures, so no listener will be called until a new touch start event occurs.
 * @protected
 */
tutao.tutanota.ctrl.SwipeRecognizer.prototype._cancel = function() {
	var SR = tutao.tutanota.ctrl.SwipeRecognizer;
	// mark all events as notified
	this._notified[SR.TYPE_LEFT_IN] = true;
	this._notified[SR.TYPE_LEFT_OUT] = true;
	this._notified[SR.TYPE_RIGHT_IN] = true;
	this._notified[SR.TYPE_RIGHT_OUT] = true;
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.TagListViewModel');

/**
 * The view model for the tag list.
 * @constructor
 */
tutao.tutanota.ctrl.TagListViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	this.activeSystemTag = ko.observable(tutao.tutanota.ctrl.TagListViewModel.RECEIVED_TAG_ID);
};

// the tags are ordered by priority, e.g. a received mail that is trashed does not appear when selecting the received tag
/**
 * Represents the system tag for trashed mails.
 */
tutao.tutanota.ctrl.TagListViewModel.TRASHED_TAG_ID = 0;

/**
 * Represents the system tag for received mails.
 */
tutao.tutanota.ctrl.TagListViewModel.RECEIVED_TAG_ID = 1;

/**
 * Represents the system tag for sent mails.
 */
tutao.tutanota.ctrl.TagListViewModel.SENT_TAG_ID = 2;

/**
 * Provides the id of the currently active system tag.
 * @return {number} one of TRASHED_TAG_ID, RECEIVED_TAG_ID, SENT_TAG_ID.
 */
tutao.tutanota.ctrl.TagListViewModel.prototype.getActiveSystemTag = function() {
	return this.activeSystemTag;
};

/**
 * Activates the received system tag. All mails fitting to this tag are shown.
 */
tutao.tutanota.ctrl.TagListViewModel.prototype.activateReceivedTag = function() {
    if (!tutao.locator.mailViewModel.tryCancelAllComposingMails()) {
        return;
    }
	this.activeSystemTag(tutao.tutanota.ctrl.TagListViewModel.RECEIVED_TAG_ID);
	tutao.locator.mailListViewModel.systemTagActivated(this.activeSystemTag());
};

/**
 * Activates the sent system tag. All mails fitting to this tag are shown.
 */
tutao.tutanota.ctrl.TagListViewModel.prototype.activateSentTag = function() {
    if (!tutao.locator.mailViewModel.tryCancelAllComposingMails()) {
        return;
    }
	this.activeSystemTag(tutao.tutanota.ctrl.TagListViewModel.SENT_TAG_ID);
	tutao.locator.mailListViewModel.systemTagActivated(this.activeSystemTag());
};

/**
 * Activates the trashed system tag. All mails fitting to this tag are shown.
 */
tutao.tutanota.ctrl.TagListViewModel.prototype.activateTrashedTag = function() {
    if (!tutao.locator.mailViewModel.tryCancelAllComposingMails()) {
        return;
    }
	this.activeSystemTag(tutao.tutanota.ctrl.TagListViewModel.TRASHED_TAG_ID);
	tutao.locator.mailListViewModel.systemTagActivated(this.activeSystemTag());
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.ThemeViewModel');

tutao.tutanota.ctrl.ThemeViewModel = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	var self = this;

	this.themes = ko.observableArray(['main', 'new']);
	this.theme = ko.observable(this.themes()[1]);
	this.theme.subscribe(function(newValue) {
		// remove existing styles and replace with newly selected ones
		if (typeof less === 'undefined') {
			$('link#theme').attr({ href: 'css/' + self.theme() + '.css' });
		} else {
			$('link#theme').attr({ href: 'css/' + self.theme() + '.less' });
			$('style[id^="less:"]').remove();
			less.refresh();
		}
	});
};

"use strict";

tutao.provide('tutao.tutanota.util.ThunderbirdContactCsvConverter');

/**
 * @constructor
 * @implements {tutao.tutanota.ctrl.ContactCsvHandler}
 */
tutao.tutanota.ctrl.ThunderbirdContactCsvConverter = function() {

};

tutao.tutanota.ctrl.ThunderbirdContactCsvConverter.prototype.csvToContacts = function(csvString) {
	return tutao.tutanota.ctrl.ContactCsvConverter.csvToContacts(csvString, this);
};

tutao.tutanota.ctrl.ThunderbirdContactCsvConverter.prototype.startContact = function(contact) {
	this.birthday = null;
	this.additionalComment = "";
	this.homeAddress = null; 
	this.homeAddress2 = null; 
	this.homeCity = null; 
	this.homeState = null; 
	this.homeZipCode = null; 
	this.homeCountry = null; 
	this.workAddress = null; 
	this.workAddress2 = null;
	this.workCity = null; 
	this.workState = null; 
	this.workZipCode = null; 
	this.workCountry = null;
};

tutao.tutanota.ctrl.ThunderbirdContactCsvConverter.prototype.addField = function(contact, name, value) {
	if (!value) {
		return true;
	}
	switch (name) {
	case "First Name":
		contact.setFirstName(value);
		return true;
	case "Last Name":
		contact.setLastName(value);
		return true;
	case "Primary Email":
	case "Secondary Email":
		var mailAddress = new tutao.entity.tutanota.ContactMailAddress(contact);
		mailAddress.setAddress(value);
		mailAddress.setCustomTypeName("");
		mailAddress.setType(tutao.entity.tutanota.TutanotaConstants.CONTACT_MAIL_ADDRESS_TYPE_OTHER);
		contact.getMailAddresses().push(mailAddress);
		return true;
	case "Work Phone":
		this.addPhoneNumber(contact, tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_WORK, "", value);
		return true;
	case "Home Phone":
		this.addPhoneNumber(contact, tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_PRIVATE, "", value);
		return true;
	case "Fax Number":
		this.addPhoneNumber(contact, tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_FAX, "", value);
		return true;
	case "Pager Number": 
		this.addPhoneNumber(contact, tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_CUSTOM, "Pager", value);
		return true;
	case "Mobile Number":
		this.addPhoneNumber(contact, tutao.entity.tutanota.TutanotaConstants.CONTACT_PHONE_NUMBER_TYPE_MOBILE, "", value);
		return true;
	case "Job Title": 
		contact.setTitle(value);
		return true;
	case "Organization":
		contact.setCompany(value);
		return true;
	case "Notes":
		contact.setComment(value);
		return true;
	case "Birth Year":
		if (!this.birthday) {
			this.birthday = new Date();
		}
		this.birthday.setYear(value);
		return true;
	case "Birth Month":
		if (!this.birthday) {
			this.birthday = new Date();
		}
		this.birthday.setMonth(value);
		return true;
	case "Birth Day":
		if (!this.birthday) {
			this.birthday = new Date();
		}
		this.birthday.setDate(value);
		return true;
	case "Home Address": 
		this.homeAddress = value;
		return true;
	case "Home Address 2":
		this.homeAddress2 = value;
		return true; 
	case "Home City":
		this.homeCity = value;
		return true; 
	case "Home State":
		this.homeState = value;
		return true;
	case "Home ZipCode":
		this.homeZipCode = value;
		return true; 
	case "Home Country":
		this.homeCountry = value;
		return true; 
	case "Work Address":
		this.workAddress = value;
		return true; 
	case "Work Address 2":
		this.workAddress2 = value;
		return true;
	case "Work City":
		this.workCity = value;
		return true; 
	case "Work State":
		this.workState = value;
		return true; 
	case "Work ZipCode":
		this.workZipCode = value;
		return true; 
	case "Work Country":
		this.workCountry = value;
		return true;
	case "Display Name":
	case "Screen Name": 
		return true;
	case "Nickname":
	case "Department": 
	case "Web Page 1": 
	case "Web Page 2": 
	case "Custom 1": 
	case "Custom 2": 
	case "Custom 3": 
	case "Custom 4": 
		this.additionalComment += ("\n" + name + ": " + value);
		return true;
	default:
		return false;
	}
};

tutao.tutanota.ctrl.ThunderbirdContactCsvConverter.prototype.finishContact = function(contact) {
	contact.setBirthday(this.birthday);
	if (this.additionalComment) {
		contact.setComment(contact.getComment() + "\n" + this.additionalComment);
	}
	var homeAddr = this.combineAddress(this.homeAddress, this.homeAddress2, this.homeZipCode, this.homeCity, this.homeState, this.homeCountry);
	this.addAddress(contact, tutao.entity.tutanota.TutanotaConstants.CONTACT_ADDRESS_TYPE_PRIVATE, homeAddr);
	var workAddr = this.combineAddress(this.workAddress, this.workAddress2, this.workZipCode, this.workCity, this.workState, this.workCountry);
	this.addAddress(contact, tutao.entity.tutanota.TutanotaConstants.CONTACT_ADDRESS_TYPE_WORK, workAddr);
	return true;
};

tutao.tutanota.ctrl.ThunderbirdContactCsvConverter.prototype.combineAddress = function(address1, address2, zipCode, city, state, country) {
	var address = "";
	if (address1) {
		address += address1 + "\n";
	}
	if (address2) {
		address += address2 + "\n";
	}
	if (zipCode && city) {
		address += zipCode + " " + city + "\n";
	} else if (zipCode) {
		address += zipCode + "\n";
	} else if (city) {
		address += city + "\n";
	}			
	if (state) {
		address += state + "\n";
	}
	if (country) {
		address += country + "\n";
	}

	if (address) {
		return address;
	} else {
		return null;
	}
};

tutao.tutanota.ctrl.ThunderbirdContactCsvConverter.prototype.addPhoneNumber = function(contact, type, customTypeName, number) {
	if (number) {
		var n = new tutao.entity.tutanota.ContactPhoneNumber(contact);
		n.setNumber(number);
		n.setType(type);
		n.setCustomTypeName(customTypeName);
		contact.getPhoneNumbers().push(n);
	}
};

tutao.tutanota.ctrl.ThunderbirdContactCsvConverter.prototype.addAddress = function(contact, type, address) {
	if (address) {
		var n = new tutao.entity.tutanota.ContactAddress(contact);
		n.setAddress(address);
		n.setType(type);
		n.setCustomTypeName("");
		contact.getAddresses().push(n);
	}
};

tutao.tutanota.ctrl.ThunderbirdContactCsvConverter.prototype.contactsToCsv = function(contacts) {
	return tutao.tutanota.ctrl.ContactCsvConverter.contactsToCsv(contacts, this);
};

"use strict";

tutao.provide('tutao.ctrl.UserController');

/**
 * Allows logging in an internal user.
 * @constructor
 */
tutao.ctrl.UserController = function () {
    this.reset();
};

/**
 * Resets all internal state, so nobody is logged in.
 */
tutao.ctrl.UserController.prototype.reset = function () {
    // internal and external user
    this._userId = null;
    this._userGroupKey = null;
    this._authVerifier = null;
    this._userGroupId = null;
    this._user = null;
    this._userPassphraseKey = null;
    this._userClientKey = null;
    this._mailAddress = null;
    this._hexSalt = null;
    this._userGroupInfo = null; // indicates that a user is logged in because this is set in the last login step

    // only set for external user
    this._authToken = null; // the hash of the salt
};

/**
 * Provides the user group id of the logged in user.
 * @return {string} The user group id.
 */
tutao.ctrl.UserController.prototype.getUserGroupId = function () {
    return this._userGroupId;
};

/**
 * Provides the symmetric user group key of the logged in user.
 * @return {Object} The user group key.
 */
tutao.ctrl.UserController.prototype.getUserGroupKey = function () {
    return this._userGroupKey;
};

/**
 * Provides the authentication verifier of the logged in user.
 * @return {string} The auth verifier.
 */
tutao.ctrl.UserController.prototype.getAuthVerifier = function () {
    return this._authVerifier;
};

/**
 * Provides the user id of the logged in user.
 * @return {string} The user id.
 */
tutao.ctrl.UserController.prototype.getUserId = function () {
    return this._userId;
};

/**
 * Provides the currently logged-in user.
 * @return {tutao.entity.sys.User} The logged-in user.
 */
tutao.ctrl.UserController.prototype.getLoggedInUser = function () {
    return this._user;
};

tutao.ctrl.UserController.prototype.isLoggedInUserAdmin = function () {
    if (this.isInternalUserLoggedIn()) {
        var memberships = this._user.getMemberships();
        for (var i = 0; i < memberships.length; i++) {
            if (memberships[i].getAdmin()) {
                return true;
            }
        }
    }
    return false;
};

/**
 * Checks if the account type of the logged in user is FREE.
 * @returns {boolean} True if the account type is FREE otherwise false
 */
tutao.ctrl.UserController.prototype.isLoggedInUserFreeAccount = function () {
    if (this.isInternalUserLoggedIn()) {
        var localAccountType = this.getLoggedInUser().getAccountType();
        return localAccountType === tutao.entity.tutanota.TutanotaConstants.ACCOUNT_TYPE_FREE;
    }
    return false;
};

// INTERNAL

/**
 * Provides the mail address of the logged in internal user.
 * @return {string} The user's mail address.
 */
tutao.ctrl.UserController.prototype.getMailAddress = function () {
    return this._mailAddress;
};

/**
 * Provides the domain of the logged in internal user.
 * @return {string} The user's domain.
 */
tutao.ctrl.UserController.prototype.getDomain = function () {
    return this._mailAddress.split("@")[1];
};

/**
 * Provides the client key of the logged in internal user.
 * @return {Object} The user's client key.
 */
tutao.ctrl.UserController.prototype.getUserClientKey = function () {
    return this._userClientKey;
};

/**
 * Provides the salt of the user verifier.
 * @return {Object} The salt.
 */
tutao.ctrl.UserController.prototype.getHexSalt = function () {
    return this._hexSalt;
};

/**
 * Provides the user group info
 * @return {tutao.entity.sys.GroupInfo} the user group info
 */
tutao.ctrl.UserController.prototype.getUserGroupInfo = function () {
    return this._userGroupInfo;
};

/**
 * Sets the given user as logged-in user.
 * @param {string} mailAddress The mail address of the user.
 * @param {string} passphrase The passphrase of the user.
 * @return {Promise.<>} Resolved when finished, rejected if the login failed.
 */
tutao.ctrl.UserController.prototype.loginUser = function (mailAddress, passphrase) {
    this.reset();
    var self = this;
    self._mailAddress = mailAddress.toLowerCase().trim();
    return tutao.entity.sys.SaltReturn.load(new tutao.entity.sys.SaltData().setMailAddress(self.getMailAddress()), {}, null).then(function (saltData) {
        self._hexSalt = tutao.util.EncodingConverter.base64ToHex(saltData.getSalt());
        return tutao.locator.kdfCrypter.generateKeyFromPassphrase(passphrase, self._hexSalt);
    }).then(function (hexKey) {
        // the verifier is always sent as url parameter, so it must be url encoded
        self._authVerifier = tutao.util.EncodingConverter.base64ToBase64Url(tutao.locator.shaCrypter.hashHex(hexKey));
        var authHeaders = {};
        authHeaders[tutao.rest.ResourceConstants.AUTH_VERIFIER_PARAMETER_NAME] = self._authVerifier;
        return tutao.entity.sys.UserIdReturn.load(new tutao.entity.sys.UserIdData().setMailAddress(self.getMailAddress()), {}, authHeaders).then(function (userIdReturn) {
            self._userId = userIdReturn.getUserId();
            self._userPassphraseKey = tutao.locator.aesCrypter.hexToKey(hexKey);
            return tutao.entity.sys.User.load(self._userId);
        });
    }).then(function (user) {
        self._user = user;
        self._userGroupId = user.getUserGroup().getGroup();
        self._userGroupKey = tutao.locator.aesCrypter.decryptKey(self._userPassphraseKey, user.getUserGroup().getSymEncGKey());
        self._userClientKey = tutao.locator.aesCrypter.decryptKey(self._userGroupKey, user.getUserEncClientKey());
        return tutao.entity.sys.GroupInfo.load(tutao.locator.userController.getLoggedInUser().getUserGroup().getGroupInfo())
    }).then(function (groupInfo) {
        self._userGroupInfo = groupInfo;
    }).caught(function (e) {
        self.reset();
        throw e;
    });
}
;

/**
 * Updates the user login data after a password change.
 * @param {String} hexPassphraseKey The key generated from the users passphrase as hex string.
 * @param {String} hexSalt hex value of the salt.
 */
tutao.ctrl.UserController.prototype.passwordChanged = function (hexPassphraseKey, hexSalt) {
    this._authVerifier = tutao.util.EncodingConverter.base64ToBase64Url(tutao.locator.shaCrypter.hashHex(hexPassphraseKey));
    this._userPassphraseKey = tutao.locator.aesCrypter.hexToKey(hexPassphraseKey);
    this._hexSalt = hexSalt;
};

/**
 * Provides the information if an internal user is logged in.
 * @return {boolean} True if an internal user is logged in, false if no user or an external user is logged in.
 */
tutao.ctrl.UserController.prototype.isInternalUserLoggedIn = function () {
    return (this._userGroupInfo && this._authToken == null);
};

// EXTERNAL

/**
 * Provides the authentication token that was used to log in the external user.
 * @return {string} The authentication token.
 */
tutao.ctrl.UserController.prototype.getAuthToken = function () {
    return this._authToken;
};

/**
 * Logs in an external user. Attention: the external user's user group key is not set here. Set it when the key is loaded via setExternalUserGroupKey().
 * @param {string} userId The user id of the user.
 * @param {string} password The password matching the authentication token.
 * @param {string} saltHex The salt that was used to salt the password, as hex string.
 * @return {Promise.<>} Resolved when finished, rejected if the login failed.
 */
tutao.ctrl.UserController.prototype.loginExternalUser = function (userId, password, saltHex) {
    var self = this;
    this.reset();

    return tutao.locator.kdfCrypter.generateKeyFromPassphrase(password, saltHex).then(function (hexKey) {
        // the verifier is always sent as url parameter, so it must be url encoded
        self._authVerifier = tutao.util.EncodingConverter.base64ToBase64Url(tutao.locator.shaCrypter.hashHex(hexKey));
        self._authToken = tutao.util.EncodingConverter.base64ToBase64Url(tutao.locator.shaCrypter.hashHex(saltHex));
        self._userId = userId;
        self._hexSalt = saltHex;

        var authHeaders = {};
        authHeaders[tutao.rest.ResourceConstants.AUTH_VERIFIER_PARAMETER_NAME] = self._authVerifier;
        self._userPassphraseKey = tutao.locator.aesCrypter.hexToKey(hexKey);
        return tutao.entity.sys.User.load(self._userId).then(function (user) {
            self._user = user;
            self._userGroupId = user.getUserGroup().getGroup();
            self._userGroupKey = tutao.locator.aesCrypter.decryptKey(self._userPassphraseKey, user.getUserGroup().getSymEncGKey());
            self._userClientKey = tutao.locator.aesCrypter.decryptKey(self._userGroupKey, user.getUserEncClientKey());
            return tutao.entity.sys.GroupInfo.load(tutao.locator.userController.getLoggedInUser().getUserGroup().getGroupInfo()).then(function (groupInfo) {
                self._userGroupInfo = groupInfo;
                self._mailAddress = groupInfo.getMailAddress();
            });
        });
    }).caught(function(e) {
        self.reset();
        throw e;
    });
};

/**
 * Provides the information if an external user is logged in.
 * @return {boolean} True if an external user is logged in, false if no user or an internal user is logged in.
 */
tutao.ctrl.UserController.prototype.isExternalUserLoggedIn = function () {
    return (this._authToken != null); // only check auth token because this is already called when loading the user in loginExternalUser()
};
"use strict";

tutao.provide('tutao.tutanota.ctrl.View');

/**
 * A View represents the canvas on which type of functionality is provided in Tutanota. The content of a view
 * is not necessarily completely visible but may be moved into the visible area (window) of a browser by a ViewSlider.
 * @interface
 */
tutao.tutanota.ctrl.View = function() {};

/**
 * Called after loading Tutanota.
 * @param {Boolean} external True if the view shall be loaded for an external user, false for an internal user.
 */
tutao.tutanota.ctrl.View.prototype.init = function(external) {};

/**
 * Provides the information if this view shall only be shown to internal users.
 */
tutao.tutanota.ctrl.View.prototype.isForInternalUserOnly = function() {};

/**
 * Called directly before the view is shown.
 * @param {Object=} params The parameters for this view.
 */
tutao.tutanota.ctrl.View.prototype.activate = function(params) {};

/**
 * Called directly before the view is hidden.
 */
tutao.tutanota.ctrl.View.prototype.deactivate = function() {};

/**
 * Called if this view is active and the window size has changed.
 * @return {tutao.tutanota.gui.SwipeSlider} The SwipeSlider used by the view.
 */
tutao.tutanota.ctrl.View.prototype.getSwipeSlider = function() {};

/**
 * Provides the information if it is allowed to show the left neighbour column.
 * @return {boolean} True if the left neighbour column can be shown, false otherwise.
 */
tutao.tutanota.ctrl.View.prototype.isShowLeftNeighbourColumnPossible = function() {};

/**
 * Provides the information if it is allowed to show the right neighbour column.
 * @return {boolean} True if the right neighbour column can be shown, false otherwise.
 */
tutao.tutanota.ctrl.View.prototype.isShowRightNeighbourColumnPossible = function() {};
"use strict";

tutao.provide('tutao.tutanota.ctrl.ViewManager');

/**
 * The ViewManager is responsible for activating and deactivating views.
 *
 * @constructor
 */
tutao.tutanota.ctrl.ViewManager = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	var self = this;

	// tutao.tutanota.ctrl.View
	this._activeView = ko.observable(new tutao.tutanota.gui.NotFoundView()); // just a dummy view because null must be avoided
	this._internalUserLoggedIn = ko.observable(false);
	this._externalUserLoggedIn = ko.observable(false);
	this._bigWindowWidth = ko.observable(tutao.tutanota.gui.getWindowWidth() >= 480);
    this.windowWidthObservable = ko.observable(0);
    this.headerBarViewModel = null;

	// if the window width is small, just show the logo without "Tutanota" to save space
	tutao.tutanota.gui.addWindowResizeListener(function(width, height) {
		self._bigWindowWidth(tutao.tutanota.gui.getWindowWidth() >= 480);
        self.windowWidthObservable(width);
	});
};



tutao.tutanota.ctrl.ViewManager.prototype.getLoggedInUserAccountType = function(){
    if ( this._internalUserLoggedIn() || this._externalUserLoggedIn()){
        return tutao.locator.userController.getLoggedInUser().getAccountType();
    }
    return null;
};

/**
 * @return {Array.<tutao.tutanota.ctrl.View>} views All the views of this ViewManager.
 */
tutao.tutanota.ctrl.ViewManager.prototype.getViews = function() {
    return [tutao.locator.registrationView, tutao.locator.loginView, tutao.locator.mailView, tutao.locator.contactView, tutao.locator.fileView, tutao.locator.externalLoginView, tutao.locator.notSupportedView, tutao.locator.settingsView,tutao.locator.registrationVerifyDomainView];
};

/**
 * @return {Array.<tutao.tutanota.ctrl.Button>} views All the views of this ViewManager.
 */
tutao.tutanota.ctrl.ViewManager.prototype.getButtons = function() {
    var self = this;
    var internalUser = function() {
        return tutao.locator.userController.getLoggedInUser() && tutao.locator.userController.isInternalUserLoggedIn();
    };
    var buttons = [
        // internalUsers
        new tutao.tutanota.ctrl.Button('new_label', 30, tutao.locator.navigator.newMail, function () {
            return internalUser() && self.getActiveView() == tutao.locator.mailView;
        }, false, "menu_mail_new", "mail-new", 'newMail_alt'),
        new tutao.tutanota.ctrl.Button('emails_label', 30, tutao.locator.navigator.mail, function () {
            return internalUser() && self.getActiveView() != tutao.locator.mailView;
        }, false, "menu_mail", "mail", 'emails_alt'),

        new tutao.tutanota.ctrl.Button('new_label', 29, tutao.locator.navigator.newContact, function () {
            return internalUser() && self.getActiveView() == tutao.locator.contactView;
        }, false, "menu_contact_new", "contact-new", 'newContact_alt'),
        new tutao.tutanota.ctrl.Button('contacts_label', 29, tutao.locator.navigator.contact, function () {
            return internalUser() && self.getActiveView() != tutao.locator.contactView;
        }, false, "menu_contact", "contact", 'contacts_alt'),

        new tutao.tutanota.ctrl.Button('invite_label', 28, function() {
            tutao.tutanota.ctrl.Navigator.prototype.newMail().then(function () {
                var mail = tutao.locator.mailViewModel.getComposingMail();
                mail.composerSubject(tutao.locator.languageViewModel.get("invitationMailSubject_msg"));
                mail.secure(false);
                var username = tutao.locator.userController.getUserGroupInfo().getName();
                tutao.locator.mailView.setComposingBody(tutao.locator.htmlSanitizer.sanitize(tutao.locator.languageViewModel.get("invitationMailBody_msg", {'$': username})));
            });

        }, self.isInternalUserLoggedIn, false, "menu_invite", "invite", 'invite_alt'),

        new tutao.tutanota.ctrl.Button('settings_label', 27, tutao.locator.navigator.settings, self.isInternalUserLoggedIn, false, "menu_settings", "settings", 'settings_alt'),

        // external users
        new tutao.tutanota.ctrl.Button('register_label', 27, tutao.locator.navigator.register, self._externalUserLoggedIn, false, "menu_register", "register", 'register_alt'),

        // all supported
        new tutao.tutanota.ctrl.Button('feedback_label', 26, tutao.locator.feedbackViewModel.open, this.feedbackSupported, false, "menu_feedback", "feedback", 'feedback_alt'),

        // all logged in
        new tutao.tutanota.ctrl.Button('logout_label', 25, function () {
            tutao.locator.navigator.logout(false, true);
        }, self.isUserLoggedIn, false, "menu_logout", "logout", 'logout_alt'),
    ];

    return buttons;
};

/**
 * Initializes the ViewManager and all views.
 * @param {Boolean} external True if the views shall be loaded for an external user, false for an internal user.
 */
tutao.tutanota.ctrl.ViewManager.prototype.init = function(external) {
    var views = this.getViews();
	for (var i = 0; i < views.length; i++) {
		views[i].init(external);
	}

    var self = this;

    // If these widths are changed, we have to update them in header.less, too.
    var menuItemWidth = 80;
    var menuItemWidthSmall= 45;
    var measureNavButton = function() {
        if (window.innerWidth >= 720) {
            return menuItemWidth;
        } else {
            return menuItemWidthSmall;
        }
    };
    this.headerBarViewModel = new tutao.tutanota.ctrl.ButtonBarViewModel(this.getButtons(), "more_label", measureNavButton);
};

tutao.tutanota.ctrl.ViewManager.prototype.feedbackSupported = function() {
    if (tutao.locator.userController.getLoggedInUser()) {
        return tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_SUPPORTED || tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_SAFARI;
    } else {
        return false;
    }
};

/**
 * Switches to another view
 * @param {tutao.tutanota.ctrl.View} view The view to display.
 * @param {Object=} params The parameters to provide to the view.
 */
tutao.tutanota.ctrl.ViewManager.prototype.select = function(view, params) {
	if (view.isForInternalUserOnly() && !tutao.locator.userController.isInternalUserLoggedIn()) {
		return;
	}
	if (this._activeView() !== view) { // only switch, if another view should be shown
		if (this._activeView() != null) {
			this._activeView().deactivate();
		}
		if (tutao.locator.userController.isInternalUserLoggedIn()) {
			this._internalUserLoggedIn(true);
		} else if (tutao.locator.userController.isExternalUserLoggedIn()) {
			this._externalUserLoggedIn(true);
		}
		this._activeView(view);
		this._activeView().activate(params);
        tutao.tutanota.gui.adjustPanelHeight();
	}
};

/**
 * @return {tutao.tutanota.ctrl.View} the currently active view.
 */
tutao.tutanota.ctrl.ViewManager.prototype.getActiveView = function() {
	return this._activeView();
};

/**
 * @return {boolean} true, if the user is already logged in, false otherwise.
 */
tutao.tutanota.ctrl.ViewManager.prototype.isUserLoggedIn = function() {
	return (this._internalUserLoggedIn() || this._externalUserLoggedIn());
};

/**
 * @return {boolean} true, if an internal user is already logged in, false otherwise.
 */
tutao.tutanota.ctrl.ViewManager.prototype.isInternalUserLoggedIn = function() {
	return this._internalUserLoggedIn();
};

/**
 * Shows the home view (which is currently the mail view).
 */
tutao.tutanota.ctrl.ViewManager.prototype.showHomeView = function() {
	if (this.isInternalUserLoggedIn() && this.getActiveView() != tutao.locator.mailView) {
		this.select(tutao.locator.mailView);
	}
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.ViewSlider');

/**
 * Represents a view with multiple view columns. Depending on the screen width and the view columns configurations, the actual widths and positions of the view
 * columns is calculated. This allows a consistent layout for any browser resolution on any type of device.
 * @constructor
 */
tutao.tutanota.ctrl.ViewSlider = function() {
	 // all dummy values until showDefault is called the first time
	// static values (only change at initialization or screen width change)
	this._viewColumns = [];
	this._screenWidth = 0;
	this._initialized = false;
	this._receiver = undefined;
	this._defaultViewStartIndex = 0;
	this._defaultViewEndIndex = 0;

	// dynamic information (changes depending on the currently visible columns of the view)
	this._minVisibleColumn = -1;
	this._maxVisibleColumn = -1;
	this._mainViewColumnId = -1; // the view column that was selected via showViewColumn or -1 if showDefault was called
};

/**
 * Adds a view column by providing its configuration and returns an id for it. All view columns must be added during the initialization of the ViewSlider.
 * @param {number} prio The priority of the view column. Lower value = higher priority. This is used to determine which view columns are visible by default.
 * @param {number} minWidth The minimum allowed width for the view column.
 * @param {number} maxWidth The maximum allowed width for the view column.
 * @param {function(number, number)} widthReceiver A listener function that is called whenever the position or width of the view column is modified. Receives the x position and width
 * of the view column as argument.
 * @return {number} The id that is now associated with the view column. Use it for calls to showViewColumn and isVisible.
 */
tutao.tutanota.ctrl.ViewSlider.prototype.addViewColumn = function(prio, minWidth, maxWidth, widthReceiver) {
	// 0 is a dummy width until showDefault is called the first time
	this._viewColumns.push({ prio: prio, minWidth: minWidth, maxWidth: maxWidth, widthReceiver: widthReceiver, width: null});
	return this._viewColumns.length - 1;
};

/**
 * Set the function that is called when the position and/or width of the view need to be adopted. This function must be called
 * during initialization.
 * @param {function(number,number,boolean)} receiver A listener function that is called as soon as the position and/or width of the view need to be adopted.
 * First argument is the left position in px, second argument is the width in px, third argument indicates if this is the initial call to set the left
 * position and width. The receiver can use this information e.g to initially set the values directly in the gui and animate the change otherwise.
 */
tutao.tutanota.ctrl.ViewSlider.prototype.setViewPositionAndSizeReceiver = function(receiver) {
	this._receiver = receiver;
};

/**
 * Calculates the width of each column and calculates the default columns.
 */
tutao.tutanota.ctrl.ViewSlider.prototype._initColumns = function() {
	this._calculateDefaultColumns();

	// calculate the column widths of the columns left and right of the default columns
	for (var i = this._defaultViewEndIndex + 1; i < this._viewColumns.length; i++) {
		// try to find a width that make complete columns visible in that view
		var widthSum = this._viewColumns[i].minWidth;
		// walk from the column left and add up the widths until it does not fit into the screen any more
		var currentColumn = i - 1;
		while (widthSum + this._viewColumns[currentColumn].width < this._screenWidth) {
			widthSum += this._viewColumns[currentColumn].width;
			currentColumn--;
		}
		this._viewColumns[i].width = Math.min(this._viewColumns[i].minWidth + (this._screenWidth - widthSum), this._viewColumns[i].maxWidth);
	}

	for (var i = this._defaultViewStartIndex - 1; i >= 0; i--) {
		// try to find a width that make complete columns visible in that view
		var widthSum = this._viewColumns[i].minWidth;
		// walk from the column right and add up the widths until it does not fit into the screen any more
		var currentColumn = i + 1;
		while (widthSum + this._viewColumns[currentColumn].width < this._screenWidth) {
			widthSum += this._viewColumns[currentColumn].width;
			currentColumn++;
		}
		this._viewColumns[i].width = Math.min(this._viewColumns[i].minWidth + (this._screenWidth - widthSum), this._viewColumns[i].maxWidth);
	}

	// notify the column widths and positions
	var posX = 0;
	for (var i = 0; i < this._viewColumns.length; i++) {
		// notify the view column via the setter function
		this._viewColumns[i].widthReceiver(posX, this._viewColumns[i].width);
		posX += this._viewColumns[i].width;
	}
};

/**
 * Calculates the default columns (_defaultViewStartIndex, _defaultViewEndIndex) and the widths of those columns.
 */
tutao.tutanota.ctrl.ViewSlider.prototype._calculateDefaultColumns = function() {
	// calculate the highest prio column
	var highestPrio = null;
	var highestPrioColumn = null;
	for (var i = 0; i < this._viewColumns.length; i++) {
		if (highestPrio == null || this._viewColumns[i].prio < highestPrio) {
			highestPrio = this._viewColumns[i].prio;
			highestPrioColumn = i;
		}
	}
	// find neighbours to be contained in the default columns
	var width = Math.min(this._viewColumns[highestPrioColumn].minWidth, this._screenWidth);
	var index = highestPrioColumn;
	this._defaultViewStartIndex = highestPrioColumn;
	this._defaultViewEndIndex = highestPrioColumn;
	while (true) {
		index = this._getHighestPrioNeighbour(this._defaultViewStartIndex, this._defaultViewEndIndex);
		if (index == null) {
			break;
		}
		if (width + this._viewColumns[index].minWidth <= this._screenWidth) {
			width += this._viewColumns[index].minWidth;
			this._defaultViewStartIndex = Math.min(this._defaultViewStartIndex, index);
			this._defaultViewEndIndex = Math.max(this._defaultViewEndIndex, index);
		} else {
			break;
		}
	}
	if (this._defaultViewStartIndex == this._defaultViewEndIndex) {
		// only one default column
		if (this._viewColumns.length == 1) {
			// there is only one column at all, so use the max width if that is less than the window width
			this._viewColumns[this._defaultViewStartIndex].width = Math.min(this._screenWidth, this._viewColumns[this._defaultViewStartIndex].maxWidth);
		} else {
			this._viewColumns[this._defaultViewStartIndex].width = this._screenWidth;
		}
	} else {
		// calculate the widths of the default columns
		var spareWidth = this._screenWidth - width;
		// distribute the spareWidth to the default columns proportional to their minWidth
		var newWidth = 0;
		for (var i = this._defaultViewStartIndex; i < this._defaultViewEndIndex; i++) {
			this._viewColumns[i].width = Math.floor(this._viewColumns[i].minWidth + spareWidth * this._viewColumns[i].minWidth / width);
			newWidth += this._viewColumns[i].width;
		}
		// calculate the last columns width from newWidth to make sure that by rounding no spare pixels are left
		this._viewColumns[this._defaultViewEndIndex].width = this._screenWidth - newWidth;
	}
};

/**
 * Provides the index of the column that has the highest priority left or right of the given columns.
 * @param {number} columnIndex The column to check the neighbours for.
 * @return {number=} The index of the heighest prio neighbour or null if none.
 */
tutao.tutanota.ctrl.ViewSlider.prototype._getHighestPrioNeighbour = function(minColumnId, maxColumnId) {
	if (minColumnId == 0 && maxColumnId == this._viewColumns.length - 1) {
		return null;
	} else if (minColumnId == 0) {
		return maxColumnId + 1;
	} else if (maxColumnId == this._viewColumns.length - 1) {
		return minColumnId - 1;
	} else if (this._viewColumns[minColumnId - 1].prio > this._viewColumns[maxColumnId + 1].prio) {
		return maxColumnId + 1;
	} else {
		return minColumnId - 1;
	}
};

/**
 * Sets the current screen width if it has changed, e.g. browser resizing or tablet orientation change.
 * The view slider will update the view columns sizes and positions accordingly.
 * @param {number} screenWidth The width of the visible browser area.
 */
tutao.tutanota.ctrl.ViewSlider.prototype.setScreenWidth = function(screenWidth) {
	this._screenWidth = screenWidth;
	if (this._initialized) {
		this._initialized = false; // screen width changes are regarded as new initialization
		// reset the visible columns to calculate them again
		if (this._mainViewColumnId == -1) {
			// the default columns were visible, so show them now again
			this.showDefault();
		} else {
			this.showViewColumn(this._mainViewColumnId);
		}
	}
};

/**
 * Adjusts the layout of the view columns according to their properties (prio, min/max width).
 * This function must be called once after the initialization of the ViewSlider
 * is finished (setViewPositionAndSizeReceiver, initial setScreenWidth and addViewColumn for all view columns).
 */
tutao.tutanota.ctrl.ViewSlider.prototype.showDefault = function() {
	var initial = !this._initialized;
	if (!this._initialized) {
		this._initColumns();
		this._initialized = true;
	}
	if (initial || this._minVisibleColumn != this._defaultViewStartIndex || this._maxVisibleColumn != this._defaultViewEndIndex) {
		this._mainViewColumnId = -1; // this must be -1 if showDefault is called

		this._minVisibleColumn = this._defaultViewStartIndex;
		this._maxVisibleColumn = this._defaultViewEndIndex;
		this.notifyViewPosition(initial);
	}
};

/**
 * Calculates the view position according to the minimum visible column and notifies the position receiver.
 * @param {boolean} initial Indicates if this is an initial notification.
 */
tutao.tutanota.ctrl.ViewSlider.prototype.notifyViewPosition = function(initial) {
	var x = 0;
	for (var i = 0; i < this._minVisibleColumn; i++) {
		x -= this._viewColumns[i].width;
	}
	var viewWidth = this._getViewWidth();
	// center the visible columns if they are smaller than the window width (may only happen if they are the only columns at all)
	if (viewWidth < this._screenWidth) {
		x = (this._screenWidth - viewWidth) / 2;
	}
	this._receiver(x, viewWidth, initial);
};

/**
 * Adjusts the view column positions to make the given view column visible.
 * @param {number} viewColumnId The id of the view columns that shall be made visible.
 */
tutao.tutanota.ctrl.ViewSlider.prototype.showViewColumn = function(viewColumnId) {
	var initial = !this._initialized; // this may be initial after a screen width change
	if (!this._initialized) {
		this._initColumns();
		this._initialized = true;
	}

	this._mainViewColumnId = viewColumnId;

	if (initial) {
		// show at least the column with the id viewColumnId
		// if possible additionally show other former visible columns (by prio)
		// if possible additionally show other columns (by prio)
		var newMin = viewColumnId;
		var newMax = viewColumnId;
		var widthSum = this._viewColumns[viewColumnId].width;
		while (true) {
			var next = null;
			if (this._minVisibleColumn < newMin && this._maxVisibleColumn > newMax) {
				// there were left and right additional visible columns, so check their prio
				next = this._getHighestPrioNeighbour(newMin, newMax);
			} else if (this._minVisibleColumn < newMin) {
				// there were left additional visible columns
				next = newMin - 1;
			} else if (this._maxVisibleColumn > newMax) {
				// there were right additional visible columns
				next = newMax + 1;
			} else {
				// there are no former visible columns left and right any more, so just check the remaining
				// former non-visible ones
				next = this._getHighestPrioNeighbour(newMin, newMax);
			}
			if (next == null || next == -1 || next == this._viewColumns.length) {
				break;
			} else if (widthSum + this._viewColumns[next].width <= this._screenWidth) {
				widthSum += this._viewColumns[next].width;
				newMin = Math.min(newMin, next);
				newMax = Math.max(newMax, next);
			} else {
				break;
			}
		}
		this._minVisibleColumn = newMin;
		this._maxVisibleColumn = newMax;
		this.notifyViewPosition(initial);
	} else	if (viewColumnId < this._minVisibleColumn) {
		// move the view as little as possible so that the column becomes visible
		// calculate the visible columns
		this._minVisibleColumn = viewColumnId;
		var widthSum = 0;
		var index = viewColumnId;
		while (widthSum + this._viewColumns[index].width <= this._screenWidth) {
			widthSum += this._viewColumns[index].width;
			index++;
		}
		this._maxVisibleColumn = index - 1;
		this.notifyViewPosition(initial);
	} else if (viewColumnId > this._maxVisibleColumn) {
		// calculate the visible columns
		this._maxVisibleColumn = viewColumnId;
		var widthSum = 0;
		var index = viewColumnId;
		while (widthSum + this._viewColumns[index].width <= this._screenWidth) {
			widthSum += this._viewColumns[index].width;
			index--;
		}
		this._minVisibleColumn = index + 1;
		this.notifyViewPosition(initial);
	}
};

/**
 * Provides the information if the view column associated with the given id is visible. Partly visible view columns are regarded as not visible.
 * @param {number} viewColumnId The id of the view columns.
 * @return {boolean} Returns true if the view columns is visible, false otherwise.
 */
tutao.tutanota.ctrl.ViewSlider.prototype.isVisible = function(viewColumnId) {
	return (viewColumnId >= this._minVisibleColumn && viewColumnId <= this._maxVisibleColumn);
};

/**
 * Provides the id of the leftmost visible column.
 * @return {number} The id of the leftmost visible column.
 */
tutao.tutanota.ctrl.ViewSlider.prototype.getLeftmostVisibleColumnId = function() {
	return this._minVisibleColumn;
};

/**
 * Provides the id of the rightmost visible column.
 * @return {number} The id of the rightmost visible column.
 */
tutao.tutanota.ctrl.ViewSlider.prototype.getRightmostVisibleColumnId = function() {
	return this._maxVisibleColumn;
};

/**
 * Provides the width of the complete view which is the sum of its view columns.
 * @protected
 * @return {number} The width of the view.
 */
tutao.tutanota.ctrl.ViewSlider.prototype._getViewWidth = function() {
	// the view width is the sum of all view columns
	var viewWidth = 0;
	for (var i = 0; i < this._viewColumns.length; i++) {
		viewWidth += this._viewColumns[i].width;
	}
	return viewWidth;
};



//Html and css for a simple test:
//
//<!DOCTYPE html>
//<html>
//<head>
//  <meta charset="utf-8" />
//  <meta name="apple-mobile-web-app-capable" content="yes" />
//  <meta name="viewport" content="initial-scale=1.0,maximum-scale=1.0">
//  <title>Test</title>
//     <link href="test.css" rel="stylesheet" type="text/css">
//    <script type="text/javascript" src="libs/closure-library-2012-01-19/closure/goog/base.js"></script>
//  <script type="text/javascript" src="libs/jquery-1.7.1.js"></script>
//  <script type="text/javascript" src="js/ctrl/ViewSlider.js"></script>
//<script type="text/javascript">
//$(document).ready(function() {
//  window.view = new tutao.tutanota.ctrl.ViewSlider();
//  window.view.setScreenWidth(1024);
//  window.view.setViewPositionAndSizeReceiver(function(left, width, initial) {
//    if (initial) {
//      $('#view').css("left", left + "px");
//    } else {
//      $('#view').animate({ left: left + "px"}, 300);
//    }
//    $('#view').css("width", width + "px");
//  });
//  window.view.addViewColumn(2, 150, 150, function(width) { {number}
//	  $('#viewColumn0').css("width", width + "px");
//  });
//  window.view.addViewColumn(0, 300, 300, function(width) {
//    $('#viewColumn1').css("width", width + "px");
//  });
//  window.view.addViewColumn(1, 724, 724, function(width) {
//    $('#viewColumn2').css("width", width + "px");
//  });
//  window.view.showDefault();
//  // window.view.showViewColumn(0);
//});
//</script>
//</head>
//<body>
//  <div id="view">
//    <div id="viewColumn0">
//      tags tags tags tags tags tags tags tags tags tags tags tags tags tags tags tags tags tags tags tags tags tags tags tags
//    </div>
//    <div id="viewColumn1">
//      mail list mail list mail list mail list mail list mail list mail list mail list mail list mail list mail list mail list mail list mail list
//    </div>
//    <div id="viewColumn2">
//      mails mails mails mails mails mails mails mails mails mails mails mails mails mails mails mails mails mails mails mails mails mails mails
//    </div>
//  </div>
//</body>
//</html>
//
//body {
//  overflow-x: hidden;
//}
//
//div#view {
//  position: absolute;
//  top: 65px;
//  bottom: 0px;
//}
//
//div#viewColumn0 {
//  position: relative;
//  height: 100%;
//  float: left;
//  background: #456743;
//}
//
//div#viewColumn1 {
//  position: relative;
//  height: 100%;
//  float: left;
//  background: #956443;
//}
//
//div#viewColumn2 {
//  position: relative;
//  height: 100%;
//  float: left;
//  background: #156793;
//}

"use strict";

tutao.provide('tutao.RecipientsNotFoundError');

/**
 * Indicates that the email could not be sent because some of the recipients could not be found.
 * @param {Array.<string>} recipients The email addresses of the recipients that could not be found.
 * @constructor
 */
tutao.RecipientsNotFoundError = function RecipientsNotFoundError(recipients) {
    this._recipients = recipients;
    this.message = "recipients not found: " + recipients.join(", ");
    this.name = "RecipientsNotFoundError";
    if (Error.captureStackTrace) {
        Error.captureStackTrace(this, RecipientsNotFoundError);
    } else {
        this.stack = this.name + ". " + this.message + "\n" + new Error().stack.split("\n").slice(1).join("\n"); // removes first line from stack
    }
};
tutao.RecipientsNotFoundError.prototype = Object.create(Error.prototype);
tutao.RecipientsNotFoundError.prototype.constructor = tutao.RecipientsNotFoundError;

/**
 * Provides the email addresses of the recipients that could not be found.
 * @return {Array.<string>} The email addresses of the recipients.
 */
tutao.RecipientsNotFoundError.prototype.getRecipients = function() {
    return this._recipients;
};

"use strict";

tutao.provide('tutao.event.EventBusClient');

/**
 * The EventBus encapsulates the WebSocket connection to the server. It currently only forwards messages to observers.
 */
tutao.event.EventBusClient = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this); // listener methods are invoked from the Websocket
	this._socket = null;
    /** @type {Array.<tutao.event.EventBusListener>} */
    this._listeners = [];
};

/**
 * Notifies all listeners on reconnect event.
 */
tutao.event.EventBusClient.prototype.notifyReconnected = function() {
    for( var i=0; i < this._listeners.length; i++){
        this._listeners[i].notifyReconnected();
    }
};

/**
 * Notifies all listener when receiving new data.
 * @param {tutao.entity.sys.EntityUpdate} data The update notification
 */
tutao.event.EventBusClient.prototype.notifyNewDataReceived = function(data) {
    for( var i=0; i < this._listeners.length; i++){
        this._listeners[i].notifyNewDataReceived(data);
    }
};


/**
 * Adds a listener to this event bus client.
 * @param {tutao.event.EventBusListener} listener The listener that is notified for changes.
 */
tutao.event.EventBusClient.prototype.addListener = function(listener) {
    this._listeners.push(listener);
};

/**
 * Opens a WebSocket connection to receive server events.
 * @param reconnect Set to true if the connection has been opened before.
 * @returns {tutao.event.EventBusClient} The event bus client object.
 */
tutao.event.EventBusClient.prototype.connect = function(reconnect) {
	var self = this;
	var url = tutao.env.getWebsocketOrigin() + "/event/";
	this._socket = new WebSocket(url);
	this._socket.onopen = function() {
		console.log("ws open: ", new Date());
		var authentication = new tutao.entity.sys.Authentication()
			.setUserId(tutao.locator.userController.getUserId())
			.setAuthVerifier(tutao.locator.userController.getAuthVerifier());
		var wrapper = new tutao.entity.sys.WebsocketWrapper()
			.setType("authentication")
			.setMsgId("0")
			.setAuthentication(authentication);

	    self._socket.send(JSON.stringify(wrapper.toJsonData()));
        if (reconnect) {
            self.notifyReconnected();
        }
	};
	this._socket.onclose = this._close;
	this._socket.onerror = this._error;
	this._socket.onmessage = this._message;
	return this;
};

/**
 * Sends a close event to the server and closes the connection.
 */
tutao.event.EventBusClient.prototype.close = function() {
	if (this._socket) {
		this._socket.close();
	}
};

tutao.event.EventBusClient.prototype._error = function(error) {
	console.log("ws error: ", error);
};

tutao.event.EventBusClient.prototype._message = function(message) {
	console.log("ws message: ", message.data);
	var wrapper = new tutao.entity.sys.WebsocketWrapper(JSON.parse(message.data));
	if (wrapper.getType() === 'chat') {
		console.log(wrapper.getChat().getSender() + " > " + wrapper.getChat().getText());
	} else if (wrapper.getType() === 'entityUpdate') {
		this.notifyNewDataReceived(wrapper.getEntityUpdate());
	}
};

tutao.event.EventBusClient.prototype._close = function(event) {
	console.log("ws close: ", event, new Date());
    if (tutao.locator.userController.isInternalUserLoggedIn()) {
        setTimeout(this._reconnect, 1000 * this._randomIntFromInterval(30, 100));
    }
};

tutao.event.EventBusClient.prototype._reconnect = function() {
    console.log("reconnect socket state: " + this._socket.readyState);
    this.connect(true);
};

tutao.event.EventBusClient.prototype._randomIntFromInterval = function(min,max) {
    return Math.floor(Math.random()*(max-min+1)+min);
};
"use strict";

tutao.provide('tutao.event.EventBusListener');

/**
 * Interface for receiving EventBusClient events.
 * @interface
 */
tutao.event.EventBusListener = function() {};


/**
 * Notifies the listener that new data has been received.
 * @param {tutao.entity.sys.EntityUpdate} data The update notification.
 */
tutao.event.EventBusListener.prototype.notifyNewDataReceived = function(data) {};


/**
 * Notifies a listener about the reconnect event,
 */
tutao.event.EventBusListener.prototype.notifyReconnected = function() {};
"use strict";

tutao.provide('tutao.event.ListEventTracker');
//import('tutao.event.Observable');


/**
 * The ListEventTracker is an Observable that itself observes db contents (Lists). Just register
 * as an observer after telling which list you want to track.
 * @param {Object} listType The list type that shall be tracked.
 * @param {string} listId The list id of the type.
 * @interface
 * @implements {tutao.event.ObservableInterface}
 * @protected
 */
tutao.event.ListEventTracker = function(listType, listId) {};


/**
 * Starts listening for new elements with an id bigger than the given one.
 * @param {string} highestId Only elements of ids bigger than this one are reported.
 */
tutao.event.ListEventTracker.prototype.observeList = function(highestId) {};

"use strict";

tutao.provide('tutao.event.Observable');

/**
 * The subject of the Observable pattern
 * @constructor
 * @implements {tutao.event.ObservableInterface}
 */
tutao.event.Observable = function() {
	/**
	 * @type {Array.<Function>}
	 * @protected
	 */
	this._observers = [];
};

/**
 * Adds the observer.
 * <b>Attention:</b> The observer will be invoked directly. Note that you are responsible
 * to bind the function another context (this) if needed.
 * @param {function()} observer The function that is called for notifications.
 */
tutao.event.Observable.prototype.addObserver = function(observer) {
	this._observers.push(observer);
};

/**
 * Removes the observer
 * @param {function()} observer The observer function that shall be removed.
 */
tutao.event.Observable.prototype.removeObserver = function(observer) {
	tutao.util.ArrayUtils.remove(this._observers, observer);
};

/**
 * Notifies all observers with the provided data
 * @param {Object} data The data structure to hand over to observers.
 */
tutao.event.Observable.prototype.notifyObservers = function(data) {
	for (var i = 0; i < this._observers.length; i++) {
		this._observers[i](data);
	}
};

"use strict";

tutao.provide('tutao.event.ObservableInterface');

/**
 * The subject of the Observable pattern
 * @interface
 */
tutao.event.ObservableInterface = function() {};

/**
 * Adds the observer.
 * <b>Attention:</b> The observer will be invoked directly. Note that you are responsible
 * to bind the function another context (this) if needed.
 * @param {function()} observer The function that is called for notifications.
 */
tutao.event.ObservableInterface.prototype.addObserver = function(observer) {};

/**
 * Removes the observer
 * @param {function()} observer The observer function that shall be removed.
 */
tutao.event.ObservableInterface.prototype.removeObserver = function(observer) {};

/**
 * Notifies all observers with the provided data
 * @param {Object} data The data structure to hand over to observers.
 */
tutao.event.ObservableInterface.prototype.notifyObservers = function(data) {};

"use strict";

tutao.provide('tutao.event.PushListEventTracker');

/**
 * The PushListEventTracker uses the EventBusClient to fetch information about
 * updated or added data for a specific list of generated id types.
 * @param {Object} listType The list type that shall be tracked.
 * @param {string} listId The list id of the type.
 * @param {string} typeName The typeName of the type.
  * @constructor
 * @implements {tutao.event.ListEventTracker}
 * @implements {tutao.event.EventBusListener}
 */
tutao.event.PushListEventTracker = function(listType, listId, typeName) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this); // listener methods are invoked from the observable EventBusClient
	this._listType = listType;
	this._path = listType.PATH;
	this._typeName = typeName;
	this._listId = listId;
	this._version = listType.MODEL_VERSION;
	this._highestElementId = tutao.rest.EntityRestInterface.GENERATED_MIN_ID;

	this._observable = new tutao.event.Observable();
};

/**
 * @inheritDoc
 */
tutao.event.PushListEventTracker.prototype.addObserver = function(observer) {
	this._observable.addObserver(observer);
};

/**
 * @inheritDoc
 */
tutao.event.PushListEventTracker.prototype.removeObserver = function(observer) {
	this._observable.removeObserver(observer);
};

/**
 * @inheritDoc
 */
tutao.event.PushListEventTracker.prototype.notifyObservers = function(data) {
	this._observable.notifyObservers(data);
};

/**
 * @inheritDoc
 */
tutao.event.PushListEventTracker.prototype.observeList = function(highestId) {
    this._highestElementId = highestId;
    this._notifyAboutExistingElements();
    tutao.locator.eventBus.addListener(this);
};


/**
 * @param {tutao.entity.sys.EntityUpdate} update The update notification.
 */
tutao.event.PushListEventTracker.prototype._handleEventBusNotification = function(update) {
	var self = this;
	if (update.getType() === this._typeName && update.getInstanceListId() === this._listId && update.getOperation() == tutao.entity.tutanota.TutanotaConstants.OPERATION_TYPE_CREATE) {
		return tutao.locator.entityRestClient.getElement(self._listType, self._path, update.getInstanceId(), self._listId, { "v": self._version }, tutao.entity.EntityHelper.createAuthHeaders()).then(function(instance) {
            return instance._entityHelper.loadSessionKey().then(function(instance) {
                self.notifyObservers([instance]);
                self._highestElementId = instance.getId()[1];
            });
		}).caught(function(exception) {
            console.log(exception);
        });
	} else {
        return Promise.resolve();
    }
};

tutao.event.PushListEventTracker.prototype._notifyAboutExistingElements = function() {
    var self = this;
    return tutao.rest.EntityRestInterface.loadAll(self._listType, self._listId, self._highestElementId).then(function(newElements) {
        if (newElements.length > 0) {
            return tutao.entity.EntityHelper.loadSessionKeys(newElements).then(function(newElements) {
                self.notifyObservers(newElements);
                if ( newElements.length > 0 ){
                    self._highestElementId = newElements[newElements.length - 1].getId()[1];
                }
            });
        } else {
            return Promise.resolve();
        }
    });
};

/**
 * @inheritDoc
 */
tutao.event.PushListEventTracker.prototype.notifyNewDataReceived = function (data) {
    this._handleEventBusNotification(data);
};

/**
 * @inheritDoc
 */
tutao.event.PushListEventTracker.prototype.notifyReconnected = function() {
    this._notifyAboutExistingElements();
};

"use strict";

tutao.provide('tutao.tutanota.index.Indexer');

/**
 * Is responsible for indexing elements and performing searches on the index.
 * @constructor
 */
tutao.tutanota.index.Indexer = function() {

};

/**
 * Indexes all elements in the provided array that are not already indexed.
 * @param {number} typeId The id of the type of the elements to index.
 * @param {[string]|Array.<[string,string]>} ids The ids of the elements to index. The id order ascending.
 * @param {function(?string)} callback This function is called as soon as the operation is finished and passes the first
 * id from the ids list whose element was indexed.
 */
tutao.tutanota.index.Indexer.prototype.tryIndexElements = function(typeId, ids, callback) {
	var self = this;
	if (ids.length === 0) {
		if (callback) {
			callback(null);
		}
		return;
	}
	// remove all ids from the list that do not need to be indexed
	tutao.locator.dao.getLastIndexed(typeId, function(status, lastIndexedId) {
		// if lastIndexedId is available, remove all ids that are smaller because these elements are already indexed
		if (lastIndexedId) {
			for (var i = 0; i < ids.length; i++) {
				// use the element id part if it is an LET id
				var id = ids[i];
				if (id instanceof Array) {
					id = id[1];
				}
				if (tutao.rest.EntityRestInterface.firstBiggerThanSecond(id, lastIndexedId)) {
					ids = ids.slice(i);
					break;
				} else if (i == ids.length - 1) {
					// no id was bigger than the last indexed, so we do not need to index any element
					callback(null);
					return;
				}
			}
		}
		self._indexElementsFrom(typeId, ids, 0, callback);
	});
};

/**
 * @protected
 * Indexes all elements in the provided array starting from the given index.
 * @param {number} typeId The id of the type of the elements to index.
 * @param {[string]|Array.<[string,string]>} ids The ids of the elements to index. The order must be ascending.
 * @param {number} index The index of the id in the ids array to start indexing from.
* @param {function(?string)} callback This function is called as soon as the operation is finished and passes the first
* id from the ids list whose element was indexed.
 */
tutao.tutanota.index.Indexer.prototype._indexElementsFrom = function(typeId, ids, index, callback) {
	var self = this;
	if (index == ids.length) {
		// we are finished
		if (callback) {
			callback(ids[0]);
		}
		return;
	}
	self._indexElement(typeId, ids[index], function() {
		self._indexElementsFrom(typeId, ids, ++index, callback);
	});
};

/**
 * @protected
 * Indexes all attributes of the given element.
 * @param {number} typeId The id of the type of the elements to index.
 * @param {string|Array.<string>} id The id of the element to index.
 * @param {function()} callback This function is called as soon as the element is indexed.
 */
tutao.tutanota.index.Indexer.prototype._indexElement = function(typeId, id, callback) {
	var self = this;
	if (typeId == tutao.entity.tutanota.Mail.prototype.TYPE_ID) {
		tutao.entity.tutanota.Mail.load(id).then(function(mail) {
			self._indexMail(mail, callback);
		});
	} else if (typeId == tutao.entity.tutanota.MailBody.prototype.TYPE_ID) {
		tutao.entity.tutanota.MailBody.load(id).then(function(body) {
            self._indexMailBody(body, callback);
		});
	}
};

tutao.tutanota.index.Indexer.prototype.tryRemoveFromIndex = function(mail, callback) {
    tutao.locator.dao.removeIndexEntries(mail.TYPE_ID, [mail.SUBJECT_ATTRIBUTE_ID], mail.getId()[1], function() {
        tutao.locator.dao.removeIndexEntries(mail.TYPE_ID, [mail.SENDER_ATTRIBUTE_ID], mail.getId()[1], function() {
            tutao.locator.dao.removeIndexEntries(mail.TYPE_ID, [mail.TORECIPIENTS_ATTRIBUTE_ID], mail.getId()[1], function() {
                tutao.locator.dao.removeIndexEntries(mail.TYPE_ID, [mail.STATE_ATTRIBUTE_ID], mail.getId()[1], function() {
                    tutao.locator.dao.removeIndexEntries(mail.TYPE_ID, [mail.UNREAD_ATTRIBUTE_ID], mail.getId()[1], function() {
                        tutao.locator.dao.removeIndexEntries(mail.TYPE_ID, [mail.TRASHED_ATTRIBUTE_ID], mail.getId()[1], function() {
                            tutao.locator.dao.removeIndexEntries(mail.TYPE_ID, [mail.BODY_ATTRIBUTE_ID], mail.getId()[1], function() {
                                tutao.locator.dao.removeIndexEntries(tutao.entity.tutanota.MailBody.prototype.TYPE_ID, [tutao.entity.tutanota.MailBody.prototype.TEXT_ATTRIBUTE_ID], mail.getBody(), callback);
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * @protected
 * Indexes all attributes of the given mail.
 * @param {tutao.entity.tutanota.Mail} mail The mail to index.
 * @param {function()} callback This function is called as soon as the mail is indexed.
 */
tutao.tutanota.index.Indexer.prototype._indexMail = function(mail, callback) {
	var self = this;
	// store the subject index
	var subjectWords = self._encryptWords(self.getSearchIndexWordsFromText(mail.getSubject()));
	tutao.locator.dao.addIndexEntries(mail.TYPE_ID, [mail.SUBJECT_ATTRIBUTE_ID], mail.getId()[1], subjectWords, function(status) {
		if (status === tutao.db.DbInterface.STATUS_SUCCESS) {
			// store the sender index (only words in name)
			var senderWords = self._encryptWords(self.getSearchIndexWordsFromText(mail.getSender().getName()));
			tutao.locator.dao.addIndexEntries(mail.TYPE_ID, [mail.SENDER_ATTRIBUTE_ID], mail.getId()[1], senderWords, function(status) {
				if (status === tutao.db.DbInterface.STATUS_SUCCESS) {
					// store all recipients (to, cc, bcc) index (only words in names) in the toRecipients index for now
					var recipientsWords = [];
					for (var i = 0; i < mail.getToRecipients().length; i++) {
						recipientsWords = tutao.util.ArrayUtils.getUniqueOrArray([recipientsWords, self.getSearchIndexWordsFromText(mail.getToRecipients()[i].getName())]);
					}
					for (var i = 0; i < mail.getCcRecipients().length; i++) {
						recipientsWords = tutao.util.ArrayUtils.getUniqueOrArray([recipientsWords, self.getSearchIndexWordsFromText(mail.getCcRecipients()[i].getName())]);
					}
					for (var i = 0; i < mail.getBccRecipients().length; i++) {
						recipientsWords = tutao.util.ArrayUtils.getUniqueOrArray([recipientsWords, self.getSearchIndexWordsFromText(mail.getBccRecipients()[i].getName())]);
					}
					recipientsWords = self._encryptWords(recipientsWords);
					tutao.locator.dao.addIndexEntries(mail.TYPE_ID, [mail.TORECIPIENTS_ATTRIBUTE_ID], mail.getId()[1], recipientsWords, function(status) {
						if (status === tutao.db.DbInterface.STATUS_SUCCESS) {
							// store the state index
							tutao.locator.dao.addIndexEntries(mail.TYPE_ID, [mail.STATE_ATTRIBUTE_ID], mail.getId()[1], self._encryptWords([mail.getState() + ""]), function(status) {
								if (status === tutao.db.DbInterface.STATUS_SUCCESS) {
									// store the unread/read index (boolean values as 0 and 1)
									tutao.locator.dao.addIndexEntries(mail.TYPE_ID, [mail.UNREAD_ATTRIBUTE_ID], mail.getId()[1], self._encryptWords((mail.getUnread()) ? ["1"] : ["0"]),
											function(status) {
										if (status === tutao.db.DbInterface.STATUS_SUCCESS) {
											// store the trashed/untrashed index (boolean values as 0 and 1)
											tutao.locator.dao.addIndexEntries(mail.TYPE_ID, [mail.TRASHED_ATTRIBUTE_ID], mail.getId()[1], self._encryptWords((mail.getTrashed()) ? ["1"] : ["0"]),
													function(status) {
												if (status === tutao.db.DbInterface.STATUS_SUCCESS) {
													// store the body id index
													tutao.locator.dao.addIndexEntries(mail.TYPE_ID, [mail.BODY_ATTRIBUTE_ID], mail.getId()[1], self._encryptWords([mail.getBody()]),
															function(status) {
														if (status === tutao.db.DbInterface.STATUS_SUCCESS) {
															tutao.locator.dao.setIndexed(mail.TYPE_ID, mail.getId()[1], callback);
														} else {
															callback();
														}
													});
												} else {
													callback();
												}
											});
										} else {
											callback();
										}
									});
								} else {
									callback();
								}
							});
						} else {
							callback();
						}
					});
				} else {
					callback();
				}
			});
		} else {
			callback();
		}
	});
};

/**
 * @protected
 * Indexes all attributes of the given mail body.
 * @param {tutao.entity.tutanota.MailBody} mailBody The mail body to index.
 * @param {function()} callback This function is called as soon as the mail body is indexed.
 */
tutao.tutanota.index.Indexer.prototype._indexMailBody = function(mailBody, callback) {
	var words = this._encryptWords(this.getSearchIndexWordsFromText(mailBody.getText()));
	tutao.locator.dao.addIndexEntries(mailBody.TYPE_ID, [mailBody.TEXT_ATTRIBUTE_ID], mailBody.getId(), words, function(status) {
		if (status === tutao.db.DbInterface.STATUS_SUCCESS) {
			tutao.locator.dao.setIndexed(mailBody.TYPE_ID, mailBody.getId(), callback);
		} else {
			callback();
		}
	});
};

/**
 * @protected
 * Provides an array of words for the search index from a given text.
 * @param {string} text The text.
 * @return {Array.<string>} The array of words.
 */
tutao.tutanota.index.Indexer.prototype.getSearchIndexWordsFromText = function(text) {
	return tutao.util.ArrayUtils.getUniqueArray(this.removeSpecialCharactersFromText(text.toLowerCase()).split(" "));
};

/**
 * Replaces all special characters in text with whitespaces.
 * @param {string} text The text.
 * @return {string} The text without special characters.
 */
tutao.tutanota.index.Indexer.prototype.removeSpecialCharactersFromText = function(text) {
	return text.replace(/[^a-zA-Z 0-9\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02AF]+/g, ' '); // all latin letters
};

/**
 * Retrieves the ids of all elements that contain at least one of the given values. The element is of type ET or LET,
 * but the attribute may be one of the aggregated types. The index is encrypted.
 * @param {number} typeId The id of the type of the element. The type may be an ET or LET.
 * @param {Array.<number>} attributeIds The ids leading to the searchable attribute of the type.
 * This id chain must start with an attribute of the type (ET or LET) and may go down to AggregatedType's attributes.
 * @param {[string]} values The values that the returned elements shall contain.
 * @param {function(Array.<string>)} callback This function is called as soon as the execution is finished. As argument an array of string ids of the matching
 * elements (only element ids, no list ids) is passed to the callback function.
 */
tutao.tutanota.index.Indexer.prototype.getElementsByValues = function(typeId, attributeIds, values, callback) {
	var result = [];
	var f = function(index) {
		if (index == values.length) {
			callback(tutao.util.ArrayUtils.getUniqueArray(result));
			return;
		}
		tutao.locator.dao.getElementsByValue(typeId, attributeIds, tutao.locator.aesCrypter.encryptUtf8Index(
				tutao.locator.userController.getUserClientKey(), values[index]), function(status, ids) {
			if (status === tutao.db.DbInterface.STATUS_SUCCESS) {
				result = result.concat(ids);
				f(++index);
			} else {
				callback([]);
			}
		});
	};
	f(0);
};

/**
 * Removes all index entries for the given element id for the given attribute ids lists.
 * @param {number} typeId The id of the type of the element. The type may be an ET or LET.
 * @param {Array.<Array.<number>>} attributeIdsList An array of arrays with ids leading to the searchable attribute of the type.
 * This id chain must start with an attribute of the type (ET or LET) and may go down to AggregatedType's attributes.
 * @param {string} elementId The id of the element (no list id in case of LET instance).
 * @param {function()} callback This function is called as soon as the execution is finished.
 */
tutao.tutanota.index.Indexer.prototype.removeIndexEntries = function(typeId, attributeIdsList, elementId, callback) {
	tutao.locator.dao.removeIndexEntries(typeId, attributeIdsList, elementId, function() {
		if (callback) {
			callback();
		}
	});
};

/**
 * Stores the index entries for an elements attribute. The element is of type ET or LET, but the attribute may be one of the
 * aggregated types. Calls the callback function when finished.
 * @param {number} typeId The id of the type of the element. The type may be an ET or LET.
 * @param {Array.<number>} attributeIds The ids leading to the searchable attribute of the type.
 * This id chain must start with an attribute of the type (ET or LET) and may go down to AggregatedType's attributes.
 * @param {string} elementId The id of the element (no list id in case of LET instance).
 * @param {Array.<string>} values The values that shall reference the element.
 * @param {function(string)=} callback This optional function is called as soon as the execution is finished with one of
 * the status code STATUS_SUCCESS or STATUS_NO_MEM.
 */
tutao.tutanota.index.Indexer.prototype.addIndexEntries = function(typeId, attributeIds, elementId, values, callback) {
	tutao.locator.dao.addIndexEntries(typeId, attributeIds, elementId, this._encryptWords(values), callback);
};

/**
 * Provides the id of the highest indexed element.
 * @param {number} typeId The type id of the element.
 * @param {function(string)} callback Is called with the id.
 */
tutao.tutanota.index.Indexer.prototype.getLastIndexedId = function(typeId, callback) {
	tutao.locator.dao.getLastIndexed(typeId, function(status, lastIndexedId) {
		if (status === tutao.db.DbInterface.STATUS_SUCCESS) {
			if (lastIndexedId) {
				callback(lastIndexedId);
			} else {
				callback(tutao.rest.EntityRestInterface.GENERATED_MIN_ID);
			}
		} else {
			// what to do here?
			callback("0");
		}
	});
};

/**
 * @protected
 * Encrypts a list of words.
 * @param {Array.<string>} plainTextWords The words.
 * @return {Array.<string>} The encrypted words.
 */
tutao.tutanota.index.Indexer.prototype._encryptWords = function(plainTextWords) {
	var encryptedWords = [];
	for (var i = 0; i < plainTextWords.length; i++) {
		encryptedWords.push(tutao.locator.aesCrypter.encryptUtf8Index(
				tutao.locator.userController.getUserClientKey(), plainTextWords[i]));
	}
	return encryptedWords;
};

"use strict";

tutao.provide('tutao.tutanota.legacy.FlashFileSaver');

/**
 * The FlashFileSaver is a fallback for older browsers (IE < 10) and is used in order to save data on the client.
 *
 * In order to compile the action script code (FlasFileSaver.as) you have to invoke <code>mxmlc FlashFileSaver.as</code>.
 * Before you are able to compile:
 * <ul>
 *   <li>The compiler must be downloaded and installed from http://www.apache.org/dyn/closer.cgi/flex/4.9.0/binaries/apache-flex-sdk-4.9.0-bin.tar.gz.
 *   <li>Download the flash player (http://fpdownload.macromedia.com/get/flashplayer/updaters/11/playerglobal11_1.swc) and put it to <code>FLEX_HOME/playerglobalHome/11.1/playerglobal.swc</code>
 *   <li>Set the following environment variables
 *   <ul>
 *     <li>FLEX_HOME=/opt/apache-flex-sdk-4.9.0-bin/
 *     <li>PLAYERGLOBAL_HOME=/opt/apache-flex-sdk-4.9.0-bin/playerglobalHome/
 *   </ul>
 * </ul>
 *
 * @param {String} id A unique id for this flashDownloader.
 * @param {Object} parentDomElement The parent DOM element of the flash button.
 * @param {String} width The width.
 * @param {String} height The height.
 * @param {String} downloadedData Base64 coded binary data.
 * @param {String} filename The filename.
 * @return {Promise.<Error>} Resolves when finished.
 * @constructor
 */
tutao.tutanota.legacy.FlashFileSaver = function(id, parentDomElement, width, height, downloadedData, filename) {
	var placeholder = document.createElement('div');
	placeholder.id = id;
	$(parentDomElement).append(placeholder);
    var params = { allowScriptAccess: 'always', wmode: 'transparent'};
    return new Promise(function(resolve, reject) {
        swfobject.embedSWF('legacy/FlashFileSaver.swf', id, width, height, "10", null, null, params, null, function(e) {
            tutao.tutanota.legacy.FlashFileSaver.wait(downloadedData, filename, e.ref, resolve);
        });
    });
};

/**
 *
 * @param {string} downloadedData
 * @param {string} filename
 * @param {FlashFileSaver} reference The reference to the ActionScript flash file saver
 * @param {function()} resolve The promise resolve function that should be called after the download is ready.
 */
tutao.tutanota.legacy.FlashFileSaver.wait = function(downloadedData, filename, reference, resolve) {
	if (reference.provideDownload) {
		reference.provideDownload(downloadedData, filename);
		resolve();
	} else {
		setTimeout(function() {
			tutao.tutanota.legacy.FlashFileSaver.wait(downloadedData, filename, reference, resolve);
		}, 50);
	}
};

"use strict";

tutao.provide('tutao.tutanota.legacy.Legacy');

/**
 * Handles settings for the legacy support and not supported browsers.
 * @param {Object.<string, Object>} singletons
 */
tutao.tutanota.legacy.Legacy.setup = function(singletons) {

	if (tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_NOT_SUPPORTED ||
        tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_UPDATE_NEEDED ||
        tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_IE ||
        tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_ANDROID) {
        delete singletons.crypto;
        delete singletons.clientWorkerProxy;
        delete singletons.rsaCrypter;
        delete singletons.eventBus;
        //noinspection JSUndefinedPropertyAssignment
        singletons.aesCrypter = tutao.crypto.SjclAes;
    }

	if (typeof Object.getPrototypeOf !== "function") {
		Object.getPrototypeOf = function(object) {
			return object.constructor.prototype; // only for ie8
		};
	}

	if (typeof String.prototype.trim !== 'function') {
		String.prototype.trim = function() {
		    return this.replace(/^\s+|\s+$/g, '');
		};
	}


    if (typeof Array.prototype.indexOf !== 'function') {
        Array.prototype.indexOf = function(obj) {
            for (var i = (0); i < this.length; i++) {
                if (this[i] === obj) {
                    return i;
                }
            }
            return -1;
        };
    }


    Object.keys = Object.keys || (function () {
        var hasOwnProperty = Object.prototype.hasOwnProperty,
            hasDontEnumBug = !{toString:null}.propertyIsEnumerable("toString"),
            DontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ],
            DontEnumsLength = DontEnums.length;

        return function (o) {
            if (typeof o != "object" && typeof o != "function" || o === null)
                throw new TypeError("Object.keys called on a non-object");

            var result = [];
            for (var name in o) {
                if (hasOwnProperty.call(o, name))
                    result.push(name);
            }

            if (hasDontEnumBug) {
                for (var i = 0; i < DontEnumsLength; i++) {
                    if (hasOwnProperty.call(o, DontEnums[i]))
                        result.push(DontEnums[i]);
                }
            }

            return result;
        };
    })();


    if (!window.console) {
        window.console = {log: function() {}};
    }

};

"use strict";

tutao.provide('tutao.tutanota.gui.BubbleInputGui');

/**
 * Resizes the input field to be maximized in the last line if there is enough space (at least more than 15px)
 * @param {*} inputField The dom element.
 * @param {string} text The text of the inputField.
 */
tutao.tutanota.gui.BubbleInputGui.resizeInputField = function(inputField, text) {
	var inputFieldDiv = $(inputField).parent();
	var bubbles = inputFieldDiv.siblings();
	var inputContainer = inputFieldDiv.parent();
	var maxLineWidth = inputContainer.width() - 5; // subtract 5 MS pixel (at least two pixels are needed in ie10, the rest are ms security pixels ;-))
	var maxTopValue = Math.max.apply(null, bubbles.map(function() {return $(this).position().top;}));
	var lastLineWidth = 0;
	bubbles.each(function() {
		var element = $(this);
		if (element.position().top === maxTopValue) {
			lastLineWidth += element.outerWidth(true);
		}
	});
	var remainingSpace = maxLineWidth - lastLineWidth;
	var textWidth = this._measureTextWidth(text, $(inputField).css('font'));
	// create a new line when there is not enough space for a single character (15px) or if the remaining space is smaller than the textwidth
	if (remainingSpace >= 15 && remainingSpace > textWidth) {
		inputFieldDiv.width(remainingSpace);
	} else {
		inputFieldDiv.width(maxLineWidth);
	}
};

/**
 * Sets the cursor to the end of the input field.
 * @param {*} target The target or one of it's children must be an input field (input with type='text').
 */
tutao.tutanota.gui.BubbleInputGui.setCursorToEnd = function(target) {
	if (!$(target).is("input[type=text]")) {
		target = $(target).find("input[type=text]");
	}
	$(target).each(function() {
		tutao.tutanota.gui.BubbleInputGui.setSelectionRange(this, this.value.length, this.value.length);
	});
};

/**
 * Sets the selection on an input field.
 * @param {*} input The input field.
 * @param {number} selectionStart The start of the selection.
 * @param {number} selectionEnd The end of the selection.
 */
tutao.tutanota.gui.BubbleInputGui.setSelectionRange = function(input, selectionStart, selectionEnd) {
	if (input.setSelectionRange) {
	    input.focus();
	    input.setSelectionRange(selectionStart, selectionEnd);
	} else if (input.createTextRange) {
	    var range = input.createTextRange();
	    range.collapse(true);
	    range.moveEnd('character', selectionEnd);
	    range.moveStart('character', selectionStart);
	    range.select();
	}
};

/**
 * Measures the width of a text with the provided font.
 * @param {string} text The text to measure.
 * @param {string} font The css font style.
 * @return {number} the width of the text in px.
 */
tutao.tutanota.gui.BubbleInputGui._measureTextWidth = function(text, font) {
	var sanitizedText = tutao.locator.htmlSanitizer.sanitize(text);
    var id = 'text-width-tester';
    var tag = $('#' + id);
    if (!tag.length) {
        tag = $('<span id="' + id + '" style="display:none;font:' + font + ';">' + sanitizedText + '</span>');
        $('body').append(tag);
    } else {
        tag.css({font: font}).html(sanitizedText);
    }
    return tag.width();
};

"use strict";

tutao.provide('tutao.tutanota.gui.ContactView');

/**
 * @constructor
 * @implements {tutao.tutanota.ctrl.View}
 */
tutao.tutanota.gui.ContactView = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
};

/**
 * These ids are returned by addViewColumn.
 */
tutao.tutanota.gui.ContactView.COLUMN_CONTACT_LIST = null;
tutao.tutanota.gui.ContactView.COLUMN_CONTACT = null;

/**
 * @inherit
 */
tutao.tutanota.gui.ContactView.prototype.init = function() {
	this._swipeSlider = new tutao.tutanota.gui.SwipeSlider(this, "contactContent");
    tutao.tutanota.gui.ContactView.COLUMN_CONTACT_LIST = this._swipeSlider.addViewColumn(0, 300, 400, 'searchAndContactListColumn');
    tutao.tutanota.gui.ContactView.COLUMN_CONTACT = this._swipeSlider.addViewColumn(1, 600, 1000, 'contactColumn');

};

/**
 * @inherit
 */
tutao.tutanota.gui.ContactView.prototype.isForInternalUserOnly = function() {
	return true;
};

/**
 * @inherit
 */
tutao.tutanota.gui.ContactView.prototype.activate = function() {
    this._swipeSlider.activate();
};

/**
 * @inherit
 */
tutao.tutanota.gui.ContactView.prototype.deactivate = function() {
};

/**
 * @inherit
 */
tutao.tutanota.gui.ContactView.prototype.getSwipeSlider = function() {
    return this._swipeSlider;
};

/**
 * @inherit
 */
tutao.tutanota.gui.ContactView.prototype.isShowLeftNeighbourColumnPossible = function() {
	return (this._swipeSlider.getLeftmostVisibleColumnId() == tutao.tutanota.gui.ContactView.COLUMN_CONTACT
    		&& (tutao.locator.contactViewModel.mode() == tutao.tutanota.ctrl.ContactViewModel.MODE_NONE || tutao.locator.contactViewModel.mode() == tutao.tutanota.ctrl.ContactViewModel.MODE_SHOW)); // allow showing contact list
};

/**
 * @inherit
 */
tutao.tutanota.gui.ContactView.prototype.isShowRightNeighbourColumnPossible = function() {
    return false;
};

/**
 * Makes sure that the contact list column is visible.
 */
tutao.tutanota.gui.ContactView.prototype.showContactListColumn = function() {
    this._swipeSlider.getViewSlider().showViewColumn(tutao.tutanota.gui.ContactView.COLUMN_CONTACT_LIST);
};

/**
 * Makes sure that the contact column is visible.
 */
tutao.tutanota.gui.ContactView.prototype.showContactColumn = function() {
    this._swipeSlider.getViewSlider().showViewColumn(tutao.tutanota.gui.ContactView.COLUMN_CONTACT);
};

"use strict";

tutao.provide('tutao.tutanota.gui.ExternalLoginView');

/**
 * @constructor
 * @implements {tutao.tutanota.ctrl.View}
 */
tutao.tutanota.gui.ExternalLoginView = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
};

/**
 * @inherit
 */
tutao.tutanota.gui.ExternalLoginView.prototype.init = function() {
    this._swipeSlider = tutao.tutanota.gui.SwipeSlider.none();
};

/**
 * @inherit
 */
tutao.tutanota.gui.ExternalLoginView.prototype.isForInternalUserOnly = function() {
	return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.ExternalLoginView.prototype.activate = function() {

};

/**
 * @inherit
 */
tutao.tutanota.gui.ExternalLoginView.prototype.deactivate = function() {

};

/**
 * @inherit
 */
tutao.tutanota.gui.ExternalLoginView.prototype.getSwipeSlider = function() {
    return this._swipeSlider;
};

/**
 * @inherit
 */
tutao.tutanota.gui.ExternalLoginView.prototype.isShowLeftNeighbourColumnPossible = function() {
	return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.ExternalLoginView.prototype.isShowRightNeighbourColumnPossible = function() {
    return false;
};

"use strict";

tutao.provide('tutao.tutanota.gui.FastMessageView');

/**
 * @constructor
 * @implements {tutao.tutanota.ctrl.View}
 */
tutao.tutanota.gui.FastMessageView = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
    this._swipeSlider = tutao.tutanota.gui.SwipeSlider.none();
};

/**
 * @inherit
 */
tutao.tutanota.gui.FastMessageView.prototype.init = function() {
};

/**
 * @inherit
 */
tutao.tutanota.gui.FastMessageView.prototype.isForInternalUserOnly = function() {
    return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.FastMessageView.prototype.activate = function() {

};

/**
 * @inherit
 */
tutao.tutanota.gui.FastMessageView.prototype.deactivate = function() {

};

/**
 * @inherit
 */
tutao.tutanota.gui.FastMessageView.prototype.getSwipeSlider = function() {
    return this._swipeSlider;
};

/**
 * @inherit
 */
tutao.tutanota.gui.FastMessageView.prototype.isShowLeftNeighbourColumnPossible = function() {
    return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.FastMessageView.prototype.isShowRightNeighbourColumnPossible = function() {
    return false;
};


"use strict";

tutao.provide('tutao.tutanota.gui.FileView');

/**
 * @constructor
 * @implements {tutao.tutanota.ctrl.View}
 */
tutao.tutanota.gui.FileView = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
};

/**
 * @inherit
 */
tutao.tutanota.gui.FileView.prototype.init = function() {
	this._swipeSlider = new tutao.tutanota.gui.SwipeSlider(this, "fileContent");
	this._swipeSlider.addViewColumn(0, 300, 1024, 'filesColumn');
	this._firstActivation = true;
};

/**
 * @inherit
 */
tutao.tutanota.gui.FileView.prototype.isForInternalUserOnly = function() {
	return true;
};

/**
 * @inherit
 */
tutao.tutanota.gui.FileView.prototype.activate = function() {
    this._swipeSlider.activate();
	if (this._firstActivation) {
		this._firstActivation = false;
		tutao.locator.fileViewModel.init();
	}
};

/**
 * @inherit
 */
tutao.tutanota.gui.FileView.prototype.deactivate = function() {
};

/**
 * @inherit
 */
tutao.tutanota.gui.FileView.prototype.getSwipeSlider = function() {
    return this._swipeSlider;
};

/**
 * @inherit
 */
tutao.tutanota.gui.FileView.prototype.isShowLeftNeighbourColumnPossible = function() {
	return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.FileView.prototype.isShowRightNeighbourColumnPossible = function() {
    return false;
};

"use strict";

tutao.provide('tutao.tutanota.gui.LoginView');

/**
 * @constructor
 * @implements {tutao.tutanota.ctrl.View}
 */
tutao.tutanota.gui.LoginView = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
};

/**
 * @inherit
 */
tutao.tutanota.gui.LoginView.prototype.init = function() {
    this._swipeSlider = tutao.tutanota.gui.SwipeSlider.none();
};

/**
 * @inherit
 */
tutao.tutanota.gui.LoginView.prototype.isForInternalUserOnly = function() {
    return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.LoginView.prototype.activate = function() {

};

/**
 * @inherit
 */
tutao.tutanota.gui.LoginView.prototype.deactivate = function() {

};

/**
 * @inherit
 */
tutao.tutanota.gui.LoginView.prototype.getSwipeSlider = function() {
    return this._swipeSlider;
};

/**
 * @inherit
 */
tutao.tutanota.gui.LoginView.prototype.isShowLeftNeighbourColumnPossible = function() {
    return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.LoginView.prototype.isShowRightNeighbourColumnPossible = function() {
    return false;
};

"use strict";

tutao.provide('tutao.tutanota.gui.MailView');

/**
 * @constructor
 * @implements {tutao.tutanota.ctrl.View}
 */
tutao.tutanota.gui.MailView = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	this._mailsHeight = 0;
	this._passwordChannelsHeight = 0;
};

/**
 * These ids are returned by addViewColumn.
 */
tutao.tutanota.gui.MailView.COLUMN_TAGS = null;
tutao.tutanota.gui.MailView.COLUMN_MAIL_LIST = null;
tutao.tutanota.gui.MailView.COLUMN_CONVERSATION = null;
tutao.tutanota.gui.MailView.COLUMN_PASSWORD_CHANNELS = null;

/**
 * @inherit
 */
tutao.tutanota.gui.MailView.prototype.init = function(external) {
    this._swipeSlider = new tutao.tutanota.gui.SwipeSlider(this, "mailContent");
    tutao.tutanota.gui.MailView.COLUMN_TAGS = this._swipeSlider.addViewColumn(2, 190, 190, 'tagListColumn');
    tutao.tutanota.gui.MailView.COLUMN_MAIL_LIST = this._swipeSlider.addViewColumn(0, 300, 800, 'searchAndMailListColumn');
    tutao.tutanota.gui.MailView.COLUMN_CONVERSATION = this._swipeSlider.addViewColumn(1, 600, 1024, 'conversationColumn');
	if (!external) {
        tutao.tutanota.gui.MailView.COLUMN_PASSWORD_CHANNELS = this._swipeSlider.addViewColumn(3, 300, 800, 'passwordChannelColumn');
	}

	this._firstActivation = true;
};

/**
 * @inherit
 */
tutao.tutanota.gui.MailView.prototype.isForInternalUserOnly = function() {
	return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.MailView.prototype.activate = function() {
    this._swipeSlider.activate();
	if (this._firstActivation) {
		this._firstActivation = false;
		tutao.locator.mailListViewModel.init();
	}
};

/**
 * @inherit
 */
tutao.tutanota.gui.MailView.prototype.deactivate = function() {

};

/**
 * @inherit
 */
tutao.tutanota.gui.MailView.prototype.isShowLeftNeighbourColumnPossible = function() {
    return (this._swipeSlider.getLeftmostVisibleColumnId() == tutao.tutanota.gui.MailView.COLUMN_MAIL_LIST) || // allow showing tag list
    (this._swipeSlider.getLeftmostVisibleColumnId() == tutao.tutanota.gui.MailView.COLUMN_CONVERSATION && !tutao.locator.mailViewModel.isComposingState()) || // allow showing mail list if displayed mail is visible
    (this._swipeSlider.getLeftmostVisibleColumnId() == tutao.tutanota.gui.MailView.COLUMN_PASSWORD_CHANNELS); // allow showing composing mail if only password channels are visible
};

/**
 * @inherit
 */
tutao.tutanota.gui.MailView.prototype.isShowRightNeighbourColumnPossible = function() {
    return ((this._swipeSlider.getRightmostVisibleColumnId() == tutao.tutanota.gui.MailView.COLUMN_CONVERSATION) && (tutao.locator.passwordChannelViewModel.getSecureExternalRecipients().length > 0) || // allow showing password channels if composing mail is visible
        (this._swipeSlider.getLeftmostVisibleColumnId() == tutao.tutanota.gui.MailView.COLUMN_TAGS && this._swipeSlider.getRightmostVisibleColumnId() <= tutao.tutanota.gui.MailView.COLUMN_MAIL_LIST)); // allow slide out tag list
};

/**
 * @inherit
 */
tutao.tutanota.gui.MailView.prototype.getSwipeSlider = function() {
    return this._swipeSlider;
};

/**
 * Makes sure that the default columns are visible (at least including the mail list column).
 */
tutao.tutanota.gui.MailView.prototype.showDefaultColumns = function() {
	this._swipeSlider.getViewSlider().showDefault();
};

/**
 * See return
 * @return {boolean} true, if the mail list column is visible.
 */
tutao.tutanota.gui.MailView.prototype.isMailListColumnVisible = function() {
	return this._swipeSlider.getViewSlider().isVisible(tutao.tutanota.gui.MailView.COLUMN_MAIL_LIST);
};

/**
 * Makes sure that the conversation column is visible.
 * @param {function()=} listener The listener to invoke after the conversation column is visible.
 */
tutao.tutanota.gui.MailView.prototype.showConversationColumn = function(listener) {
	if (!this.isConversationColumnVisible()) {
        this._swipeSlider.getViewSlider().showViewColumn(tutao.tutanota.gui.MailView.COLUMN_CONVERSATION);
		if (listener) {
			setTimeout(function() {
				listener();
			}, 400);
		}
	} else {
		if (listener) {
			listener();
		}
	}
};

/**
 * See return
 * @return {boolean} true, if the conversation column is visible.
 */
tutao.tutanota.gui.MailView.prototype.isConversationColumnVisible = function() {
	return this._swipeSlider.getViewSlider().isVisible(tutao.tutanota.gui.MailView.COLUMN_CONVERSATION);
};

/**
 * Makes sure that the password channel column is visible.
 */
tutao.tutanota.gui.MailView.prototype.showPasswordChannelColumn = function() {
	this._swipeSlider.getViewSlider().showViewColumn(tutao.tutanota.gui.MailView.COLUMN_PASSWORD_CHANNELS);
};

/**
 * Sets the composing mail body text.
 * @param {string} text The html body text.
 */
tutao.tutanota.gui.MailView.prototype.setComposingBody = function(text) {
	var composeBody = $(".conversation").find(".composeBody");
    if (composeBody.length == 0) {
        throw new Error("no composing mail created");
    }
    composeBody.append(tutao.locator.htmlSanitizer.sanitize(text));
    this.addSubmitCheckToDivs(composeBody);

};

/**
 * Gets the composing mail body text.
 * @return {string} The html body text.
 */
tutao.tutanota.gui.MailView.prototype.getComposingBody = function() {
	var bodyTextNode = $(".conversation").find(".composeBody");
	// sibling blockquotes on top level are not merged if separated by user
	return tutao.locator.htmlSanitizer.sanitize(bodyTextNode.html());
};

/**
 * Fades the new mail out
 */
tutao.tutanota.gui.MailView.prototype.fadeFirstMailOut = function() {
	$(".conversation").find('.mail').first().fadeOut();
};

/**
 * Provides the dom element of the given mail in the mail list.
 * @param {tutao.entity.tutanota.Mail} mail The mail.
 * @return {Object} The dom element.
 */
tutao.tutanota.gui.MailView.prototype.getMailListDomElement = function(mail) {
	return $('#mailInList' + mail.getId()[0] + mail.getId()[1]);
};

/**
 * Splits the highest parent of current below boundary into two parts. The parts are separated
 * from current to the highest parent below boundary whereas current belongs to the first
 * part and all following siblings of current belong to the second part.
 *
 * The parents of current are splitted and therefore created for a second time for the second
 * part. Other elements are from first to second part, if needed.
 *
 * A new paragraph (<p>) is inserted between the two parts. This paragraph contains a whitespace
 * to make sure that the browser reserves space for it.
 *
 * @param {Object} current The dom element with the current cursor position.
 * @param {Object} boundary The dom element (contenteditable) that surrounds the editing area.
 * @param {Object} childToAdd The dom element that should be added as first child to the newly
 * 					created parent or next to the newly created <p> as child of the boundary.
 * @return
 */
tutao.tutanota.gui.MailView.splitBlockquote = function(current, boundary, childToAdd) {
	var parent = current.parentNode;
	if (parent.nodeType === tutao.tutanota.gui.ELEMENT_NODE && parent != boundary) { // only add Element nodes
		var newParent = $("<" + parent.nodeName + ">");
		newParent.attr("class", $(parent).attr("class"));
		newParent.attr("style", $(parent).attr("style"));
		if (childToAdd && childToAdd.childNodes.length != 0) {
			newParent.append(childToAdd);
		}
		var next = current;
		var siblingsToAdd = [];
		while (next = next.nextSibling) {
			siblingsToAdd.push(next);
		}
		for (var i = 0; i < siblingsToAdd.length; i++) {
			newParent.append(siblingsToAdd[i]);
		}

		return tutao.tutanota.gui.MailView.splitBlockquote(parent, boundary, newParent.get(0));
	} else if (childToAdd) {
		if (childToAdd && childToAdd.childNodes.length != 0) {
			$(current).after(childToAdd);
		}
		var textNode = $("<p>&nbsp;</p>");
		$(current).after(textNode);
		return textNode;
	}
};

/**
 * A key event listener that handles inserting blank newlines into quotations in a contenteditable. Must be attached to a contenteditable.
 * @param {Object} vm The view model.
 * @param {Object} e The jquery key event.
 * @return {boolean} True if the event was handled, false otherwise.
 */
tutao.tutanota.gui.MailView.handleMailComposerReturnKey = function(vm, e) {
	if (e.keyCode === 13) {
		var boundary = e.target;
		var range = null;
	    if (window.getSelection && window.getSelection().getRangeAt) {
	        range = window.getSelection().getRangeAt(0);
	    } else if (document.selection && document.selection.createRange) {
	        range = document.selection.createRange();
	    }
	    if (range) {
	    	var current = range.startContainer;
	    	if (current.nodeType === tutao.tutanota.gui.TEXT_NODE && range.startOffset != current.length) {
	    		current.splitText(range.startOffset);
	    	} else if (current.nodeType === tutao.tutanota.gui.ELEMENT_NODE && current.childNodes.length !== 0) {
	    		current = range.startContainer.childNodes[range.startOffset];
	    	}
	    	if ($(current).parentsUntil(boundary).filter($(boundary).find("> blockquote.tutanota_quote")).size() > 0) {
	    		var newTextNode = tutao.tutanota.gui.MailView.splitBlockquote(current, boundary);
	    		if (newTextNode) {
	    			range = document.createRange();
	    			range.setStart(newTextNode.get(0), 0);
	    			range.setEnd(newTextNode.get(0), 0);
	    			range.collapse(true);
	    			window.getSelection().removeAllRanges();
	    			window.getSelection().addRange(range);
	    			return false;
	    		}
	    	}
	    }
	}
	return true;
};

/**
 * Tries to find the one quotation block inside the given html and returns it separated from the "normal" part. If more than one quotation block is found, everything is returned
 * as "normal" part. Optimized for Tutanota, gmail, thunderbird and partly Outlook (quotes with left border).
 * @param {string} html The html text to check.
 * @return {Object.<string,string>} An object containing a "text" property and a "quotation" property with the separated html parts. The quotation part may be empty.
 */
tutao.tutanota.gui.MailView.prototype.splitMailTextQuotation = function(html) {
	var div = $("<div>" + html + "</div>");
	var quotes = div.find("> blockquote.tutanota_quote, > blockquote.gmail_quote, > blockquote.thunderbird_quote");
	if (quotes.length === 0) {
		quotes = this._findNearestOutlookQuotations(div);
	}
	if (quotes.length == 1) {
		var rest = $("<div>");
		var next = null;
		while (next = quotes[0].nextSibling) {
			rest.append(next);
		}
		var quoteAndRest = $("<div>").append(quotes.first().remove()).append(rest.contents());
		return {text: div.html(), quotation: quoteAndRest.html()};
	} else {
		return {text: html, quotation: ""};
	}
};

/**
 * Tries to find the outlook quotation that is nearest to the given outer div. Multiple parallel quotations are not recognized.
 * @param {Object} outerDiv The jquery div.
 * @return {Object} The jquery div that was recognized as the quotation part.
 */
tutao.tutanota.gui.MailView.prototype._findNearestOutlookQuotations = function(outerDiv) {
	var outlookQuotes = outerDiv.find("div").filter(function() {
		var element = $(this);
		return (element.css("border-left-width") != "0px" && element.css("border-left-width") != "") &&
				(element.css("border-top-width") == "0px" || element.css("border-top-width") == "") &&
				(element.css("border-right-width") == "0px" || element.css("border-right-width") == "") &&
				(element.css("border-bottom-width") == "0px" || element.css("border-bottom-width") == "");
	});
	var distances = [];
	distances.length = 100;
	for (var i = 0; i < outlookQuotes.length; i++) {
		var distance = $(outlookQuotes[i]).parentsUntil(outerDiv).length;
		if (distance < distances.length) {
            if (!distances[distance]) {
                distances[distance] = [];
            }
            distances[distance].push(outlookQuotes.get(i));
		}
	}
	var i = 0;
	while (!distances[i] && i < distances.length) {
		i++;
	}
	return distances[i] ? $(distances[i]) : $([]);
};

/**
 * Fades the conversation column in and out.
 */
tutao.tutanota.gui.MailView.prototype.fadeConversation = function() {
	$("#innerConversationColumn").children().fadeOut().fadeIn();
};

/**
 * Fades the conversation column in.
 */
tutao.tutanota.gui.MailView.prototype.fadeConversationIn = function(callback) {
	$("#innerConversationColumn").children().hide().fadeIn(callback);
};

/**
 * Hides the conversation column
 */
tutao.tutanota.gui.MailView.prototype.hideConversation = function() {
	$("#innerConversationColumn").children().hide();
};

/**
 * Adds a submit listener to all forms of the mail body which shows a warning if the form is submitted.
 */
tutao.tutanota.gui.MailView.prototype.addSubmitCheckToMailBody = function() {
    var divs = $(".conversation").find('.mailBody, .mailBodyQuotation');
    this.addSubmitCheckToDivs(divs);
};

/**
 * Adds a submit listener to all forms of the mail body which shows a warning if the form is submitted.
 */
tutao.tutanota.gui.MailView.prototype.addSubmitCheckToDivs = function(jQueryDivs) {
    jQueryDivs.submit(function(event) {
        if (!tutao.tutanota.gui.confirm(tutao.lang("reallySubmitContent_msg"))) {
            event.preventDefault();
        }
    });
};

"use strict";

tutao.provide('tutao.tutanota.gui.NotFoundView');

/**
 * @constructor
 * @implements {tutao.tutanota.ctrl.View}
 */
tutao.tutanota.gui.NotFoundView = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
};

/**
 * @inherit
 */
tutao.tutanota.gui.NotFoundView.prototype.init = function() {
    this._swipeSlider = tutao.tutanota.gui.SwipeSlider.none();
};

/**
 * @inherit
 */
tutao.tutanota.gui.NotFoundView.prototype.isForInternalUserOnly = function() {
    return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.NotFoundView.prototype.activate = function() {

};

/**
 * @inherit
 */
tutao.tutanota.gui.NotFoundView.prototype.deactivate = function() {

};

/**
 * @inherit
 */
tutao.tutanota.gui.NotFoundView.prototype.getSwipeSlider = function() {
    return this._swipeSlider;
};

/**
 * @inherit
 */
tutao.tutanota.gui.NotFoundView.prototype.isShowLeftNeighbourColumnPossible = function() {
    return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.NotFoundView.prototype.isShowRightNeighbourColumnPossible = function() {
    return false;
};

"use strict";

tutao.provide('tutao.tutanota.gui.NotSupportedView');

/**
 * @constructor
 * @implements {tutao.tutanota.ctrl.View}
 */
tutao.tutanota.gui.NotSupportedView = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
};

/**
 * @inherit
 */
tutao.tutanota.gui.NotSupportedView.prototype.init = function() {
    this._swipeSlider = tutao.tutanota.gui.SwipeSlider.none();
};

/**
 * @inherit
 */
tutao.tutanota.gui.NotSupportedView.prototype.isForInternalUserOnly = function() {
    return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.NotSupportedView.prototype.activate = function() {

};

/**
 * @inherit
 */
tutao.tutanota.gui.NotSupportedView.prototype.deactivate = function() {

};

/**
 * @inherit
 */
tutao.tutanota.gui.NotSupportedView.prototype.getSwipeSlider = function() {
    return this._swipeSlider;
};

/**
 * @inherit
 */
tutao.tutanota.gui.NotSupportedView.prototype.isShowLeftNeighbourColumnPossible = function() {
    return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.NotSupportedView.prototype.isShowRightNeighbourColumnPossible = function() {
    return false;
};

"use strict";

tutao.provide('tutao.tutanota.gui.RegistrationVerifyDomainView');

/**
 * @constructor
 * @implements {tutao.tutanota.ctrl.View}
 */
tutao.tutanota.gui.RegistrationVerifyDomainView= function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
};

/**
 * @inherit
 */
tutao.tutanota.gui.RegistrationVerifyDomainView.prototype.init = function() {
    this._swipeSlider = tutao.tutanota.gui.SwipeSlider.none();
};

/**
 * @inherit
 */
tutao.tutanota.gui.RegistrationVerifyDomainView.prototype.isForInternalUserOnly = function() {
    return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.RegistrationVerifyDomainView.prototype.activate = function() {
    tutao.locator.registrationVerifyDomainViewModel.activate();
};

/**
 * @inherit
 */
tutao.tutanota.gui.RegistrationVerifyDomainView.prototype.deactivate = function() {

};

/**
 * @inherit
 */
tutao.tutanota.gui.RegistrationVerifyDomainView.prototype.getSwipeSlider = function() {
    return this._swipeSlider;
};

/**
 * @inherit
 */
tutao.tutanota.gui.RegistrationVerifyDomainView.prototype.isShowLeftNeighbourColumnPossible = function() {
    return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.RegistrationVerifyDomainView.prototype.isShowRightNeighbourColumnPossible = function() {
    return false;
};

"use strict";

tutao.provide('tutao.tutanota.gui.RegistrationView');

/**
 * @constructor
 * @implements {tutao.tutanota.ctrl.View}
 */
tutao.tutanota.gui.RegistrationView = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
};

/**
 * @inherit
 */
tutao.tutanota.gui.RegistrationView.prototype.init = function() {
    this._swipeSlider = tutao.tutanota.gui.SwipeSlider.none();
};

/**
 * @inherit
 */
tutao.tutanota.gui.RegistrationView.prototype.isForInternalUserOnly = function() {
    return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.RegistrationView.prototype.activate = function(parameters) {
    tutao.locator.registrationViewModel.activate(parameters.authToken);
};

/**
 * @inherit
 */
tutao.tutanota.gui.RegistrationView.prototype.deactivate = function() {

};

/**
 * @inherit
 */
tutao.tutanota.gui.RegistrationView.prototype.getSwipeSlider = function() {
    return this._swipeSlider;
};

/**
 * @inherit
 */
tutao.tutanota.gui.RegistrationView.prototype.isShowLeftNeighbourColumnPossible = function() {
    return false;
};

/**
 * @inherit
 */
tutao.tutanota.gui.RegistrationView.prototype.isShowRightNeighbourColumnPossible = function() {
    return false;
};

"use strict";

tutao.provide('tutao.tutanota.gui.SettingsView');

/**
 * @constructor
 * @implements {tutao.tutanota.ctrl.View}
 */
tutao.tutanota.gui.SettingsView = function() {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
};

tutao.tutanota.gui.SettingsView.COLUMN_SETTINGS = null;
tutao.tutanota.gui.SettingsView.COLUMN_CHANGE_SETTINGS = null;
tutao.tutanota.gui.SettingsView.COLUMN_CHANGE_SETTINGS_DETAILS = null;

/**
 * @inherit
 */
tutao.tutanota.gui.SettingsView.prototype.init = function(external) {
	this._swipeSlider = new tutao.tutanota.gui.SwipeSlider(this, 'settingsContent');
    tutao.tutanota.gui.SettingsView.COLUMN_SETTINGS = this._swipeSlider.addViewColumn(0, 150, 200, 'settingsColumn');
    tutao.tutanota.gui.SettingsView.COLUMN_CHANGE_SETTINGS = this._swipeSlider.addViewColumn(1, 400, 600, 'changeSettingsColumn');
    tutao.tutanota.gui.SettingsView.COLUMN_CHANGE_SETTINGS_DETAILS = this._swipeSlider.addViewColumn(1, 400, 600, 'changeSettingsDetailsColumn');
};

/**
 * @inherit
 */
tutao.tutanota.gui.SettingsView.prototype.isForInternalUserOnly = function() {
	return true;
};

/**
 * @inherit
 */
tutao.tutanota.gui.SettingsView.prototype.activate = function() {
    this._swipeSlider.activate();
};

/**
 * @inherit
 */
tutao.tutanota.gui.SettingsView.prototype.deactivate = function() {
};

/**
 * @inherit
 */
tutao.tutanota.gui.SettingsView.prototype.getSwipeSlider = function() {
    return this._swipeSlider;
};

/**
 * @inherit
 */
tutao.tutanota.gui.SettingsView.prototype.isShowLeftNeighbourColumnPossible = function() {
    return (this._swipeSlider.getLeftmostVisibleColumnId() == tutao.tutanota.gui.SettingsView.COLUMN_CHANGE_SETTINGS);
};

/**
 * @inherit
 */
tutao.tutanota.gui.SettingsView.prototype.isShowRightNeighbourColumnPossible = function() {
    return false;
};

/**
 * Makes sure that the change settings column is visible.
 */
tutao.tutanota.gui.SettingsView.prototype.showChangeSettingsColumn = function() {
    this._swipeSlider.getViewSlider().showViewColumn(tutao.tutanota.gui.SettingsView.COLUMN_CHANGE_SETTINGS);
};

/**
 * Makes sure that the change settings details column is visible.
 */
tutao.tutanota.gui.SettingsView.prototype.showChangeSettingsDetailsColumn = function() {
    this._swipeSlider.getViewSlider().showViewColumn(tutao.tutanota.gui.SettingsView.COLUMN_CHANGE_SETTINGS_DETAILS);
};
"use strict";

tutao.provide('tutao.tutanota.gui.SwipeSlider');

/**
 * Connects the view slider of a div with the swipe recognition.
 * @constructor
 * @param {tutao.tutanota.ctrl.View} view The view that is slided.
 * @param {string} contentDivId The name of the content div this SwipeSlider is responsible for.
 */
tutao.tutanota.gui.SwipeSlider = function(view, contentDivId) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);

    this._view = view;

	this._leftmostVisibleColumn = ko.observable(-1);
	this._rightmostVisibleColumn = ko.observable(-1);

    this._viewSlider = null;
    if (view) {
        var self = this;
        // configure view slider
        this._viewSlider = new tutao.tutanota.ctrl.ViewSlider();
        this._viewSlider.setScreenWidth(tutao.tutanota.gui.getWindowWidth());
        this._viewSlider.setViewPositionAndSizeReceiver(function(x, y, initial) {
            self._leftmostVisibleColumn(self._viewSlider.getLeftmostVisibleColumnId());
            self._rightmostVisibleColumn(self._viewSlider.getRightmostVisibleColumnId());
            tutao.tutanota.gui.viewPositionAndSizeReceiver("#" + contentDivId, x, y, initial);
        });
    }
    this._firstActivation = true;
};

tutao.tutanota.gui.SwipeSlider.none = function() {
    return new tutao.tutanota.gui.SwipeSlider(null, null);
};

tutao.tutanota.gui.SwipeSlider.prototype.addViewColumn = function(prio, minWidth, maxWidth, columnDivId) {
    return this._viewSlider.addViewColumn(prio, minWidth, maxWidth, function(x, width) {
        $('#' + columnDivId).css("width", width + "px");
    });
};

tutao.tutanota.gui.SwipeSlider.prototype.activate = function() {
	this._viewSlider.setScreenWidth(tutao.tutanota.gui.getWindowWidth());
	if (this._firstActivation) {
		this._firstActivation = false;
		// only show the default view columns if this is the first activation, otherwise we want to see the last visible view columns
		this._viewSlider.showDefault();
	}
};

tutao.tutanota.gui.SwipeSlider.prototype.windowSizeChanged = function(width, height) {
    if (this._viewSlider) {
	    this._viewSlider.setScreenWidth(width);
    }
};

tutao.tutanota.gui.SwipeSlider.prototype.swipeRecognized = function(type) {
    if (this._viewSlider) {
        if (type == tutao.tutanota.ctrl.SwipeRecognizer.TYPE_LEFT && this._view.isShowRightNeighbourColumnPossible()) {
                this.showRightNeighbourColumn();
        } else if (type == tutao.tutanota.ctrl.SwipeRecognizer.TYPE_RIGHT && this._view.isShowLeftNeighbourColumnPossible()) {
            this.showLeftNeighbourColumn();
        }
    }
};

tutao.tutanota.gui.SwipeSlider.prototype.showLeftNeighbourColumn = function() {
	this._viewSlider.showViewColumn(this._viewSlider.getLeftmostVisibleColumnId() - 1);
};

tutao.tutanota.gui.SwipeSlider.prototype.showRightNeighbourColumn = function() {
    this._viewSlider.showViewColumn(this._viewSlider.getRightmostVisibleColumnId() + 1);
};

tutao.tutanota.gui.SwipeSlider.prototype.getViewSlider = function() {
    return this._viewSlider;
};

tutao.tutanota.gui.SwipeSlider.prototype.getLeftmostVisibleColumnId = function() {
    return this._leftmostVisibleColumn();
};

tutao.tutanota.gui.SwipeSlider.prototype.getRightmostVisibleColumnId = function() {
    return this._rightmostVisibleColumn();
};

"use strict";

tutao.provide('tutao.tutanota.gui');

/**
 * The static id of the text node type.
 */
tutao.tutanota.gui.TEXT_NODE = 3;
/**
 * The static id of the element node type.
 */
tutao.tutanota.gui.ELEMENT_NODE = 1;

/**
 * @export
 */
tutao.tutanota.gui.initKnockout = function() {
	ko.bindingHandlers['class'] = {
	    'update': function(element, valueAccessor) {
	        if (element['__ko__previousClassValue__']) {
	            ko.utils.toggleDomNodeCssClass(element, element['__ko__previousClassValue__'], false);
	        }
	        var value = ko.utils.unwrapObservable(valueAccessor());
	        ko.utils.toggleDomNodeCssClass(element, value, true);
	        element['__ko__previousClassValue__'] = value;
	    }
	};
	ko.bindingHandlers.fastClick = {
		init: function(element, valueAccessor, allBindingsAccessor, viewModel) {
			// FastButton is used because the FastClick bug does not exist (jumping focus)
			// Disadvantage: The cursor does not stay in the bubbleinputfield when selecting a suggestion (seems to depend on body movement)
			// Additional bad disadvantage: elements that are bound to the fastClick can not be iscroll-scrolled
			// Additional disadvantage: click events may come twice if the click triggers a alert or confirm popup, e.g. in the contact view
			// one time when the delete button is clicked (then press cancel) and the second time when you try to
			// scroll the contact afterwards (see iss129)
			// workaround is to call the handler function in a setTimeout
			new FastButton(element, function(event) {
				valueAccessor()(viewModel, event);
			});
		}
	};
	// FastClick is currently not used because when selecting the subject field, the focus jumps to the body in certain cases
	// Advantage of FastClick: The cursor is always staying in the bubble input field when selecting a suggestion (the body does not scroll)
	//new FastClick(document.body);

	// allows the view model to receive the bound dom element
	ko.bindingHandlers.domInit = {
		init: function(element, valueAccessor, allBindingsAccessor, viewModel) {
			valueAccessor()(element);
		}
	};

	ko.bindingHandlers.fadeVisible = {
			init: function(element, valueAccessor) {
				// Initially set the element to be instantly visible/hidden depending on the value
				var value = valueAccessor();
				$(element).toggle(ko.utils.unwrapObservable(value)); // Use "unwrapObservable" so we can handle values that may or may not be observable
			},
			update: function(element, valueAccessor) {
				// Whenever the value subsequently changes, slowly fade the element in or out
				var value = valueAccessor();
				ko.utils.unwrapObservable(value) ? $(element).fadeIn() : $(element).fadeOut();
			}
	};

	ko.bindingHandlers.fadeInVisible = {
			init: function(element, valueAccessor) {
				// Initially set the element to be instantly visible/hidden depending on the value
				var value = valueAccessor();
				$(element).toggle(ko.utils.unwrapObservable(value)); // Use "unwrapObservable" so we can handle values that may or may not be observable
			},
			update: function(element, valueAccessor) {
				// Whenever the value subsequently changes, slowly fade the element in or out
				var value = valueAccessor();
				ko.utils.unwrapObservable(value) ? $(element).fadeIn() : $(element).hide();
			}
	};
	
	ko.bindingHandlers.lang = {
		update: function(element, valueAccessor, allBindingsAccessor) {
			var params = allBindingsAccessor()["params"];
			ko.bindingHandlers.text.update(element, function() { return tutao.locator.languageViewModel.get(ko.utils.unwrapObservable(valueAccessor()), params); });
	    }
	};
	
	ko.bindingHandlers.simpleDate = {
		// one-way
		update: function(element, valueAccessor, allBindingsAccessor) {
			var defaultText = allBindingsAccessor()["default"];
			var unwrappedDate = ko.utils.unwrapObservable(valueAccessor());
			if (unwrappedDate == null) {
				ko.bindingHandlers.text.update(element, function() { return defaultText; });
			} else {
				ko.bindingHandlers.text.update(element, function() { return tutao.tutanota.util.Formatter.dateToSimpleString(unwrappedDate); });
			}
	    }
	};
	
	ko.bindingHandlers.dateInput = {
		// two-way
		init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
	        ko.utils.registerEventHandler(element, 'change', function (event) {
        		valueAccessor()(tutao.tutanota.util.Formatter.dashStringToDate($(element).val()));
	        });
	    },
	    update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
	    	var unwrappedDate = ko.utils.unwrapObservable(valueAccessor());
	    	if (unwrappedDate == null) {
	    		$(element).val(null);
			} else {
				$(element).val(tutao.tutanota.util.Formatter.dateToDashString(unwrappedDate));
			}
	    }
	};
	
	ko.bindingHandlers.fadeLang = {
		update: function(element, valueAccessor, allBindingsAccessor) {
			var params = allBindingsAccessor()["params"];
			ko.bindingHandlers.fadeText.update(element, function() { return tutao.locator.languageViewModel.get(valueAccessor(), params); });
	    }
	};
	
	// sets a wide class on all forms that are wider than 350px
	var updateForm = function(element, container) {
		var e = $(element);
		e.toggleClass("wide", container.width() > 360);
	};
	// allows moving the record-data part of a record-container below the record-name on small devices
	var currentForms = []; 
	ko.bindingHandlers.form = {
		init: function(element, valueAccessor) {
			var container = $(element).closest(".viewColumn, .panel");
			setTimeout(function() {
				updateForm(element, container);
			},1);
			var formMapping = {formElement: element, container: container};
			currentForms.push(formMapping);
			
			ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
				currentForms.splice(formMapping,1);
		    });
		},
		update: function(element, valueAccessor) {
			var container = $(element).closest(".viewColumn, .panel");
			updateForm(element, container);
		}
	};
	$(window).resize(function() {
		for (var i = 0; i < currentForms.length; i++) {
			updateForm(currentForms[i].formElement, currentForms[i].container);
		}
	});
	
	ko.bindingHandlers.fadeText = {
	    init: function(element, valueAccessor) { 
	        // initially don't show the element        
	        //$(element).hide();        
	    },
	    update: function(element, valueAccessor) {
	        var value = ko.utils.unwrapObservable(valueAccessor());
	        $(element).fadeOut(500, function() {
	            // set the text of the element, 
	            // value needs to be defined outside of the fadeOut valueAccessor to work
	        	ko.bindingHandlers.text.update(element, function() { return value; } );
	            $(element).fadeIn(500);
	        });
	    }
	};
	
	ko.bindingHandlers.slideHideTop = {
		init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
			// Initially set the element to be instantly visible/hidden depending on the value
			bindingContext.oldValue = ko.utils.unwrapObservable(valueAccessor());
			$(element).toggle(Boolean(bindingContext.oldValue)); // Use "unwrapObservable" so we can handle values that may or may not be observable
		},
		update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
			var value = ko.utils.unwrapObservable(valueAccessor());
			if (value === bindingContext.oldValue) {
				return;
			}
			bindingContext.oldValue = value;
			if (value) {
				$(element).css({ y: '-100%' });
				$(element).show().transition({ y: '0%' }, function () {});
			} else {
				$(element).transition({ y: '-100%' }, function () { $(this).hide(); });
			}

		}
	};
	$.fx.speeds._default = 600;
	var slideViewQueue = [];
	ko.bindingHandlers.slideView = {
		previousView: null,
		init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
			// Initially set the element to be instantly visible/hidden depending on the value
			bindingContext.oldValue = ko.utils.unwrapObservable(valueAccessor());
			$(element).toggle(Boolean(bindingContext.oldValue)); // Use "unwrapObservable" so we can handle values that may or may not be observable
		},
		update: function(newView, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
			var value = ko.utils.unwrapObservable(valueAccessor());
			if (value) {
				slideViewQueue.push(function() {
					ko.bindingHandlers.slideView.runTransition(newView);
				});
				if (slideViewQueue.length == 1) {
					slideViewQueue[0]();
				}
			}
		},
		runTransition: function(newView) {
			var previousView = ko.bindingHandlers.slideView.previousView;
			if (previousView != newView) {
				var finishedHandler = function () {
					// TODO remove, after https://github.com/rstacruz/jquery.transit/issues/158 has been fixed
					$(newView).css({'-webkit-transform': ''}, {'-ms-transform': ''}, {'-moz-transform': ''}, {'transform': ''});
					
					ko.bindingHandlers.slideView.previousView = newView;
					slideViewQueue.shift();
					if (slideViewQueue.length > 0) {
						slideViewQueue[0]();
					}
				};
				if (newView == $("div#login")[0]) { // just a workaround as long as sliding in the loginview does not work on all devices
					$(previousView).hide();
					$(newView).show();
					finishedHandler();
					
				} else {
					$(previousView).transition({ y: '-100%' }).transition({display: "none"}, 0);
					$(newView).transition({ y: '100%' },0).transition({display: ""}, 0).transition({ y: '0%' }, finishedHandler);
				}
			} else {
				slideViewQueue.shift();
				if (slideViewQueue.length > 0) {
					slideViewQueue[0]();
				}
			}
		}
	};	
	
	// slides the dom-element to the left to hide it and to the right to make it visible
	ko.bindingHandlers.slideHideLeft = {
		init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
			// Initially set the element to be instantly visible/hidden depending on the value
			bindingContext.oldValue = ko.utils.unwrapObservable(valueAccessor());
			$(element).toggle(Boolean(bindingContext.oldValue)); // Use "unwrapObservable" so we can handle values that may or may not be observable
		},
		update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
			var value = ko.utils.unwrapObservable(valueAccessor());
			if (value === bindingContext.oldValue) {
				return;
			}
			bindingContext.oldValue = value;
			//setTimeout(function() {
				if (value) {
					//$(element).css({ x: '-1%' });
					$(element).show().transition({ x: '0%' }, function () {});
				} else {
					$(element).transition({ x: '-100%' }, function () { $(this).hide(); });
				}
			//}, 0);
		}
	};

	ko.bindingHandlers.slideVisible = {
		init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
			// Initially set the element to be instantly visible/hidden depending on the value
			bindingContext.oldValue = ko.utils.unwrapObservable(valueAccessor());
			$(element).toggle(Boolean(bindingContext.oldValue)); // Use "unwrapObservable" so we can handle values that may or may not be observable
		},
		update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
			// Whenever the value subsequently changes, slowly fade the element in or out
			var value = ko.utils.unwrapObservable(valueAccessor());
			if (value === bindingContext.oldValue) {
				return;
			}
			bindingContext.oldValue = value;
			// invoke the slideDown/up operation after all knockout bindings to the value have been updated
			// Problem: text or html binding is defined on a child of a div which is slided up or down depending on the child text
			setTimeout(function() {
				if (value) {
					$(element).hide().slideDown();
				} else {
					/* ATTENTION: The animation time must match the timeout in:
					 * * tutao.tutanota.ctrl.DisplayedMail.prototype._loadBody
					 */
					$(element).slideUp(function() {
						$(element).hide();
					});
				}
			}, 0);
		}
	};

//	ko.bindingHandlers.slideVisible = {
//		    update: function(element, valueAccessor, allBindingsAccessor) {
//		        // First get the latest data that we're bound to
//		        var value = valueAccessor(), allBindings = allBindingsAccessor();
//
//		        // Next, whether or not the supplied model property is observable, get its current value
//		        var valueUnwrapped = ko.utils.unwrapObservable(value);
//
//		        // Grab some more data from another binding property
//		        var duration = allBindings.slideDuration || 400; // 400ms is default duration unless otherwise specified
//
//		        // Now manipulate the DOM element
//		        if (valueUnwrapped == true)
//		            $(element).slideDown(duration); // Make the element visible
//		        else
//		            $(element).slideUp(duration);   // Make the element invisible
//		    }
//		};

//	ko.bindingHandlers.wysihtml5 = {
//	        control: "",
//	        init: function (element, valueAccessor, allBindingsAccessor, viewModel) {
//	            control = $(element).wysihtml5({
//	                "events": {
//	                    "change" : function() {
//	                        var observable = valueAccessor();
//	                        observable(control.getValue());
//	                    }
//	                }
//	            }).data("wysihtml5").editor;
//
//
//	        },
//	        update: function (element, valueAccessor, allBindingsAccessor, viewModel) {
//	            var content = valueAccessor();
//
//	            if (content != undefined) {
//	                control.setValue(content());
//	            }
//	        }
//	    };

	// must be invoked because knockout won't render anything otherwise
	ko.applyBindings({});
};

/**
 * Initializes all global events for the gui.
 */
tutao.tutanota.gui.initEvents = function() {
	// not used currently
//	setTimeout(function() { // without the timeout the animation does not work.
//		// additionally binding mousedown starts the animation twice
//		$('.menu_link').bind("touchstart", function(e) {
//			self = $(this).children('div').children('img');
//	        self.animate({ height: '42', top: '0', width: '42'}, 150, function() {
//	        	self.animate({ height: '34', top: '4', width: '34'}, 150);
//	        });
//	    });
//	}, 0);

    if (tutao.tutanota.util.ClientDetector.getDeviceType() == tutao.tutanota.util.ClientDetector.DEVICE_TYPE_IPAD && tutao.tutanota.util.ClientDetector.getBrowserVersion() == 7) {
        tutao.tutanota.gui._fixWindowHeight();
        window.addEventListener("orientationchange", tutao.tutanota.gui._fixWindowHeight);
        document.addEventListener('focusout', tutao.tutanota.gui._fixWindowHeight);
    }

	if (tutao.tutanota.util.ClientDetector.isMobileDevice()) {
		tutao.tutanota.gui._disableWindowScrolling();
	}
    // not used currently because in the most important case (history sliding on iOS 7) it is not working
    // window.onbeforeunload = tutao.tutanota.gui._confirmExit;

    // workaround for firefox bug
    tutao.tutanota.gui.addWindowResizeListener(function() {
        tutao.tutanota.gui.adjustPanelHeight();
    });
};

/*tutao.tutanota.gui._confirmExit = function() {
    if (tutao.locator.viewManager.isUserLoggedIn()) {
        return tutao.lang("leavePageConfirmation_msg");
    } else {
        return null;
    }
};*/

tutao.tutanota.gui._fixWindowHeight = function() {
    if (window.innerHeight != document.body.style.height) {
        document.body.style.height = window.innerHeight + "px";
    }
    if (document.body.scrollTop !== 0) {
        window.scrollTo(0, 0);
    }
};

/**
 * Prevents the complete window from scrolling vertically on touch devices.
 * See http://stackoverflow.com/questions/10238084/ios-safari-how-to-disable-overscroll-but-allow-scrollable-divs-to-scroll-norma
 */
tutao.tutanota.gui._disableWindowScrolling = function() {

    // Uses document because document will be topmost level in bubbling
    $(document).on('touchmove',function(e){
        e.preventDefault();
    });

    // Uses body because jquery on events are called off of the element they are
    // added to, so bubbling would not work if we used document instead.
    var scrolling = false;
    $('body').on('touchstart','.scrollable',function(e) {

        // Only execute the below code once at a time
        if (!scrolling) {
            scrolling = true;
            if (e.currentTarget.scrollTop === 0) {
                e.currentTarget.scrollTop = 1;
            } else if (e.currentTarget.scrollHeight === e.currentTarget.scrollTop + e.currentTarget.offsetHeight) {
                e.currentTarget.scrollTop -= 1;
            }
            scrolling = false;
        }
    });

    // Prevents preventDefault from being called on document if it sees a scrollable div
    $('body').on('touchmove', '.scrollable', function(e) {
        // Only block default if internal div contents are large enough to scroll
        // Warning: scrollHeight support is not universal. (http://stackoverflow.com/a/15033226/40352)
        if($(this)[0].scrollHeight > $(this).innerHeight()) {
            e.stopPropagation();
        }
    });
};

/**
 * Provides the information if the given dom element is a contenteditable or belongs to one.
 * @param {Object} domElement The element to test.
 * @return {boolean} If it is/belongs to a contenteditable.
 */
tutao.tutanota.gui.isContentEditable = function(domElement) {
	// contenteditables contain other nodes, so we also need to check the parents
	var current = domElement;
	while (current) {
		if (current.contentEditable == "true") {
			return true;
		}
		current = current.parentNode;
	}
	return false;
};

/**
 * Provides the information if the given dom element is editable. These are selects, inputs, textareas and contenteditables.
 * @param {Object} domElement The element to test.
 * @return {boolean} If it is editable.
 */
tutao.tutanota.gui.isEditable = function(domElement) {
	return (domElement.tagName == 'SELECT' || domElement.tagName == 'INPUT' || domElement.tagName == 'TEXTAREA' ||
			tutao.tutanota.gui.isContentEditable(domElement));
};

// currently not used because deleting mails is done in mail view and not via context menu in mail list view
///**
// * Register a listener function that is called when a long press on a mail in the mail list is registered.
// * @param {function(Object,number,number)} listener The listener passes the pressed dom element and the x/y position that was pressed.
// */
//tutao.tutanota.gui.registerMailLongPress = function(listener) {
//	var pressTimer = undefined;
//	var startX = undefined;
//	var startY = undefined;
//	var cancelLongPress = false;
//
//	var pressFunction = function(e) {
//		cancelLongPress = false;
//		startX = e.pageX;
//		startY = e.pageY;
//		pressTimer = window.setTimeout(function() {
//			if (!cancelLongPress) {
//				listener($(e.target).closest(".mailInList").get(0), startX, startY);
//			}
//		}, 1000);
//		return false;
//	};
//
//	// cancel the long press if the finger position is too far from the start press position
//	var moveFunction = function(e) {
//		if (!cancelLongPress) {
//			if (Math.abs(e.pageX - startX) > 5 || Math.abs(e.pageY - startY) > 5) {
//				cancelLongPress = true;
//			}
//		}
//		return false;
//	};
//
//	var releaseFunction = function(e) {
//		window.clearTimeout(pressTimer);
//		return false;
//	};
//
//	document.addEventListener("mousedown", pressFunction); // just for desktop compatibility
//	document.addEventListener("touchstart", pressFunction);
//	document.addEventListener("mouseup", releaseFunction); // just for desktop compatibility
//	document.addEventListener("touchend", releaseFunction);
//	document.addEventListener("touchmove", moveFunction);
//};

/**
 * Asks the user for a confirmation to cancel the mail and provides the result.
 * @param {string} text The text to show to the user.
 * @return {boolean} True if the mail shall be cancelled, false otherwise.
 */
tutao.tutanota.gui.confirm = function(text) {
	return confirm(text);
};

/**
 * Shows an alert window to the user and returns when it is closed.
 * @param {string} text The text in the window.
 */
tutao.tutanota.gui.alert = function(text) {
	alert(text);
};

/**
 * Set the search status in the gui.
 * @param {number} status 0: search icon is visible, 1: cancel icon is visible.
 */
tutao.tutanota.gui.setSearchStatus = function(status) {
	if (status === 0) {
		$("#searchImage").removeClass('searchCancel');
		$("#searchImage").addClass('searchStart');
	} else if (status === 1) {
		$("#searchImage").removeClass('searchStart');
		$("#searchImage").addClass('searchCancel');
	}
};

/**
 * Marks the given dom elements as selected.
 * @param {Array.<Object>} elements The dom elements.
 */
tutao.tutanota.gui.select = function(elements) {
	for (var i = 0; i < elements.length; i++) {
		$(elements[i]).addClass('selected');
		$(elements[i]).removeClass('unreadFont');
	}
};

/**
 * Marks the given dom elements as not selected.
 * @param {Array.<Object>} elements The dom elements.
 */
tutao.tutanota.gui.unselect = function(elements) {
	for (var i = 0; i < elements.length; i++) {
		$(elements[i]).removeClass('selected');
	}
};

/* Gui part for the view slider */

/**
 * Makes the changes on the view requested by the view slider.
 * @param {number} left Left position of the view.
 * @param {number} width The width of the view.
 * @param {boolean} initial True if this is the first time the values are set.
 */
tutao.tutanota.gui.viewPositionAndSizeReceiver = function(domElement, left, width, initial) {
	// the transition is done via css
	if (initial) {
		$(domElement).css("left", left + "px");
		$(domElement).css("width", width + "px");
	} else {
		$(domElement).transition({left: left + "px", width: width + "px"}, 300, 'easeInOutCubic');
	}
};

/**
 * Slides a new dom element instead of displaying it immediately. Knockout event handler (afterAdd).
 * @param {Object} domElement The dom element.
 */
tutao.tutanota.gui.slideAfterAdd = function(domElement) {
	tutao.tutanota.gui.slideDown(domElement, null);
};

/**
 * Slides a dom element down
 * @param {Object} domElement The dom element.
 */
tutao.tutanota.gui.slideDown = function(domElement, callback) {
	if (domElement.nodeType !== tutao.tutanota.gui.TEXT_NODE) {
		$(domElement).hide().slideDown(400, callback);
	}
};

/**
 * Slides a dom element before removal instead of removing it immediately.
 * @param {Object} domElement The dom element.
 */
tutao.tutanota.gui.slideBeforeRemove = function(domElement) {
	if (domElement.nodeType !== tutao.tutanota.gui.TEXT_NODE) {
		// ATTENTION: The animation time must match the timeout in:
		//   tutao.tutanota.ctrl.ComposingMail.prototype.cancelMail
		$(domElement).slideUp(function() {
			$(domElement).remove();
		});
	}
};

/**
 * Removes the focus from all currently selected elements. This can be used to hide the keyboard on mobile devices.
 */
tutao.tutanota.gui.blur = function(element) {
	$(element).focus().blur();
};


/**
 * Returns the width of the window (user visible area).
 * @return {number} The width of the browser window in px.
 */
tutao.tutanota.gui.getWindowWidth = function() {
	return $(window).width();
};

/**
 * Returns the height of the window (user visible area).
 * @return {number} The height of the browser window in px.
 */
tutao.tutanota.gui.getWindowHeight = function() {
	return $(window).height();
};

/**
 * Notifies the listener about window size changes.
 * @param {function(number, number)} listener Provides the new width and height of the window if the values change.
 */
tutao.tutanota.gui.addWindowResizeListener = function(listener) {
	var self = this;
	$(window).on("resize", function() {
		listener(self.getWindowWidth(), self.getWindowHeight());
	});
	// on iOS 6, the orientation change events do not trigger resize events in ComposerMode (see e.g. tutao.locator.mailView.enableTouchComposingMode())
	if (tutao.tutanota.util.ClientDetector.isMobileDevice()) {
		$(window).on("orientationchange", function() {
			listener(self.getWindowWidth(), self.getWindowHeight());
		});
	}
};

/**
 * Adjust the height of all panel elements to enable scrolling in firefox browser. This is just a workaround.
 * http://www.webdesignerdepot.com/2014/02/how-to-create-horizontal-scrolling-using-display-table-cell
 */
tutao.tutanota.gui.adjustPanelHeight = function () {
    if (tutao.tutanota.util.ClientDetector.getBrowserType() == tutao.tutanota.util.ClientDetector.BROWSER_TYPE_FIREFOX || (tutao.tutanota.util.ClientDetector.getBrowserType() == tutao.tutanota.util.ClientDetector.BROWSER_TYPE_IE && tutao.tutanota.util.ClientDetector.getBrowserVersion() >= 10 && tutao.tutanota.util.ClientDetector.getDeviceType() == tutao.tutanota.util.ClientDetector.DEVICE_TYPE_DESKTOP)) {
        var panelPadding = parseInt( $('.panel').css('padding-top'));
        var calculatedHeight = $(window).height() - panelPadding;
        $('.panel > div').css('height', calculatedHeight);
    }
};


/**
 * Shows the tooltip on mobile devices
 * @param {DOMElement} element
 */
tutao.tutanota.gui.showTooltip = function(item, event) {
    var element = event.target.parentElement; // the bubble

    $(document).trigger("click.tooltip"); // hide other tooltips
    $(element).children(".tooltip").show().transition({ opacity: 0.9 });
    $(document).on("click.tooltip", function (e) {
        if (e.timeStamp !== event.timeStamp) { // it takes a bit till the original click event bubbles and we do not want to catch this one and hide the tooltip immediately
            $(document).off("click.tooltip");
            $(element).children(".tooltip").transition({ opacity: 0 }).hide();
        }
    });
    return false;
};

"use strict";

tutao.provide('tutao.rest.EntityRestCache');

/**
 * This implementation of the EntityRestInterface provides a caching mechanism to the entity rest chain.
 * It forwards requests to another EntityRestInterface implementation, so it can be put in front of a
 * EntityRestClient. In front of a EntityRestDummy it can serve as a stub for unit tests.
 * The cache works as follows:
 * If a write to the target fails, the cache is also not written and the request fails.
 * If a read from the target fails, the request fails.
 * If a write to the target is successful, the cache is also written.
 * If a read from the target is successful, the cache is written and the element returned.
 * The cache initially loads the complete range of LETS from target and puts it into the cache. Further
 * range requests are served by the cache.
 *
 * This behavior allows using a EntityRestDummy as target and still serve all requests from the cache, even though
 * the dummy would not return any elements for read requests.
 *
 * @constructor
 * @implements tutao.rest.EntityRestInterface
 * @implements {tutao.event.EventBusListener}
 */
tutao.rest.EntityRestCache = function() {
    /**
	 * stores all contents that would be stored on the server, otherwise
	 * @protected
	 */
    // @type {Object.<string,Object.<string, Array.<string>>>}
	this._db = {};
//	var dbstructure = {         // only for documentation
//		'path': { 		// element type
//			"0": {
//              entities: {
//				    'element1Id': 'element1',
//				    'element2Id': 'element2'
//			    	// and so on
//              }
//			}
//		},
//		'path': { 		// list element type
//			'listId': {
//				allRange: ['listElement1Id', 'listElement2Id'],
//              lowerRangeId: listElement1Id,
//              upperRangeId: GENERATED_MAX_ID,
//              entities: {
//				    'listElement1Id': 'listElement1',
//				    'listElement2Id': 'listElement2',
//    				// and so on
//              }
//			}
//		}
//	};

	/**
	 * requests are forwarded to this entity rest instance
	 */
    /* @type {tutao.rest.EntityRestInterface} */
	this._target = undefined;

    // TODO (story push events) remove after update notifications are in place
    this._ignoredPaths = [tutao.entity.sys.GroupInfo.PATH];
};

/**
 * Set an instance that implements EntityRestInterface to which requests are forwarded.
 * This function must be called before any other request functions to instances of this class.
 * @param {tutao.rest.EntityRestInterface} entityRestTarget The target.
 */
tutao.rest.EntityRestCache.prototype.setTarget = function(entityRestTarget) {
	this._target = entityRestTarget;
    if (tutao.locator.eventBus) { // there may be no eventBus instance if Tutanota is not supported
        tutao.locator.eventBus.addListener(this);
    }
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestCache.prototype.getElement = function(type, path, id, listId, parameters, headers) {
	var self = this;
	var cacheListId = (listId) ? listId : "0";
	var versionRequest = (parameters && parameters.version) ? true : false;
	if (versionRequest || !this._db[path] || !this._db[path][cacheListId] || !this._db[path][cacheListId]['entities'][id] || tutao.util.ArrayUtils.contains(this._ignoredPaths, path)) {
		// the element is not in the cache, so get it from target
		return this._target.getElement(type, path, id, listId, parameters, headers).then(function(element) {
			// cache the received element
			if (!versionRequest) {
				self._addToCache(path, element);
                self._tryAddToRange(path, element);
			}
			return element;
		});
	} else {
		return Promise.resolve(self._db[path][cacheListId]['entities'][id]);
	}
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestCache.prototype.getService = function(type, path, data, parameters, headers) {
	return this._target.getService(type, path, data, parameters, headers);
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestCache.prototype.getElements = function(type, path, ids, parameters, headers) {
	var elements = [];
	var fromDbIds = [];
	var cacheListId = "0"; // currently only for ETs
	for ( var i = 0; i < ids.length; i++) {
		var id = ids[i];
		if (!this._db[path] || !this._db[path][cacheListId] || !this._db[path][cacheListId]['entities'][id]) {
			// the element is not in the cache, so get it from target
			fromDbIds.push(id);
		} else {
			// read from cache
			elements.push(this._db[path][cacheListId]['entities'][id]);
		}
	}
	if (fromDbIds.length > 0) {
		var self = this;
		return this._target.getElements(type, path, fromDbIds, parameters, headers).then(function(serverElements) {
			for ( var i = 0; i < serverElements.length; i++) {
				// cache the received elements
				self._addToCache(path, serverElements[i]);
                self._tryAddToRange(path, serverElements[i]);
				// merge with cached elements
				elements.push(serverElements[i]);
			}			
			return elements;
		});
	} else {
		return Promise.resolve(elements);
	}
};

/**
 * Adds the element id to the range if it is an LET and the range is loaded
 * @param {string} path The name of the type of the given element.
 * @param {Object} element The element to add.
 * @protected
 */
tutao.rest.EntityRestCache.prototype._tryAddToRange = function(path, element) {
	if (element.__id instanceof Array) {
        var listId = tutao.rest.EntityRestCache.getListId(element);
        var elementId = tutao.rest.EntityRestInterface.getElementId(element);
        var allRange = this._db[path][listId]['allRange'];

		if (allRange) {
            // If element id does not fit into range do not add it.
            if( tutao.rest.EntityRestInterface.firstBiggerThanSecond (elementId, this._db[path][listId].upperRangeId) || tutao.rest.EntityRestInterface.firstBiggerThanSecond (this._db[path][listId].lowerRangeId, elementId)){
                return;
            }

            for(var i=0; i<allRange.length; i++){
                var rangeElement = allRange[i];
                if (tutao.rest.EntityRestInterface.firstBiggerThanSecond(rangeElement, elementId)){
                    allRange.splice(i, 0, elementId);
                    return;
                }
                if (rangeElement === elementId){
                    return;
                }
            }
            allRange.push(elementId);
		}
	}
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestCache.prototype.postElement = function(path, element, listId, parameters, headers) {
	var self = this;
	return this._target.postElement(path, element, listId, parameters, headers).then(function(returnEntity) {
		var cacheListId = undefined;
		var id = undefined;
		if (element.__id instanceof Array) {
			cacheListId = element.__id[0];
			id = element.__id[1];
		} else {
			cacheListId = "0";
			id = element.__id;
		}
		if (self._db[path] && self._db[path][cacheListId] && self._db[path][cacheListId]['entities'][id]) {
			// this should not happen
			console.log("cache out of sync for post: " + path);
		}
		self._addToCache(path, element);
		return returnEntity;
	});
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestCache.prototype.postService = function(path, element, parameters, headers, returnType) {
	return this._target.postService(path, element, parameters, headers, returnType);
};

/**
 * Puts the given element into the cache.
 * @param {string} path The name of the type of the given element.
 * @param {Object} element The element to add.
 * @protected
 */
tutao.rest.EntityRestCache.prototype._addToCache = function(path, element) {
	var cacheListId = tutao.rest.EntityRestCache.getListId(element);
	var id = tutao.rest.EntityRestInterface.getElementId(element);
	this._getListData(path, cacheListId)['entities'][id] = element;
};


/**
 * @inheritDoc
 */
tutao.rest.EntityRestCache.prototype.putElement = function(path, element, parameters, headers) {
	var self = this;
	return this._target.putElement(path, element, parameters, headers, function(exception) {
        var cacheListId = tutao.rest.EntityRestCache.getListId(element);
        var id = tutao.rest.EntityRestInterface.getElementId(element);
		if (!self._db[path] || !self._db[path][cacheListId] || !self._db[path][cacheListId]['entities'][id]) {
			// this should not happen. it means that the target and this cache are out of sync.
			// put on the target worked fine, so the element was existing on the target.
			// it must habe been received from the target or posted first, otherwise it would not have been possible to put it.
			// we somehow must have missed receiving the element and putting it into the cache.
			console.log("cache out of sync for " + path);
		}
		self._addToCache(path, element);
	});
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestCache.prototype.putService = function(path, element, parameters, headers, returnType) {
    return this._target.putService(path, element, parameters, headers, returnType);
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestCache.prototype.postList = function(path, parameters, headers) {
	return this._target.postList(path, parameters, headers);
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestCache.prototype.getElementRange = function(type, path, listId, start, count, reverse, parameters, headers) {
    tutao.util.Assert.assert(typeof start == "string", "expected start to be a string, but was: " + start + " -> " + (typeof start)); // element id

	var self = this;
    var listData = this._getListData(path, listId);

	if (path.indexOf("/rest/monitor/") != -1 || !type.GENERATED_ID) { // customIds shall not be cached because new instances might be inserted into already retrieved ranges
		return this._target.getElementRange(type, path, listId, start, count, reverse, parameters, headers);
	} else if (!listData['allRange'] || (start == tutao.rest.EntityRestInterface.GENERATED_MAX_ID && reverse && listData.upperRangeId != tutao.rest.EntityRestInterface.GENERATED_MAX_ID)) {
        // if our upper range id is not MAX_ID and we now read the range starting with MAX_ID we just replace the complete existing range with the new one because we do not want to handle multiple ranges
		return this._target.getElementRange(type, path, listId, start, count, reverse, parameters, headers).then(function(elements) {
            if (elements.length > 0) {
                listData.allRange = [];
                listData.lowerRangeId = start;
                listData.upperRangeId = start;
                return self._handleElementRangeResult(path, listId, start, count, reverse, elements);
            }
            return [];
		});
	} else if (this._isStartInRange(path, listId, start)){ // check if the requested start element is located in range
       // count the numbers of elements that are already in allRange to determine the number of elements to read
        var result = this._getNumberOfElementsToRead(path, listId, start, count, reverse);
        if ( result.newCount > 0 ){
            return self._target.getElementRange(type, path, listId, result.newStart, result.newCount, reverse, parameters, headers).then(function(elements) {
                return self._handleElementRangeResult(path, listId, start, count, reverse, elements);
            });
        } else {
            // all elements are located in cache.
            return Promise.resolve(self._provideFromCache(path, listId, start, count, reverse));
        }
    } else {
        var msg = "invalid range request. start:" + start + " count: " + count + " reverse:" + reverse;
        return Promise.reject(new tutao.InvalidDataError(msg));
	}
};


tutao.rest.EntityRestCache.prototype._handleElementRangeResult = function( path, listId, start, count, reverse, elements) {
    var listData = this._getListData(path, listId);
    var elementsToAdd = elements;
	if ( elements.length > 0){
		// Ensure that elements are cached in ascending (not reverse) order
		if (reverse){
		    elementsToAdd = elements.reverse();
		    // After reversing the list the first element in the list is the lower range limit
	        listData.lowerRangeId = elements[0].__id[1];
		} else{
		    // Last element in the list is the upper range limit
	        listData.upperRangeId = elements[elements.length -1].__id[1];
		}

		for (var i = 0; i < elementsToAdd.length; i++) {
		    // add the elements to cache
		    this._addToCache(path, elementsToAdd[i]);
		    // add the elements to the range
		    this._tryAddToRange(path, elementsToAdd[i]);
		}
	} 
	return this._provideFromCache(path, listId, start, count, reverse);
};




tutao.rest.EntityRestCache.prototype._isStartInRange = function(path, listId, start) {
    var listCache = tutao.locator.entityRestClient._db[path][listId];
    if ( tutao.util.ArrayUtils.contains( listCache["allRange"], start) ){
        return true;
    }
    return listCache["lowerRangeId"] == start || listCache["upperRangeId"] == start;
};



/**
 * Calculates the new start value for the getElementRange request and the number of elements to read in
 * order to read no duplicate values.
 * @param {string} path The path including prefix, app name and type name.
 * @param {string} listId The id of the list that contains the elements.
 * @param {string} start The id from where to start to get elements.
 * @param {number} count The maximum number of elements to load.
 * @param {boolean} reverse If true, the elements are loaded from the start backwards in the list, forwards otherwise.
 * @return {{newStart:string, newCount:number}} returns the new start and count value.
 */
tutao.rest.EntityRestCache.prototype._getNumberOfElementsToRead = function(path, listId, start, count, reverse) {
    var listCache = tutao.locator.entityRestClient._db[path][listId];
    var allRangeList = listCache['allRange'];
    var elementsToRead = count;
    var startElementId = start;

    var indexOfStart = allRangeList.indexOf(start);
    if ( allRangeList.length == 0){ // Element range is empty read all elements
        elementsToRead = count;
    } else if ( indexOfStart != -1 ){ // Start element is located in allRange read only elements that are not in allRange.
        if (reverse ){
            elementsToRead = count - indexOfStart;
            startElementId = allRangeList[0]; // use the lowest id in allRange as start element
        } else {
            elementsToRead = count - (allRangeList.length -1 - indexOfStart);
            startElementId = allRangeList[allRangeList.length-1]; // use the  highest id in allRange as start element
        }
    } else if (listCache["lowerRangeId"] == start) { // Start element is not in allRange but has been used has start element for a range request, eg. EntityRestInterface.GENERATED_MIN_ID
        if ( !reverse ){ // if not reverse read only elements that are not in allRange
            startElementId = allRangeList[allRangeList.length-1]; // use the  highest id in allRange as start element
            elementsToRead = count - allRangeList.length
        }
        // if reverse read all elements
    } else if (listCache["upperRangeId"] == start) { // Start element is not in allRange but has been used has start element for a range request, eg. EntityRestInterface.GENERATED_MAX_ID
        if ( reverse ){ // if not reverse read only elements that are not in allRange
            startElementId = allRangeList[0]; // use the  highest id in allRange as start element
            elementsToRead = count - allRangeList.length
        }
        // if not reverse read all elements
    } 
    return { newStart:startElementId, newCount:elementsToRead };
};



/**
 * Provides the elements from the cache.
 * @param {string} path The path including prefix, app name and type name.
 * @param {string} listId The id of the list that contains the elements.
 * @param {string} start The id from where to start to get elements.
 * @param {number} count The maximum number of elements to load.
 * @param {boolean} reverse If true, the elements are loaded from the start backwards in the list, forwards otherwise.
 */
tutao.rest.EntityRestCache.prototype._provideFromCache = function(path, listId, start, count, reverse) {
	var range = this._db[path][listId]['allRange'];
	var ids = undefined;
	if (reverse) {
		for (var i = range.length - 1; i >= 0; i--) {
			if (tutao.rest.EntityRestInterface.firstBiggerThanSecond(start, range[i])) {
				break;
			}
		}
		if (i >= 0) {
			var startIndex = i + 1 - count;
			if (count < 0) {
				count = 0;
			}
            if (startIndex < 0){ // start index may be negative if more elements have been requested than available when getting elements reverse.
                startIndex = 0;
            }
			ids = range.slice(startIndex, i + 1);
			ids.reverse();
		} else {
			ids = [];
		}
	} else {
		for (var i = 0; i < range.length; i++) {
			if (tutao.rest.EntityRestInterface.firstBiggerThanSecond(range[i], start)) {
				break;
			}
		}
		ids = range.slice(i, i + count);
	}
	var result = [];
	for (var a = 0; a < ids.length; a++) {
		result.push(this._db[path][listId]['entities'][ids[a]]);
	}
	return result;
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestCache.prototype.deleteElement = function(path, id, listId, parameters, headers) {
	var self = this;
	return this._target.deleteElement(path, id, listId, parameters, headers).then(function(data) {
        self._deleteFromCache(path, id, listId);
		return data;
	});
};

tutao.rest.EntityRestCache.prototype._deleteFromCache = function(path, id, listId) {
    if (!listId) {
        listId = "0";
    }
    if (!this._db[path] || !this._db[path][listId]) {
        // this may happen when the elements where not yet cached, but the id was
        // taken from another loaded element. Or the element was deleted with a normal rest call. This is not an error.
        return;
    }
    if (this._db[path][listId]['entities'][id]) {
        delete this._db[path][listId]['entities'][id];
    }
    if (this._db[path][listId]['allRange']) {
        // if the id exists in the range, then delete it
        tutao.util.ArrayUtils.remove(this._db[path][listId]['allRange'], id);
    }
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestCache.prototype.deleteService = function(path, element, parameters, headers, returnType) {
    return this._target.deleteService(path, element, parameters, headers, returnType);
};

tutao.rest.EntityRestCache.prototype._getListData = function(path, listId){
    this._db[path] = this._db[path] || {};
    this._db[path][listId] = this._db[path][listId] || {};
    this._db[path][listId]['entities'] = this._db[path][listId]['entities'] || {};
    return this._db[path][listId];
};


/**
 * Returns the list id of the specified element if it is a LET otherwise "0" returns.
 * @param {Object} element The element
 * @returns {string} The list id
 */
tutao.rest.EntityRestCache.getListId = function(element) {
    if (element.__id instanceof Array) {
        return element.__id[0];
    } else {
        return "0";
    }
};

/**
 * Notifies the listener that new data has been received.
 * @param {tutao.entity.sys.EntityUpdate} data The update notification.
 */
tutao.rest.EntityRestCache.prototype.notifyNewDataReceived = function(data) {
    if (data.getOperation() === tutao.entity.tutanota.TutanotaConstants.OPERATION_TYPE_DELETE) {
        this._deleteFromCache("/rest/" + data.getApplication().toLowerCase() + "/" + data.getType().toLocaleLowerCase(), data.getInstanceId(), data.getInstanceListId());
    }
};


/**
 * Notifies a listener about the reconnect event,
 */
tutao.rest.EntityRestCache.prototype.notifyReconnected = function() {
    // nothing to do
};

"use strict";

tutao.provide('tutao.rest.EntityRestClient');

/**
 * The EntityRestClient provides a convenient interface for invoking server side REST services.
 * They make use of the RestClient and add an additional layer for mapping from/to Entity-Objects.
 * @constructor
 * @implements {tutao.rest.EntityRestInterface}
 */
tutao.rest.EntityRestClient = function() {};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestClient.prototype.getElement = function(type, path, id, listId, parameters, headers) {
    var url = tutao.rest.EntityRestClient.createUrl(path, listId, id, parameters);
    return tutao.locator.restClient.getElement(url, headers, null).then(function(returnData) {
        return new type(returnData);
    });
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestClient.prototype.getService = function(type, path, data, parameters, headers) {
	var url = tutao.rest.EntityRestClient.createUrl(path, null, null, parameters);
	return tutao.locator.restClient.getElement(url, headers, JSON.stringify(data.toJsonData())).then(function(returnData) {
        return new type(returnData);
    });
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestClient.prototype.getElements = function(type, path, ids, parameters, headers) {
	var self = this;
	var allParameters = this._cloneParameters(parameters);
	var idParameter = "";
	for (var i = 0; i < ids.length; i++) {
		idParameter += ids[i];
		if (i != ids.length - 1) {
			idParameter += ",";
		}
	}
	allParameters[tutao.rest.ResourceConstants.IDS_PARAMETER_NAME] = idParameter;
	var url = tutao.rest.EntityRestClient.createUrl(path, null, null, allParameters);
    return tutao.locator.restClient.getElement(url, headers, null).then(function(data) {
        return self._createElements(type, data);
    });
};

/**
 * Creates an array of elements from given data with a given type.
 * @param {function(new:Object, Object)} type Type of the elements to load, i.e. the constructor.
 * @param {Array.<Object>} data The data of the elements.
 * @return {Array.<Object>} The entities.
 */
tutao.rest.EntityRestClient.prototype._createElements = function(type, data) {
	var elements = [];
	for (var i=0; i<data.length; i++) {
		elements.push(new type(data[i]));
	}
	return elements;
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestClient.prototype.postElement = function(path, element, listId, parameters, headers) {
	var url = tutao.rest.EntityRestClient.createUrl(path, listId, null, parameters);

	// send the request
    return tutao.locator.restClient.postElement(url, headers, JSON.stringify(element.toJsonData())).then(function(returnString) {
        var returnEntity = new tutao.entity.base.PersistenceResourcePostReturn(returnString);
        if (!element.__id) {
            if (listId) {
                element.__id = [listId, returnEntity.getGeneratedId()];
            } else {
                element.__id = returnEntity.getGeneratedId();
            }
        }
        element.__permissions = returnEntity.getPermissionListId();
        return returnEntity;
    });
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestClient.prototype.postService = function(path, element, parameters, headers, returnType) {
	var url = tutao.rest.EntityRestClient.createUrl(path, null, null, parameters);
    return tutao.locator.restClient.postElement(url, headers, JSON.stringify(element.toJsonData())).then(function(returnData) {
        if (returnType) {
            return new returnType(returnData);
        }
    });
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestClient.prototype.putElement = function(path, element, parameters, headers) {
	var listId;
	var id;
	if (element.__id instanceof Array) {
		listId = element.__id[0];
		id = element.__id[1];
	} else {
		listId = null;
		id = element.__id;
	}
	var url = tutao.rest.EntityRestClient.createUrl(path, listId, id, parameters);

    return tutao.locator.restClient.putElement(url, headers, JSON.stringify(element.toJsonData()));
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestClient.prototype.putService = function(path, element, parameters, headers, returnType) {
    var url = tutao.rest.EntityRestClient.createUrl(path, null, null, parameters);
    return tutao.locator.restClient.putElement(url, headers, JSON.stringify(element.toJsonData())).then(function(returnData) {
            if (returnType) {
                return new returnType(returnData);
            }
    });
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestClient.prototype.postList = function(path, parameters, headers) {
	var url = tutao.rest.EntityRestClient.createUrl(path, null, null, parameters);
    return tutao.locator.restClient.postElement(url, headers, "").then(function(returnEntity) {
		return new tutao.entity.base.PersistenceResourcePostReturn(returnEntity);
	});
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestClient.prototype.getElementRange = function(type, path, listId, start, count, reverse, parameters, headers) {
	var self = this;
	var allParameters = this._cloneParameters(parameters);
	allParameters[tutao.rest.ResourceConstants.START_ID_PARAMETER] = start;
	allParameters[tutao.rest.ResourceConstants.ELEMENT_COUNT_PARAMETER] = count;
	allParameters[tutao.rest.ResourceConstants.REVERSE_PARAMETER] = reverse;
	var url = tutao.rest.EntityRestClient.createUrl(path, listId, null, allParameters);
    return tutao.locator.restClient.getElement(url, headers, null).then(function(data) {
        return self._createElements(type, data);
	});
};

/**
 * Makes a copy of the given parameters and returns it.
 * @param {Object.<string, string>} parameters. The parameters to clone.
 * @return {Object.<string, string>} The copy.
 */
tutao.rest.EntityRestClient.prototype._cloneParameters = function(parameters) {
	var copy = {};
	if (parameters) {
		for (var parameter in parameters) {
			copy[parameter] = parameters[parameter];
		}
	}
	return copy;
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestClient.prototype.deleteElement = function(path, id, listId, parameters, headers) {
    return tutao.locator.restClient.deleteElement(tutao.rest.EntityRestClient.createUrl(path, listId, id, parameters), headers, null);
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestClient.prototype.deleteService = function(path, element, parameters, headers, returnType) {
    var url = tutao.rest.EntityRestClient.createUrl(path, null, null, parameters);
    return tutao.locator.restClient.deleteElement(url, headers, JSON.stringify(element.toJsonData())).then(function(returnData) {
        if (returnType) {
            return new returnType(returnData);
        }
    });
};

/**
 * Provides an uri consisting of the given data.
 * @param {string} path The base path.
 * @param {?string} listId The optional list id of the element.
 * @param {?string} id The id of the element.
 * @param {?Object} parameters Request parameters.
 * @return {string} The uri.
 */
tutao.rest.EntityRestClient.createUrl = function(path, listId, id, parameters) {
	var url = path.toLowerCase();
	if (listId) {
		url += "/" + listId;
	}
	if (id) {
		url += "/" + id;
	}
	if (parameters) {
		url += "?";
		for (var key in parameters) {
			url += key + "=" + parameters[key] + "&";
		}
		url = url.substring(0, url.length - 1);
	}
	return url;
};

"use strict";

tutao.provide('tutao.rest.EntityRestDummy');

/**
 * The EntityRestDummy is an implementation of the EntityRestInterface that does nothing. It does neither return
 * any entities nor forward requests to other implementations.
 * @constructor
 * @implements tutao.rest.EntityRestInterface
 */
tutao.rest.EntityRestDummy = function() {
	// start with a 14 digit number to make it fit to the base64ext format
	this._nextId = 10000000;
	this._prefix = "----";

    // @type {Object.<string,Object.<string, Array.<Object>>>}
    this._db = {};
//	var dbstructure = {         // only for documentation
//		'path': { 		// element type
//			"0": [element1, element2]
//		},
//		'path': { 		// list element type
//			'listId': [element1, element2]
//		}
//	};

};

/**
 * @protected
 * Provides the next id.
 * @return {string} The next id.
 */
tutao.rest.EntityRestDummy.prototype._getNextId = function() {
	var id = this._prefix + this._nextId;
	this._nextId++;
	return id;
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestDummy.prototype.getElement = function(type, path, id, listId, parameters, headers) {
    return Promise.reject(new tutao.NotFoundError());
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestDummy.prototype.getService = function(type, path, data, parameters, headers) {
    return Promise.reject(new tutao.NotFoundError());
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestDummy.prototype.getElements = function(type, path, ids, parameters, headers) {
    return Promise.resolve([]);
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestDummy.prototype.postElement = function(path, element, listId, parameters, headers) {
	var returnEntity = new tutao.entity.base.PersistenceResourcePostReturn();
	// only generated ids must be set, so check if it is missing (custom ids are set by client before the post call)
	if (!element.__id) {		
		if (listId) {
			element.__id = [listId, this._getNextId()];
			returnEntity.setGeneratedId(element.__id[1]);  
		} else {
			element.__id = this._getNextId();
			returnEntity.setGeneratedId(element.__id);  
		}
	}
	element.__permissions = this._getNextId();
	returnEntity.setPermissionListId(element.__permissions);

    this._addToCache(path, element);

	return Promise.resolve(returnEntity);
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestDummy.prototype.postService = function(path, element, parameters, headers, returnType) {
    return Promise.reject(new tutao.NotFoundError());
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestDummy.prototype.putElement = function(path, element, parameters, headers) {
    return Promise.resolve();
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestDummy.prototype.putService = function(path, element, parameters, headers, returnType) {
    return Promise.reject(new tutao.NotFoundError());
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestDummy.prototype.postList = function(path, parameters, headers) {
    return Promise.resolve(new tutao.entity.base.PersistenceResourcePostReturn({generatedId: this._getNextId(), permissionListId: this._getNextId()}));
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestDummy.prototype.getElementRange = function(type, path, listId, start, count, reverse, parameters, headers, callback) {
	return Promise.resolve(this._provideFromCache(path, listId, start, count, reverse));
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestDummy.prototype.deleteElement = function(path, id, listId, parameters, headers) {
    return Promise.resolve();
};

/**
 * @inheritDoc
 */
tutao.rest.EntityRestDummy.prototype.deleteService = function(path, element, parameters, headers, returnType) {
    return Promise.reject(new tutao.NotFoundError());
};

/**
 * Posts the given element into the cache.
 * @param {string} path The name of the type of the given element.
 * @param {Object} element The element to add.
 * @protected
 */
tutao.rest.EntityRestDummy.prototype._addToCache = function(path, element) {
    var listId = tutao.rest.EntityRestDummy.getListId(element);
    var elementId = tutao.rest.EntityRestInterface.getElementId(element);
    var listData = this._getListData(path,listId);
    for(var i=0; i<listData.length; i++){
        var listElement = listData[i];
        if (tutao.rest.EntityRestInterface.firstBiggerThanSecond(tutao.rest.EntityRestInterface.getElementId(listElement),elementId)) {
            listData.splice(i, 0, element);
            return;
        }
        if (elementId == tutao.rest.EntityRestInterface.getElementId(listElement)) {
            listData.splice(i, 1, element);
            return;
        }
    }
    listData.push(element);
};


/**
 * Provides the elements from the cache.
 * @param {string} path The path including prefix, app name and type name.
 * @param {string} listId The id of the list that contains the elements.
 * @param {string} start The id from where to start to get elements.
 * @param {number} count The maximum number of elements to load.
 * @param {boolean} reverse If true, the elements are loaded from the start backwards in the list, forwards otherwise.
 */
tutao.rest.EntityRestDummy.prototype._provideFromCache = function(path, listId, start, count, reverse) {
	tutao.util.Assert.assert(count >= 0, "count is negative");
    var listData = this._getListData(path, listId);
    var result = [];
    if (reverse) {
        for (var i = listData.length - 1; i >= 0; i--) {
            if (tutao.rest.EntityRestInterface.firstBiggerThanSecond(start, tutao.rest.EntityRestInterface.getElementId(listData[i]))) {
                var startIndex = i + 1 - count;
                if(startIndex < 0){
                    startIndex = 0;
                }
                result = listData.slice(startIndex, i + 1);
                result.reverse();
                break;
            }
        }
    } else {
        for (var i = 0; i < listData.length; i++) {
            if (tutao.rest.EntityRestInterface.firstBiggerThanSecond(tutao.rest.EntityRestInterface.getElementId(listData[i]), start)) {
                result = listData.slice(i, i + count);
                break;
            }
        }
    }
    return result;
};


tutao.rest.EntityRestDummy.prototype._getListData = function(path, listId){
    this._db[path] = this._db[path] || {};
    this._db[path][listId] = this._db[path][listId] || [];
    return this._db[path][listId];
};


/**
 * Returns the list id of the specified element if it is a LET otherwise "0" returns.
 * @param {Object} element The element
 * @returns {string} The list id
 */
tutao.rest.EntityRestDummy.getListId = function(element) {
    if (element.__id instanceof Array) {
        return element.__id[0];
    } else {
        return "0";
    }
};

"use strict";

tutao.provide('tutao.rest.EntityRestInterface');

/**
 * The EntityRestInterface provides a convenient interface for invoking server side REST services.
 * @interface
 */
tutao.rest.EntityRestInterface = function() {};

/**
 * the maximum ID for elements stored on the server (number with the length of 10 bytes) => 2^80 - 1
 * @const
 */
tutao.rest.EntityRestInterface.GENERATED_MAX_ID = "Uzzzzzzzzzzz";
/**
 * The minimum ID for elements with generated id stored on the server
 * @const
 */
tutao.rest.EntityRestInterface.GENERATED_MIN_ID = "------------";

/**
 * The minimum ID for elements with custom id stored on the server
 * @const
 */
tutao.rest.EntityRestInterface.CUSTOM_MIN_ID = "";


/**
 * Gets an element from the server.
 * @param {function(new:Object, Object)} type Type of the elements to load, i.e. the constructor.
 * @param {string} path The path including prefix, app name and type name.
 * @param {string} id The id of the element to get.
 * @param {?string} listId The list id of the element. May be null for ETs.
 * @param {?Object} parameters The parameters to send with this request.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @return {Promise.<Object>} Resolves to loaded element when finished, rejected if the rest call failed.
 */
tutao.rest.EntityRestInterface.prototype.getElement = function(type, path, id, listId, parameters, headers) { };

/**
 * Executes a get request to a service.
 * @param {Object} type Type of the data to load, i.e. the constructor.
 * @param {string} path The path including prefix, app name and type name.
 * @param {?Object} data The entity to send with the request (DataTransferType).
 * @param {?Object} parameters The parameters to send with this request.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @return {Promise.<Object>} Resolves to loaded element when finished, rejected if the rest call failed.
 */
tutao.rest.EntityRestInterface.prototype.getService = function(type, path, data, parameters, headers) { };

/**
 * Gets multiple elements from the server. If any of the elements are not found, they are not returned, but no
 * error is thrown.
 * @param {function(new:Object, Object)} type Type of the elements to load, i.e. the constructor.
 * @param {string} path The path including prefix, app name and type name.
 * @param {Array.<string>|Array.<Array.<string>>} ids The id of the elements to get.
 * @param {?Object} parameters The parameters to send with this request.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @return {Promise.<Array.<Object>>} Resolves to the list of elements when finished, rejected if the rest call failed.
 */
tutao.rest.EntityRestInterface.prototype.getElements = function(type, path, ids, parameters, headers) { };

/**
 * Stores a new element on the server.
 * @param {string} path The path including prefix, app name and type name.
 * @param {Object} element the object to store.
 * @param {?string} listId The id of the list that shall contain the element.
 * @param {?Object} parameters The parameters to send with this request.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @return {Promise.<tutao.entity.base.PersistenceResourcePostReturn>} Resolves to return entity from the server when finished, rejected if the rest call failed.
 */
tutao.rest.EntityRestInterface.prototype.postElement = function(path, element, listId, parameters, headers) { };

/**
 * Posts to a service. The difference to postElement is that the given element is not regarded as entity.
 * @param {string} path The path including prefix, app name and type name.
 * @param {Object} element the object to store.
 * @param {?Object} parameters The parameters to send with this request.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @param {?Object} returnType Type of the data that is returned.
 * @return {Promise.<Object>} Resolves to response entity from the server when finished, rejected if the rest call failed.
 */
tutao.rest.EntityRestInterface.prototype.postService = function(path, element, parameters, headers, returnType) { };

/**
 * Updates an element on the server.
 * @param {string} path The path including prefix, app name and type name.
 * @param {Object} element the object to store.
 * @param {?Object} parameters The parameters to send with this request.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @return {Promise.<>} Resolved when finished, rejected if the rest call failed.
 */
tutao.rest.EntityRestInterface.prototype.putElement = function(path, element, parameters, headers) { };

/**
 * TODO (timely) put service did not work: When accessing the inputstream on the server, a timeout occurs (no data can be read)
 * Puts to a service.
 * @param {string} path The path including prefix, app name and type name.
 * @param {Object} element the object to store.
 * @param {?Object} parameters The parameters to send with this request.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @param {?Object} returnType Type of the data that is returned.
 * @return {Promise.<Object>} Resolves to response entity from the server when finished, rejected if the rest call failed.
 */
tutao.rest.EntityRestInterface.prototype.putService = function(path, element, parameters, headers, returnType) { };

/**
 * Creates a new list on the server and provides its id.
 * @param {string} path The path including prefix, app name and type name.
 * @param {?Object} parameters The parameters to send with this request.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @return {Promise.<string>} Resolves to the id of the newly created list when finished, rejected if the rest call failed.
 */
tutao.rest.EntityRestInterface.prototype.postList = function(path, parameters, headers) { };

/**
 * Provides a list of elements.
 * @param {function(new:Object, Object)} type The type of the elements (constructor).
 * @param {string} path The path including prefix, app name and type name.
 * @param {string} listId The id of the list that contains the elements.
 * @param {string} start The id from where to start to get elements.
 * @param {number} count The maximum number of elements to load.
 * @param {boolean} reverse If true, the elements are loaded from the start backwards in the list, forwards otherwise.
 * @param {?Object} parameters The parameters to send with this request.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @return {Promise.<Array.<Object>>} Resolves to the the loaded elements when finished, rejected if the rest call failed.
 */
tutao.rest.EntityRestInterface.prototype.getElementRange = function(type, path, listId, start, count, reverse, parameters, headers) { };

/**
 * Deletes elements by id.
 * @param {string} path The path including prefix, app name and type name.
 * @param {string} id The id.
 * @param {?string} listId An optional list id. Use it to pass the list id of LETs.
 * @param {?Object} parameters The parameters to send with this request.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @return {Promise.<>} Resolved when finished, rejected if the rest call failed.
 */
tutao.rest.EntityRestInterface.prototype.deleteElement = function(path, id, listId, parameters, headers) { };

/**
 * Invokes delete on a service. Just like postService besides that the used HTTP method is DELETE
 * @param {string} path The path including prefix, app name and type name.
 * @param {Object} element the object to transmit.
 * @param {?Object} parameters The parameters to send with this request.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @param {?Object} returnType Type of the data that is returned.
 * @return {Promise.<Object>} Resolves to response entity from the server when finished, rejected if the rest call failed.
 */
tutao.rest.EntityRestInterface.prototype.deleteService = function(path, element, parameters, headers, returnType) { };

/**
 * Tests if one id is bigger than another.
 * @param {string} firstId The id that is tested if it is bigger.
 * @param {string} secondId The id that is tested against.
 * @return {boolean} True if firstId is bigger than secondId, false otherwise.
 */
tutao.rest.EntityRestInterface.firstBiggerThanSecond = function(firstId, secondId) {
	// if the number of digits is bigger, then the id is bigger, otherwise we can use the lexicographical comparison
	if (firstId.length > secondId.length) {
		return true;
	} else if (secondId.length > firstId.length) {
		return false;
	} else {
		return firstId > secondId;
	}
};

/**
 * Converts a string to a custom id. Attention: the custom id must be intended to be derived from a string.
 * @param {string} string The string.
 */
tutao.rest.EntityRestInterface.stringToCustomId = function(string) {
	return tutao.util.EncodingConverter.base64ToBase64Url(tutao.util.EncodingConverter.hexToBase64(tutao.util.EncodingConverter.utf8ToHex(string)));
};

/**
 * Converts a custom id to a string. Attention: the custom id must be intended to be derived from a string.
 * @param {string} customId The custom id.
 */
tutao.rest.EntityRestInterface.customIdToString = function(customId) {
	return tutao.util.EncodingConverter.hexToUtf8(tutao.util.EncodingConverter.base64ToHex(tutao.util.EncodingConverter.base64UrlToBase64(customId)));
};

/**
 * Returns the element id from the specified element
 * @param {object} element The element
 * @returns {string} The element id
 */
tutao.rest.EntityRestInterface.getElementId = function(element) {
    if (element.__id instanceof Array) {
        return element.__id[1];
    } else {
        return element.__id;
    }
};

/**
 * Loads all elements of the given list.
 * @param {Object} type The constructor of the type to load.
 * @param listId The list id.
 * @param {string=} startId The id to start from. if not set, min id is used
 * @returns {Promise.<Array.<Object>>} The loaded entities in forward order.
 */
tutao.rest.EntityRestInterface.loadAll = function(type, listId, startId) {
    var resultList = [];
    return tutao.rest.EntityRestInterface._loadAll(type, listId, (startId) ? startId : tutao.rest.EntityRestInterface.GENERATED_MIN_ID, resultList).then(function() {
        return resultList;
    });
};

tutao.rest.EntityRestInterface._loadAll = function(type, listId, startId, resultList) {
    var SINGLE_CALL_COUNT = 100;
    return type.loadRange(listId, startId, SINGLE_CALL_COUNT, false).then(function(elements) {
        tutao.util.ArrayUtils.addAll(resultList, elements);
        if (elements.length == SINGLE_CALL_COUNT) {
            return tutao.rest.EntityRestInterface._loadAll(type, listId, tutao.rest.EntityRestInterface.getElementId(elements[elements.length - 1]), resultList);
        } else {
            return Promise.resolve();
        }
    });
};

/**
 * Loads all elements of the given list in reverse order.
 * @param {Object} type The constructor of the type to load.
 * @param listId The list id.
 * @param {string=} startId The id to start from. if not set, min id is used
 * @returns {Promise.<Array.<Object>>} The loaded entities in reverse order.
 */
tutao.rest.EntityRestInterface.loadAllReverse = function(type, listId, startId) {
    var resultList = [];
    return tutao.rest.EntityRestInterface._loadAllReverse(type, listId, (startId) ? startId : tutao.rest.EntityRestInterface.GENERATED_MAX_ID, resultList).then(function() {
        return resultList;
    });
};

tutao.rest.EntityRestInterface._loadAllReverse = function(type, listId, startId, resultList) {
    var SINGLE_CALL_COUNT = 100;
    return type.loadRange(listId, startId, SINGLE_CALL_COUNT, true).then(function(elements) {
        tutao.util.ArrayUtils.prependAll(resultList, elements);
        if (elements.length == SINGLE_CALL_COUNT) {
            return tutao.rest.EntityRestInterface._loadAllReverse(type, listId, tutao.rest.EntityRestInterface.getElementId(elements[elements.length - 1]), resultList);
        } else {
            return Promise.resolve();
        }
    });
};
"use strict";

tutao.provide("tutao.rest.ResourceConstants");

/**
 * @const
 */
tutao.rest.ResourceConstants.META_SERVICE_BASE_URI = "meta";
/**
 * @const
 */
tutao.rest.ResourceConstants.DB_REST_BASE_URI = "rest";

/**
 * @const
 */
tutao.rest.ResourceConstants.SW_VERSION_PARAMETER = "v";

// any requests
/**
 * @const
 */
tutao.rest.ResourceConstants.USER_ID_PARAMETER_NAME = "userId";

/**
 * @const
 */
tutao.rest.ResourceConstants.AUTH_ID_PARAMETER_NAME = "authId";

/**
 * @const
 */
tutao.rest.ResourceConstants.AUTH_TOKEN_PARAMETER_NAME = "authToken";

/**
 * @const
 */
tutao.rest.ResourceConstants.AUTH_VERIFIER_PARAMETER_NAME = "authVerifier";

/**
 * @const
 */
tutao.rest.ResourceConstants.DEVICE_TOKEN_PARAMETER_NAME = "device";

// get requests
/**
 * get requests are not allowed to send a body. Therefore, we convert our body to a paramater
 * @const
 */
tutao.rest.ResourceConstants.GET_BODY_PARAM = "_body";
/**
 * @const
 */
tutao.rest.ResourceConstants.IDS_PARAMETER_NAME = "ids";
/**
 * @const
 */
tutao.rest.ResourceConstants.PARAMETER_LIST_SEPARATOR = ",";
/**
 * @const
 */
tutao.rest.ResourceConstants.START_ID_PARAMETER = "start";
/**
 * @const
 */
tutao.rest.ResourceConstants.ELEMENT_COUNT_PARAMETER = "count";
/**
 * @const
 */
tutao.rest.ResourceConstants.REVERSE_PARAMETER = "reverse";

/**
 * @const
 */
tutao.rest.ResourceConstants.PERMISSION_PARAMETER = "permission";

// post requests
/**
 * @const
 */
tutao.rest.ResourceConstants.GROUP_ID = "group";
/**
 * @const
 */
tutao.rest.ResourceConstants.SYM_ENC_SESSION_KEY = "symEncSessionKey";
/**
 * @const
 */
tutao.rest.ResourceConstants.SYM_ENC_LIST_KEY = "symEncListKey";
/**
 * @const
 */
tutao.rest.ResourceConstants.BUCKET_ENC_LIST_KEY = "bucketEncListKey";
/**
 * @const
 */
tutao.rest.ResourceConstants.BUCKET_ENC_SESSION_KEY = "bucketEncSessionKey";
/**
 * @const
 */
tutao.rest.ResourceConstants.LIST_ENC_SESSION_KEY = "listEncSessionKey";
/**
 * @const
 */
tutao.rest.ResourceConstants.BUCKET_PERMISSION_LIST_ID = "bucketList";
/**
 * @const
 */
tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY = "updateListEncSessionKey";

// public key service get request

/**
 * @const
 */
tutao.rest.ResourceConstants.CONTENT_TYPE_APPLICATION_JSON_CHARSET_UTF_8 = "application/json;charset=UTF-8";

/**
 * @const
 */
tutao.rest.ResourceConstants.ID_PARAMETER_NAME = "id";

/**
 * @const
 */
tutao.rest.ResourceConstants.VERSION_PARAMETER_NAME = "version";

"use strict";

tutao.provide('tutao.rest.RestClient');

/**
 * The RestClient class is a facade to jquery's ajax implementation. It provides operations
 * that are more appropriate for our server side.
 *
 * We do not provide any data types as jquery will infer them from the returned mime type (which should be set correctly by tutadb)
 * @constructor
 */
tutao.rest.RestClient = function() {
    this._errorFactory = new tutao.util.ErrorFactory();
    this.url = tutao.env.getHttpOrigin();
};

/**
 * Provides an element or multiple elements loaded from the server.
 * @param {string} path path of the element(s), includes element type name, optionally a list id, an id and optionally parameters.
 * E.g. "body/428347293847" or "mail/232410342431/203482034234".
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @param {?string} json The payload. 
 * @return {Promise.<Object>} Resolves to the data of the element(s), rejects if the rest call failed.
 */
tutao.rest.RestClient.prototype.getElement = function(path, headers, json) {
    var self = this;
    path = this.url + path;
    return new Promise(function(resolve, reject) {
        var contentType = (json) ? "application/x-www-form-urlencoded; charset=UTF-8" : null;
        json = json ? tutao.rest.ResourceConstants.GET_BODY_PARAM + "=" + encodeURIComponent(json) : "";
        // avoid caching (needed for IE) by setting cache: false
        jQuery.ajax({ type: "GET", url: path, contentType: contentType, data: json, processData: true, async: true, cache: false, headers: headers,
            success: function(data, textStatus, jqXHR) {
                resolve(data);
            },
            error: function(jqXHR, textStatus, errorThrown) {
                reject(self._errorFactory.handleRestError(jqXHR.status, textStatus));
            }
        });
    });
};

/**
 * Stores an element on the server.
 * @param {string} path path of the element, includes element type name.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @param {string} json The json data to store.
 * @return {Promise.<string>} Resolves to the response from the server as a string, rejects if the rest call failed.
 */
tutao.rest.RestClient.prototype.postElement = function(path, headers, json) {
    var self = this;
    path = this.url + path;
    return new Promise(function(resolve, reject) {
        jQuery.ajax({ type: "POST", url: path, contentType: tutao.rest.ResourceConstants.CONTENT_TYPE_APPLICATION_JSON_CHARSET_UTF_8, data: json, processData: false, async: true, headers: headers,
            success: function(data, textStatus, jqXHR) {
                resolve(data);
            },
            error: function(jqXHR, textStatus, errorThrown) {
                reject(self._errorFactory.handleRestError(jqXHR.status, textStatus));
            }
        });
    });
};

/**
 * Updates an element on the server.
 * @param {string} path path of the element, includes element type name, a list id (in case of LET) and an id.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * E.g. "body/428347293847" or "mail/232410342431/203482034234".
 * @param {string} json The json data to store.
 * @return {Promise.<string>} Provides an exception if the rest call failed
 */
tutao.rest.RestClient.prototype.putElement = function(path, headers, json) {
    var self = this;
    path = this.url + path;
    return new Promise(function(resolve, reject) {
        jQuery.ajax({ type: "PUT", url: path, contentType: tutao.rest.ResourceConstants.CONTENT_TYPE_APPLICATION_JSON_CHARSET_UTF_8, data: json, processData: false, async: true, headers: headers,
            success: function(data, textStatus, jqXHR) {
                resolve(data);
            },
            error: function(jqXHR, textStatus, errorThrown) {
                reject(self._errorFactory.handleRestError(jqXHR.status, textStatus));
            }
        });
    });
};

/**
 * Deletes one or more elements.
 * @param {string} path Path of the element(s);.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @param {string} json The payload.
 * @return {Promise.<string>} Resolves to the response from the server as a string, rejects if the rest call failed.
 */
tutao.rest.RestClient.prototype.deleteElement = function(path, headers, json) {
    var self = this;
    path = this.url + path;
    return new Promise(function(resolve, reject) {
        var contentType = (json) ? tutao.rest.ResourceConstants.CONTENT_TYPE_APPLICATION_JSON_CHARSET_UTF_8 : null;
        json = json ? json : "";
        jQuery.ajax({ type: "DELETE", url: path, contentType: contentType, data: json, processData: false, async: true, headers: headers,
            success: function(data, textStatus, jqXHR) {
                resolve(data);
            },
            error: function(jqXHR, textStatus, errorThrown) {
                reject(self._errorFactory.handleRestError(jqXHR.status, textStatus));
            }
        });
    });
};

/**
 * Uploads binary data.
 * @param {string} path Path of the service which receives the binary data.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @param {ArrayBuffer} data The binary data as ArrayBuffer.
 * @return {Promise.<>} Resolves after finished, rejects if the rest call failed.
 */
tutao.rest.RestClient.prototype.putBinary = function(path, headers, data) {
    var self = this;
    path = this.url + path;
    return new Promise(function(resolve, reject) {
        jQuery.ajax({ type: "PUT", url: path, contentType: 'application/octet-stream', data: data, processData: false, async: true, headers: headers,
            success: function(data, textStatus, jqXHR) {
                resolve(data);
            },
            error: function(jqXHR, textStatus, errorThrown) {
                reject(self._errorFactory.handleRestError(jqXHR.status, textStatus));
            }
        });
    });
};

/**
 * Downloads binary data.
 * @param {string} path Path of the service which provides the binary data.
 * @param {?Object.<string, string>} headers A map with header key/value pairs to send with the request.
 * @return {Promise.<(ArrayBuffer|String|null)>} Resolves to the binary data as ArrayBuffer or base64 coded string if the parameter base64=true is set. Rejects if the rest call failed.
 */
tutao.rest.RestClient.prototype.getBinary = function(path, headers) {
    var self = this;

    return new Promise(function(resolve, reject) {
        var xhr = new XMLHttpRequest();
        // use the same trick to avoid caching (actually only needed for IE) like jquery: append a unique timestamp
        xhr.open('GET', path + "&_=" + new Date().getTime(), true);
        xhr.responseType = 'arraybuffer';
        for (var i in headers) {
            xhr.setRequestHeader(i, headers[i]);
        }
        xhr.onreadystatechange = function(e) { // XMLHttpRequestProgressEvent, but not needed
            if (this.readyState == 4) { // DONE
                if (this.status == 200) {
                    resolve(this.response ? this.response : this.responseText); // LEGACY variant for IE 8/9 which uses responseBody for base64 string data
                } else {
                    reject(self._errorFactory.handleRestError(this.status, this.statusText));
                }
            }
        };
        xhr.send();
    });
};

"use strict";

tutao.provide('tutao.tutanota.security.CajaSanitizer');

/**
 * Uses the sanitizer of google-caja.
 * @interface
 */
tutao.tutanota.security.CajaSanitizer = function() {};

tutao.tutanota.security.CajaSanitizer.prototype._urlTransformer = function(url) {
	return url;
};

tutao.tutanota.security.CajaSanitizer.prototype._nameIdClassTransformer = function(s) {
	return s;
};

/**
 * @inherit
 */
tutao.tutanota.security.CajaSanitizer.prototype.sanitize = function(html) {
	try {
		var cleanHtml = html_sanitize(html, this._urlTransformer, this._nameIdClassTransformer);
		// set target="_blank" for all links
		var domHtml = $('<div>').append(cleanHtml);
		domHtml.find("a").attr("target", "_blank");
		return domHtml.html();
	} catch (e) {
		console.log("error in html: " + html, e);
		return "";
	}
};

"use strict";

tutao.provide('tutao.tutanota.security.HtmlSanitizer');

/**
 * This Interface provides an abstraction of a Html sanitizer.
 * A concrete instance is bound by the Locator.
 * @interface
 */
tutao.tutanota.security.HtmlSanitizer = function() {};

/**
 * Sanitizes the given html.
 * @param {string} html The html content to sanitize.
 * @return {string} The safe html.
 */
tutao.tutanota.security.HtmlSanitizer.prototype.sanitize = function(html) {};

"use strict";

tutao.provide('tutao.native.ContactApp');

/**
 * Functions to retrieve all contacts that are store on the phone
 * @interface
 */
tutao.native.ContactApp = function(){};

/**
 * Returns the contacts of this device.
 * @return {Promise.<Array.<mizz.entity.Contact>, Error>} Called with the phone number.
 */
tutao.native.ContactApp.prototype.getAllContacts = function() {
    return new Promise(function (resolve, reject) {
        var options      = new ContactFindOptions();
        options.filter   = "";
        options.multiple = true;
        var fields       = ["*"];

        navigator.contacts.find(fields, function(nativeContacts) {
            try {
                var contacts = [];
                for(var i=0;i < nativeContacts.length; i++) {
                    var nativeContact = nativeContacts[i];
                    var contact = new mizz.entity.Contact({
                        name: nativeContact.displayName,
                        phoneNumbers: nativeContact.phoneNumbers
                    });
                    if (contact.name) {
                        contacts.push(contact);
                    }
                }
                resolve(contacts.sort(function(a,b) {return a.name < b.name ? -1 : 1}));
            } catch(e) {
                reject(e);
            }
        }, reject, options);

    });
};
"use strict";

tutao.provide('tutao.native.ContactBrowser');

/**
 * Functions to retrieve all contacts that are store on the phone
 * @interface
 */
tutao.native.ContactBrowser = function(){};

/**
 * Returns the contacts of this device.
 * @return {Promise.<string, Error>} Called with the phone number.
 */
tutao.native.ContactBrowser.prototype.getAllContacts = function() {
    return new Promise(function (resolve, reject) {
        resolve([
            new mizz.entity.Contact(
                {name: "none",
                    statusMessage: "-",
                    phoneNumbers: [
                        {type: "work", value: "none", preferred: "true"},
                    ],
                    photos: []})
        ]);
    });
};
"use strict";

tutao.provide('tutao.native.ContactInterface');

/**
 * Functions to retrieve all contacts that are store on the phone
 * @interface
 */
tutao.native.ContactInterface = function(){};

/**
 * Returns the contacts of this device.
 * @return {Promise.<string, Error>} Called with the phone number.
 */
tutao.native.ContactInterface.prototype.getAllContacts = function() {};
"use strict";

tutao.provide('tutao.native.CryptoInterface');

/**
 * All cryptographic functions
 * @interface
 */
tutao.native.CryptoInterface = function(){};

/**
 * Returns the newly generated key
 * @param {number=} keyLength
 * @promise
 * @return {Promise.<tutao.native.KeyPair, Error>} will return the keypair.
 */
tutao.native.CryptoInterface.prototype.generateRsaKey = function(keyLength) {};

/**
 * Encrypt bytes with the provided publicKey
 * @param {tutao.native.PublicKey} publicKey
 * @param {Uint8Array} bytes
 * @return {Promise.<Uint8Array, Error>} will return the encrypted bytes.
 */
tutao.native.CryptoInterface.prototype.rsaEncrypt = function (publicKey, bytes) {};

/**
 * Decrypt bytes with the provided privateKey
 * @param {tutao.native.PrivateKey} privateKey
 * @param {Uint8Array} bytes
 * @return {Promise.<Uint8Array, Error>} will return the decrypted bytes.
 */
tutao.native.CryptoInterface.prototype.rsaDecrypt = function (privateKey, bytes) {};
"use strict";

tutao.provide('tutao.native.CryptoJsbn');

/**
 * @implements {tutao.native.CryptoInterface}
 * @constructor
 */
tutao.native.CryptoJsbn = function () {
    this.defaultKeyLengthInBits = 2048;
    this.publicExponent = 65537;
    this.worker = operative({
        generateRsaKey: function (keyLengthInBits, publicExponent, random, callback) {
            SecureRandom.setNextRandomBytes(random);
            try {
                var rsa = new RSAKey();
                rsa.generate(keyLengthInBits, publicExponent.toString(16)); // must be hex for JSBN
                // @type {tutao.native.KeyPair}
                var result = {
                    publicKey: {
                        version: 0,
                        keyLength: keyLengthInBits,
                        modulus: tutao.util.EncodingConverter.arrayBufferToBase64(new Uint8Array(rsa.n.toByteArray())),
                        publicExponent: publicExponent
                    },
                    privateKey: {
                        version: 0,
                        keyLength: keyLengthInBits,
                        privateExponent: tutao.util.EncodingConverter.arrayBufferToBase64(new Uint8Array(rsa.d.toByteArray())),
                        primeP: tutao.util.EncodingConverter.arrayBufferToBase64(new Uint8Array(rsa.p.toByteArray())),
                        primeQ: tutao.util.EncodingConverter.arrayBufferToBase64(new Uint8Array(rsa.q.toByteArray())),
                        primeExponentP: tutao.util.EncodingConverter.arrayBufferToBase64(new Uint8Array(rsa.dmp1.toByteArray())),
                        primeExponentQ: tutao.util.EncodingConverter.arrayBufferToBase64(new Uint8Array(rsa.dmq1.toByteArray())),
                        crtCoefficient: tutao.util.EncodingConverter.arrayBufferToBase64(new Uint8Array(rsa.coeff.toByteArray()))
                    }
                };
                callback({ type: 'result', result: result});
            } catch (e) {
                callback({ type: 'error', msg: e.stack });
            }
        },
        rsaEncrypt: function (publicKey, bytes, randomBytes, callback) {
            try {
                var rsa = new RSAKey();
                rsa.n = new BigInteger(new Int8Array(this.base64ToArray(publicKey.modulus))); // BigInteger of JSBN uses a signed byte array and we convert to it by using Int8Array
                rsa.e = publicKey.publicExponent;
                var paddedBytes = new tutao.crypto.Oaep().pad(bytes, publicKey.keyLength, randomBytes);
                var paddedHex = this._bytesToHex(paddedBytes);

                var bigInt = parseBigInt(paddedHex, 16);
                var encrypted = rsa.doPublic(bigInt);

                var encryptedHex = encrypted.toString(16);
                if ((encryptedHex.length % 2) == 1) {
                    encryptedHex = "0" + encryptedHex;
                }

                callback({ type: 'result', result: new Uint8Array(this._hexToBytes(encryptedHex))});
            } catch (e) {
                callback({ type: 'error', msg: e.stack });
            }
        },
        rsaDecrypt: function (privateKey, bytes, callback) {
            try {
                var rsa = new RSAKey();
                // BigInteger of JSBN uses a signed byte array and we convert to it by using Int8Array
                rsa.d = new BigInteger(new Int8Array(this.base64ToArray(privateKey.privateExponent)));
                rsa.p = new BigInteger(new Int8Array(this.base64ToArray(privateKey.primeP)));
                rsa.q = new BigInteger(new Int8Array(this.base64ToArray(privateKey.primeQ)));
                rsa.dmp1 = new BigInteger(new Int8Array(this.base64ToArray(privateKey.primeExponentP)));
                rsa.dmq1 = new BigInteger(new Int8Array(this.base64ToArray(privateKey.primeExponentQ)));
                rsa.coeff = new BigInteger(new Int8Array(this.base64ToArray(privateKey.crtCoefficient)));

                var hex = this._bytesToHex(bytes);
                var bigInt = parseBigInt(hex, 16);;
                var paddedBigInt = rsa.doPrivate(bigInt);
                var decryptedHex = paddedBigInt.toString(16);
                // fill the hex string to have a padded block of exactly (keylength / 8 - 1 bytes) for the unpad function
                // two possible reasons for smaller string:
                // - one "0" of the byte might be missing because toString(16) does not consider this
                // - the bigint value might be smaller than (keylength / 8 - 1) bytes
                var expectedPaddedHexLength = (privateKey.keyLength / 8 - 1) * 2;
                var fill = Array(expectedPaddedHexLength - decryptedHex.length + 1).join("0"); // creates the missing zeros
                decryptedHex = fill + decryptedHex;
                var paddedBytes = this._hexToBytes(decryptedHex);
                var bytes = new tutao.crypto.Oaep().unpad(paddedBytes, privateKey.keyLength);
                callback({ type: 'result', result: new Uint8Array(bytes)});
            } catch (e) {
                callback({ type: 'error', msg: e.stack});
            }
        },
        base64ToArray: function(base64) {
            return tutao.util.EncodingConverter.base64ToArray(base64);
        },
        _hexToBytes: function (hex) {
            return tutao.util.EncodingConverter.hexToBytes(hex);
        },
        _bytesToHex: function (bytes) {
            return tutao.util.EncodingConverter.bytesToHex(bytes);
        }
    }, tutao.native.CryptoJsbn.DEPENDENCIES);
};

tutao.native.CryptoJsbn.initWorkerFileNames = function(basePath) {
    var libsPath = basePath + "lib/worker/";
    var srcPath = basePath + "js/";
    if (tutao.env.type === tutao.Env.LOCAL) {
        tutao.native.CryptoJsbn.DEPENDENCIES = [
                libsPath + 'base.js',
                libsPath + 'base64shim.js',
                libsPath + 'crypto-jsbn-2012-08-09_1.js',
                libsPath + 'crypto-sjcl-2012-08-09_1.js',
                srcPath + 'crypto/SecureRandom.js',
                srcPath + 'crypto/Oaep.js',
                srcPath + 'util/EncodingConverter.js'
        ];
    } else {
        tutao.native.CryptoJsbn.DEPENDENCIES = ['app.min.js'];
    }
};

tutao.native.CryptoJsbn.prototype.generateRsaKey = function (keyLength) {
    var self = this;
    keyLength = typeof keyLength !== 'undefined' ? keyLength : this.defaultKeyLengthInBits; // optional param
    var random = this._random(512);
    return new Promise(function (resolve, reject) {
        self.worker.generateRsaKey(keyLength, self.publicExponent, random, self._createReturnHandler(resolve, reject));
    });
};

tutao.native.CryptoJsbn.prototype.rsaEncrypt = function (publicKey, bytes) {
    var self = this;
    var random = this._random(32);
    return new Promise(function (resolve, reject) {
        self.worker.rsaEncrypt(publicKey, bytes, random, self._createReturnHandler(resolve, reject));
    });
};

tutao.native.CryptoJsbn.prototype.rsaDecrypt = function (privateKey, bytes) {
    var self = this;
    return new Promise(function (resolve, reject) {
        self.worker.rsaDecrypt(privateKey, bytes, self._createReturnHandler(resolve, reject));
    });
};

tutao.native.CryptoJsbn.prototype._unsign = function (signedArray) {
    var unsignedArray = [];
    for (var i = 0; i < signedArray.length; i++) {
        unsignedArray.push(signedArray[i] & 0xff);
    }
    return unsignedArray;
};

tutao.native.CryptoJsbn.prototype._random = function (byteLength) {
    // TODO retrieve bytes directly
    return tutao.util.EncodingConverter.hexToBytes(tutao.locator.randomizer.generateRandomData(byteLength));
};

tutao.native.CryptoJsbn.prototype._createReturnHandler = function (resolve, reject) {
    return function (data) {
        if (data.type != 'result') {
            reject(data.msg);
        } else {
            resolve(data.result);
        }
    }
};
"use strict";

tutao.provide('tutao.native.FileTransferApp');

/**
 * @constructor
 * @implements {tutao.native.FileTransferInterface}
 */
tutao.native.FileTransferApp = function(){
    this.fileUtil = new tutao.native.device.FileUtil();
};

tutao.native.FileTransferApp.prototype.downloadAndOpen = function(url) {
    var self = this;
    var filename = url.split('/')[url.split('/').length - 1];
    return new Promise(function (resolve, reject) {


        var fileTransfer = new FileTransfer();
        var uri = encodeURI(url);
        var fileURL = cordova.file.dataDirectory + "temp/" + filename;

        fileTransfer.download(
            uri,
            fileURL,
            function(entry) {
                self.fileUtil.open(entry.toURL()).then(function() {
                    resolve();
                });
            },
            function(error) {
                console.log("download error source " + error.source);
                console.log("download error target " + error.target);
                console.log("upload error code" + error.code);
                reject(new Error("Source: " + error.source + "\n " + "Target: " + error.target + "\n " + "Code: " + error.code));
            },
            false,
            {
                headers: {
                    "Authorization": "Basic dGVzdHVzZXJuYW1lOnRlc3RwYXNzd29yZA=="
                }
            }
        );
    });
};
"use strict";

tutao.provide('tutao.native.FileTransferBrowser');

/**
 * @constructor
 * @implements {tutao.native.FileTransferInterface}
 */
tutao.native.FileTransferBrowser = function(){};

tutao.native.FileTransferBrowser.prototype.downloadAndOpen = function(url) {
    return new Promise(function (resolve, reject) {
        var filename = url.split('/')[url.split('/').length - 1];
        var xhr = new XMLHttpRequest();
        // use the same trick to avoid caching (actually only needed for IE) like jquery: append a unique timestamp
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onreadystatechange = function(e) { // XMLHttpRequestProgressEvent, but not needed
            if (this.readyState == 4) { // DONE
                if (this.status == 200) {
                    var blob = new Blob([this.response]); //, { "type" : "image/jpeg" });
                    saveAs(blob, filename);
                    resolve();
                } else {
                    reject(this.status);
                }
            }
        };
        xhr.send();
    });
};
"use strict";

tutao.provide('tutao.native.FileTransferInterface');

/**
 * Functions to transfer files in both directions
 * @interface
 */
tutao.native.FileTransferInterface = function(){};

/**
 * Downloads and opens a file
 * @return {Promise.<undefined, Error>}.
 */
tutao.native.FileTransferInterface.prototype.downloadAndOpen = function(url) {};
"use strict";

tutao.provide('tutao.native.KeyPair');

/**
 * @param {tutao.native.KeyPair} keyPair
 * @constructor
 */
tutao.native.KeyPair = function (keyPair) {
    // @type {tutao.native.PublicKey}
    this.publicKey = keyPair.publicKey;
    // @type {tutao.native.PrivateKey}
    this.privateKey = keyPair.privateKey;
};

"use strict";

tutao.provide('tutao.native.NotificationApp');

/**
 * @implements {tutao.native.NotificationInterface}
 */
tutao.native.NotificationApp = function(){
    this.currentId = 0;
};

tutao.native.NotificationApp.prototype.add = function(title, message, badge) {
    window.plugin.notification.local.add({id: this.currentId++, title: title, message: message, badge: badge, autoCancel: true});
};

tutao.native.NotificationApp.prototype.updateBadge = function(number) {
    cordova.plugins.notification.badge.set(number);
};
"use strict";

tutao.provide('tutao.native.NotificationBrowser');

/**
 * @implements {tutao.native.NotificationInterface}
 */
tutao.native.NotificationBrowser = function(){};

tutao.native.NotificationBrowser.prototype.add = function(title, message) {
    var self = this;
    return new Promise(function (resolve, reject) {
        if ("Notification" in window) {
            if (Notification.permission !== 'denied' && Notification.permission !== 'granted') {
                Notification.requestPermission(function (permission) {
                    // Whatever the user answers, we make sure we store the information
                    if (!('permission' in Notification)) {
                        Notification.permission = permission;
                    }
                    self._showIfGranted(title, message, resolve);
                });
            } else {
                self._showIfGranted(title, message, resolve);
            }
        }
    });
};

tutao.native.NotificationBrowser.prototype.updateBadge = function(number) {
    // no badge available
};

tutao.native.NotificationBrowser.prototype._showIfGranted = function(title, message, resolve) {
    if (Notification.permission === "granted") {
        var notification = new Notification(title, {body: message, icon: 'images/apple-touch-icon-114x114-precomposed.png'});
        notification.onshow = function () {
            setTimeout(function() { notification.close(); }, 5000);
        };
        notification.onclick = function () {
            notification.close();
            resolve();
        };
    }
};


"use strict";

tutao.provide('tutao.native.NotificationInterface');

/**
 * All notification functions
 * @interface
 */
tutao.native.NotificationInterface = function(){};

/**
 * Creates a new notification for the user
 * @param {string} title
 * @param {string} message
 * @param {number} badge
 * @return {Promise.<string, Error>} A result is passed, when the user has clicked on the message.
 */
tutao.native.NotificationInterface.prototype.add = function(title, message, badge) {};

/**
 * Updates the bade number on the app icon (only for ios and windows phone).
 * @param {number} number
 */
tutao.native.NotificationInterface.prototype.updateBadge = function(number) {};
"use strict";

tutao.provide('tutao.native.Phone');

/**
 * @implements {tutao.native.PhoneInterface}
 * @constructor
 */
tutao.native.Phone = function(){};

/**
 * Returns the phone number of this device, if available.
 * @return {Promise.<string, Error>} callback Called with the phone number.
 */
tutao.native.Phone.prototype.getNumber = function() {
    return new Promise(function (resolve, reject) {
        resolve("none");
    });
};
"use strict";

tutao.provide('tutao.native.PhoneInterface');

/**
 * All phone functions
 * @interface
 */
tutao.native.PhoneInterface = function(){};

/**
 * Returns the phone number of this device, if available.
 * @return {Promise.<string, Error>} callback Called with the phone number.
 */
tutao.native.PhoneInterface.prototype.getNumber = function() {};
"use strict";

tutao.provide('tutao.native.PrivateKey');

/**
 * @param {tutao.native.PrivateKey} key
 * @constructor
 */
tutao.native.PrivateKey = function (key) {
    // @type {number}
    this.version = key.version;

    // @type {number} In Bits
    this.keyLength = key.keyLength;
    // @type {string} Base64 encoded
    this.privateExponent = key.privateExponent;
    // @type {string} Base64 encoded
    this.primeP = key.primeP;
    // @type {string} Base64 encoded
    this.primeQ = key.primeQ;
    // @type {string} Base64 encoded
    this.primeExponentP = key.primeExponentP;
    // @type {string} Base64 encoded
    this.primeExponentQ = key.primeExponentQ;
    // @type {string} Base64 encoded
    this.crtCoefficient = key.crtCoefficient;
};


"use strict";

tutao.provide('tutao.native.PublicKey');

/**
 * @param {tutao.native.PublicKey} key
 * @constructor
 */
tutao.native.PublicKey = function (key) {
    // @type {number}
    this.version = key.version;
    // @type {number} In Bits
    this.keyLength = key.keyLength;
    // @type {string} base64 encoded
    this.modulus = key.modulus;
    // @type {number}
    this.publicExponent = key.publicExponent;
};

"use strict";

tutao.provide('tutao.native.RsaInterfaceAdapter');

/**
 * @constructor
 * @implements {tutao.crypto.RsaInterface}
 */
tutao.native.RsaInterfaceAdapter = function () {
    this.keyLengthInBits = 2048;
};

/**
 * @inheritDoc
 */
tutao.native.RsaInterfaceAdapter.prototype.generateKeyPair = function (callback) {
    var self = this;
    tutao.locator.crypto.generateRsaKey(this.keyLengthInBits).then(function (/*tutao.native.KeyPair*/keypair) {
        callback(self._convertFromKeyPair(keypair))
    });
};

/**
 * @param {tutao.native.KeyPair} keypair
 * @return {object}
 * @private
 */
tutao.native.RsaInterfaceAdapter.prototype._convertFromKeyPair = function (keypair) {
    return {
        publicKey: [this._base64ToBigInt(keypair.publicKey.modulus)],
        privateKey: [
            this._base64ToBigInt(keypair.publicKey.modulus),
            this._base64ToBigInt(keypair.privateKey.privateExponent),
            this._base64ToBigInt(keypair.privateKey.primeP),
            this._base64ToBigInt(keypair.privateKey.primeQ),
            this._base64ToBigInt(keypair.privateKey.primeExponentP),
            this._base64ToBigInt(keypair.privateKey.primeExponentQ),
            this._base64ToBigInt(keypair.privateKey.crtCoefficient)
        ]};
};

/**
 * @param {object}
 * @return {tutao.native.KeyPair}
 * @private
 */
tutao.native.RsaInterfaceAdapter.prototype._convertToKeyPair = function (object) {
    return {
        publicKey: this._convertToPublicKey(object.publicKey),
        privateKey: this._convertToPrivateKey(object.privateKey)
    };
};

tutao.native.RsaInterfaceAdapter.prototype._convertToPublicKey = function (privateKey) {
    var self = this;
    return {
        version: 0,
        keyLength: self.keyLengthInBits,
        modulus: tutao.util.EncodingConverter.arrayBufferToBase64(new Uint8Array(privateKey[0].toByteArray())),
        publicExponent: tutao.locator.crypto.publicExponent
    };
};

tutao.native.RsaInterfaceAdapter.prototype._convertToPrivateKey = function (privateKey) {
    var self = this;
    return {
        version: 0,
        keyLength: self.keyLengthInBits,
        privateExponent: tutao.util.EncodingConverter.arrayBufferToBase64(new Uint8Array(privateKey[1].toByteArray())),
        primeP: tutao.util.EncodingConverter.arrayBufferToBase64(new Uint8Array(privateKey[2].toByteArray())),
        primeQ: tutao.util.EncodingConverter.arrayBufferToBase64(new Uint8Array(privateKey[3].toByteArray())),
        primeExponentP: tutao.util.EncodingConverter.arrayBufferToBase64(new Uint8Array(privateKey[4].toByteArray())),
        primeExponentQ: tutao.util.EncodingConverter.arrayBufferToBase64(new Uint8Array(privateKey[5].toByteArray())),
        crtCoefficient: tutao.util.EncodingConverter.arrayBufferToBase64(new Uint8Array(privateKey[6].toByteArray()))
    };
};

tutao.native.RsaInterfaceAdapter.prototype._base64ToBigInt = function (base64) {
    return new BigInteger(new Int8Array(tutao.util.EncodingConverter.base64ToArray(base64)));
};

/**
 * Provides the length of the given string as hex string of 4 characters length. Padding to 4 characters is done with '0'.
 * @param {string} string A string to get the length of.
 * @return {string} A hex string containing the length of string.
 */
tutao.native.RsaInterfaceAdapter.prototype._hexLen = function (string) {
    var hexLen = string.length.toString(16);
    while (hexLen.length < 4) {
        hexLen = "0" + hexLen;
    }
    return hexLen;
};

/**
 * @inheritDoc
 */
tutao.native.RsaInterfaceAdapter.prototype.keyToHex = function (key) {
    var hex = "";
    for (var i = 0; i < key.length; i++) {
        var param = key[i].toString(16);
        if ((param.length % 2) == 1) {
            param = "0" + param;
        }
        hex += this._hexLen(param) + param;
    }
    return hex;
};

/**
 * @inheritDoc
 */
tutao.native.RsaInterfaceAdapter.prototype.hexToKey = function (hex) {
    try {
        var key = [];
        var pos = 0;
        while (pos < hex.length) {
            var nextParamLen = parseInt(hex.substring(pos, pos + 4), 16);
            pos += 4;
            key.push(parseBigInt(hex.substring(pos, pos + nextParamLen), 16));
            pos += nextParamLen;
        }
        this._validateKeyLength(key);
        return key;
    } catch (e) {
        throw new tutao.crypto.CryptoError("hex to rsa key failed", e);
    }
};

/**
 * @param {Array} key
 * @private
 */
tutao.native.RsaInterfaceAdapter.prototype._validateKeyLength = function (key) {
    if (key.length != 1 && key.length != 7) {
        throw new Error("invalid key params");
    }
    if (key[0].bitLength() < this.keyLengthInBits - 1 || key[0].bitLength() > this.keyLengthInBits) {
        throw new Error("invalid key length, expected: around " + this.keyLengthInBits + ", but was: " + key[0].bitLength());
    }
};

/**
 * @inheritDoc
 */
tutao.native.RsaInterfaceAdapter.prototype.encryptAesKey = function (publicKey, hex, callback) {
    try {
        var bytes = tutao.util.EncodingConverter.hexToBytes(hex);
        tutao.locator.crypto.rsaEncrypt(this._convertToPublicKey(publicKey), bytes).then(function (/*Uint8Array*/bytes) {
            callback(tutao.util.EncodingConverter.arrayBufferToBase64(bytes));
        }).caught(function (e) {
            callback(null, new tutao.crypto.CryptoError("rsa encryption failed", e));
        });
    } catch (e) {
        callback(null, new tutao.crypto.CryptoError("rsa encryption failed", e));
    }
};

/**
 * @inheritDoc
 */
tutao.native.RsaInterfaceAdapter.prototype.decryptAesKey = function (privateKey, base64, callback) {
    try {
        var bytes = tutao.util.EncodingConverter.base64ToArray(base64);
        tutao.locator.crypto.rsaDecrypt(this._convertToPrivateKey(privateKey), bytes).then(function (/*Uint8Array*/bytes) {
            callback(tutao.util.EncodingConverter.bytesToHex(bytes));
        }).caught(function (e) {
            callback(null, new tutao.crypto.CryptoError("rsa decryption failed", e));
        });
    } catch (e) {
        callback(null, new tutao.crypto.CryptoError("rsa decryption failed", e));
    }
};
"use strict";

tutao.provide('tutao.util.ArrayUtils');

/**
 * Provides an array containing all elements that are in all of the provided arrays. duplicates and empty elements are removed.
 * @param {Array.<Array>} arrays The arrays that shall be combined.
 * @return {Array} The combined array.
 */
tutao.util.ArrayUtils.getUniqueAndArray = function(arrays) {
	if (arrays.length == 0) {
		return [];
	}

	var targetObject = [];
	var currentObject = tutao.util.ArrayUtils._arrayToObject(arrays[0]);
	for (var a = 1; a < arrays.length; a++) {
		var array = arrays[a];
		for (var i = 0; i < array.length; i++) {
			if (array[i] != "" && currentObject[array[i]]) {
				targetObject[array[i]] = array[i];
			}
		}
		currentObject = targetObject;
		targetObject = {};
	}
	return tutao.util.ArrayUtils._objectToArray(currentObject);
};

/**
 * Provides an array containing all elements that are in any of the provided arrays. duplicates and empty elements are removed.
 * @param {Array.<Array>} arrays The arrays that shall be combined.
 * @return {Array} The combined array.
 */
tutao.util.ArrayUtils.getUniqueOrArray = function(arrays) {
	var object = {};

    for (var a = 0; a < arrays.length; a++) {
    	var array = arrays[a];
	    for (var i = 0; i < array.length; i++) {
	    	if (array[i] != "") {
	    		object[array[i]] = array[i];
	    	}
	    }
    }
    return tutao.util.ArrayUtils._objectToArray(object);
};

/**
 * Provides an array containing all unique elements from the given array.
 * @param {Array} array The array.
 * @return {Array} An array with unique elements from array.
 */
tutao.util.ArrayUtils.getUniqueArray = function(array) {
	return tutao.util.ArrayUtils._objectToArray(tutao.util.ArrayUtils._arrayToObject(array));
};

/**
 * Provides an object containing all elements from the given array mapping to the element itself. Empty elements are discarded.
 * @param {Array} array The array.
 * @return {Object} The object.
 */
tutao.util.ArrayUtils._arrayToObject = function(array) {
	var object = {};
	for (var i = 0; i < array.length; i++) {
    	if (array[i] != "") {
    		object[array[i]] = array[i];
    	}
    }
	return object;
};

/**
 * Provides an array containing all values from the given object.
 * @param {Object} object The object.
 * @return {Array} array The array.
 */
tutao.util.ArrayUtils._objectToArray = function(object) {
	var array = [];
	for (var element in object) {
		array.push(object[element]);
    }
	return array;
};

/**
 * Remove the element from theArray if it is contained in the array.
 * @param {Array} theArray The array to remove the element from.
 * @param {*} elementToRemove The element to remove from the array.
 */
tutao.util.ArrayUtils.remove = function(theArray, elementToRemove) {
    var i = theArray.indexOf(elementToRemove);
    if (i != -1) {
        theArray.splice(i, 1);
    }
};

/**
 * Provides the last element of the given array.
 * @param {Array} theArray The array.
 * @return {*} The last element of the array.
 */
tutao.util.ArrayUtils.last = function(theArray) {
    return theArray[theArray.length - 1];
};

/**
 * Compares two arrays on equality.
 * @param {Array} a1 The first array.
 * @param {Array} a2 The second array.
 * @return {boolean} True if the arrays are equal, false otherwise.
 */
tutao.util.ArrayUtils.arrayEquals = function(a1, a2) {
	if (a1.length === a2.length) {
		for (var i = 0; i < a1.length; i++) {
			if (a1[i] !== a2[i]) {
				return false;
			}
		}
		return true;
	}
	return false;
};

/**
 * Checks if an array contains a given value.
 * @param {Array} array The array to test.
 * @param {*} value The value that is checked to be contained in the array.
 * @return {boolean} True if the array contains the value, false otherwise.
 */
tutao.util.ArrayUtils.contains = function(array, value) {
	return array.indexOf(value) != -1;
};

/**
 * Adds all elements from an array to another array.
 * @param {Array} array The array to add elements to.
 * @param {Array} elements The array with the elements to be added.
 */
tutao.util.ArrayUtils.addAll = function(array, elements) {
    array.push.apply(array, elements);
};

/**
 * Adds all elements from an array to the beginning of another array.
 * @param {Array} array The array to prepend elements to.
 * @param {Array} elements The array with the elements to be prepended.
 */
tutao.util.ArrayUtils.prependAll = function(array, elements) {
    array.splice.apply(array, [0, 0].concat(elements));
};

"use strict";

tutao.provide('tutao.util.Assert');

/**
 * Throws an exception if the given object is null or undefined;
 * @param {?*} object The object that is tested to be not null and not undefined.
 * @param {string=} text An optional text that is thrown if the assertion fails.
 */
tutao.util.Assert.assertObject = function(object, text) {
	if (object === null) {
//		undefined['assertionFailedBecauseObjectIsNull'] = 0;
		throw new Error((text) ? text : "object is null");
	}
	if (object === undefined) {
//		undefined['assertionFailedBecauseObjectIsUndefined'] = 0;
		throw new Error((text) ? text : "object is undefined");
	}
};

/**
 * Throws an exception if the given object is not undefined;
 * @param {?*} object The object that is tested to be undefined.
 * @param {string=} text An optional text that is thrown if the assertion fails.
 */
tutao.util.Assert.assertUndefined = function(object, text) {
	if (object !== undefined) {
//		undefined['assertionFailedBecauseObjectIsNotUndefined'] = 0;
		throw new Error((text) ? text : "object is not undefined");
	}
};

/**
 * Throws an exception if the expression does not evaluate to true.
 * @param {boolean} exp The expression that is tested to be true.
 * @param {string=} text An optional text that is thrown if the assertion fails.
 */
tutao.util.Assert.assert = function(exp, text) {
	if (!exp) {
		throw new Error((text) ? text : "Assertion failed");
	}
};

/**
 * Throws an exception.
 * @param {string=} text An optional text that is thrown if the assertion fails.
 */
tutao.util.Assert.fail = function(text) {
//	undefined['assertionFailed'] = 0;
	throw new Error((text) ? text : "assertion fail");
};

"use strict";

tutao.provide('tutao.tutanota.util.ClientDetector');

/** Chrome browser */
tutao.tutanota.util.ClientDetector.BROWSER_TYPE_CHROME = "Chrome";
/** Firefox browser */
tutao.tutanota.util.ClientDetector.BROWSER_TYPE_FIREFOX = "Firefox";
/** IE browser */
tutao.tutanota.util.ClientDetector.BROWSER_TYPE_IE = "Internet Explorer";
/** Safari browser */
tutao.tutanota.util.ClientDetector.BROWSER_TYPE_SAFARI = "Safari";
/** Android browser */
tutao.tutanota.util.ClientDetector.BROWSER_TYPE_ANDROID = "Android";
/** Opera browser */
tutao.tutanota.util.ClientDetector.BROWSER_TYPE_OPERA = "Opera";
/** other browser */
tutao.tutanota.util.ClientDetector.BROWSER_TYPE_OTHER = "Other";

/** Unix/Linux OS */
tutao.tutanota.util.ClientDetector.OS_TYPE_LINUX = "Linux";
/** Mac/iOS OS */
tutao.tutanota.util.ClientDetector.OS_TYPE_MAC = "Mac";
/** Windows OS */
tutao.tutanota.util.ClientDetector.OS_TYPE_WINDOWS = "Windows";
/** other OS */
tutao.tutanota.util.ClientDetector.OS_TYPE_OTHER = "Other";


/** iPhone device */
tutao.tutanota.util.ClientDetector.DEVICE_TYPE_IPHONE = "iPhone";
/** iPad device */
tutao.tutanota.util.ClientDetector.DEVICE_TYPE_IPAD = "iPad";
/** Android device */
tutao.tutanota.util.ClientDetector.DEVICE_TYPE_ANDROID = "Android";
/** Windows phone */
tutao.tutanota.util.ClientDetector.DEVICE_TYPE_WINDOWS_PHONE = "Windows Phone";
/** other device */
tutao.tutanota.util.ClientDetector.DEVICE_TYPE_DESKTOP = "Desktop";



/** browser is supported */
tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_SUPPORTED = "supported";
/** browser is supported in legacy mode for IE8 and IE9 with flash plugin (view mails es external recipient). Replying to emails is not supported. */
tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_IE = "legacy ie";
/** browser does not support attaching files and downloading attachments */
tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_IE_MOBILE = "legacy ie mobile";
/** browser is supported in legacy mode for Safari (view mails es external recipient). Downloading attachments is not fully supported. */
tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_SAFARI = "legacy safari";
/** browser is supported in legacy mode for Android 4.0 - 4.3. Replying to emails is not supported. */
tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_ANDROID = "legacy android";
/** browser is not supported */
tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_NOT_SUPPORTED = "not supported";
/** browser is generally supported, but must be updated to fit supported version */
tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_UPDATE_NEEDED = "update needed";

/** german language */
tutao.tutanota.util.ClientDetector.LANGUAGE_DE = "de";
/** english language */
tutao.tutanota.util.ClientDetector.LANGUAGE_EN = "en";

/**
 * Information about the client.
 * For a list of used agent strings, see: http://www.useragentstring.com/pages/Browserlist/
 */
/**
 * @type {?string}
 * @private
 */
tutao.tutanota.util.ClientDetector._browser = null;
/**
 * @type {?number}
 * @private
 */
tutao.tutanota.util.ClientDetector._browserVersion = null;
/**
 * @type {?string}
 * @private
 */
tutao.tutanota.util.ClientDetector._os = null;
/**
 * @type {?string}
 * @private
 */
tutao.tutanota.util.ClientDetector._device = null;
/**
 * @type {?boolean}
 * @private
 */
tutao.tutanota.util.ClientDetector._phone = null;
/**
 * @type {?string}
 * @private
 */
tutao.tutanota.util.ClientDetector._supported = null;
/**
 * @type {?string}
 * @private
 */
tutao.tutanota.util.ClientDetector._lang = null;

/**
 * Provides the browser type.
 * @return {string} The type of browser. One of BROWSER_TYPES.
 */
tutao.tutanota.util.ClientDetector.getBrowserType = function() {
	if (tutao.tutanota.util.ClientDetector._browser == null) {
		tutao.tutanota.util.ClientDetector._setClientInfo(navigator.userAgent);
	}
	return tutao.tutanota.util.ClientDetector._browser;
};

/**
 * Provides the browser main version.
 * @return {number} The version of the browser. 0 if unknown.
 */
tutao.tutanota.util.ClientDetector.getBrowserVersion = function() {
	if (tutao.tutanota.util.ClientDetector._browser == null) {
		tutao.tutanota.util.ClientDetector._setClientInfo(navigator.userAgent);
	}
	return tutao.tutanota.util.ClientDetector._browserVersion;
};

/**
 * Provides the operating system.
 * @return {string} The operating system. One of OS_TYPES.
 */
tutao.tutanota.util.ClientDetector.getOs = function() {
	if (tutao.tutanota.util.ClientDetector._browser == null) {
		tutao.tutanota.util.ClientDetector._setClientInfo(navigator.userAgent);
	}
	return tutao.tutanota.util.ClientDetector._os;
};

/**
 * Provides the device type.
 * @return {string} The operating system. One of DEVICE_TYPES.
 */
tutao.tutanota.util.ClientDetector.getDeviceType = function() {
	if (tutao.tutanota.util.ClientDetector._browser == null) {
		tutao.tutanota.util.ClientDetector._setClientInfo(navigator.userAgent);
	}
	return tutao.tutanota.util.ClientDetector._device;
};

/**
 * Provides the information if phone capabilities exist on the device. Defaults to true for desktop browsers.
 * @return {Boolean} True if the device has phone capabilities.
 */
tutao.tutanota.util.ClientDetector.isPhoneSupported = function() {
	if (tutao.tutanota.util.ClientDetector._browser == null) {
		tutao.tutanota.util.ClientDetector._setClientInfo(navigator.userAgent);
	}
	return tutao.tutanota.util.ClientDetector._phone;
};

/**
 * Provides the type of support by Tutanota.
 * @return {string} Indicates if the browser is supported. One of SUPPORTED_TYPES.
 */
tutao.tutanota.util.ClientDetector.getSupportedType = function() {
	if (tutao.tutanota.util.ClientDetector._browser == null) {
		tutao.tutanota.util.ClientDetector._setClientInfo(navigator.userAgent);
	}
	return tutao.tutanota.util.ClientDetector._supported;
};

/**
 * Provides the default language which is a supported language derived from the browser language.
 * @return {string} The default language. One of the LANGUAGE* values.
 */
tutao.tutanota.util.ClientDetector.getDefaultLanguage = function() {
	if (tutao.tutanota.util.ClientDetector._lang == null) {
		tutao.tutanota.util.ClientDetector._setDefaultLanguage();
	}
	return tutao.tutanota.util.ClientDetector._lang;
};

/**
 * Sets the information about the client from a user agent string.
 * @param {string} userAgent The user agent string.
 */
tutao.tutanota.util.ClientDetector._setClientInfo = function(userAgent) {
	tutao.tutanota.util.ClientDetector._setBrowserAndVersion(userAgent);
	tutao.tutanota.util.ClientDetector._setOs(userAgent);
	tutao.tutanota.util.ClientDetector._setDeviceInfo(userAgent);
	tutao.tutanota.util.ClientDetector._setSupportInfo(userAgent);
};

/**
 * Sets the support info.
 * @param {string} userAgent The user agent string.
 */
tutao.tutanota.util.ClientDetector._setSupportInfo = function(userAgent) {
	var info = tutao.tutanota.util.ClientDetector;
	var minVersionNeeded = {};
	minVersionNeeded[info.BROWSER_TYPE_CHROME] = 30; // we need at least version 30 as swiping is used for tab switching in earlier releases (see https://code.google.com/p/chromium/issues/detail?id=117657)
	minVersionNeeded[info.BROWSER_TYPE_FIREFOX] = 16;
	minVersionNeeded[info.BROWSER_TYPE_IE] = 10;
    minVersionNeeded[info.BROWSER_TYPE_SAFARI] = 6;
    minVersionNeeded[info.BROWSER_TYPE_ANDROID] = 4; // only legacy
    minVersionNeeded[info.BROWSER_TYPE_OPERA] = 19;

    if (info._browser == info.BROWSER_TYPE_OTHER ||
        (info._device != info.DEVICE_TYPE_DESKTOP && (info._browser == info.BROWSER_TYPE_FIREFOX))) {
		info._supported = info.SUPPORTED_TYPE_NOT_SUPPORTED;
    } else if (info._browserVersion < minVersionNeeded[info._browser]) {
		info._supported = info.SUPPORTED_TYPE_UPDATE_NEEDED;
    } else {
        info._supported = info.SUPPORTED_TYPE_SUPPORTED;
    }
	if (info._device == info.DEVICE_TYPE_DESKTOP &&
            info._browser == info.BROWSER_TYPE_IE &&
            info._browserVersion >= 8 && // since version 8 file download is supported
            info._browserVersion < 10 &&
            window.swfobject &&
            swfobject.getFlashPlayerVersion().major >= 8) {
        info._supported = info.SUPPORTED_TYPE_LEGACY_IE;
    } if (info._device == info.DEVICE_TYPE_WINDOWS_PHONE &&
            info._browser == info.BROWSER_TYPE_IE &&
            info._browserVersion >= 10) {
        info._supported = info.SUPPORTED_TYPE_LEGACY_IE_MOBILE;
    } if (info._device == info.DEVICE_TYPE_WINDOWS_PHONE &&
            info._browser == info.BROWSER_TYPE_IE &&
            info._browserVersion < 10) {
        // tool old IE versions on win phone shall be shown as not supported instead of update needed
        info._supported = info.SUPPORTED_TYPE_NOT_SUPPORTED;
    } else if (info._device == info.DEVICE_TYPE_DESKTOP &&
            info._browser == info.BROWSER_TYPE_SAFARI &&
            info._browserVersion >= 6.1) {
        info._supported = info.SUPPORTED_TYPE_LEGACY_SAFARI;
	} else if (info._device == info.DEVICE_TYPE_DESKTOP &&
            info._browser == info.BROWSER_TYPE_SAFARI &&
            info._browserVersion < 6.1) {
        info._supported = info.SUPPORTED_TYPE_UPDATE_NEEDED;
    } else if (info._device == info.DEVICE_TYPE_ANDROID &&
            info._browser == info.BROWSER_TYPE_ANDROID &&
            info._browserVersion >= 4) {
        info._supported = info.SUPPORTED_TYPE_LEGACY_ANDROID;
    }
};

tutao.tutanota.util.ClientDetector.isSupported = function() {
	return tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_SUPPORTED;
};


tutao.tutanota.util.ClientDetector.isMobileDevice = function() {
    if (tutao.tutanota.util.ClientDetector._device == null) {
        tutao.tutanota.util.ClientDetector._setClientInfo(navigator.userAgent);
    }
    var info = tutao.tutanota.util.ClientDetector;
    return (info._device != info.DEVICE_TYPE_DESKTOP);
};



/**
 * Sets the device info.
 * @param {string} userAgent The user agent string.
 */
tutao.tutanota.util.ClientDetector._setDeviceInfo = function(userAgent) {
	var info = tutao.tutanota.util.ClientDetector;
	info._device = info.DEVICE_TYPE_DESKTOP;
	info._phone = false; // we assume by default devices do not support phones
	if (userAgent.match(/iPad.*AppleWebKit/) != null) {
		info._device = info.DEVICE_TYPE_IPAD;
		info._phone = false;
	} else if (userAgent.match(/iPhone.*AppleWebKit/) != null) {
		info._device = info.DEVICE_TYPE_IPHONE;
		info._phone = true;
	} else if (userAgent.match(/Android/) != null) {
		info._device = info.DEVICE_TYPE_ANDROID;
		info._phone = true;
	} else if (userAgent.match(/Windows Phone/) != null){
        info._device = info.DEVICE_TYPE_WINDOWS_PHONE;
        info._phone = true;
    }
};

/**
 * Sets the OS info.
 * @param {string} userAgent The user agent string.
 */
tutao.tutanota.util.ClientDetector._setOs = function(userAgent) {
	var info = tutao.tutanota.util.ClientDetector;
	info._os = info.OS_TYPE_OTHER;
    var windowsIndex = userAgent.indexOf("Windows");
    var linuxIndex = userAgent.indexOf("Linux");
    var androidIndex = userAgent.indexOf("Android");
    var appleIndex1 = userAgent.indexOf("Macintosh");
    var appleIndex2 = userAgent.indexOf("Mac OS");
	if (windowsIndex != -1) {
        info._os = info.OS_TYPE_WINDOWS;
	} else if (linuxIndex != -1 || androidIndex != -1) {
		info._os = info.OS_TYPE_LINUX;
	} else if (appleIndex1 != -1 || appleIndex2 != -1) {
		info._os = info.OS_TYPE_MAC;
	}
};

/**
 * Sets the browser and version info.
 * @param {string} userAgent The user agent string.
 */
tutao.tutanota.util.ClientDetector._setBrowserAndVersion = function(userAgent) {
	var info = tutao.tutanota.util.ClientDetector;
	info._browser = info.BROWSER_TYPE_OTHER;
	info._browserVersion = 0;

    var operaIndex1 = userAgent.indexOf("Opera");
    var operaIndex2 = userAgent.indexOf("OPR/");
	var firefoxIndex = userAgent.indexOf("Firefox/");
	var chromeIndex = userAgent.indexOf("Chrome/");
	var safariIndex = userAgent.indexOf("Safari/");
	var ieIndex = userAgent.indexOf("MSIE");
	var ie11Index = userAgent.indexOf("Trident");
    var androidIndex = userAgent.indexOf("Android");
	var versionIndex = -1;
    if (operaIndex1 != -1) {
        info._browser = info.BROWSER_TYPE_OPERA;
        versionIndex = userAgent.indexOf("Version/");
        if (versionIndex != -1) {
            versionIndex += 8;
        } else {
            versionIndex = operaIndex1 + 6;
        }
    } else if (operaIndex2 != -1) {
        info._browser = info.BROWSER_TYPE_OPERA;
        versionIndex = operaIndex2 + 4;
    } else if ((firefoxIndex != -1) && (operaIndex1 == -1) && (operaIndex2 == -1)) {
		// Opera may pretend to be Firefox, so it is skipped
		info._browser = info.BROWSER_TYPE_FIREFOX;
		versionIndex = firefoxIndex + 8;
	} else if (chromeIndex != -1) {
		info._browser = info.BROWSER_TYPE_CHROME;
		versionIndex = chromeIndex + 7;
    } else if (androidIndex != -1) {
        // keep this check after Chrome, Firefox and Opera, because the Android browser does not identify itself in any other way
        info._browser = info.BROWSER_TYPE_ANDROID;
        versionIndex = androidIndex + 8;
	} else if (safariIndex != -1 && chromeIndex == -1) {
		// Chrome pretends to be Safari, so it is skipped
		info._browser = info.BROWSER_TYPE_SAFARI;
		// Safari prints its version after "Version/"
		versionIndex = userAgent.indexOf("Version/");
		if (versionIndex != -1) {
			versionIndex += 8;
		}
	/* homescreen detection currently deactivated because of problems (see: https://next.tutao.de/confluence/display/next/Browser+support)
	} else if (userAgent.match(/iPad.*AppleWebKit/) || userAgent.match(/iPhone.*AppleWebKit/)) {
		// ipad and iphone do not send the Safari userAgent when HTML-apps are directly started from the homescreen; a browser version is sent neither
        // after "OS" the iOS version is sent, so use that one
		versionIndex = userAgent.indexOf(" OS ");
        if (versionIndex != -1) {
		    info._browser = info.BROWSER_TYPE_SAFARI;
            try {
		        info._browserVersion = Number(userAgent.substring(versionIndex + 4, versionIndex + 5));
            } catch (e) {}
            return;
        }*/
	} else if (ieIndex != -1) {
		info._browser = info.BROWSER_TYPE_IE;
		versionIndex = ieIndex + 5;
	} else if (ie11Index != -1) {
		info._browser = info.BROWSER_TYPE_IE;
		info._browserVersion = 11;
	}	
	if (versionIndex != -1) {
		var mainVersionEndIndex = userAgent.indexOf(".", versionIndex);
		if (mainVersionEndIndex != -1) {
			try {
				info._browserVersion = Number(userAgent.substring(versionIndex, mainVersionEndIndex + 2)); // we recognize one digit after the '.'
			} catch (e) {}
		}
	}
    // if the version is not valid, the browser type is not valid, so set it to other
    if (info._browserVersion == 0) {
        info._browser = info.BROWSER_TYPE_OTHER;
    }
};

/**
 * Sets the default language derived from the browser language.
 */
tutao.tutanota.util.ClientDetector._setDefaultLanguage = function() {
	var lang = navigator.language || navigator.userLanguage;
	if (lang && (lang.toLowerCase() == "de" || lang.toLowerCase() == "de-de")) {
		tutao.tutanota.util.ClientDetector._lang = tutao.tutanota.util.ClientDetector.LANGUAGE_DE;
	} else {
		tutao.tutanota.util.ClientDetector._lang = tutao.tutanota.util.ClientDetector.LANGUAGE_EN;
	}
};


"use strict";

tutao.provide('tutao.tutanota.util.CsvConverter');

/**
 * Converts a CSV string to a two-dimensional array.
 */
tutao.tutanota.util.CsvConverter.csvToArray = function(csvString) {
	return $.csv.toArrays(csvString);
};

/**
 * Converts a two-dimensional array to a CSV string.
 */
tutao.tutanota.util.CsvConverter.arrayToCsv = function(array) {
	var separator = ",";
	var csv = "";
	for (var i=0; i<array.length;i++) {
		for (var a=0; a<array[i].length;a++) {			
			csv += tutao.tutanota.util.CsvConverter._stringToCsvField(array[i][a]);
			if (a != array[i].length - 1) {
				csv += ",";
			}
		}
		if (i != array.length - 1) {
			csv += "\r\n";
		}
	}
	return csv;
};

tutao.tutanota.util.CsvConverter._stringToCsvField = function(string) {
	var s = string.replace(/\"/g,"\\\""); // escape quotes
	return "\"" + s + "\""; // quote the string to allow CRLF inside
};

"use strict";

tutao.provide('tutao.tutanota.util.DataFile');

/**
 * A data file contains the file name, the content of the file (unencrypted) and the session key.
 * @param {ArrayBuffer|String} data The content of the file as ArrayBuffer or as base64 string in LEGACY mode.
 * @param {File|tutao.entity.tutanota.File} file The file.
 * @constructor
 */
tutao.tutanota.util.DataFile = function(data, file) {
	if (file instanceof tutao.entity.tutanota.File) {
		this._name = file.getName();
		this._mimeType = file.getMimeType();
		this._id = file.getId();
	} else { // instanceof File, must be in else block as IE 8/9 do not support the type File (and they use only tutao.entity.tutanota.File)
		this._name = file.name;
		if (file.type && file.type !== "") {
			this._mimeType = file.type;
		} else {
			this._mimeType = "application/octet-stream";
		}
		this._id = null; // file read from filesystem, does not have an id because it has not been stored in tutanota.
	}
	this._data = data;
};

/**
 * Provides the name of the file.
 * @return {string} The name of the file.
 */
tutao.tutanota.util.DataFile.prototype.getName = function() {
	return this._name;
};

/**
 * Provides the content of the file as ArrayBuffer.
 * @return {ArrayBuffer|String} The content of the file as ArrayBuffer or base64 string in LEGACY mode.
 */
tutao.tutanota.util.DataFile.prototype.getData = function() {
	return this._data;
};

/**
 * Provides the mime type of the file. If the mime type is not known, by default "application/octet-stream" is used.
 * @return {string} The mime type of the file.
 */
tutao.tutanota.util.DataFile.prototype.getMimeType = function() {
	return this._mimeType;
};

/**
 * Provides the size of the file.
 * @return {number} The size of the file in bytes.
 */
tutao.tutanota.util.DataFile.prototype.getSize = function() {
	return this._data.byteLength;
};

/**
 * Provides the id of the file, if it has been store in Tutanota.
 * @return {string} The id of the file.
 */
tutao.tutanota.util.DataFile.prototype.getId = function() {
	return this._id;
};

"use strict";

tutao.provide('tutao.util.EncodingConverter');

/**
 * Converts a hex coded string into a base64 coded string.
 *
 * @param {String} hex A hex encoded string.
 * @return {String} A base64 encoded string.
 */
tutao.util.EncodingConverter.hexToBase64 = function(hex) {
	return sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(hex));
};

/**
 * Converts a base64 coded string into a hex coded string.
 *
 * @param {String} base64 A base64 encoded string.
 * @return {String} A hex encoded string.
 */
tutao.util.EncodingConverter.base64ToHex = function(base64) {
	return sjcl.codec.hex.fromBits(sjcl.codec.base64.toBits(base64));
};

/**
 * Converts a utf8 bytes hex coded string into a string.
 *
 * @param {String} hex A hex encoded string.
 * @return {String} A utf8 encoded string.
 */
tutao.util.EncodingConverter.hexToUtf8 = function(hex) {
	return sjcl.codec.utf8String.fromBits(sjcl.codec.hex.toBits(hex));
};

/**
 * Converts a string into a hex coded string containing utf8 bytes.
 *
 * @param {String} utf8 A utf8 encoded string.
 * @return {String} A hex encoded string.
 */
tutao.util.EncodingConverter.utf8ToHex = function(utf8) {
	return sjcl.codec.hex.fromBits(sjcl.codec.utf8String.toBits(utf8));
};

/**
 * Converts a hex coded string into an array of byte values.
 *
 * @param {String} hex A hex encoded string.
 * @return {Array.<number>} An array of byte values. A byte can have the value
 *         0 to 255.
 */
tutao.util.EncodingConverter.hexToBytes = function(hex) {
	return sjcl.codec.bytes.fromBits(sjcl.codec.hex.toBits(hex));
};

/**
 * Converts an array of byte values into a hex coded string.
 *
 * @param {Array.<number>} bytes An array of byte values. A byte can have the value
 *            0 to 255.
 * @return {String} A hex encoded string.
 */
tutao.util.EncodingConverter.bytesToHex = function(bytes) {
	return sjcl.codec.hex.fromBits(sjcl.codec.bytes.toBits(bytes));
};

/**
 * Converts a base64 string to a url-conform base64 string. This is used for
 * base64 coded url parameters.
 *
 * @param {string} base64 The base64 string.
 * @return {string} The base64url string.
 */
tutao.util.EncodingConverter.base64ToBase64Url = function(base64) {
	var base64url = base64.replace(/\+/g, "-");
	base64url = base64url.replace(/\//g, "_");
	base64url = base64url.replace(/=/g, "");
	return base64url;
};

/**
 * Converts a base64 string to a base64ext string. Base64ext uses another character set than base64 in order to make it sortable.
 * 
 *
 * @param {string} base64 The base64 string.
 * @return {string} The base64url string.
 */
tutao.util.EncodingConverter.base64ToBase64Ext = function(base64) {
	var base64Alphabet =  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	var base64extAlphabet = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";

	base64 = base64.replace(/=/g, "");
	var base64ext = new Array(base64.length);
	for (var i = 0; i < base64.length; i++) {
		var index = base64Alphabet.indexOf(base64.charAt(i));
		base64ext[i] = base64extAlphabet[index];
	}
	return base64ext.join("");
};

/**
 * Converts a timestamp number to a GeneratedId (the counter is set to zero) in hex format. 
 * 
 * @param {number} timestamp The timestamp of the GeneratedId
 * @return {string} The GeneratedId as hex string.
 */
tutao.util.EncodingConverter.timestampToHexGeneratedId = function(timestamp) {
	var id = timestamp * 4; // shifted 2 bits left, so the value covers 44 bits overall (42 timestamp + 2 shifted)
	var hex = parseInt(id).toString(16) + "0000000"; // add one zero for the missing 4 bits plus 6 more (3 bytes) to get 9 bytes 
	// add leading zeros to reach 9 bytes (GeneratedId length) = 18 hex
	for (var length = hex.length; length < 18; length++) {
		hex = "0" + hex;
	}
	return hex;
};

/**
 * Converts a timestamp number to a GeneratedId (the counter is set to zero).
 * 
 * @param {number} timestamp The timestamp of the GeneratedId
 * @return {string} The GeneratedId.
 */
tutao.util.EncodingConverter.timestampToGeneratedId = function(timestamp) {
	var hex = tutao.util.EncodingConverter.timestampToHexGeneratedId(timestamp);
	return tutao.util.EncodingConverter.base64ToBase64Ext(tutao.util.EncodingConverter.hexToBase64(hex));
};

/**
 * Converts a base64 url string to a "normal" base64 string. This is used for
 * base64 coded url parameters.
 *
 * @param {string} base64url The base64 url string.
 * @return {string} The base64 string.
 */
tutao.util.EncodingConverter.base64UrlToBase64 = function(base64url) {
	var base64 = base64url.replace(/\-/g, "+");
	base64 = base64.replace(/_/g, "/");
	var nbrOfRemainingChars = base64.length % 4;
	if (nbrOfRemainingChars === 0) {
		return base64;
	} else if (nbrOfRemainingChars === 2) {
		return base64 + "==";
	} else if (nbrOfRemainingChars === 3) {
		return base64 + "=";
	}
	throw new Error("Illegal base64 string.");
};

/**
 * Converts the content of an array to a base64 string. For comparison
 * see http://jsperf.com/encoding-xhr-image-data/5
 *
 * @param {Array.<number>} byteArray The Array of bytes.
 * @return {string} The base64 string.
 */
tutao.util.EncodingConverter.bytesToBase64 = function(byteArray) {
	var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	var byteLength = byteArray.length;

	var byteRemainder = byteLength % 3;
	var mainLength = byteLength - byteRemainder;

	var base64Array = [];
	base64Array.length = Math.floor((byteLength + 2) / 3 * 4);
	var index = 0;

	var a, b, c, d;
	var chunk;

	// Main loop deals with bytes in chunks of 3
	for (var i = 0; i < mainLength; i = i + 3) {
		// Combine the three bytes into a single integer
		chunk = (byteArray[i] << 16) | (byteArray[i + 1] << 8) | byteArray[i + 2];

		// Use bitmasks to extract 6-bit segments from the triplet
		a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
		b = (chunk & 258048) >> 12; // 258048 = (2^6 - 1) << 12
		c = (chunk & 4032) >> 6; // 4032 = (2^6 - 1) << 6
		d = chunk & 63; // 63 = 2^6 - 1

		// Convert the raw binary segments to the appropriate ASCII encoding
		base64Array[index++] = encodings[a];
		base64Array[index++] = encodings[b];
		base64Array[index++] = encodings[c];
		base64Array[index++] = encodings[d];
	}

	// Deal with the remaining bytes and padding
	if (byteRemainder == 1) {
		chunk = byteArray[mainLength];

		a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2

		// Set the 4 least significant bits to zero
		b = (chunk & 3) << 4; // 3 = 2^2 - 1

		base64Array[index++] = encodings[a];
		base64Array[index++] = encodings[b];
		base64Array[index++] = '=';
		//noinspection JSUnusedAssignment
        base64Array[index++] = '=';
	} else if (byteRemainder == 2) {
		chunk = (byteArray[mainLength] << 8) | byteArray[mainLength + 1];

		a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
		b = (chunk & 1008) >> 4; // 1008 = (2^6 - 1) << 4

		// Set the 2 least significant bits to zero
		c = (chunk & 15) << 2; // 15 = 2^4 - 1

		base64Array[index++] = encodings[a];
		base64Array[index++] = encodings[b];
		base64Array[index++] = encodings[c];
		//noinspection JSUnusedAssignment
        base64Array[index++] = '=';
	}

	return base64Array.join('');
};

/**
 * Converts an ASCII string to an ArrayBuffer string. Do not use this
 * for UTF-8/UTF-16-Strings as this conversion uses only one byte per char!
 *
 * @param {string} string The ASCII-String to convert.
 * @return {ArrayBuffer} The ArrayBuffer.
 */
tutao.util.EncodingConverter.asciiToArrayBuffer = function(string) {
    var buffer = new ArrayBuffer(string.length);
    var bytes = new Uint8Array( buffer );
    for(var i = 0; i < string.length; i++) {
        bytes[i] = string.charCodeAt(i);
    }
    return buffer;
};

/**
 * Converts an ArrayBuffer to a Base64 encoded string.
 * Works only on IE > 10 (uses btoa).
 *
 * @param {ArrayBuffer} string The ASCII-String to convert.
 * @return {string} The Base64 encoded string.
 */
tutao.util.EncodingConverter.arrayBufferToBase64 = function(buffer) {
    var binary = '';
    var bytes = new Uint8Array(buffer);
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode( bytes[ i ] );
    }
    return btoa(binary);
};

tutao.util.EncodingConverter.base64ToArray = function(base64) {
    return new Uint8Array(atob(base64).split("").map(function(c) {
        return c.charCodeAt(0);
    }));
};

"use strict";

tutao.provide("tutao.Environment");
tutao.provide("tutao.Env");
tutao.provide("tutao.Mode");
tutao.provide("tutao.env");

/**
 * @enum {number}
 */
tutao.Env = {
    LOCAL: 0,
    LOCAL_COMPILED: 1,
    DEV: 2,
    TEST: 3,
    PROD: 4
};

/**
 * @enum {number}
 */
tutao.Mode = {
    Browser: 0,
    App: 1
};

/**
 * @type {tutao.Environment}
 */
tutao.env;

/**
 * @param {tutao.Env} type
 * @param {boolean} ssl
 * @param {string} server
 * @param {string?} port
 * @constructor
 */
tutao.Environment = function (type, ssl, server, port) {
    this.type = type;
    this.ssl = ssl;
    this.server = server;
    this.port = port;
    this.mode = tutao.Mode.Browser;
};

tutao.Environment.prototype.getWebsocketOrigin = function () {
    return (this.ssl ? 'wss' : 'ws') + "://" + this.server + (this.port ? ":" + this.port : "");
};

tutao.Environment.prototype.getHttpOrigin = function () {
    return (this.ssl ? 'https' : 'http') + "://" + this.server + (this.port ? ":" + this.port : "");
};

"use strict";

tutao.provide('tutao.util.ErrorFactory');

tutao.provide('tutao.AccessBlockedError');
tutao.provide('tutao.AccessDeactivatedError');
tutao.provide('tutao.AccessExpiredError');
tutao.provide('tutao.BadRequestError');
tutao.provide('tutao.InvalidDataError');
tutao.provide('tutao.InvalidSoftwareVersionError');
tutao.provide('tutao.LimitReachedError');
tutao.provide('tutao.MethodNotAllowedError');
tutao.provide('tutao.NotAuthenticatedError');
tutao.provide('tutao.NotAuthorizedError');
tutao.provide('tutao.NotFoundError');
tutao.provide('tutao.ResourceError');
tutao.provide('tutao.TechnicalError');
tutao.provide('tutao.TooManyRequestsError');
tutao.provide('tutao.ConnectionError');

tutao.util.ErrorFactory = function () {
};

/**
 * @param errorCode
 * @param {string=} message
 * @returns {*}
 */
tutao.util.ErrorFactory.prototype.handleRestError = function (errorCode, message) {
    switch (errorCode) {
        case 0:
            return new tutao.ConnectionError();
        case 472:
            return new tutao.AccessBlockedError();
        case 470:
            return new tutao.AccessDeactivatedError();
        case 471:
            return new tutao.AccessExpiredError();
        case 400:
            return new tutao.BadRequestError();
        case 473:
            return new tutao.InvalidDataError();
        case 474:
            return new tutao.InvalidSoftwareVersionError();
        case 475:
            return new tutao.LimitReachedError();
        case 405:
            return new tutao.MethodNotAllowedError();
        case 401:
            return new tutao.NotAuthenticatedError();
        case 403:
            return new tutao.NotAuthorizedError();
        case 404:
            return new tutao.NotFoundError();
        case 429:
            return new tutao.TooManyRequestsError();
        case 500:
            return new tutao.InternalServerError();
        default:
            return new tutao.ResourceError(errorCode + ":" + (typeof message == "string" ? message : ""));
    }
};


(function () {
    function createCustomError(message, name) {
        function RestError(param) {
            if (typeof param == "string") {
                this.message = param;
            } else {
                this.message = message;
            }
            this.name = name;
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, RestError);
            } else {
                var error = new Error();
                if (!error.stack){
                    // fill the stack trace on ios devices
                    try {
                        throw error;
                    } catch (e) {
                    }
                }
                this.stack = this.name + ". " + this.message + "\n" + error.stack.split("\n").slice(1).join("\n"); // removes first line from stack
            }
        }
        RestError.prototype = Object.create(Error.prototype);
        RestError.prototype.constructor = RestError;
        return RestError;
    }

    tutao.AccessBlockedError = createCustomError(472, "AccessBlockedError");
    tutao.AccessDeactivatedError = createCustomError(470, "AccessDeactivatedError");
    tutao.AccessExpiredError = createCustomError(471, "AccessExpiredError");
    tutao.BadRequestError = createCustomError(400, "BadRequestError");
    tutao.InvalidDataError = createCustomError(473, "InvalidDataError");
    tutao.InvalidSoftwareVersionError = createCustomError(474, "InvalidSoftwareVersionError");
    tutao.LimitReachedError = createCustomError(475, "LimitReachedError");
    tutao.MethodNotAllowedError = createCustomError(405, "MethodNotAllowedError");
    tutao.NotAuthenticatedError = createCustomError(401, "NotAuthenticatedError");
    tutao.NotAuthorizedError = createCustomError(403, "NotAuthorizedError");
    tutao.NotFoundError = createCustomError(404, "NotFoundError");
    tutao.TooManyRequestsError = createCustomError(429, "TooManyRequestsError");
    tutao.ResourceError = createCustomError("", "ResourceError");
    tutao.ConnectionError = createCustomError("", "ConnectionError");
    tutao.InternalServerError = createCustomError("", "InternalServerError");
})();

"use strict";

tutao.provide('tutao.tutanota.util.Exporter');

/**
 * Converts a mail into the plain text EML format.
 * @param {tutao.tutanota.ctrl.DisplayedMail} displayedMail The mail we want to export.
 * @return {Promise.<string, Error>} resolves to the EML string, rejected if the export failed
 */
tutao.tutanota.util.Exporter.toEml = function(displayedMail) {
    return new Promise(function (resolve, reject) {
        try  {
            // @type {tutao.entity.tutanota.Mail}
            var mail = displayedMail.mail;
            var emlArray = ["From: " + mail.getSender().getAddress(),
                "MIME-Version: 1.0"];
            if (mail.getToRecipients().length > 0) {
                emlArray.push(tutao.tutanota.util.Exporter._formatRecipient("To: ", mail.getToRecipients()));
            }
            if (mail.getCcRecipients().length > 0) {
                emlArray.push(tutao.tutanota.util.Exporter._formatRecipient("CC: ", mail.getCcRecipients()));
            }
            if (mail.getBccRecipients().length > 0) {
                emlArray.push(tutao.tutanota.util.Exporter._formatRecipient("BCC: ", mail.getBccRecipients()));
            }
            var subject = (mail.getSubject().trim() == "") ? "" : "=?UTF-8?B?" + tutao.util.EncodingConverter.hexToBase64(tutao.util.EncodingConverter.utf8ToHex(mail.getSubject())) + "?=";
            emlArray = emlArray.concat([
                    "Subject: " + subject,
                    "Date: " + tutao.tutanota.util.Formatter.formatSmtpDateTime(mail.getSentDate()),
                // TODO (later) load conversation entries and write message id and references
                //"Message-ID: " + // <006e01cf442b$52864f10$f792ed30$@tutao.de>
                //References: <53074EB8.4010505@tutao.de> <DD374AF0-AC6D-4C58-8F38-7F6D8A0307F3@tutao.de> <530E3529.70503@tutao.de>
                "Content-Type: multipart/mixed; boundary=\"------------79Bu5A16qPEYcVIZL@tutanota\"",
                "",
                "--------------79Bu5A16qPEYcVIZL@tutanota",
                "Content-Type: text/html; charset=UTF-8",
                "Content-transfer-encoding: base64",
                "",
                tutao.util.EncodingConverter.hexToBase64(tutao.util.EncodingConverter.utf8ToHex(displayedMail.bodyText())).match(/.{1,78}/g).join("\r\n"),
                ""
            ]);

        } catch (exception) {
            reject(exception);
        }


        // @type {Array.<tutao.entity.tutanota.File>}
        var attachments = displayedMail.attachments();
        resolve(Promise.map(attachments, function(attachment) {
            return tutao.tutanota.ctrl.FileFacade.readFileData(attachment).then(function(dataFile) {
                var base64Filename = "=?UTF-8?B?" + tutao.util.EncodingConverter.hexToBase64(tutao.util.EncodingConverter.utf8ToHex(attachment.getName())) + "?=";
                emlArray = emlArray.concat([
                    "--------------79Bu5A16qPEYcVIZL@tutanota",
                    "Content-Type: " + attachment.getMimeType(),
                    " name=" + base64Filename + "",
                    "Content-Transfer-Encoding: base64",
                    "Content-Disposition: attachment;",
                    " filename=" + base64Filename + "",
                    "",
                    tutao.util.EncodingConverter.arrayBufferToBase64(dataFile.getData()).match(/.{1,78}/g).join("\r\n")
                ]);
            });
        }).then(function() {
            emlArray.push("--------------79Bu5A16qPEYcVIZL@tutanota--");
            return emlArray.join("\r\n");
        })).caught(reject);
    });
};

tutao.tutanota.util.Exporter._formatRecipient = function(key, recipients) {
    var recipientsString = key;
    for(var i = 0; i < recipients.length; i++) {
        recipientsString += recipients[i].getAddress() + ",\r\n" + new Array(key.length).join(' ');
    }
    return recipientsString.substr(0, recipientsString.length - (2 + key.length));
};
"use strict";

tutao.provide('tutao.tutanota.util.FileUtils');

/**
 * Shows a file chooser and lets the user select multiple files.
 * @return {Promise.<FileList>} Resolves to the FileList.
 */
tutao.tutanota.util.FileUtils.showFileChooser = function() {
    if (tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_IE_MOBILE) {
        tutao.tutanota.gui.alert(tutao.lang("addAttachmentNotPossibleIe_msg"));
        return Promise.resolve([]);
    }
	// each time when called create a new file chooser to make sure that the same file can be selected twice directly after another
	// remove the last file input
	var lastFileInput = document.getElementById("hiddenFileChooser");
	if (lastFileInput) {
		$("body").get(0).removeChild(lastFileInput);
	}

	var fileInput = document.createElement("input");
	fileInput.setAttribute("type", "file");
	fileInput.setAttribute("multiple", "multiple");
	fileInput.setAttribute("id", "hiddenFileChooser");

    var promise = new Promise(function(resolve, reject) {
        $(fileInput).bind("change", function(e) {
            resolve(e.originalEvent.target.files);
        });
    });

    // the file input must be put into the dom, otherwise it does not work in IE
    $("body").get(0).appendChild(fileInput);
    if (!tutao.tutanota.util.FileUtils.WATIR_MODE) {
        fileInput.click();
    }

    return promise
};

// this flag disables showing the file chooser when running with watir as watir handles file uploads in another way
tutao.tutanota.util.FileUtils.WATIR_MODE = false;

/**
 * Loads the content of the given file into an ArrayBuffer.
 * @param {File} file The file to load.
 * @return {Promise.<tutao.tutanota.util.DataFile, Error>} Resolves to the loaded DataFile, rejects if the loading fails.
 */
tutao.tutanota.util.FileUtils.readLocalFile = function(file) {
    return new Promise(function(resolve, reject) {
        var reader = new FileReader();
        reader.onloadend = function(evt) {
            if (evt.target.readyState == FileReader.DONE && evt.target.result) { // DONE == 2
                resolve(new tutao.tutanota.util.DataFile(evt.target.result, file));
            } else {
                reject(new Error("could not load file"));
            }
        };
        reader.readAsArrayBuffer(file);
    });
};

/**
 * Reads the content of the given file as a UTF8 string.
 * @param {File} file The file to load.
 * @return {Promise.<string, Error>} Resolves to the loaded file content as string, rejects if the loading fails.
 */
tutao.tutanota.util.FileUtils.readLocalFileContentAsUtf8 = function(file) {
    return new Promise(function(resolve, reject) {
        var reader = new FileReader();
        reader.onloadend = function(evt) {
            if (evt.target.readyState == FileReader.DONE) { // DONE == 2
                resolve(evt.target.result);
            } else {
                reject(new Error("could not load file"));
            }
        };
        reader.readAsText(file, "UTF-8");
    });
};

/**
 * Provides a link for the user to download the given data file. Using the given file name only works on some browsers.
 * @param {tutao.tutanota.util.DataFile} dataFile The data file.
 * @return {Promise.<Error>} Resolves when finished, rejects if the dowload fails.
 */
tutao.tutanota.util.FileUtils.provideDownload = function(dataFile) {
	navigator.saveBlob = navigator.saveBlob || navigator.msSaveBlob || navigator.mozSaveBlob || navigator.webkitSaveBlob;
	window.saveAs = window.saveAs || window.webkitSaveAs || window.mozSaveAs || window.msSaveAs;
	var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
    var mimeType = "application/octet-stream"; // default mime type should only be overridden if a valid (non empty) mime type is provided
    if (dataFile.getMimeType().trim().length > 0) {
        mimeType = dataFile.getMimeType();
    }

	if (typeof dataFile.getData() === "string") {
		// LEGACY mode
		var downloadButton = $("#downloadButton_" + dataFile.getId()[1]);
		return new tutao.tutanota.legacy.FlashFileSaver("flashDownloader_" + dataFile.getId()[1], downloadButton, downloadButton.outerWidth() + 2, downloadButton.outerHeight() + 2, dataFile.getData(), dataFile.getName()).then(function() {
			downloadButton.find("> span.legacyDownloadText").show().css("visibility", "visible");
		});
	} else if (window.saveAs || navigator.saveBlob) {
		var blob = new Blob([dataFile.getData()], { "type" : mimeType });
        try {
            if (window.saveAs) {
                window.saveAs(blob, dataFile.getName());
            } else {
                navigator.saveBlob(blob, dataFile.getName());
            }
        } catch (e) {
            tutao.tutanota.gui.alert(tutao.lang("saveDownloadNotPossibleIe_msg"));
        }
		return Promise.resolve();
	} else {
        var url;
		// safari mobile < v7 can not open blob urls. unfortunately we can not generally check if this is supported, so we need to check the browser type
		if (tutao.tutanota.util.ClientDetector.getBrowserType() == tutao.tutanota.util.ClientDetector.BROWSER_TYPE_SAFARI && tutao.tutanota.util.ClientDetector.isMobileDevice() && tutao.tutanota.util.ClientDetector.getBrowserVersion() < 7) {
			var base64 = tutao.util.EncodingConverter.bytesToBase64(new Uint8Array(dataFile.getData()));
			url = "data:" + mimeType + ";base64," + base64;
		} else {
			var blob = new Blob([dataFile.getData()], { "type" : mimeType });
			url = URL.createObjectURL(blob);
		}
        // safari on OS X and >= v7 on iOS do not support opening links with simulated clicks, so show a download dialog. Safari < v7 and Android browser may only open some file types in the browser, so we show the dialog to display the info text
        if (tutao.tutanota.util.ClientDetector.getBrowserType() == tutao.tutanota.util.ClientDetector.BROWSER_TYPE_SAFARI || tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_ANDROID) {
            var textId = 'saveDownloadNotPossibleSafariDesktop_msg';
            if (tutao.tutanota.util.ClientDetector.getSupportedType() == tutao.tutanota.util.ClientDetector.SUPPORTED_TYPE_LEGACY_ANDROID) {
                textId = 'saveDownloadNotPossibleAndroid_msg';
            } else if (tutao.tutanota.util.ClientDetector.isMobileDevice()) {
                textId = 'saveDownloadNotPossibleSafariMobile_msg';
            }
            return tutao.locator.legacyDownloadViewModel.showDialog(dataFile.getName(), url, textId).then(function() {
                // the blob must be deleted after usage. delete it after 1 ms in case some save operation is done async
                setTimeout(function() {
                    URL.revokeObjectURL(url);
                }, 1);
            });
        } else {
            var link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", dataFile.getName()); // only chrome currently supports the download link, but it does not cause problems in other browsers
            link.setAttribute("target", "_blank"); // makes sure that data urls are opened in a new tab instead of replacing the tutanota window on mobile safari
            /*
            var event = document.createEvent('MouseEvents');
            event.initMouseEvent('click', true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
            link.dispatchEvent(event);
            */
            this.simulatedClick(link, {});

            // the blob must be deleted after usage. delete it after 1 ms in case some save operation is done async
            setTimeout(function() {
                URL.revokeObjectURL(url);
            }, 1);
            return Promise.resolve();
        }
	}
};

// see http://stackoverflow.com/a/6158160
tutao.tutanota.util.FileUtils.simulatedClick = function (target, options) {

    var event = target.ownerDocument.createEvent('MouseEvents');
    var options = options || {};

    //Set your default options to the right of ||
    var opts = {
        type: options.type                  || 'click',
        canBubble:options.canBubble             || true,
        cancelable:options.cancelable           || true,
        view:options.view                       || target.ownerDocument.defaultView,
        detail:options.detail                   || 1,
        screenX:options.screenX                 || 0, //The coordinates within the entire page
        screenY:options.screenY                 || 0,
        clientX:options.clientX                 || 0, //The coordinates within the viewport
        clientY:options.clientY                 || 0,
        ctrlKey:options.ctrlKey                 || false,
        altKey:options.altKey                   || false,
        shiftKey:options.shiftKey               || false,
        metaKey:options.metaKey                 || false, //I *think* 'meta' is 'Cmd/Apple' on Mac, and 'Windows key' on Win. Not sure, though!
        button:options.button                   || 0, //0 = left, 1 = middle, 2 = right
        relatedTarget:options.relatedTarget     || null
    };

    //Pass in the options
    event.initMouseEvent(
        opts.type,
        opts.canBubble,
        opts.cancelable,
        opts.view,
        opts.detail,
        opts.screenX,
        opts.screenY,
        opts.clientX,
        opts.clientY,
        opts.ctrlKey,
        opts.altKey,
        opts.shiftKey,
        opts.metaKey,
        opts.button,
        opts.relatedTarget
    );

    //Fire the event
    target.dispatchEvent(event);
};

/**
 * Provides the extension of the given filename in lowercase letters.
 * @param {string} fileName The filename.
 * @return {string} The extension of the filename.
 */
tutao.tutanota.util.FileUtils.getFileNameExtension = function(fileName) {
	var index = fileName.lastIndexOf(".");
	if (index != -1 && index != (fileName.length - 1)) {
		return fileName.substring(index + 1).toLowerCase();
	} else {
		return "";
	}
};

/**
 * Provides the image that shall be shown in the attachment.
 * @param {String} fileName The name of the file.
 * @param {boolean} busy True if the file is currently busy.
 * @return {String} The name of the image.
 */
tutao.tutanota.util.FileUtils.getFileTypeImage = function(fileName, busy) {
	if (busy) {
		return "graphics/busy.gif";
	} else {
		return 'graphics/mime/' + tutao.tutanota.util.FileUtils.getFileNameExtension(fileName) + '.png';
	}
};

"use strict";

tutao.provide('tutao.tutanota.util.Formatter');

/**
 * @param {Date} date The date to format.
 * @return {string} the formatted date in the form 'hh:mm:ss'.
 */
tutao.tutanota.util.Formatter.formatLocalTime = function(date) {
	return tutao.util.StringUtils.pad(date.getHours(), 2) + ":" + tutao.util.StringUtils.pad(date.getMinutes(), 2) + ":" + tutao.util.StringUtils.pad(date.getSeconds(), 2);
};

/**
 * Parses a time string and returns the corresponding milliseconds.
 * @param {string} string The formatted date in the form 'hh:mm:ss'.
 * @return {Number} The date.
 */
tutao.tutanota.util.Formatter.parseLocalTime = function(string) {
	var parts = string.split(":");
	return (Number(parts[0]) * 60 * 60 + Number(parts[1]) * 60 + Number(parts[2])) * 1000 + (new Date().getTimezoneOffset() * 60000);  
};

/**
 * Provides a formatted time with millis.
 * @param {Date} date The date to format.
 * @return {string} the formatted date in the form 'hh:mm:ss.SSS'.
 */
tutao.tutanota.util.Formatter.formatTimeMillis = function(date) {
	return tutao.util.StringUtils.pad(date.getHours(), 2) + ":" + tutao.util.StringUtils.pad(date.getMinutes(), 2) + ":" + tutao.util.StringUtils.pad(date.getSeconds(), 2) + "." + tutao.util.StringUtils.pad(date.getMilliseconds(), 2);
};

/**
 * @see http://www.elated.com/articles/working-with-dates/
 * @param {Date} date The date to format.
 * @return {string} the formatted date in the form 'EE dd. Month [yyyy] hh:mm'.
 */
tutao.tutanota.util.Formatter.formatDateTime = function(date) {
	return tutao.tutanota.util.Formatter.formatDateWithWeekday(date) + " " + tutao.util.StringUtils.pad(date.getHours(), 2) + ":" + tutao.util.StringUtils.pad(date.getMinutes(), 2);
};

/**
 * @see http://www.elated.com/articles/working-with-dates/
 * @param {Date} date The date to format.
 * @return {string} the formatted date in the form 'EE dd. Month [yyyy] hh:mm'.
 */
tutao.tutanota.util.Formatter.formatDateTimeFromYesterdayOn = function(date) {
	var dateString = null;
	var startOfToday = new Date().setHours(0,0,0,0);
	var startOfYesterday = startOfToday - 1000*60*60*24;
	if (date.getTime() >= startOfToday) {
		dateString = "";
	} else if (startOfToday > date.getTime() && date.getTime() >= startOfYesterday) {
		dateString = tutao.locator.languageViewModel.get("yesterday_label");
	} else {
		dateString = tutao.tutanota.util.Formatter.formatDateWithWeekday(date);
	}
	return (dateString + " " + tutao.util.StringUtils.pad(date.getHours(), 2) + ":" + tutao.util.StringUtils.pad(date.getMinutes(), 2)).trim();
};

/**
 * Provides the date as a string.
 * @param {Date} date The date to format.
 * @return {string} the formatted date in the form '[d]d. Month yyyy hh:mm'.
 */
tutao.tutanota.util.Formatter.formatFullDateTime = function(date) {
	var monthNames = tutao.locator.languageViewModel.get("monthNames_label");
	return date.getDate() + ". " + monthNames[date.getMonth()] + " " + (1900 + date.getYear()) + " " + tutao.util.StringUtils.pad(date.getHours(), 2) + ":" + tutao.util.StringUtils.pad(date.getMinutes(), 2);
};

/**
 * Provides the date as a string.
 * @param {Date} date The date to format.
 * @return {string} the formatted date in the form 'Day of week, [d]d Month yyyy hh:mm:ss +zone', e.g. Thu, 20 Mar 2014 11:58:26 +0100.
 */
tutao.tutanota.util.Formatter.formatSmtpDateTime = function(date) {
    var dayNames = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    return dayNames[date.getUTCDay()] + ", " + date.getUTCDate() + " " + monthNames[date.getUTCMonth()] + " " + date.getUTCFullYear() + " " + tutao.util.StringUtils.pad(date.getUTCHours(), 2) + ":" + tutao.util.StringUtils.pad(date.getUTCMinutes(), 2) + ":" + tutao.util.StringUtils.pad(date.getUTCSeconds(), 2) + " +0000";
};

/**
 * Provides the date as a string with the year skipped if it is the current year.
 * TODO (timely) switch to google Date tools for all date formattings, esp. for different locales?
 *
 * @see http://www.elated.com/articles/working-with-dates/
 * @param {Date} date The date to format.
 * @return {string} the formatted date in the form '[d]d. Month [yyyy]'.
 */
tutao.tutanota.util.Formatter.formatDate = function(date) {
	var monthNames = tutao.locator.languageViewModel.get("monthNames_label");
	var currentYear = new Date().getYear();
	var yearString = (date.getYear() == currentYear) ? "" : " " + (1900 + date.getYear());
	return date.getDate() + ". " + monthNames[date.getMonth()] + yearString;
};

/**
 * @see http://www.elated.com/articles/working-with-dates/
 * @param {Date} date The date to format.
 * @return {string} the formatted date in the form 'EE [d]d. Month [yyyy]'.
 */
tutao.tutanota.util.Formatter.formatDateWithWeekday = function(date) {
	var dayNames = tutao.locator.languageViewModel.get("weekDays_label");
	var monthNames = tutao.locator.languageViewModel.get("monthNames_label");
	var currentYear = new Date().getYear();
	var yearString = (date.getYear() == currentYear) ? "" : " " + (1900 + date.getYear());
	return dayNames[date.getDay()] + " " + date.getDate() + ". " + monthNames[date.getMonth()] + yearString;
};

/**
 * Converts a date to a string.
 * @param {Date} date The date to format.
 * @return {string} the formatted date in the form 'dd.mm.yyyy'.
 */
tutao.tutanota.util.Formatter.dateToSimpleString = function(date) {
	return tutao.util.StringUtils.pad(date.getDate(), 2) + "." + tutao.util.StringUtils.pad(date.getMonth() + 1, 2) + "." + tutao.util.StringUtils.pad(date.getFullYear(), 4);
};

/**
 * Converts a date to a string.
 * @param {Date} date The date to format.
 * @return {string} the formatted date in the form 'yyyy-mm-dd'.
 */
tutao.tutanota.util.Formatter.dateToDashString = function(date) {
	return tutao.util.StringUtils.pad(date.getFullYear(), 4) + "-" + tutao.util.StringUtils.pad(date.getMonth() + 1, 2) + "-" + tutao.util.StringUtils.pad(date.getDate(), 2);
};

/**
 * Converts a string to a date.
 * @param {string} string the formatted date in the form 'yyyy-mm-dd'.
 * @return {Date} The date or null if the dash string has no valid format.
 */
tutao.tutanota.util.Formatter.dashStringToDate = function(string) {
	var date = new Date(string);
	if (isNaN(date.getTime())) {
		return null;
	} else {
		return date;
	}
};

/**
 * Converts a string to a date.
 * @param  {string} string The string to convert in the form '[d]d.[m]m.yyyy'.
 * @return {Date=} date The date or null if the string could not be parsed.
 */
tutao.tutanota.util.Formatter.simpleStringToDate = function(string) {
	if (string.indexOf("-") != -1) {
		return null;
	}
	var s = string.split('.');
	if (s.length != 3 || (s[0].length != 1 && s[0].length != 2) || (s[1].length != 1 && s[1].length != 2) || s[2].length != 4 || isNaN(s[0]) || isNaN(s[1]) || isNaN(s[2])) {
		return null;
	}
	var day = Number(s[0]);
	var month = Number(s[1]);
	var year = Number(s[2]);
	if (day < 1 || day > 31 || month < 1 || month > 12) {
		return null;
	}
	return new Date(year, month - 1, day, 0, 0, 0, 0);
};

/**
 * Checks if the given string is a valid email address format.
 * @param {string} string The string to check.
 * @return {boolean} If the string is an email address.
 */
tutao.tutanota.util.Formatter.isMailAddress = function(string) {
	/* KEEP IN SYNC WITH JAVA VERSION IN PhoneNumberUtils.js (except uppercase) */
	// check trailing whitespaces because they are not covered by the following regexp
    // allow uppercase addresses in input check, convert them before sending to server.
	if (string == null || string != string.trim()) {
		return false;
	}
	// see http://ntt.cc/2008/05/10/over-10-useful-javascript-regular-expression-functions-to-improve-your-web-applications-efficiency.html
	return /^\s*[\w\-\+_]+(\.[\w\-\+_]+)*\@[\w\-\+_]+\.[\w\-\+_]+(\.[\w\-\+_]+)*\s*$/.test(string);
};

/**
 * Returns a cleaned mail address from the input mail address. Removes leading or trailing whitespaces and converters
 * the address to lower case.
 * @param {string} mailAddress The input mail address.
 * @return {string} The cleaned mail address.
 */
tutao.tutanota.util.Formatter.getCleanedMailAddress = function(mailAddress){
    var cleanedMailAddress = mailAddress.toLowerCase().trim();
    if (tutao.tutanota.util.Formatter.isMailAddress(cleanedMailAddress)) {
		return cleanedMailAddress;
	}	
   	return null;
};


/**
 * Checks if the given string is a valid local part of a Tutanota email address.
 * @param {string} string The string to check.
 * @return {boolean} If the string is valid.
 */
tutao.tutanota.util.Formatter.isValidTutanotaLocalPart = function(string) {
	// check uppercase and leading or trailing whitespaces because they are not covered by the following regexp
	if (string != string.toLowerCase().trim()) {
		return false;
	}
	if (string[0] == '.' || string[string.length - 1] == '.') {
		return false;
	}
	if (string.indexOf("..") != -1) {
		return false;
	}
	// see http://ntt.cc/2008/05/10/over-10-useful-javascript-regular-expression-functions-to-improve-your-web-applications-efficiency.html
	return /^[a-zA-Z0-9_\-\.]+$/.test(string);
};

/**
 * Parses the given string for a name and mail address. The following formats are recognized: [name][<]mailAddress[>] Additionally, whitespaces at any positions outside name and mailAddress are ignored.
 * @param {string} string The string to check.
 * @return {Object.<string,string>=} Returns an object with the attributes "name" and "mailAddress" or null if nothing was found.
 */
tutao.tutanota.util.Formatter.stringToNameAndMailAddress = function(string) {
	string = string.trim();
	if (string == "") {
		return null;
	}
	var startIndex = string.indexOf("<");
	if (startIndex != -1) {
		var endIndex = string.indexOf(">", startIndex);
		if (endIndex == -1) {
			return null;
		}
        var cleanedMailAddress = this.getCleanedMailAddress(string.substring(startIndex + 1, endIndex));

		if (!tutao.tutanota.util.Formatter.isMailAddress(cleanedMailAddress)) {
			return null;
		}
		var name = string.substring(0, startIndex).trim();
		return {name: name, mailAddress: cleanedMailAddress};
	} else {
		var startIndex = string.lastIndexOf(" ");
		startIndex++;
        var cleanedMailAddress = this.getCleanedMailAddress(string.substring(startIndex));
		if (!tutao.tutanota.util.Formatter.isMailAddress(cleanedMailAddress)) {
			return null;
		}
		var name = string.substring(0, startIndex).trim();
		return {name: name, mailAddress: cleanedMailAddress};
	}
};

/**
 * Formats the given size in bytes to a better human readable string using B, KB, MB, GB, TB.
 * @param {number} size The size in bytes.
 */
tutao.tutanota.util.Formatter.formatFileSize = function(size) {
	var unit = ["B", "KB", "MB", "GB", "TB"];
	var unitIndex = 0;
	while (size >= 1000) {
		size /= 1024;
		unitIndex++;
	}
	// round to 1 digit after comma
	size = Math.floor(size * 10) / 10;
	return size + " " + unit[unitIndex];
};

/**
 * Provides the cleaned phone number. Format: +<country_code><number_without_0>. Uses the country code +49 if none is provided.
 * Accepts and removes ' ', '/', '-', '(', ')' from the given phoneNumber.
 * @param {string} phoneNumber The phone number to clean.
 * @return {string?} The cleaned phone number or null if the phone number is not valid.
 */
tutao.tutanota.util.Formatter.getCleanedPhoneNumber = function(phoneNumber) {
	/* KEEP IN SYNC WITH JAVA VERSION IN PhoneNumberUtils.java */
	phoneNumber = phoneNumber.replace(/ /g, "");
	phoneNumber = phoneNumber.replace(/\//g, "");
	phoneNumber = phoneNumber.replace(/-/g, "");
	phoneNumber = phoneNumber.replace(/\(/g, "");
	phoneNumber = phoneNumber.replace(/\)/g, "");
	return (/^\+[1-9]{1}[0-9]+$/.test(phoneNumber)) ? phoneNumber : null;
};

/**
 * Provides the information if the given cleaned phone number is a german mobile phone number.
 * @param {?string} cleanPhoneNumber The phone number to check.
 * @return {boolean} True if it is a mobile phone number, false otherwise.
 */
tutao.tutanota.util.Formatter.isGermanMobilePhoneNumber = function(cleanPhoneNumber) {
	/* KEEP IN SYNC WITH JAVA VERSION IN Formatutils.java and CommonCodes.java */
	if (!cleanPhoneNumber || cleanPhoneNumber.length < (3 + 10) || cleanPhoneNumber.length > (3 + 11) || !tutao.util.StringUtils.startsWith(cleanPhoneNumber, "+49")) {
		return false;
	}
	var germanMobileAreaCodes = ["0151", "0160", "0170", "0171", "0175", /* telekom */
	                             "0152", "0162", "0172", "0173", "0174", /* vodafone */
	                             "0155", "0157", "0163", "0177", "0178", /* e-plus */
	                             "0159", "0176", "0179"]; /* o2 */
	for (var i = 0; i < germanMobileAreaCodes.length; i++) {
		if (tutao.util.StringUtils.startsWith(cleanPhoneNumber.substring(3), germanMobileAreaCodes[i].substring(1))) {
			return true;
		}
	}
	return false;
};

"use strict";

tutao.provide('tutao.util.FunctionUtils');

/**
 * Rebinds all methods defined on a prototype to this. This is useful for methods that
 * are invoked from another context (e.g. event handlers).
 * @param {Object} instance The instance whose methods are bound to this.
 * @see http://groups.google.com/group/knockoutjs/browse_thread/thread/7181e2fc6a4e2dab
 */
tutao.util.FunctionUtils.bindPrototypeMethodsToThis = function(instance) {
	for (var method in Object.getPrototypeOf(instance)) {
	    instance[method] = instance[method].bind(instance);
	}
};

/**
 * Executes a given function for each element in the given array sequentially.
 * The given callback is called when either all elements are executed or an
 * exception occurs.
 *
 * @param {Array} array An array of any type of elements.
 * @param {function(*,function(Error=))} executor A function receiving the element from the array to
 *            execute as well as a finish function. The finish function must be
 *            called when executing the element was finished. If an error
 *            occurred an exception can be passed to the finish function. In
 *            this case the overall execution is stopped and the callback is
 *            called passing the exception.
 * @param {function(Error=)} callback Called when either an error occurred or all elements from
 *            the array are executed.
 */
tutao.util.FunctionUtils.executeSequentially = function(array, executor, callback) {
	var executeRemaining = function(nextIndex) {
		if (nextIndex == array.length) {
			callback();
			return;
		}
		executor(array[nextIndex], function(exception) {
			if (exception) {
				callback(exception);
			} else {
				executeRemaining(nextIndex + 1);
			}
		});
	};
	executeRemaining(0);
};

/**
 * Executes a given function for each element in the given array sequentially.
 * The given callback is called when either all elements are executed or an
 * exception occurs.
 *
 * @param {Array} array An array of any type of elements.
 * @param {function(*,function(Object, Error=))} executor A function receiving the element from the array to
 *            execute as well as a finish function. The finish function must be
 *            called with the return value when executing the element was finished. 
 *            If an error occurred an exception can be passed to the finish function. In
 *            this case the overall execution is stopped and the callback is
 *            called passing the exception.
 * @param {function(Array.<Object>, Error=)} callback Called when either an error occurred or all elements from
 *            the array are executed. The first parameter are the return values.
 */
tutao.util.FunctionUtils.executeSequentiallyAndReturn = function(array, executor, callback) {
	var resultArray = [];
	var executeRemaining = function(nextIndex) {
		if (nextIndex == array.length) {
			callback(resultArray);
			return;
		}
		executor(array[nextIndex], function(result, exception) {
			if (exception) {
				callback(null, exception);
			} else {
				resultArray.push(result);
				executeRemaining(nextIndex + 1);
			}
		});
	};
	executeRemaining(0);
};

/**
 * Executes a given function in the given number of threads in parallel until the executor function callback indicates that execution shall be stopped.
 *
 * @param {Number} nbrOfThreads The number of parallel executions.
 * @param {function(function(boolean))} executor A function that shall be executed. In the callback it must provide true if execution shall continue and false if execution shall be stopped.
 * @param {function()} callback Called once when the first executor callback provided "false". Some executions may still be running at this time, but no new ones are started any more.
 */
tutao.util.FunctionUtils.executeInParallel = function(nbrOfThreads, executor, callback) {
    var finished = false;
    var run = function() {
        executor(function(continueExecution) {
            if (continueExecution && !finished) {
                // the last executor said we shall continue exection and no other set the finished flag, so we execute again from this thread.
                run();
            } else if (!finished) {
                // this is the first time an executor said we shall stop execution, so we call the callback now.
                finished = true;
                callback();
            }
        });
    };

    // start executors for the given number of threads
    for (var i=0; i<nbrOfThreads; i++) {
        // always check the finished flag because an executor might run synchronously and finish, so not all threads have to be started.
        if (!finished) {
            run();
        }
    }
};

"use strict";

tutao.provide('tutao.tutanota.util.LocalStore');

/**
 * Stores some data in the local storage.
 * @param {String} id The id of the data.
 * @param {String} data The data.
 * @return {boolean} True if the data could be stored, false if the local storage is not available.
 */
tutao.tutanota.util.LocalStore.store = function(id, data) {
	// exception is thrown if local store is not available
	try {
		localStorage.setItem(id, data);
		return true;
	} catch (e) {
		return false;
	}
};

/**
 * Checks if some data exists in the local storage.
 * @param {String} id The id of the data.
 * @return {boolean} True if the data exists in the local store, false otherwise.
 */
tutao.tutanota.util.LocalStore.contains = function(id) {
	try {
		return (localStorage.getItem(id) != null);
	} catch (e) {
		return false;
	}
};

/**
 * Loads some data from the local storage.
 * @param {String} id The id of the data.
 * @return {String} The loaded data or null if none was found.
 */
tutao.tutanota.util.LocalStore.load = function(id) {
	try {
		return localStorage.getItem(id);
	} catch (e) {
		return null;
	}
};

/**
 * Removes some data from the local storage if it exists.
 * @param {String} id The id of the data.
 */
tutao.tutanota.util.LocalStore.remove = function(id) {
	try {
		localStorage.removeItem(id);
	} catch (e) {}
};


"use strict";

tutao.provide('tutao.tutanota.util.PasswordUtils');

/**
 * Generates a password that can be used to derive a key and encrypt a message to an external recipient.
 * @return {string} The password.
 */
tutao.tutanota.util.PasswordUtils.generateMessagePassword = function() {
	return tutao.tutanota.util.PasswordUtils.generatePassword(tutao.tutanota.util.PasswordUtils.MESSAGE_PASSWORD_LENGTH);
};

/**
 * Generates a password that can be used for a newly created account.
 * @param {number} length The length of the new password
 * @return {string} The password.
 */
tutao.tutanota.util.PasswordUtils.generatePassword = function(length) {
	var password = "";
	for (var i = 0; i < length; i++) {
		while (true) {
			var index = tutao.util.EncodingConverter.hexToBytes(tutao.locator.randomizer.generateRandomData(1))[0];
			// the random value must be within the character set range, otherwise try the next one
			if (index < tutao.tutanota.util.PasswordUtils.MESSAGE_PASSWORD_CHAR_SET.length) {
				password += tutao.tutanota.util.PasswordUtils.MESSAGE_PASSWORD_CHAR_SET[index];
				break;
			}
		}
	}
	return password;
};

tutao.tutanota.util.PasswordUtils.MESSAGE_PASSWORD_CHAR_SET = "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnopqrstuvwxyz123456789";
tutao.tutanota.util.PasswordUtils.MESSAGE_PASSWORD_LENGTH = 8;

// contains german and english keyboard sequences
tutao.tutanota.util.PasswordUtils._BAD_SEQUENCES = [ "^1234567890ß´", "°!\"§$%&/()=?`", "qwertzuiopü+", "QWERTZUIOPÜ*", "asdfghjklöä#",  "ASDFGHJKLÖÄ'",  "<yxcvbnm,.-",  ">YXCVBNM;:_",
    "`1234567890-=", "~!@#$%^&*()_+",  "qwertyuiop[]", "QWERTYUIOP{}", "asdfghjkl;'\\" ,"ASDFGHJKL:\"|", "\\zxcvbnm,./", "|ZXCVBNM<>?",
    "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ" ];

// contains strings that reducece the strenght of a password
tutao.tutanota.util.PasswordUtils._BAD_STRINGS = [ "passwort", "Passwort", "password", "Password", "tutanota", "Tutanota", "free", "Free", "starter", "Starter", "Test", "test" ];

/**
 * Checks how secure the given password is. The following password characteristics decrease the password strength:
 * - irregular distribution of characters across the character classes lower case, upper case, digit, other
 * - consecutive characters of the same class
 * - same chars
 * - same consecutive chars
 * - keyboard (german/english) or alphabet sequences
 * - bad strings (statically defined and passed to function in badStrings)
 * @param {string} password The password to check.
 * @param {Array.<string>} badStrings Strings that reduce the strength of the password.
 * @return {number} A number from 0 to 100.
 */
tutao.tutanota.util.PasswordUtils.getPasswordStrength = function(password, badStrings) {
    if (password.length == 0) {
        return 0;
    }

    // calculate the characteristics of the password
    var nbrOfLowerChars = tutao.tutanota.util.PasswordUtils._getNbrOfOccurrences(password, /[a-z ]/g);
    var nbrOfConsecutiveLowerChars = Math.max(0, tutao.tutanota.util.PasswordUtils._getLongestResult(password, /[a-z ]*/g) - 2); // consecutive chars > 2
    var nbrOfUpperChars = tutao.tutanota.util.PasswordUtils._getNbrOfOccurrences(password, /[A-Z]/g);
    var nbrOfConsecutiveUpperChars = Math.max(0, tutao.tutanota.util.PasswordUtils._getLongestResult(password, /[A-Z]*/g) - 2);
    var nbrOfDigits = tutao.tutanota.util.PasswordUtils._getNbrOfOccurrences(password, /[0-9]/g);
    var nbrOfConsecutiveDigits = Math.max(0, tutao.tutanota.util.PasswordUtils._getLongestResult(password, /[0-9]*/g) - 2);
    var nbrOfOtherChars = password.length - nbrOfDigits - nbrOfLowerChars - nbrOfUpperChars;
    var nbrOfConsecutiveOtherChars = Math.max(0, tutao.tutanota.util.PasswordUtils._getLongestResult(password, /[^a-z A-Z0-9]*/g) - 2);
    var nbrOfConsecutiveSame = Math.max(0, tutao.tutanota.util.PasswordUtils._getLongestResult(password, /(.)\1+/g) - 2);
    var minNbrOfCharsPerType = password.length / 4; // best is 1/4 lower case, 1/4 upper case, 1/4 digits, 1/4 other chars

    // all these values decrease the strength
    var nbrOfMissingLowerChars = Math.max(0, minNbrOfCharsPerType - nbrOfLowerChars);
    var nbrOfMissingUpperChars = Math.max(0, minNbrOfCharsPerType - nbrOfUpperChars);
    var nbrOfMissingDigits = Math.max(0, minNbrOfCharsPerType - nbrOfDigits);
    var nbrOfMissingOtherChars = Math.max(0, minNbrOfCharsPerType - nbrOfOtherChars);
    var nbrOfSameChars = tutao.tutanota.util.PasswordUtils._getNbrOfSameChars(password);
    var nbrOfSequenceDigits = tutao.tutanota.util.PasswordUtils._getNbrOfSequenceChars(password, tutao.tutanota.util.PasswordUtils._BAD_SEQUENCES, true);
    var nbrOfBadStringDigits = tutao.tutanota.util.PasswordUtils._getNbrOfSequenceChars(password, badStrings.concat(tutao.tutanota.util.PasswordUtils._BAD_STRINGS), false);

    var strength = password.length * 11; // 11 = strength per character without reduction
    strength -= nbrOfMissingLowerChars * 3;
    strength -= nbrOfMissingUpperChars * 3;
    strength -= nbrOfMissingDigits * 3;
    strength -= nbrOfMissingOtherChars * 3;
    strength -= nbrOfConsecutiveLowerChars * 2;
    strength -= nbrOfConsecutiveUpperChars * 2;
    strength -= nbrOfConsecutiveDigits * 2;
    strength -= nbrOfConsecutiveOtherChars * 2;
    strength -= nbrOfConsecutiveSame * 2;
    strength -= nbrOfSameChars * 5;
    strength -= nbrOfSequenceDigits * 4;
    strength -= nbrOfBadStringDigits * 4;

    return Math.min(100, Math.max(0, Math.round(strength)));
};

/**
 * Provides the number of repetitions of any characters in the given password at any position.
 * @param password {string} The password to check.
 * @returns {number} The number of same characters.
 * @private
 */
tutao.tutanota.util.PasswordUtils._getNbrOfSameChars = function(password) {
    var characterObject = {};
    for (var i = 0; i < password.length; i++) {
        characterObject[password[i]] = true;
    }
    return password.length - Object.keys(characterObject).length;
};


/**
 * Provides the number of chars in the given password that contains parts (> 2 characters) of the given sequences.
 * @param {string} password The password to check.
 * @param  {Array.<string>} sequences The sequences to check.
 * @param {bool} reverseToo If true, also all reverse sequences are checked.
 * @returns {number} The number of chars that match any sequences.
 * @private
 */
tutao.tutanota.util.PasswordUtils._getNbrOfSequenceChars = function(password, sequences, reverseToo) {
    // all sequences to the list of checked sequences s. also add all reverse sequences if requested
    var s = sequences.slice();
    if (reverseToo) {
        for (var l = 0; l < sequences.length; l++) {
            s.push(sequences[l].split("").reverse().join(""));
        }
    }

    var MIN_SEQUENCE_LEN = 3;
    var nbrOfSequenceDigits = 0;
    // check the part of the password (substringToCheck) from i to i+sequenceLen in a loop
    for (var i = 0; i < (password.length - MIN_SEQUENCE_LEN); i++) {
        var maxFoundLen = 0;
        for (var sequenceLen = MIN_SEQUENCE_LEN; (i + sequenceLen) <= password.length; sequenceLen++) {
            var substringToCheck = password.substring(i, i + sequenceLen);
            for (var a = 0; a < s.length; a++) {
                if (s[a].indexOf(substringToCheck) != -1) {
                    maxFoundLen = sequenceLen;
                    break;
                }
            }
        }
        if (maxFoundLen > 0) {
            nbrOfSequenceDigits += maxFoundLen;
            i += (maxFoundLen - 1); // skip the found sequence. -1 because the for loop also decreases by 1
        }
    }
    return nbrOfSequenceDigits;
};

/**
 * Gets the number of occurrences of the given regular expression in the given string.
 * @param {string} string The string to check.
 * @param {RegExp} regexp The reqular expression to check against.
 * @return {number} The number of occurrences.
 * @private
 */
tutao.tutanota.util.PasswordUtils._getNbrOfOccurrences = function(string, regexp) {
    var result = string.match(regexp);
    if (!result) {
        return 0;
    } else {
        return result.length;
    }
};

/**
 * Gets the number of characters in the longest result when checking the given string against the given regular expression.
 * @param {string} string The string to check.
 * @param {RegExp} regexp The reqular expression to check against.
 * @returns {number} The number of characters of the longest result.
 * @private
 */
tutao.tutanota.util.PasswordUtils._getLongestResult = function(string, regexp) {
    var result = string.match(regexp);
    if (!result) {
        return 0;
    } else {
        var maxLen = 0;
        for (var i=0; i<result.length; i++) {
            maxLen = Math.max(maxLen, result[i].length);
        }
        return maxLen;
    }
};
"use strict";

tutao.provide('tutao.tutanota.util.StateMachine');

tutao.tutanota.util.StateMachine = function() {
	this._states = {}; // stateName: { trigger: function, transitions: { eventName: nextState }, properties: { propertyName: propertyValue } }
	this._state = ko.observable(null); // contains the current state name
	this._startStateName = null;
};

/**
 * @param {string} name
 * @param {Object} properties
 * @param {function()=} trigger Called when this state is entered.
 */
tutao.tutanota.util.StateMachine.prototype.addState = function(name, properties, trigger) {
	// the first state is the start state
	if (Object.keys(this._states).length == 0) {
		tutao.util.Assert.assert(!trigger, "no trigger allowed");
		this._startStateName = name;
		this._state(name);
	} else {
		// check that the propertyNames are the same as in the start state
		var startProperties = Object.keys(this._states[this._startStateName].properties);
		tutao.util.Assert.assert(startProperties.length == Object.keys(properties).length, "different properties for state " + name);
		for (var i=0; i<startProperties.length; i++) {
			tutao.util.Assert.assert(properties[startProperties[i]] !== undefined, "different properties for state " + name);
		}
	}
	this._states[name] = { trigger: trigger, transitions: {}, properties: properties};
};

tutao.tutanota.util.StateMachine.prototype.addTransition = function(sourceStateName, eventName, targetStateName) {
	tutao.util.Assert.assert(this._states[sourceStateName], "source state not found: " + sourceStateName);
	tutao.util.Assert.assert(this._states[targetStateName], "target state not found: " + targetStateName);
	this._states[sourceStateName].transitions[eventName] = targetStateName;
};

tutao.tutanota.util.StateMachine.prototype.reset = function() {
	this._state(this._startStateName);
};

tutao.tutanota.util.StateMachine.prototype.event = function(eventName) {
	var nextStateName = this._states[this._state()].transitions[eventName];
	tutao.util.Assert.assert(nextStateName, "invalid transition: " + this._state() + " -> " + eventName);
	this._state(nextStateName);
	if (this._states[this._state()].trigger) {
		this._states[this._state()].trigger();
	}
};

tutao.tutanota.util.StateMachine.prototype.getState = function() {
	return this._state();
};

tutao.tutanota.util.StateMachine.prototype.getProperty = function(propertyName) {
	var p = this._states[this._state()].properties[propertyName];
	tutao.util.Assert.assert(p !== undefined, "invalid property: " + propertyName);
	return p;
};

"use strict";

tutao.provide('tutao.util.StringUtils');

/**
 * Returns a string which contains the given number padded with 0s.
 * @param {number} num The number to pad.
 * @param {number} size The number of resulting digits.
 * @return {string} The padded number as string.
 */
tutao.util.StringUtils.pad = function(num, size) {
	var s = num + "";
	while (s.length < size)
		s = "0" + s;
	return s;
};

/**
 * Checks if a string starts with another string.
 * @param {string} string The string to test.
 * @param {string} substring If the other string begins with this one, we return true.
 * @return {boolean} True if string begins with substring, false otherwise.
 */
tutao.util.StringUtils.startsWith = function(string, substring) {
    return string.indexOf(substring) == 0;
};

/**
 * Checks if a string ends with another string.
 * @param {string} string The string to test.
 * @param {string} substring If the other string ends with this one, we return true.
 * @return {boolean} True if string ends with substring, false otherwise.
 */
tutao.util.StringUtils.endsWith = function(string, substring) {
	var pos = string.lastIndexOf(substring);
    return (pos != -1 && pos == (string.length - substring.length));
};

"use strict";

/**
 * Overrides the bind method if it does not exist (which is currently only the case for safari).
 */
if (!Function.prototype.bind) {

/**
 * Implements bind on the function prototype.
 * @param {Object} oThis The object to bind.
 * @return {function()} The bound function.
 * @suppress {duplicate}
 */
  Function.prototype.bind = function(oThis) {
    if (typeof this !== "function") {
      // closest thing possible to the ECMAScript 5 internal IsCallable function
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        /**
         * @constructor
         */
        fNOP = function() {},
        fBound = function() {
          return fToBind.apply(this instanceof fNOP ? this : oThis || window, aArgs.concat(Array.prototype.slice.call(arguments)));
        };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();

    return fBound;
  };
}

"use strict";

tutao.provide('tutao.tutanota.ctrl.bubbleinput.Bubble');

/**
 * Creates a new Bubble from the following args:
 * @param {*} entity The backing entity.
 * @param {ko.observable} text The text displayed by the bubble.
 * @param {ko.observable} tooltip The tooltip text displayed by the bubble.
 * @param {ko.observable} state The state of the bubble (must be mapped to a css class).
 * @param {bool} showDeleteIcon If true, shows a delete icon which removes this bubble when clicked.
 * @constructor
 */
tutao.tutanota.ctrl.bubbleinput.Bubble = function(entity, text, tooltip, state, showDeleteIcon) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	this.entity = entity;
	this.text = text;
	this.tooltip = tooltip;
	this.state = state;
	this.selected = ko.observable(false);
    this.showDeleteIcon = showDeleteIcon;
};

/**
 * Inverts the selection state: Selects or deselects this bubble depending on it's current state.
 */
tutao.tutanota.ctrl.bubbleinput.Bubble.prototype.invertSelection = function() {
	this.selected(!this.selected());
};


"use strict";

tutao.provide('tutao.tutanota.ctrl.bubbleinput.BubbleHandler');


/**
 * The BubbleInputField delegates certain tasks like retrieving suggestions and creating bubbles
 * to the BubbleHandler.
 *
 * This interface is implemented by ViewModels which make use of the BubbleInputField
 *
 * @interface
 */
tutao.tutanota.ctrl.bubbleinput.BubbleHandler = function() {};

/**
 * @param {string} text The text to filter for.
 * @return {Array.<tutao.tutanota.ctrl.bubbleinput.Suggestion>} suggestions that are valid for text.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleHandler.prototype.getSuggestions = function(text) {};

/**
 * Creates a new bubble for a suggestion.
 * @param {tutao.tutanota.ctrl.bubbleinput.Suggestion} suggestion The suggestion.
 * @return {tutao.tutanota.ctrl.bubbleinput.Bubble=} Returns the new bubble or null if none could be created.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleHandler.prototype.createBubbleFromSuggestion = function(suggestion) {};

/**
 * Creates a new bubble from the provided text.
 * @param {string} text
 * @return {Array.<tutao.tutanota.ctrl.bubbleinput.Bubble>} Returns the new bubble or null if none could be created.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleHandler.prototype.createBubblesFromText = function(text) {};

/**
 * Notifies the BubbleHandler that the given bubble was deleted.
 * @param {tutao.tutanota.ctrl.bubbleinput.Bubble} bubble The bubble that was deleted.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleHandler.prototype.bubbleDeleted = function(bubble) {};

/**
 * Gets invoked whenever the button gets clicked
 */
tutao.tutanota.ctrl.bubbleinput.BubbleHandler.prototype.buttonClick = function() {};

/**
 * Is invoked in order to display the image on the button
 * @return {string} the path to the button that should be displayed.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleHandler.prototype.buttonCss = function() {};

"use strict";

tutao.provide('tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel');

/**
 * Displays a BubbleInputField. A BubbleInputField is an input field that converts text to bubbles
 * for an enhanced user experience. It supports suggestions via a drop down list.
 *
 * Always use with the bubbleinput-template (see index.html)
 *
 * The BubbleInputField consists of the following components:
 * <ul>
 *   <li>bubbles which are created based on the text input of the user and
 *   <li>an input field into which the user types text.
 * </ul>
 *
 * As the BubbleInputField is made of these components, a bit of background work is done in order to provide a seamless user experience:
 * <ul>
 *   <li>The input field gets resized whenever the user types text, or a bubble is created.
 *   <li>We try to create a new bubble if the user has pressed space or return or the focus of the input field gets lost.
 *   <li>If the user clicks anywhere inside the BubbleInputField (besided on bubbles), the underlying input field is focused.
 * </ul>
 *
 * TODO (story: Make navigation items selectable and mark selected item (keyboard navigation)) key event handler on the document that delegates keypresses to the currently active element (must be marked with tabindex)
 *       pseudo-code: ko.dataFor(document.activeElement).keypress(event)
 *
 * @constructor
 * @param {tutao.tutanota.ctrl.bubbleinput.BubbleHandler} bubbleHandler
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel = function(bubbleHandler) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	// a delegate for retrieving suggestions and creating bubbles (see BubbleHandler)
	this.bubbleHandler = bubbleHandler;
	// true if the inputField is focused
	this.inputActive = ko.observable(false);
	if (tutao.tutanota.util.ClientDetector.getBrowserType() == tutao.tutanota.util.ClientDetector.BROWSER_TYPE_FIREFOX) {
		// firefox hides fields just in the moment when the focus is lost. If this is enabled for chrome, clicking on suggestions does not work in the exploded distribution
		this.inputActive = this.inputActive.extend({throttle: 0});
	}
	this.inputActive.subscribe(function(active) {
		if (!active && !this.skipNextBlur) {
			this.createBubbles();  // focus lost
		}
	}, this);
	// true if the BubbleInputField is active (currently always when the input field is active)
	this.active = this.inputActive;

	// the current value of the input field
	this.inputValue = ko.observable("");
	this.inputValue.subscribe(function(newValue) {
		tutao.tutanota.gui.BubbleInputGui.resizeInputField(this.inputDomField, newValue);
	}, this);
	this.bubbles = ko.observableArray();
	// The dom element representing the input field. This is used for gui actions like resizing the input field to the correct size (see tutao.tutanota.gui.BubbleInputGui)
	this.inputDomField = null;
	this.suggestions = ko.computed(function() {
		return this.bubbleHandler.getSuggestions(this.inputValue());
	}, this);
	this.selectedSuggestion = ko.observable(null);
	this.suggestions.subscribe(function(newSuggestions) {
		if (newSuggestions.length > 0 && (this.selectedSuggestion() == null || !tutao.util.ArrayUtils.contains(this.suggestions(), this.selectedSuggestion()))) {
			this.selectedSuggestion(newSuggestions[0]);
		} else if (newSuggestions.length == 0 && this.selectedSuggestion() != null) {
			this.selectedSuggestion(null);
		}
	}, this);

	// a blur occurs after a mousedown on a suggestion. These blurs must be skipped in order to hold the cursor on the input field.
	this.skipNextBlur = false;
    this.enabled = true;
};

/**
 * Sets the focus on the input field.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.setInputActive = function() {
	this.inputActive(true);
	var self = this;
	// setTimeout is needed because mobile safari hides the cursor after selecting a suggestion otherwise.
	setTimeout(function() {
		tutao.tutanota.gui.BubbleInputGui.setCursorToEnd(self.inputDomField);
	},0);
};

/**
 * Disables input.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.setEnabled = function(enabled) {
    this.enabled = enabled;
};

/**
 * Dispatches all relevant key codes to the BubbleInputField (see belows methods).
 * @see http://api.jquery.com/keyup/ and http://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes for key codes
 * @param data
 * @param event
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.handleKey = function(data, event) {
    if (!this.enabled) {
        return false;
    }
	if (event.which === 13 || event.which === 32) {
		return this.createBubbles(); // return and whitespace
	} else if (event.which === 8) {// backspace, del: 46
		this.handleBackspace();
	} else if (event.which === 46) {
		return this.handleDelete();
	} else if (event.which === 37) {
		this.handleLeftArrow();
	} else if (event.which === 39) {
		return this.handleRightArrow();
	} else if (event.which === 38) {
		return this.handleUpArrow();
	} else if (event.which === 40) {
		return this.handleDownArrow();
	} else if (event.which === 65 && event.ctrlKey) {
		this.selectAll();
	} else if (event.which === 17) {
		// do not react on ctrl key
	} else {
		this.removeBubbleSelection();
	}
	return true;
};

/**
 * Does the following when a backspache occurs:
 * <ul>
 *   <li>If no bubble is selected and the cursor is positioned at the beginning of the input field, the last bubble gets selected
 *   <li>If at least one bubble is selected, the bubbles are deleted and the selection is set on the left sibling of the leftmost deleted bubble
 * </ul>
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.handleBackspace = function() {
	if (this.isBubbleSelected()) {
		var nextSelection = null;
		for (var i = 0; i < this.bubbles().length; i++) {
			if (this.bubbles()[i].selected() && i > 0) {
				nextSelection = this.bubbles()[i - 1];
				break;
			}
		}
		this.deleteSelectedBubbles();
		if (nextSelection) {
			nextSelection.selected(true);
		}
	} else if (this.inputValue() == "") {
		this.selectLastBubble();
	}
};

/**
 * If at least one bubble is selected, the bubbles are deleted and the selection is set on the right sibling of the rightmost deleted bubble
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.handleDelete = function() {
	if (this.isBubbleSelected()) {
		var nextSelection = null;
		for (var i = this.bubbles().length - 1; i >= 0; i--) {
			if (this.bubbles()[i].selected() && i < this.bubbles().length - 1) {
				nextSelection = this.bubbles()[i + 1];
				break;
			}
		}
		this.deleteSelectedBubbles();
		if (nextSelection) {
			nextSelection.selected(true);
		}
		return true;
	}
	return true;
};

/**
 * Steps from right to left through the bubbles when the cursor is positioned on the first position of the input field
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.handleLeftArrow = function() {
	if (this.isBubbleSelected()) {
		for (var i = 0; i < this.bubbles().length; i++) {
			if (this.bubbles()[i].selected()) {
				if (i > 0) {
					this.bubbles()[i].selected(false);
					this.bubbles()[i - 1].selected(true);
					return;
				}
			}
		}
	} else {
		this.selectLastBubble();
	}
};

/**
 * Steps from left to right through the bubbles
 * @return {boolean} false, if another bubble has been selected, true otherwise.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.handleRightArrow = function() {
	if (this.isBubbleSelected()) {
		for (var i = 0; i < this.bubbles().length; i++) {
			if (this.bubbles()[i].selected()) {
					this.bubbles()[i].selected(false);
					if (i < this.bubbles().length - 1) {
						this.bubbles()[i + 1].selected(true);
					}
					return false;
			}
		}
	}
	return true;
};

/**
 * Selects the previous available suggestions
 * @return {boolean} false.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.handleUpArrow = function() {
	if (this.selectedSuggestion()) {
		var nextPosition = this.suggestions().indexOf(this.selectedSuggestion()) - 1;
		if (nextPosition == -1) {
			nextPosition = this.suggestions().length - 1;
		} else {
			nextPosition = nextPosition % this.suggestions().length;
		}
		this.selectedSuggestion(this.suggestions()[nextPosition]);
	}
	return false;
};

/**
 * Selects the next available suggestions
 * @return {boolean} false.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.handleDownArrow = function() {
	if (this.selectedSuggestion()) {
		var nextPosition = this.suggestions().indexOf(this.selectedSuggestion()) + 1;
		this.selectedSuggestion(this.suggestions()[nextPosition % this.suggestions().length]);
	}
	return false;
};

/**
 * Selects the last bubble if the cursor is positioned at the beginning of the input field
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.selectLastBubble = function() {
	var lastElement = tutao.util.ArrayUtils.last(this.bubbles());
    // getting the cursor position of input type=email fields does not work on chrome, so we check that the field is empty instead
    if (lastElement && this.inputValue() == "") {
        lastElement.selected(true);
    }
};

/**
 * Deletes all currently selected bubbles.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.deleteSelectedBubbles = function() {
	for (var i = this.bubbles().length - 1; i >= 0; i--) {
		if (this.bubbles()[i].selected()) {
			var deletedBubble = this.bubbles.splice(i, 1)[0];
			this.bubbleHandler.bubbleDeleted(deletedBubble);
		}
	}
	tutao.tutanota.gui.BubbleInputGui.resizeInputField(this.inputDomField, this.inputValue());
};

/**
 * Removes the selection from all selected bubbles
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.removeBubbleSelection = function() {
	for (var i = 0; i < this.bubbles().length; i++) {
		if (this.bubbles()[i].selected()) {
			this.bubbles()[i].selected(false);
		}
	}
};

/**
 * @return {Boolean} true, if at least one bubble is selected.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.isBubbleSelected = function() {
	for (var i = 0; i < this.bubbles().length; i++) {
		if (this.bubbles()[i].selected()) {
			return true;
		}
	}
	return false;
};

/**
 * Creates a new bubble (delegates to the bubbleHandler)
 * @return {boolean} true, if the bubble has been created, false otherwise.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.createBubbles = function() {
	var value = this.inputValue().trim();
	if (value === "") {
		return false;
	}
	var bubbles = [];
	// if there is a selected suggestion, we shall create a bubble from that suggestions instead of the entered text
	if (this.selectedSuggestion()) {
        var bubble = this.bubbleHandler.createBubbleFromSuggestion(this.selectedSuggestion());
        if (bubble) {
            bubbles.push(bubble);
        }
	} else {
		bubbles = this.bubbleHandler.createBubblesFromText(value);
	}
	if (bubbles.length > 0) {
        for (var i=0; i<bubbles.length; i++) {
		    this.bubbles.push(bubbles[i]);
        }
		this.inputValue("");
		tutao.tutanota.gui.BubbleInputGui.resizeInputField(this.inputDomField, this.inputValue());
	}
	return false;
};

/**
 * Selects all bubbles.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.selectAll = function() {
	for (var i = 0; i < this.bubbles().length; i++) {
		this.bubbles()[i].selected(true);
	}
};

/**
 * Sets the inputDomField when the dom is created.
 * @param {Object} domElement The dom element.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.setInputField = function(domElement) {
	this.inputDomField = domElement;
};

/**
 * Handles blur events of the input field and resets the focus to the input field if skipNextBlur is true.
 * @param {BubbleInputviewModel} vm The BubbleInputViewModel.
 * @param {jQuery.Event} event The blur event.
 * @return {Boolean} false, if the focus to the input field has been resetted (prevents default) and true otherwise.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.inputFieldBlurFired = function(vm, event) {
	if (this.skipNextBlur) {
		this.skipNextBlur = false;
		this.setInputActive();
		return false;
	}
	return true;
};

/**
 * Handles the mousedown event on a suggestion and sets skipNextBlur to true
 * @return {Boolean} true.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.suggestionMousedownFired = function() {
	this.skipNextBlur = true;
	return true;
};


/**
 * Creates a bubble for the given suggestion.
 * @param {tutao.tutanota.ctrl.bubbleinput.Suggestion} suggestion The suggestion.
 * @param {jQuery.Event} event Not used currently.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.acceptSuggestion = function(suggestion, event) {
	var bubble = this.bubbleHandler.createBubbleFromSuggestion(suggestion);
	if (bubble) {
		this.bubbles.push(bubble);
		this.inputValue("");
		tutao.tutanota.gui.BubbleInputGui.resizeInputField(this.inputDomField, this.inputValue());
	}
	this.setInputActive();
	return true;
};

/**
 * Adds the given bubble to the bubble input field.
 * @param {tutao.tutanota.ctrl.bubbleinput.Bubble} bubble The bubble.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.addBubble = function(bubble) {
	var self = this;
	this.bubbles.push(bubble);
	setTimeout(function() {
		tutao.tutanota.gui.BubbleInputGui.resizeInputField(self.inputDomField, self.inputValue());
	}, 0);
};

/**
 * Deletes the given bubble.
 */
tutao.tutanota.ctrl.bubbleinput.BubbleInputViewModel.prototype.removeBubble = function(bubble) {
    var deletedBubble = this.bubbles.splice(this.bubbles.indexOf(bubble), 1)[0];
    this.bubbleHandler.bubbleDeleted(deletedBubble);
    tutao.tutanota.gui.BubbleInputGui.resizeInputField(this.inputDomField, this.inputValue());
};

"use strict";

tutao.provide('tutao.tutanota.ctrl.bubbleinput.Suggestion');

/**
 * Suggestions are provided to the user whenever he writes text to the input field.
 * @constructor
 */
tutao.tutanota.ctrl.bubbleinput.Suggestion = function(id, text) {
	this.id = id;
	this.text = text;
};

"use strict";

tutao.provide('tutao.entity.base.PersistenceResourcePostReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.base.PersistenceResourcePostReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._generatedId = data.generatedId;
    this._permissionListId = data.permissionListId;
  } else {
    this.__format = "0";
    this._generatedId = null;
    this._permissionListId = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.base.PersistenceResourcePostReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.base.PersistenceResourcePostReturn.MODEL_VERSION = '1';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.base.PersistenceResourcePostReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.base.PersistenceResourcePostReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    generatedId: this._generatedId, 
    permissionListId: this._permissionListId
  };
};

/**
 * The id of the PersistenceResourcePostReturn type.
 */
tutao.entity.base.PersistenceResourcePostReturn.prototype.TYPE_ID = 0;

/**
 * The id of the generatedId attribute.
 */
tutao.entity.base.PersistenceResourcePostReturn.prototype.GENERATEDID_ATTRIBUTE_ID = 2;

/**
 * The id of the permissionListId attribute.
 */
tutao.entity.base.PersistenceResourcePostReturn.prototype.PERMISSIONLISTID_ATTRIBUTE_ID = 3;

/**
 * Sets the format of this PersistenceResourcePostReturn.
 * @param {string} format The format of this PersistenceResourcePostReturn.
 */
tutao.entity.base.PersistenceResourcePostReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this PersistenceResourcePostReturn.
 * @return {string} The format of this PersistenceResourcePostReturn.
 */
tutao.entity.base.PersistenceResourcePostReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the generatedId of this PersistenceResourcePostReturn.
 * @param {string} generatedId The generatedId of this PersistenceResourcePostReturn.
 */
tutao.entity.base.PersistenceResourcePostReturn.prototype.setGeneratedId = function(generatedId) {
  this._generatedId = generatedId;
  return this;
};

/**
 * Provides the generatedId of this PersistenceResourcePostReturn.
 * @return {string} The generatedId of this PersistenceResourcePostReturn.
 */
tutao.entity.base.PersistenceResourcePostReturn.prototype.getGeneratedId = function() {
  return this._generatedId;
};

/**
 * Sets the permissionListId of this PersistenceResourcePostReturn.
 * @param {string} permissionListId The permissionListId of this PersistenceResourcePostReturn.
 */
tutao.entity.base.PersistenceResourcePostReturn.prototype.setPermissionListId = function(permissionListId) {
  this._permissionListId = permissionListId;
  return this;
};

/**
 * Provides the permissionListId of this PersistenceResourcePostReturn.
 * @return {string} The permissionListId of this PersistenceResourcePostReturn.
 */
tutao.entity.base.PersistenceResourcePostReturn.prototype.getPermissionListId = function() {
  return this._permissionListId;
};

"use strict";

tutao.provide('tutao.entity.sys.AccountingInfo');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.AccountingInfo = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._lastInvoiceNbrOfSentSms = data.lastInvoiceNbrOfSentSms;
    this._lastInvoiceTimestamp = data.lastInvoiceTimestamp;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._lastInvoiceNbrOfSentSms = null;
    this._lastInvoiceTimestamp = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.AccountingInfo.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.AccountingInfo.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.AccountingInfo.PATH = '/rest/sys/accountinginfo';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.AccountingInfo.ROOT_INSTANCE_ID = 'A3N5cwAAjw';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.AccountingInfo.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.AccountingInfo.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.AccountingInfo.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    lastInvoiceNbrOfSentSms: this._lastInvoiceNbrOfSentSms, 
    lastInvoiceTimestamp: this._lastInvoiceTimestamp
  };
};

/**
 * The id of the AccountingInfo type.
 */
tutao.entity.sys.AccountingInfo.prototype.TYPE_ID = 143;

/**
 * The id of the lastInvoiceNbrOfSentSms attribute.
 */
tutao.entity.sys.AccountingInfo.prototype.LASTINVOICENBROFSENTSMS_ATTRIBUTE_ID = 593;

/**
 * The id of the lastInvoiceTimestamp attribute.
 */
tutao.entity.sys.AccountingInfo.prototype.LASTINVOICETIMESTAMP_ATTRIBUTE_ID = 592;

/**
 * Provides the id of this AccountingInfo.
 * @return {string} The id of this AccountingInfo.
 */
tutao.entity.sys.AccountingInfo.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this AccountingInfo.
 * @param {string} format The format of this AccountingInfo.
 */
tutao.entity.sys.AccountingInfo.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this AccountingInfo.
 * @return {string} The format of this AccountingInfo.
 */
tutao.entity.sys.AccountingInfo.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this AccountingInfo.
 * @param {string} permissions The permissions of this AccountingInfo.
 */
tutao.entity.sys.AccountingInfo.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this AccountingInfo.
 * @return {string} The permissions of this AccountingInfo.
 */
tutao.entity.sys.AccountingInfo.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the lastInvoiceNbrOfSentSms of this AccountingInfo.
 * @param {string} lastInvoiceNbrOfSentSms The lastInvoiceNbrOfSentSms of this AccountingInfo.
 */
tutao.entity.sys.AccountingInfo.prototype.setLastInvoiceNbrOfSentSms = function(lastInvoiceNbrOfSentSms) {
  this._lastInvoiceNbrOfSentSms = lastInvoiceNbrOfSentSms;
  return this;
};

/**
 * Provides the lastInvoiceNbrOfSentSms of this AccountingInfo.
 * @return {string} The lastInvoiceNbrOfSentSms of this AccountingInfo.
 */
tutao.entity.sys.AccountingInfo.prototype.getLastInvoiceNbrOfSentSms = function() {
  return this._lastInvoiceNbrOfSentSms;
};

/**
 * Sets the lastInvoiceTimestamp of this AccountingInfo.
 * @param {Date} lastInvoiceTimestamp The lastInvoiceTimestamp of this AccountingInfo.
 */
tutao.entity.sys.AccountingInfo.prototype.setLastInvoiceTimestamp = function(lastInvoiceTimestamp) {
  if (lastInvoiceTimestamp == null) {
    this._lastInvoiceTimestamp = null;
  } else {
    this._lastInvoiceTimestamp = String(lastInvoiceTimestamp.getTime());
  }
  return this;
};

/**
 * Provides the lastInvoiceTimestamp of this AccountingInfo.
 * @return {Date} The lastInvoiceTimestamp of this AccountingInfo.
 */
tutao.entity.sys.AccountingInfo.prototype.getLastInvoiceTimestamp = function() {
  if (this._lastInvoiceTimestamp == null) {
    return null;
  }
  if (isNaN(this._lastInvoiceTimestamp)) {
    throw new tutao.InvalidDataError('invalid time data: ' + this._lastInvoiceTimestamp);
  }
  return new Date(Number(this._lastInvoiceTimestamp));
};

/**
 * Loads a AccountingInfo from the server.
 * @param {string} id The id of the AccountingInfo.
 * @return {Promise.<tutao.entity.sys.AccountingInfo>} Resolves to the AccountingInfo or an exception if the loading failed.
 */
tutao.entity.sys.AccountingInfo.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.AccountingInfo, tutao.entity.sys.AccountingInfo.PATH, id, null, {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity._entityHelper.loadSessionKey();
  });
};

/**
 * Loads a version of this AccountingInfo from the server.
 * @param {string} versionId The id of the requested version.
 * @return {Promise.<tutao.entity.sys.AccountingInfo>} Resolves to AccountingInfo or an exception if the loading failed.
 */
tutao.entity.sys.AccountingInfo.prototype.loadVersion = function(versionId) {
  var map = {};
  map["version"] = versionId;
  map["v"] = 4;
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.AccountingInfo, tutao.entity.sys.AccountingInfo.PATH, this.getId(), null, map, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Loads information about all versions of this AccountingInfo from the server.
 * @return {Promise.<tutao.entity.sys.VersionReturn>} Resolves to an tutao.entity.sys.VersionReturn or an exception if the loading failed.
 */
tutao.entity.sys.AccountingInfo.prototype.loadVersionInfo = function() {
  var versionData = new tutao.entity.sys.VersionData()
    .setApplication("sys")
    .setType(143)
    .setId(this.getId());
  return tutao.entity.sys.VersionReturn.load(versionData, {}, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Loads multiple AccountingInfos from the server.
 * @param {Array.<string>} ids The ids of the AccountingInfos to load.
 * @return {Promise.<Array.<tutao.entity.sys.AccountingInfo>>} Resolves to an array of AccountingInfo or rejects with an exception if the loading failed.
 */
tutao.entity.sys.AccountingInfo.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.AccountingInfo, tutao.entity.sys.AccountingInfo.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return tutao.entity.EntityHelper.loadSessionKeys(entities);
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.AccountingInfo.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.AccountingInfo.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.AuthenticatedDevice');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.AuthenticatedDevice = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._authType = data.authType;
    this._deviceKey = data.deviceKey;
    this._deviceToken = data.deviceToken;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._authType = null;
    this._deviceKey = null;
    this._deviceToken = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.AuthenticatedDevice.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.AuthenticatedDevice.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    authType: this._authType, 
    deviceKey: this._deviceKey, 
    deviceToken: this._deviceToken
  };
};

/**
 * The id of the AuthenticatedDevice type.
 */
tutao.entity.sys.AuthenticatedDevice.prototype.TYPE_ID = 43;

/**
 * The id of the authType attribute.
 */
tutao.entity.sys.AuthenticatedDevice.prototype.AUTHTYPE_ATTRIBUTE_ID = 45;

/**
 * The id of the deviceKey attribute.
 */
tutao.entity.sys.AuthenticatedDevice.prototype.DEVICEKEY_ATTRIBUTE_ID = 47;

/**
 * The id of the deviceToken attribute.
 */
tutao.entity.sys.AuthenticatedDevice.prototype.DEVICETOKEN_ATTRIBUTE_ID = 46;

/**
 * Sets the id of this AuthenticatedDevice.
 * @param {string} id The id of this AuthenticatedDevice.
 */
tutao.entity.sys.AuthenticatedDevice.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this AuthenticatedDevice.
 * @return {string} The id of this AuthenticatedDevice.
 */
tutao.entity.sys.AuthenticatedDevice.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the authType of this AuthenticatedDevice.
 * @param {string} authType The authType of this AuthenticatedDevice.
 */
tutao.entity.sys.AuthenticatedDevice.prototype.setAuthType = function(authType) {
  this._authType = authType;
  return this;
};

/**
 * Provides the authType of this AuthenticatedDevice.
 * @return {string} The authType of this AuthenticatedDevice.
 */
tutao.entity.sys.AuthenticatedDevice.prototype.getAuthType = function() {
  return this._authType;
};

/**
 * Sets the deviceKey of this AuthenticatedDevice.
 * @param {string} deviceKey The deviceKey of this AuthenticatedDevice.
 */
tutao.entity.sys.AuthenticatedDevice.prototype.setDeviceKey = function(deviceKey) {
  this._deviceKey = deviceKey;
  return this;
};

/**
 * Provides the deviceKey of this AuthenticatedDevice.
 * @return {string} The deviceKey of this AuthenticatedDevice.
 */
tutao.entity.sys.AuthenticatedDevice.prototype.getDeviceKey = function() {
  return this._deviceKey;
};

/**
 * Sets the deviceToken of this AuthenticatedDevice.
 * @param {string} deviceToken The deviceToken of this AuthenticatedDevice.
 */
tutao.entity.sys.AuthenticatedDevice.prototype.setDeviceToken = function(deviceToken) {
  this._deviceToken = deviceToken;
  return this;
};

/**
 * Provides the deviceToken of this AuthenticatedDevice.
 * @return {string} The deviceToken of this AuthenticatedDevice.
 */
tutao.entity.sys.AuthenticatedDevice.prototype.getDeviceToken = function() {
  return this._deviceToken;
};

"use strict";

tutao.provide('tutao.entity.sys.Authentication');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.Authentication = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._authVerifier = data.authVerifier;
    this._userId = data.userId;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._authVerifier = null;
    this._userId = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.Authentication.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.Authentication.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    authVerifier: this._authVerifier, 
    userId: this._userId
  };
};

/**
 * The id of the Authentication type.
 */
tutao.entity.sys.Authentication.prototype.TYPE_ID = 453;

/**
 * The id of the authVerifier attribute.
 */
tutao.entity.sys.Authentication.prototype.AUTHVERIFIER_ATTRIBUTE_ID = 456;

/**
 * The id of the userId attribute.
 */
tutao.entity.sys.Authentication.prototype.USERID_ATTRIBUTE_ID = 455;

/**
 * Sets the id of this Authentication.
 * @param {string} id The id of this Authentication.
 */
tutao.entity.sys.Authentication.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this Authentication.
 * @return {string} The id of this Authentication.
 */
tutao.entity.sys.Authentication.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the authVerifier of this Authentication.
 * @param {string} authVerifier The authVerifier of this Authentication.
 */
tutao.entity.sys.Authentication.prototype.setAuthVerifier = function(authVerifier) {
  this._authVerifier = authVerifier;
  return this;
};

/**
 * Provides the authVerifier of this Authentication.
 * @return {string} The authVerifier of this Authentication.
 */
tutao.entity.sys.Authentication.prototype.getAuthVerifier = function() {
  return this._authVerifier;
};

/**
 * Sets the userId of this Authentication.
 * @param {string} userId The userId of this Authentication.
 */
tutao.entity.sys.Authentication.prototype.setUserId = function(userId) {
  this._userId = userId;
  return this;
};

/**
 * Provides the userId of this Authentication.
 * @return {string} The userId of this Authentication.
 */
tutao.entity.sys.Authentication.prototype.getUserId = function() {
  return this._userId;
};

/**
 * Loads the userId of this Authentication.
 * @return {Promise.<tutao.entity.sys.User>} Resolves to the loaded userId of this Authentication or an exception if the loading failed.
 */
tutao.entity.sys.Authentication.prototype.loadUserId = function() {
  return tutao.entity.sys.User.load(this._userId);
};

"use strict";

tutao.provide('tutao.entity.sys.AutoLoginDataDelete');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.AutoLoginDataDelete = function(data) {
  if (data) {
    this.__format = data._format;
    this._deviceToken = data.deviceToken;
  } else {
    this.__format = "0";
    this._deviceToken = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.AutoLoginDataDelete.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.AutoLoginDataDelete.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.AutoLoginDataDelete.PATH = '/rest/sys/autologinservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.AutoLoginDataDelete.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.AutoLoginDataDelete.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    deviceToken: this._deviceToken
  };
};

/**
 * The id of the AutoLoginDataDelete type.
 */
tutao.entity.sys.AutoLoginDataDelete.prototype.TYPE_ID = 435;

/**
 * The id of the deviceToken attribute.
 */
tutao.entity.sys.AutoLoginDataDelete.prototype.DEVICETOKEN_ATTRIBUTE_ID = 437;

/**
 * Sets the format of this AutoLoginDataDelete.
 * @param {string} format The format of this AutoLoginDataDelete.
 */
tutao.entity.sys.AutoLoginDataDelete.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this AutoLoginDataDelete.
 * @return {string} The format of this AutoLoginDataDelete.
 */
tutao.entity.sys.AutoLoginDataDelete.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the deviceToken of this AutoLoginDataDelete.
 * @param {string} deviceToken The deviceToken of this AutoLoginDataDelete.
 */
tutao.entity.sys.AutoLoginDataDelete.prototype.setDeviceToken = function(deviceToken) {
  this._deviceToken = deviceToken;
  return this;
};

/**
 * Provides the deviceToken of this AutoLoginDataDelete.
 * @return {string} The deviceToken of this AutoLoginDataDelete.
 */
tutao.entity.sys.AutoLoginDataDelete.prototype.getDeviceToken = function() {
  return this._deviceToken;
};

/**
 * Invokes DELETE on a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.AutoLoginDataDelete=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.AutoLoginDataDelete.prototype.erase = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.deleteService(tutao.entity.sys.AutoLoginDataDelete.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.sys.AutoLoginDataGet');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.AutoLoginDataGet = function(data) {
  if (data) {
    this.__format = data._format;
    this._deviceToken = data.deviceToken;
    this._userId = data.userId;
  } else {
    this.__format = "0";
    this._deviceToken = null;
    this._userId = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.AutoLoginDataGet.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.AutoLoginDataGet.MODEL_VERSION = '4';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.AutoLoginDataGet.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.AutoLoginDataGet.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    deviceToken: this._deviceToken, 
    userId: this._userId
  };
};

/**
 * The id of the AutoLoginDataGet type.
 */
tutao.entity.sys.AutoLoginDataGet.prototype.TYPE_ID = 431;

/**
 * The id of the deviceToken attribute.
 */
tutao.entity.sys.AutoLoginDataGet.prototype.DEVICETOKEN_ATTRIBUTE_ID = 434;

/**
 * The id of the userId attribute.
 */
tutao.entity.sys.AutoLoginDataGet.prototype.USERID_ATTRIBUTE_ID = 433;

/**
 * Sets the format of this AutoLoginDataGet.
 * @param {string} format The format of this AutoLoginDataGet.
 */
tutao.entity.sys.AutoLoginDataGet.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this AutoLoginDataGet.
 * @return {string} The format of this AutoLoginDataGet.
 */
tutao.entity.sys.AutoLoginDataGet.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the deviceToken of this AutoLoginDataGet.
 * @param {string} deviceToken The deviceToken of this AutoLoginDataGet.
 */
tutao.entity.sys.AutoLoginDataGet.prototype.setDeviceToken = function(deviceToken) {
  this._deviceToken = deviceToken;
  return this;
};

/**
 * Provides the deviceToken of this AutoLoginDataGet.
 * @return {string} The deviceToken of this AutoLoginDataGet.
 */
tutao.entity.sys.AutoLoginDataGet.prototype.getDeviceToken = function() {
  return this._deviceToken;
};

/**
 * Sets the userId of this AutoLoginDataGet.
 * @param {string} userId The userId of this AutoLoginDataGet.
 */
tutao.entity.sys.AutoLoginDataGet.prototype.setUserId = function(userId) {
  this._userId = userId;
  return this;
};

/**
 * Provides the userId of this AutoLoginDataGet.
 * @return {string} The userId of this AutoLoginDataGet.
 */
tutao.entity.sys.AutoLoginDataGet.prototype.getUserId = function() {
  return this._userId;
};

/**
 * Loads the userId of this AutoLoginDataGet.
 * @return {Promise.<tutao.entity.sys.User>} Resolves to the loaded userId of this AutoLoginDataGet or an exception if the loading failed.
 */
tutao.entity.sys.AutoLoginDataGet.prototype.loadUserId = function() {
  return tutao.entity.sys.User.load(this._userId);
};

"use strict";

tutao.provide('tutao.entity.sys.AutoLoginDataReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.AutoLoginDataReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._deviceKey = data.deviceKey;
  } else {
    this.__format = "0";
    this._deviceKey = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.AutoLoginDataReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.AutoLoginDataReturn.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.AutoLoginDataReturn.PATH = '/rest/sys/autologinservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.AutoLoginDataReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.AutoLoginDataReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    deviceKey: this._deviceKey
  };
};

/**
 * The id of the AutoLoginDataReturn type.
 */
tutao.entity.sys.AutoLoginDataReturn.prototype.TYPE_ID = 438;

/**
 * The id of the deviceKey attribute.
 */
tutao.entity.sys.AutoLoginDataReturn.prototype.DEVICEKEY_ATTRIBUTE_ID = 440;

/**
 * Sets the format of this AutoLoginDataReturn.
 * @param {string} format The format of this AutoLoginDataReturn.
 */
tutao.entity.sys.AutoLoginDataReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this AutoLoginDataReturn.
 * @return {string} The format of this AutoLoginDataReturn.
 */
tutao.entity.sys.AutoLoginDataReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the deviceKey of this AutoLoginDataReturn.
 * @param {string} deviceKey The deviceKey of this AutoLoginDataReturn.
 */
tutao.entity.sys.AutoLoginDataReturn.prototype.setDeviceKey = function(deviceKey) {
  this._deviceKey = deviceKey;
  return this;
};

/**
 * Provides the deviceKey of this AutoLoginDataReturn.
 * @return {string} The deviceKey of this AutoLoginDataReturn.
 */
tutao.entity.sys.AutoLoginDataReturn.prototype.getDeviceKey = function() {
  return this._deviceKey;
};

/**
 * Loads from the service.
 * @param {tutao.entity.sys.AutoLoginDataGet} entity The entity to send to the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.AutoLoginDataReturn>} Resolves to AutoLoginDataReturn or an exception if the loading failed.
 */
tutao.entity.sys.AutoLoginDataReturn.load = function(entity, parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.getService(tutao.entity.sys.AutoLoginDataReturn, tutao.entity.sys.AutoLoginDataReturn.PATH, entity, parameters, headers);
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.AutoLoginPostReturn=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.AutoLoginDataReturn.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.sys.AutoLoginDataReturn.PATH, this, parameters, headers, tutao.entity.sys.AutoLoginPostReturn);
};

"use strict";

tutao.provide('tutao.entity.sys.AutoLoginPostReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.AutoLoginPostReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._deviceToken = data.deviceToken;
  } else {
    this.__format = "0";
    this._deviceToken = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.AutoLoginPostReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.AutoLoginPostReturn.MODEL_VERSION = '4';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.AutoLoginPostReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.AutoLoginPostReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    deviceToken: this._deviceToken
  };
};

/**
 * The id of the AutoLoginPostReturn type.
 */
tutao.entity.sys.AutoLoginPostReturn.prototype.TYPE_ID = 441;

/**
 * The id of the deviceToken attribute.
 */
tutao.entity.sys.AutoLoginPostReturn.prototype.DEVICETOKEN_ATTRIBUTE_ID = 443;

/**
 * Sets the format of this AutoLoginPostReturn.
 * @param {string} format The format of this AutoLoginPostReturn.
 */
tutao.entity.sys.AutoLoginPostReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this AutoLoginPostReturn.
 * @return {string} The format of this AutoLoginPostReturn.
 */
tutao.entity.sys.AutoLoginPostReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the deviceToken of this AutoLoginPostReturn.
 * @param {string} deviceToken The deviceToken of this AutoLoginPostReturn.
 */
tutao.entity.sys.AutoLoginPostReturn.prototype.setDeviceToken = function(deviceToken) {
  this._deviceToken = deviceToken;
  return this;
};

/**
 * Provides the deviceToken of this AutoLoginPostReturn.
 * @return {string} The deviceToken of this AutoLoginPostReturn.
 */
tutao.entity.sys.AutoLoginPostReturn.prototype.getDeviceToken = function() {
  return this._deviceToken;
};

"use strict";

tutao.provide('tutao.entity.sys.Bucket');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.Bucket = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._bucketPermissions = data.bucketPermissions;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._bucketPermissions = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.Bucket.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.Bucket.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    bucketPermissions: this._bucketPermissions
  };
};

/**
 * The id of the Bucket type.
 */
tutao.entity.sys.Bucket.prototype.TYPE_ID = 129;

/**
 * The id of the bucketPermissions attribute.
 */
tutao.entity.sys.Bucket.prototype.BUCKETPERMISSIONS_ATTRIBUTE_ID = 131;

/**
 * Sets the id of this Bucket.
 * @param {string} id The id of this Bucket.
 */
tutao.entity.sys.Bucket.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this Bucket.
 * @return {string} The id of this Bucket.
 */
tutao.entity.sys.Bucket.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the bucketPermissions of this Bucket.
 * @param {string} bucketPermissions The bucketPermissions of this Bucket.
 */
tutao.entity.sys.Bucket.prototype.setBucketPermissions = function(bucketPermissions) {
  this._bucketPermissions = bucketPermissions;
  return this;
};

/**
 * Provides the bucketPermissions of this Bucket.
 * @return {string} The bucketPermissions of this Bucket.
 */
tutao.entity.sys.Bucket.prototype.getBucketPermissions = function() {
  return this._bucketPermissions;
};

"use strict";

tutao.provide('tutao.entity.sys.BucketPermission');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.BucketPermission = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._ops = data.ops;
    this._pubEncBucketKey = data.pubEncBucketKey;
    this._pubKeyVersion = data.pubKeyVersion;
    this._symEncBucketKey = data.symEncBucketKey;
    this._type = data.type;
    this._group = data.group;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._ops = null;
    this._pubEncBucketKey = null;
    this._pubKeyVersion = null;
    this._symEncBucketKey = null;
    this._type = null;
    this._group = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.BucketPermission.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.BucketPermission.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.BucketPermission.PATH = '/rest/sys/bucketpermission';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.BucketPermission.ROOT_INSTANCE_ID = 'A3N5cwB2';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.BucketPermission.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.BucketPermission.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.BucketPermission.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    ops: this._ops, 
    pubEncBucketKey: this._pubEncBucketKey, 
    pubKeyVersion: this._pubKeyVersion, 
    symEncBucketKey: this._symEncBucketKey, 
    type: this._type, 
    group: this._group
  };
};

/**
 * The id of the BucketPermission type.
 */
tutao.entity.sys.BucketPermission.prototype.TYPE_ID = 118;

/**
 * The id of the ops attribute.
 */
tutao.entity.sys.BucketPermission.prototype.OPS_ATTRIBUTE_ID = 127;

/**
 * The id of the pubEncBucketKey attribute.
 */
tutao.entity.sys.BucketPermission.prototype.PUBENCBUCKETKEY_ATTRIBUTE_ID = 125;

/**
 * The id of the pubKeyVersion attribute.
 */
tutao.entity.sys.BucketPermission.prototype.PUBKEYVERSION_ATTRIBUTE_ID = 126;

/**
 * The id of the symEncBucketKey attribute.
 */
tutao.entity.sys.BucketPermission.prototype.SYMENCBUCKETKEY_ATTRIBUTE_ID = 124;

/**
 * The id of the type attribute.
 */
tutao.entity.sys.BucketPermission.prototype.TYPE_ATTRIBUTE_ID = 123;

/**
 * The id of the group attribute.
 */
tutao.entity.sys.BucketPermission.prototype.GROUP_ATTRIBUTE_ID = 128;

/**
 * Provides the id of this BucketPermission.
 * @return {Array.<string>} The id of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this BucketPermission.
 * @param {string} format The format of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this BucketPermission.
 * @return {string} The format of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this BucketPermission.
 * @param {string} permissions The permissions of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this BucketPermission.
 * @return {string} The permissions of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the ops of this BucketPermission.
 * @param {string} ops The ops of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.setOps = function(ops) {
  this._ops = ops;
  return this;
};

/**
 * Provides the ops of this BucketPermission.
 * @return {string} The ops of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.getOps = function() {
  return this._ops;
};

/**
 * Sets the pubEncBucketKey of this BucketPermission.
 * @param {string} pubEncBucketKey The pubEncBucketKey of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.setPubEncBucketKey = function(pubEncBucketKey) {
  this._pubEncBucketKey = pubEncBucketKey;
  return this;
};

/**
 * Provides the pubEncBucketKey of this BucketPermission.
 * @return {string} The pubEncBucketKey of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.getPubEncBucketKey = function() {
  return this._pubEncBucketKey;
};

/**
 * Sets the pubKeyVersion of this BucketPermission.
 * @param {string} pubKeyVersion The pubKeyVersion of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.setPubKeyVersion = function(pubKeyVersion) {
  this._pubKeyVersion = pubKeyVersion;
  return this;
};

/**
 * Provides the pubKeyVersion of this BucketPermission.
 * @return {string} The pubKeyVersion of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.getPubKeyVersion = function() {
  return this._pubKeyVersion;
};

/**
 * Sets the symEncBucketKey of this BucketPermission.
 * @param {string} symEncBucketKey The symEncBucketKey of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.setSymEncBucketKey = function(symEncBucketKey) {
  this._symEncBucketKey = symEncBucketKey;
  return this;
};

/**
 * Provides the symEncBucketKey of this BucketPermission.
 * @return {string} The symEncBucketKey of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.getSymEncBucketKey = function() {
  return this._symEncBucketKey;
};

/**
 * Sets the type of this BucketPermission.
 * @param {string} type The type of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.setType = function(type) {
  this._type = type;
  return this;
};

/**
 * Provides the type of this BucketPermission.
 * @return {string} The type of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.getType = function() {
  return this._type;
};

/**
 * Sets the group of this BucketPermission.
 * @param {string} group The group of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.setGroup = function(group) {
  this._group = group;
  return this;
};

/**
 * Provides the group of this BucketPermission.
 * @return {string} The group of this BucketPermission.
 */
tutao.entity.sys.BucketPermission.prototype.getGroup = function() {
  return this._group;
};

/**
 * Loads the group of this BucketPermission.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded group of this BucketPermission or an exception if the loading failed.
 */
tutao.entity.sys.BucketPermission.prototype.loadGroup = function() {
  return tutao.entity.sys.Group.load(this._group);
};

/**
 * Loads a BucketPermission from the server.
 * @param {Array.<string>} id The id of the BucketPermission.
 * @return {Promise.<tutao.entity.sys.BucketPermission>} Resolves to the BucketPermission or an exception if the loading failed.
 */
tutao.entity.sys.BucketPermission.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.BucketPermission, tutao.entity.sys.BucketPermission.PATH, id[1], id[0], {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple BucketPermissions from the server.
 * @param {Array.<Array.<string>>} ids The ids of the BucketPermissions to load.
 * @return {Promise.<Array.<tutao.entity.sys.BucketPermission>>} Resolves to an array of BucketPermission or rejects with an exception if the loading failed.
 */
tutao.entity.sys.BucketPermission.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.BucketPermission, tutao.entity.sys.BucketPermission.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.sys.BucketPermission.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 4;
  return tutao.locator.entityRestClient.putElement(tutao.entity.sys.BucketPermission.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Provides a  list of BucketPermissions loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.sys.BucketPermission>>} Resolves to an array of BucketPermission or rejects with an exception if the loading failed.
 */
tutao.entity.sys.BucketPermission.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.sys.BucketPermission, tutao.entity.sys.BucketPermission.PATH, listId, start, count, reverse, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.BucketPermission.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.BucketPermission.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.ChangePasswordData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.ChangePasswordData = function(data) {
  if (data) {
    this.__format = data._format;
    this._code = data.code;
    this._pwEncUserGroupKey = data.pwEncUserGroupKey;
    this._salt = data.salt;
    this._verifier = data.verifier;
  } else {
    this.__format = "0";
    this._code = null;
    this._pwEncUserGroupKey = null;
    this._salt = null;
    this._verifier = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.ChangePasswordData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.ChangePasswordData.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.ChangePasswordData.PATH = '/rest/sys/changepasswordservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.ChangePasswordData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.ChangePasswordData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    code: this._code, 
    pwEncUserGroupKey: this._pwEncUserGroupKey, 
    salt: this._salt, 
    verifier: this._verifier
  };
};

/**
 * The id of the ChangePasswordData type.
 */
tutao.entity.sys.ChangePasswordData.prototype.TYPE_ID = 534;

/**
 * The id of the code attribute.
 */
tutao.entity.sys.ChangePasswordData.prototype.CODE_ATTRIBUTE_ID = 539;

/**
 * The id of the pwEncUserGroupKey attribute.
 */
tutao.entity.sys.ChangePasswordData.prototype.PWENCUSERGROUPKEY_ATTRIBUTE_ID = 538;

/**
 * The id of the salt attribute.
 */
tutao.entity.sys.ChangePasswordData.prototype.SALT_ATTRIBUTE_ID = 537;

/**
 * The id of the verifier attribute.
 */
tutao.entity.sys.ChangePasswordData.prototype.VERIFIER_ATTRIBUTE_ID = 536;

/**
 * Sets the format of this ChangePasswordData.
 * @param {string} format The format of this ChangePasswordData.
 */
tutao.entity.sys.ChangePasswordData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this ChangePasswordData.
 * @return {string} The format of this ChangePasswordData.
 */
tutao.entity.sys.ChangePasswordData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the code of this ChangePasswordData.
 * @param {string} code The code of this ChangePasswordData.
 */
tutao.entity.sys.ChangePasswordData.prototype.setCode = function(code) {
  this._code = code;
  return this;
};

/**
 * Provides the code of this ChangePasswordData.
 * @return {string} The code of this ChangePasswordData.
 */
tutao.entity.sys.ChangePasswordData.prototype.getCode = function() {
  return this._code;
};

/**
 * Sets the pwEncUserGroupKey of this ChangePasswordData.
 * @param {string} pwEncUserGroupKey The pwEncUserGroupKey of this ChangePasswordData.
 */
tutao.entity.sys.ChangePasswordData.prototype.setPwEncUserGroupKey = function(pwEncUserGroupKey) {
  this._pwEncUserGroupKey = pwEncUserGroupKey;
  return this;
};

/**
 * Provides the pwEncUserGroupKey of this ChangePasswordData.
 * @return {string} The pwEncUserGroupKey of this ChangePasswordData.
 */
tutao.entity.sys.ChangePasswordData.prototype.getPwEncUserGroupKey = function() {
  return this._pwEncUserGroupKey;
};

/**
 * Sets the salt of this ChangePasswordData.
 * @param {string} salt The salt of this ChangePasswordData.
 */
tutao.entity.sys.ChangePasswordData.prototype.setSalt = function(salt) {
  this._salt = salt;
  return this;
};

/**
 * Provides the salt of this ChangePasswordData.
 * @return {string} The salt of this ChangePasswordData.
 */
tutao.entity.sys.ChangePasswordData.prototype.getSalt = function() {
  return this._salt;
};

/**
 * Sets the verifier of this ChangePasswordData.
 * @param {string} verifier The verifier of this ChangePasswordData.
 */
tutao.entity.sys.ChangePasswordData.prototype.setVerifier = function(verifier) {
  this._verifier = verifier;
  return this;
};

/**
 * Provides the verifier of this ChangePasswordData.
 * @return {string} The verifier of this ChangePasswordData.
 */
tutao.entity.sys.ChangePasswordData.prototype.getVerifier = function() {
  return this._verifier;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.ChangePasswordData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.sys.ChangePasswordData.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.sys.Chat');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.Chat = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._recipient = data.recipient;
    this._sender = data.sender;
    this._text = data.text;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._recipient = null;
    this._sender = null;
    this._text = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.Chat.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.Chat.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    recipient: this._recipient, 
    sender: this._sender, 
    text: this._text
  };
};

/**
 * The id of the Chat type.
 */
tutao.entity.sys.Chat.prototype.TYPE_ID = 457;

/**
 * The id of the recipient attribute.
 */
tutao.entity.sys.Chat.prototype.RECIPIENT_ATTRIBUTE_ID = 460;

/**
 * The id of the sender attribute.
 */
tutao.entity.sys.Chat.prototype.SENDER_ATTRIBUTE_ID = 459;

/**
 * The id of the text attribute.
 */
tutao.entity.sys.Chat.prototype.TEXT_ATTRIBUTE_ID = 461;

/**
 * Sets the id of this Chat.
 * @param {string} id The id of this Chat.
 */
tutao.entity.sys.Chat.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this Chat.
 * @return {string} The id of this Chat.
 */
tutao.entity.sys.Chat.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the recipient of this Chat.
 * @param {string} recipient The recipient of this Chat.
 */
tutao.entity.sys.Chat.prototype.setRecipient = function(recipient) {
  this._recipient = recipient;
  return this;
};

/**
 * Provides the recipient of this Chat.
 * @return {string} The recipient of this Chat.
 */
tutao.entity.sys.Chat.prototype.getRecipient = function() {
  return this._recipient;
};

/**
 * Sets the sender of this Chat.
 * @param {string} sender The sender of this Chat.
 */
tutao.entity.sys.Chat.prototype.setSender = function(sender) {
  this._sender = sender;
  return this;
};

/**
 * Provides the sender of this Chat.
 * @return {string} The sender of this Chat.
 */
tutao.entity.sys.Chat.prototype.getSender = function() {
  return this._sender;
};

/**
 * Sets the text of this Chat.
 * @param {string} text The text of this Chat.
 */
tutao.entity.sys.Chat.prototype.setText = function(text) {
  this._text = text;
  return this;
};

/**
 * Provides the text of this Chat.
 * @return {string} The text of this Chat.
 */
tutao.entity.sys.Chat.prototype.getText = function() {
  return this._text;
};

"use strict";

tutao.provide('tutao.entity.sys.ConfigDataReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.ConfigDataReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._longValues = [];
    for (var i=0; i < data.longValues.length; i++) {
      this._longValues.push(new tutao.entity.sys.LongConfigValue(this, data.longValues[i]));
    }
    this._stringValues = [];
    for (var i=0; i < data.stringValues.length; i++) {
      this._stringValues.push(new tutao.entity.sys.StringConfigValue(this, data.stringValues[i]));
    }
    this._timeRangeLists = [];
    for (var i=0; i < data.timeRangeLists.length; i++) {
      this._timeRangeLists.push(new tutao.entity.sys.TimeRangeListConfigValue(this, data.timeRangeLists[i]));
    }
  } else {
    this.__format = "0";
    this._longValues = [];
    this._stringValues = [];
    this._timeRangeLists = [];
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.ConfigDataReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.ConfigDataReturn.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.ConfigDataReturn.PATH = '/rest/sys/configservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.ConfigDataReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.ConfigDataReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    longValues: tutao.entity.EntityHelper.aggregatesToJsonData(this._longValues), 
    stringValues: tutao.entity.EntityHelper.aggregatesToJsonData(this._stringValues), 
    timeRangeLists: tutao.entity.EntityHelper.aggregatesToJsonData(this._timeRangeLists)
  };
};

/**
 * The id of the ConfigDataReturn type.
 */
tutao.entity.sys.ConfigDataReturn.prototype.TYPE_ID = 528;

/**
 * The id of the longValues attribute.
 */
tutao.entity.sys.ConfigDataReturn.prototype.LONGVALUES_ATTRIBUTE_ID = 530;

/**
 * The id of the stringValues attribute.
 */
tutao.entity.sys.ConfigDataReturn.prototype.STRINGVALUES_ATTRIBUTE_ID = 531;

/**
 * The id of the timeRangeLists attribute.
 */
tutao.entity.sys.ConfigDataReturn.prototype.TIMERANGELISTS_ATTRIBUTE_ID = 532;

/**
 * Sets the format of this ConfigDataReturn.
 * @param {string} format The format of this ConfigDataReturn.
 */
tutao.entity.sys.ConfigDataReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this ConfigDataReturn.
 * @return {string} The format of this ConfigDataReturn.
 */
tutao.entity.sys.ConfigDataReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Provides the longValues of this ConfigDataReturn.
 * @return {Array.<tutao.entity.sys.LongConfigValue>} The longValues of this ConfigDataReturn.
 */
tutao.entity.sys.ConfigDataReturn.prototype.getLongValues = function() {
  return this._longValues;
};

/**
 * Provides the stringValues of this ConfigDataReturn.
 * @return {Array.<tutao.entity.sys.StringConfigValue>} The stringValues of this ConfigDataReturn.
 */
tutao.entity.sys.ConfigDataReturn.prototype.getStringValues = function() {
  return this._stringValues;
};

/**
 * Provides the timeRangeLists of this ConfigDataReturn.
 * @return {Array.<tutao.entity.sys.TimeRangeListConfigValue>} The timeRangeLists of this ConfigDataReturn.
 */
tutao.entity.sys.ConfigDataReturn.prototype.getTimeRangeLists = function() {
  return this._timeRangeLists;
};

/**
 * Loads from the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.ConfigDataReturn>} Resolves to ConfigDataReturn or an exception if the loading failed.
 */
tutao.entity.sys.ConfigDataReturn.load = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.ConfigDataReturn, tutao.entity.sys.ConfigDataReturn.PATH, null, null, parameters, headers);
};

/**
 * Updates this service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.ConfigDataReturn.prototype.update = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.putService(tutao.entity.sys.ConfigDataReturn.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.sys.CreateGroupData');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.CreateGroupData = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._adminEncGKey = data.adminEncGKey;
    this._encryptedName = data.encryptedName;
    this._listEncSessionKey = data.listEncSessionKey;
    this._mailAddress = data.mailAddress;
    this._pubKey = data.pubKey;
    this._symEncGKey = data.symEncGKey;
    this._symEncPrivKey = data.symEncPrivKey;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._adminEncGKey = null;
    this._encryptedName = null;
    this._listEncSessionKey = null;
    this._mailAddress = null;
    this._pubKey = null;
    this._symEncGKey = null;
    this._symEncPrivKey = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.CreateGroupData.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.CreateGroupData.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    adminEncGKey: this._adminEncGKey, 
    encryptedName: this._encryptedName, 
    listEncSessionKey: this._listEncSessionKey, 
    mailAddress: this._mailAddress, 
    pubKey: this._pubKey, 
    symEncGKey: this._symEncGKey, 
    symEncPrivKey: this._symEncPrivKey
  };
};

/**
 * The id of the CreateGroupData type.
 */
tutao.entity.sys.CreateGroupData.prototype.TYPE_ID = 356;

/**
 * The id of the adminEncGKey attribute.
 */
tutao.entity.sys.CreateGroupData.prototype.ADMINENCGKEY_ATTRIBUTE_ID = 363;

/**
 * The id of the encryptedName attribute.
 */
tutao.entity.sys.CreateGroupData.prototype.ENCRYPTEDNAME_ATTRIBUTE_ID = 358;

/**
 * The id of the listEncSessionKey attribute.
 */
tutao.entity.sys.CreateGroupData.prototype.LISTENCSESSIONKEY_ATTRIBUTE_ID = 364;

/**
 * The id of the mailAddress attribute.
 */
tutao.entity.sys.CreateGroupData.prototype.MAILADDRESS_ATTRIBUTE_ID = 359;

/**
 * The id of the pubKey attribute.
 */
tutao.entity.sys.CreateGroupData.prototype.PUBKEY_ATTRIBUTE_ID = 360;

/**
 * The id of the symEncGKey attribute.
 */
tutao.entity.sys.CreateGroupData.prototype.SYMENCGKEY_ATTRIBUTE_ID = 362;

/**
 * The id of the symEncPrivKey attribute.
 */
tutao.entity.sys.CreateGroupData.prototype.SYMENCPRIVKEY_ATTRIBUTE_ID = 361;

/**
 * Sets the id of this CreateGroupData.
 * @param {string} id The id of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this CreateGroupData.
 * @return {string} The id of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the adminEncGKey of this CreateGroupData.
 * @param {string} adminEncGKey The adminEncGKey of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.setAdminEncGKey = function(adminEncGKey) {
  this._adminEncGKey = adminEncGKey;
  return this;
};

/**
 * Provides the adminEncGKey of this CreateGroupData.
 * @return {string} The adminEncGKey of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.getAdminEncGKey = function() {
  return this._adminEncGKey;
};

/**
 * Sets the encryptedName of this CreateGroupData.
 * @param {string} encryptedName The encryptedName of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.setEncryptedName = function(encryptedName) {
  this._encryptedName = encryptedName;
  return this;
};

/**
 * Provides the encryptedName of this CreateGroupData.
 * @return {string} The encryptedName of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.getEncryptedName = function() {
  return this._encryptedName;
};

/**
 * Sets the listEncSessionKey of this CreateGroupData.
 * @param {string} listEncSessionKey The listEncSessionKey of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.setListEncSessionKey = function(listEncSessionKey) {
  this._listEncSessionKey = listEncSessionKey;
  return this;
};

/**
 * Provides the listEncSessionKey of this CreateGroupData.
 * @return {string} The listEncSessionKey of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.getListEncSessionKey = function() {
  return this._listEncSessionKey;
};

/**
 * Sets the mailAddress of this CreateGroupData.
 * @param {string} mailAddress The mailAddress of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.setMailAddress = function(mailAddress) {
  this._mailAddress = mailAddress;
  return this;
};

/**
 * Provides the mailAddress of this CreateGroupData.
 * @return {string} The mailAddress of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.getMailAddress = function() {
  return this._mailAddress;
};

/**
 * Sets the pubKey of this CreateGroupData.
 * @param {string} pubKey The pubKey of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.setPubKey = function(pubKey) {
  this._pubKey = pubKey;
  return this;
};

/**
 * Provides the pubKey of this CreateGroupData.
 * @return {string} The pubKey of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.getPubKey = function() {
  return this._pubKey;
};

/**
 * Sets the symEncGKey of this CreateGroupData.
 * @param {string} symEncGKey The symEncGKey of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.setSymEncGKey = function(symEncGKey) {
  this._symEncGKey = symEncGKey;
  return this;
};

/**
 * Provides the symEncGKey of this CreateGroupData.
 * @return {string} The symEncGKey of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.getSymEncGKey = function() {
  return this._symEncGKey;
};

/**
 * Sets the symEncPrivKey of this CreateGroupData.
 * @param {string} symEncPrivKey The symEncPrivKey of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.setSymEncPrivKey = function(symEncPrivKey) {
  this._symEncPrivKey = symEncPrivKey;
  return this;
};

/**
 * Provides the symEncPrivKey of this CreateGroupData.
 * @return {string} The symEncPrivKey of this CreateGroupData.
 */
tutao.entity.sys.CreateGroupData.prototype.getSymEncPrivKey = function() {
  return this._symEncPrivKey;
};

"use strict";

tutao.provide('tutao.entity.sys.CreateGroupListData');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.CreateGroupListData = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._adminEncGroupInfoListKey = data.adminEncGroupInfoListKey;
    this._customerEncGroupInfoListKey = data.customerEncGroupInfoListKey;
    this._createGroupData = (data.createGroupData) ? new tutao.entity.sys.CreateGroupData(parent, data.createGroupData) : null;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._adminEncGroupInfoListKey = null;
    this._customerEncGroupInfoListKey = null;
    this._createGroupData = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.CreateGroupListData.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.CreateGroupListData.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    adminEncGroupInfoListKey: this._adminEncGroupInfoListKey, 
    customerEncGroupInfoListKey: this._customerEncGroupInfoListKey, 
    createGroupData: tutao.entity.EntityHelper.aggregatesToJsonData(this._createGroupData)
  };
};

/**
 * The id of the CreateGroupListData type.
 */
tutao.entity.sys.CreateGroupListData.prototype.TYPE_ID = 365;

/**
 * The id of the adminEncGroupInfoListKey attribute.
 */
tutao.entity.sys.CreateGroupListData.prototype.ADMINENCGROUPINFOLISTKEY_ATTRIBUTE_ID = 368;

/**
 * The id of the customerEncGroupInfoListKey attribute.
 */
tutao.entity.sys.CreateGroupListData.prototype.CUSTOMERENCGROUPINFOLISTKEY_ATTRIBUTE_ID = 367;

/**
 * The id of the createGroupData attribute.
 */
tutao.entity.sys.CreateGroupListData.prototype.CREATEGROUPDATA_ATTRIBUTE_ID = 369;

/**
 * Sets the id of this CreateGroupListData.
 * @param {string} id The id of this CreateGroupListData.
 */
tutao.entity.sys.CreateGroupListData.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this CreateGroupListData.
 * @return {string} The id of this CreateGroupListData.
 */
tutao.entity.sys.CreateGroupListData.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the adminEncGroupInfoListKey of this CreateGroupListData.
 * @param {string} adminEncGroupInfoListKey The adminEncGroupInfoListKey of this CreateGroupListData.
 */
tutao.entity.sys.CreateGroupListData.prototype.setAdminEncGroupInfoListKey = function(adminEncGroupInfoListKey) {
  this._adminEncGroupInfoListKey = adminEncGroupInfoListKey;
  return this;
};

/**
 * Provides the adminEncGroupInfoListKey of this CreateGroupListData.
 * @return {string} The adminEncGroupInfoListKey of this CreateGroupListData.
 */
tutao.entity.sys.CreateGroupListData.prototype.getAdminEncGroupInfoListKey = function() {
  return this._adminEncGroupInfoListKey;
};

/**
 * Sets the customerEncGroupInfoListKey of this CreateGroupListData.
 * @param {string} customerEncGroupInfoListKey The customerEncGroupInfoListKey of this CreateGroupListData.
 */
tutao.entity.sys.CreateGroupListData.prototype.setCustomerEncGroupInfoListKey = function(customerEncGroupInfoListKey) {
  this._customerEncGroupInfoListKey = customerEncGroupInfoListKey;
  return this;
};

/**
 * Provides the customerEncGroupInfoListKey of this CreateGroupListData.
 * @return {string} The customerEncGroupInfoListKey of this CreateGroupListData.
 */
tutao.entity.sys.CreateGroupListData.prototype.getCustomerEncGroupInfoListKey = function() {
  return this._customerEncGroupInfoListKey;
};

/**
 * Sets the createGroupData of this CreateGroupListData.
 * @param {tutao.entity.sys.CreateGroupData} createGroupData The createGroupData of this CreateGroupListData.
 */
tutao.entity.sys.CreateGroupListData.prototype.setCreateGroupData = function(createGroupData) {
  this._createGroupData = createGroupData;
  return this;
};

/**
 * Provides the createGroupData of this CreateGroupListData.
 * @return {tutao.entity.sys.CreateGroupData} The createGroupData of this CreateGroupListData.
 */
tutao.entity.sys.CreateGroupListData.prototype.getCreateGroupData = function() {
  return this._createGroupData;
};

"use strict";

tutao.provide('tutao.entity.sys.Customer');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.Customer = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._type = data.type;
    this._adminGroup = data.adminGroup;
    this._adminGroups = data.adminGroups;
    this._customerGroup = data.customerGroup;
    this._customerGroups = data.customerGroups;
    this._customerInfo = data.customerInfo;
    this._teamGroups = data.teamGroups;
    this._userGroups = data.userGroups;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._type = null;
    this._adminGroup = null;
    this._adminGroups = null;
    this._customerGroup = null;
    this._customerGroups = null;
    this._customerInfo = null;
    this._teamGroups = null;
    this._userGroups = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.Customer.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.Customer.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.Customer.PATH = '/rest/sys/customer';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.Customer.ROOT_INSTANCE_ID = 'A3N5cwAf';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.Customer.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.Customer.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.Customer.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    type: this._type, 
    adminGroup: this._adminGroup, 
    adminGroups: this._adminGroups, 
    customerGroup: this._customerGroup, 
    customerGroups: this._customerGroups, 
    customerInfo: this._customerInfo, 
    teamGroups: this._teamGroups, 
    userGroups: this._userGroups
  };
};

/**
 * The id of the Customer type.
 */
tutao.entity.sys.Customer.prototype.TYPE_ID = 31;

/**
 * The id of the type attribute.
 */
tutao.entity.sys.Customer.prototype.TYPE_ATTRIBUTE_ID = 36;

/**
 * The id of the adminGroup attribute.
 */
tutao.entity.sys.Customer.prototype.ADMINGROUP_ATTRIBUTE_ID = 37;

/**
 * The id of the adminGroups attribute.
 */
tutao.entity.sys.Customer.prototype.ADMINGROUPS_ATTRIBUTE_ID = 39;

/**
 * The id of the customerGroup attribute.
 */
tutao.entity.sys.Customer.prototype.CUSTOMERGROUP_ATTRIBUTE_ID = 38;

/**
 * The id of the customerGroups attribute.
 */
tutao.entity.sys.Customer.prototype.CUSTOMERGROUPS_ATTRIBUTE_ID = 40;

/**
 * The id of the customerInfo attribute.
 */
tutao.entity.sys.Customer.prototype.CUSTOMERINFO_ATTRIBUTE_ID = 160;

/**
 * The id of the teamGroups attribute.
 */
tutao.entity.sys.Customer.prototype.TEAMGROUPS_ATTRIBUTE_ID = 42;

/**
 * The id of the userGroups attribute.
 */
tutao.entity.sys.Customer.prototype.USERGROUPS_ATTRIBUTE_ID = 41;

/**
 * Provides the id of this Customer.
 * @return {string} The id of this Customer.
 */
tutao.entity.sys.Customer.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this Customer.
 * @param {string} format The format of this Customer.
 */
tutao.entity.sys.Customer.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this Customer.
 * @return {string} The format of this Customer.
 */
tutao.entity.sys.Customer.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this Customer.
 * @param {string} permissions The permissions of this Customer.
 */
tutao.entity.sys.Customer.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this Customer.
 * @return {string} The permissions of this Customer.
 */
tutao.entity.sys.Customer.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the type of this Customer.
 * @param {string} type The type of this Customer.
 */
tutao.entity.sys.Customer.prototype.setType = function(type) {
  this._type = type;
  return this;
};

/**
 * Provides the type of this Customer.
 * @return {string} The type of this Customer.
 */
tutao.entity.sys.Customer.prototype.getType = function() {
  return this._type;
};

/**
 * Sets the adminGroup of this Customer.
 * @param {string} adminGroup The adminGroup of this Customer.
 */
tutao.entity.sys.Customer.prototype.setAdminGroup = function(adminGroup) {
  this._adminGroup = adminGroup;
  return this;
};

/**
 * Provides the adminGroup of this Customer.
 * @return {string} The adminGroup of this Customer.
 */
tutao.entity.sys.Customer.prototype.getAdminGroup = function() {
  return this._adminGroup;
};

/**
 * Loads the adminGroup of this Customer.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded adminGroup of this Customer or an exception if the loading failed.
 */
tutao.entity.sys.Customer.prototype.loadAdminGroup = function() {
  return tutao.entity.sys.Group.load(this._adminGroup);
};

/**
 * Sets the adminGroups of this Customer.
 * @param {string} adminGroups The adminGroups of this Customer.
 */
tutao.entity.sys.Customer.prototype.setAdminGroups = function(adminGroups) {
  this._adminGroups = adminGroups;
  return this;
};

/**
 * Provides the adminGroups of this Customer.
 * @return {string} The adminGroups of this Customer.
 */
tutao.entity.sys.Customer.prototype.getAdminGroups = function() {
  return this._adminGroups;
};

/**
 * Sets the customerGroup of this Customer.
 * @param {string} customerGroup The customerGroup of this Customer.
 */
tutao.entity.sys.Customer.prototype.setCustomerGroup = function(customerGroup) {
  this._customerGroup = customerGroup;
  return this;
};

/**
 * Provides the customerGroup of this Customer.
 * @return {string} The customerGroup of this Customer.
 */
tutao.entity.sys.Customer.prototype.getCustomerGroup = function() {
  return this._customerGroup;
};

/**
 * Loads the customerGroup of this Customer.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded customerGroup of this Customer or an exception if the loading failed.
 */
tutao.entity.sys.Customer.prototype.loadCustomerGroup = function() {
  return tutao.entity.sys.Group.load(this._customerGroup);
};

/**
 * Sets the customerGroups of this Customer.
 * @param {string} customerGroups The customerGroups of this Customer.
 */
tutao.entity.sys.Customer.prototype.setCustomerGroups = function(customerGroups) {
  this._customerGroups = customerGroups;
  return this;
};

/**
 * Provides the customerGroups of this Customer.
 * @return {string} The customerGroups of this Customer.
 */
tutao.entity.sys.Customer.prototype.getCustomerGroups = function() {
  return this._customerGroups;
};

/**
 * Sets the customerInfo of this Customer.
 * @param {Array.<string>} customerInfo The customerInfo of this Customer.
 */
tutao.entity.sys.Customer.prototype.setCustomerInfo = function(customerInfo) {
  this._customerInfo = customerInfo;
  return this;
};

/**
 * Provides the customerInfo of this Customer.
 * @return {Array.<string>} The customerInfo of this Customer.
 */
tutao.entity.sys.Customer.prototype.getCustomerInfo = function() {
  return this._customerInfo;
};

/**
 * Loads the customerInfo of this Customer.
 * @return {Promise.<tutao.entity.sys.CustomerInfo>} Resolves to the loaded customerInfo of this Customer or an exception if the loading failed.
 */
tutao.entity.sys.Customer.prototype.loadCustomerInfo = function() {
  return tutao.entity.sys.CustomerInfo.load(this._customerInfo);
};

/**
 * Sets the teamGroups of this Customer.
 * @param {string} teamGroups The teamGroups of this Customer.
 */
tutao.entity.sys.Customer.prototype.setTeamGroups = function(teamGroups) {
  this._teamGroups = teamGroups;
  return this;
};

/**
 * Provides the teamGroups of this Customer.
 * @return {string} The teamGroups of this Customer.
 */
tutao.entity.sys.Customer.prototype.getTeamGroups = function() {
  return this._teamGroups;
};

/**
 * Sets the userGroups of this Customer.
 * @param {string} userGroups The userGroups of this Customer.
 */
tutao.entity.sys.Customer.prototype.setUserGroups = function(userGroups) {
  this._userGroups = userGroups;
  return this;
};

/**
 * Provides the userGroups of this Customer.
 * @return {string} The userGroups of this Customer.
 */
tutao.entity.sys.Customer.prototype.getUserGroups = function() {
  return this._userGroups;
};

/**
 * Loads a Customer from the server.
 * @param {string} id The id of the Customer.
 * @return {Promise.<tutao.entity.sys.Customer>} Resolves to the Customer or an exception if the loading failed.
 */
tutao.entity.sys.Customer.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.Customer, tutao.entity.sys.Customer.PATH, id, null, {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple Customers from the server.
 * @param {Array.<string>} ids The ids of the Customers to load.
 * @return {Promise.<Array.<tutao.entity.sys.Customer>>} Resolves to an array of Customer or rejects with an exception if the loading failed.
 */
tutao.entity.sys.Customer.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.Customer, tutao.entity.sys.Customer.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.Customer.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.Customer.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.CustomerData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.CustomerData = function(data) {
  if (data) {
    this.__format = data._format;
    this._accountingInfoBucketEncAccountingInfoSessionKey = data.accountingInfoBucketEncAccountingInfoSessionKey;
    this._adminEncAccountingInfoSessionKey = data.adminEncAccountingInfoSessionKey;
    this._authToken = data.authToken;
    this._company = data.company;
    this._domain = data.domain;
    this._salt = data.salt;
    this._symEncAccountGroupKey = data.symEncAccountGroupKey;
    this._systemCustomerPubEncAccountingInfoBucketKey = data.systemCustomerPubEncAccountingInfoBucketKey;
    this._systemCustomerPubKeyVersion = data.systemCustomerPubKeyVersion;
    this._userEncClientKey = data.userEncClientKey;
    this._verifier = data.verifier;
    this._adminGroupList = (data.adminGroupList) ? new tutao.entity.sys.CreateGroupListData(this, data.adminGroupList) : null;
    this._customerGroupList = (data.customerGroupList) ? new tutao.entity.sys.CreateGroupListData(this, data.customerGroupList) : null;
    this._teamGroupList = (data.teamGroupList) ? new tutao.entity.sys.CreateGroupListData(this, data.teamGroupList) : null;
    this._userGroupList = (data.userGroupList) ? new tutao.entity.sys.CreateGroupListData(this, data.userGroupList) : null;
  } else {
    this.__format = "0";
    this._accountingInfoBucketEncAccountingInfoSessionKey = null;
    this._adminEncAccountingInfoSessionKey = null;
    this._authToken = null;
    this._company = null;
    this._domain = null;
    this._salt = null;
    this._symEncAccountGroupKey = null;
    this._systemCustomerPubEncAccountingInfoBucketKey = null;
    this._systemCustomerPubKeyVersion = null;
    this._userEncClientKey = null;
    this._verifier = null;
    this._adminGroupList = null;
    this._customerGroupList = null;
    this._teamGroupList = null;
    this._userGroupList = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.CustomerData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.CustomerData.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.CustomerData.PATH = '/rest/sys/customerservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.CustomerData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.CustomerData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    accountingInfoBucketEncAccountingInfoSessionKey: this._accountingInfoBucketEncAccountingInfoSessionKey, 
    adminEncAccountingInfoSessionKey: this._adminEncAccountingInfoSessionKey, 
    authToken: this._authToken, 
    company: this._company, 
    domain: this._domain, 
    salt: this._salt, 
    symEncAccountGroupKey: this._symEncAccountGroupKey, 
    systemCustomerPubEncAccountingInfoBucketKey: this._systemCustomerPubEncAccountingInfoBucketKey, 
    systemCustomerPubKeyVersion: this._systemCustomerPubKeyVersion, 
    userEncClientKey: this._userEncClientKey, 
    verifier: this._verifier, 
    adminGroupList: tutao.entity.EntityHelper.aggregatesToJsonData(this._adminGroupList), 
    customerGroupList: tutao.entity.EntityHelper.aggregatesToJsonData(this._customerGroupList), 
    teamGroupList: tutao.entity.EntityHelper.aggregatesToJsonData(this._teamGroupList), 
    userGroupList: tutao.entity.EntityHelper.aggregatesToJsonData(this._userGroupList)
  };
};

/**
 * The id of the CustomerData type.
 */
tutao.entity.sys.CustomerData.prototype.TYPE_ID = 374;

/**
 * The id of the accountingInfoBucketEncAccountingInfoSessionKey attribute.
 */
tutao.entity.sys.CustomerData.prototype.ACCOUNTINGINFOBUCKETENCACCOUNTINGINFOSESSIONKEY_ATTRIBUTE_ID = 385;

/**
 * The id of the adminEncAccountingInfoSessionKey attribute.
 */
tutao.entity.sys.CustomerData.prototype.ADMINENCACCOUNTINGINFOSESSIONKEY_ATTRIBUTE_ID = 383;

/**
 * The id of the authToken attribute.
 */
tutao.entity.sys.CustomerData.prototype.AUTHTOKEN_ATTRIBUTE_ID = 376;

/**
 * The id of the company attribute.
 */
tutao.entity.sys.CustomerData.prototype.COMPANY_ATTRIBUTE_ID = 377;

/**
 * The id of the domain attribute.
 */
tutao.entity.sys.CustomerData.prototype.DOMAIN_ATTRIBUTE_ID = 378;

/**
 * The id of the salt attribute.
 */
tutao.entity.sys.CustomerData.prototype.SALT_ATTRIBUTE_ID = 388;

/**
 * The id of the symEncAccountGroupKey attribute.
 */
tutao.entity.sys.CustomerData.prototype.SYMENCACCOUNTGROUPKEY_ATTRIBUTE_ID = 390;

/**
 * The id of the systemCustomerPubEncAccountingInfoBucketKey attribute.
 */
tutao.entity.sys.CustomerData.prototype.SYSTEMCUSTOMERPUBENCACCOUNTINGINFOBUCKETKEY_ATTRIBUTE_ID = 386;

/**
 * The id of the systemCustomerPubKeyVersion attribute.
 */
tutao.entity.sys.CustomerData.prototype.SYSTEMCUSTOMERPUBKEYVERSION_ATTRIBUTE_ID = 387;

/**
 * The id of the userEncClientKey attribute.
 */
tutao.entity.sys.CustomerData.prototype.USERENCCLIENTKEY_ATTRIBUTE_ID = 384;

/**
 * The id of the verifier attribute.
 */
tutao.entity.sys.CustomerData.prototype.VERIFIER_ATTRIBUTE_ID = 389;

/**
 * The id of the adminGroupList attribute.
 */
tutao.entity.sys.CustomerData.prototype.ADMINGROUPLIST_ATTRIBUTE_ID = 379;

/**
 * The id of the customerGroupList attribute.
 */
tutao.entity.sys.CustomerData.prototype.CUSTOMERGROUPLIST_ATTRIBUTE_ID = 381;

/**
 * The id of the teamGroupList attribute.
 */
tutao.entity.sys.CustomerData.prototype.TEAMGROUPLIST_ATTRIBUTE_ID = 382;

/**
 * The id of the userGroupList attribute.
 */
tutao.entity.sys.CustomerData.prototype.USERGROUPLIST_ATTRIBUTE_ID = 380;

/**
 * Sets the format of this CustomerData.
 * @param {string} format The format of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this CustomerData.
 * @return {string} The format of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the accountingInfoBucketEncAccountingInfoSessionKey of this CustomerData.
 * @param {string} accountingInfoBucketEncAccountingInfoSessionKey The accountingInfoBucketEncAccountingInfoSessionKey of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setAccountingInfoBucketEncAccountingInfoSessionKey = function(accountingInfoBucketEncAccountingInfoSessionKey) {
  this._accountingInfoBucketEncAccountingInfoSessionKey = accountingInfoBucketEncAccountingInfoSessionKey;
  return this;
};

/**
 * Provides the accountingInfoBucketEncAccountingInfoSessionKey of this CustomerData.
 * @return {string} The accountingInfoBucketEncAccountingInfoSessionKey of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getAccountingInfoBucketEncAccountingInfoSessionKey = function() {
  return this._accountingInfoBucketEncAccountingInfoSessionKey;
};

/**
 * Sets the adminEncAccountingInfoSessionKey of this CustomerData.
 * @param {string} adminEncAccountingInfoSessionKey The adminEncAccountingInfoSessionKey of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setAdminEncAccountingInfoSessionKey = function(adminEncAccountingInfoSessionKey) {
  this._adminEncAccountingInfoSessionKey = adminEncAccountingInfoSessionKey;
  return this;
};

/**
 * Provides the adminEncAccountingInfoSessionKey of this CustomerData.
 * @return {string} The adminEncAccountingInfoSessionKey of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getAdminEncAccountingInfoSessionKey = function() {
  return this._adminEncAccountingInfoSessionKey;
};

/**
 * Sets the authToken of this CustomerData.
 * @param {string} authToken The authToken of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setAuthToken = function(authToken) {
  this._authToken = authToken;
  return this;
};

/**
 * Provides the authToken of this CustomerData.
 * @return {string} The authToken of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getAuthToken = function() {
  return this._authToken;
};

/**
 * Sets the company of this CustomerData.
 * @param {string} company The company of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setCompany = function(company) {
  this._company = company;
  return this;
};

/**
 * Provides the company of this CustomerData.
 * @return {string} The company of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getCompany = function() {
  return this._company;
};

/**
 * Sets the domain of this CustomerData.
 * @param {string} domain The domain of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setDomain = function(domain) {
  this._domain = domain;
  return this;
};

/**
 * Provides the domain of this CustomerData.
 * @return {string} The domain of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getDomain = function() {
  return this._domain;
};

/**
 * Sets the salt of this CustomerData.
 * @param {string} salt The salt of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setSalt = function(salt) {
  this._salt = salt;
  return this;
};

/**
 * Provides the salt of this CustomerData.
 * @return {string} The salt of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getSalt = function() {
  return this._salt;
};

/**
 * Sets the symEncAccountGroupKey of this CustomerData.
 * @param {string} symEncAccountGroupKey The symEncAccountGroupKey of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setSymEncAccountGroupKey = function(symEncAccountGroupKey) {
  this._symEncAccountGroupKey = symEncAccountGroupKey;
  return this;
};

/**
 * Provides the symEncAccountGroupKey of this CustomerData.
 * @return {string} The symEncAccountGroupKey of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getSymEncAccountGroupKey = function() {
  return this._symEncAccountGroupKey;
};

/**
 * Sets the systemCustomerPubEncAccountingInfoBucketKey of this CustomerData.
 * @param {string} systemCustomerPubEncAccountingInfoBucketKey The systemCustomerPubEncAccountingInfoBucketKey of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setSystemCustomerPubEncAccountingInfoBucketKey = function(systemCustomerPubEncAccountingInfoBucketKey) {
  this._systemCustomerPubEncAccountingInfoBucketKey = systemCustomerPubEncAccountingInfoBucketKey;
  return this;
};

/**
 * Provides the systemCustomerPubEncAccountingInfoBucketKey of this CustomerData.
 * @return {string} The systemCustomerPubEncAccountingInfoBucketKey of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getSystemCustomerPubEncAccountingInfoBucketKey = function() {
  return this._systemCustomerPubEncAccountingInfoBucketKey;
};

/**
 * Sets the systemCustomerPubKeyVersion of this CustomerData.
 * @param {string} systemCustomerPubKeyVersion The systemCustomerPubKeyVersion of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setSystemCustomerPubKeyVersion = function(systemCustomerPubKeyVersion) {
  this._systemCustomerPubKeyVersion = systemCustomerPubKeyVersion;
  return this;
};

/**
 * Provides the systemCustomerPubKeyVersion of this CustomerData.
 * @return {string} The systemCustomerPubKeyVersion of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getSystemCustomerPubKeyVersion = function() {
  return this._systemCustomerPubKeyVersion;
};

/**
 * Sets the userEncClientKey of this CustomerData.
 * @param {string} userEncClientKey The userEncClientKey of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setUserEncClientKey = function(userEncClientKey) {
  this._userEncClientKey = userEncClientKey;
  return this;
};

/**
 * Provides the userEncClientKey of this CustomerData.
 * @return {string} The userEncClientKey of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getUserEncClientKey = function() {
  return this._userEncClientKey;
};

/**
 * Sets the verifier of this CustomerData.
 * @param {string} verifier The verifier of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setVerifier = function(verifier) {
  this._verifier = verifier;
  return this;
};

/**
 * Provides the verifier of this CustomerData.
 * @return {string} The verifier of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getVerifier = function() {
  return this._verifier;
};

/**
 * Sets the adminGroupList of this CustomerData.
 * @param {tutao.entity.sys.CreateGroupListData} adminGroupList The adminGroupList of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setAdminGroupList = function(adminGroupList) {
  this._adminGroupList = adminGroupList;
  return this;
};

/**
 * Provides the adminGroupList of this CustomerData.
 * @return {tutao.entity.sys.CreateGroupListData} The adminGroupList of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getAdminGroupList = function() {
  return this._adminGroupList;
};

/**
 * Sets the customerGroupList of this CustomerData.
 * @param {tutao.entity.sys.CreateGroupListData} customerGroupList The customerGroupList of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setCustomerGroupList = function(customerGroupList) {
  this._customerGroupList = customerGroupList;
  return this;
};

/**
 * Provides the customerGroupList of this CustomerData.
 * @return {tutao.entity.sys.CreateGroupListData} The customerGroupList of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getCustomerGroupList = function() {
  return this._customerGroupList;
};

/**
 * Sets the teamGroupList of this CustomerData.
 * @param {tutao.entity.sys.CreateGroupListData} teamGroupList The teamGroupList of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setTeamGroupList = function(teamGroupList) {
  this._teamGroupList = teamGroupList;
  return this;
};

/**
 * Provides the teamGroupList of this CustomerData.
 * @return {tutao.entity.sys.CreateGroupListData} The teamGroupList of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getTeamGroupList = function() {
  return this._teamGroupList;
};

/**
 * Sets the userGroupList of this CustomerData.
 * @param {tutao.entity.sys.CreateGroupListData} userGroupList The userGroupList of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.setUserGroupList = function(userGroupList) {
  this._userGroupList = userGroupList;
  return this;
};

/**
 * Provides the userGroupList of this CustomerData.
 * @return {tutao.entity.sys.CreateGroupListData} The userGroupList of this CustomerData.
 */
tutao.entity.sys.CustomerData.prototype.getUserGroupList = function() {
  return this._userGroupList;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.CustomerReturn=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.CustomerData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.sys.CustomerData.PATH, this, parameters, headers, tutao.entity.sys.CustomerReturn);
};

"use strict";

tutao.provide('tutao.entity.sys.CustomerInfo');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.CustomerInfo = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._activationTime = data.activationTime;
    this._company = data.company;
    this._creationTime = data.creationTime;
    this._domain = data.domain;
    this._registrationMailAddress = data.registrationMailAddress;
    this._testEndTime = data.testEndTime;
    this._accountingInfo = data.accountingInfo;
    this._customer = data.customer;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._activationTime = null;
    this._company = null;
    this._creationTime = null;
    this._domain = null;
    this._registrationMailAddress = null;
    this._testEndTime = null;
    this._accountingInfo = null;
    this._customer = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.CustomerInfo.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.CustomerInfo.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.CustomerInfo.PATH = '/rest/sys/customerinfo';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.CustomerInfo.ROOT_INSTANCE_ID = 'A3N5cwAAlA';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.CustomerInfo.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.CustomerInfo.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.CustomerInfo.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    activationTime: this._activationTime, 
    company: this._company, 
    creationTime: this._creationTime, 
    domain: this._domain, 
    registrationMailAddress: this._registrationMailAddress, 
    testEndTime: this._testEndTime, 
    accountingInfo: this._accountingInfo, 
    customer: this._customer
  };
};

/**
 * The id of the CustomerInfo type.
 */
tutao.entity.sys.CustomerInfo.prototype.TYPE_ID = 148;

/**
 * The id of the activationTime attribute.
 */
tutao.entity.sys.CustomerInfo.prototype.ACTIVATIONTIME_ATTRIBUTE_ID = 157;

/**
 * The id of the company attribute.
 */
tutao.entity.sys.CustomerInfo.prototype.COMPANY_ATTRIBUTE_ID = 153;

/**
 * The id of the creationTime attribute.
 */
tutao.entity.sys.CustomerInfo.prototype.CREATIONTIME_ATTRIBUTE_ID = 155;

/**
 * The id of the domain attribute.
 */
tutao.entity.sys.CustomerInfo.prototype.DOMAIN_ATTRIBUTE_ID = 154;

/**
 * The id of the registrationMailAddress attribute.
 */
tutao.entity.sys.CustomerInfo.prototype.REGISTRATIONMAILADDRESS_ATTRIBUTE_ID = 597;

/**
 * The id of the testEndTime attribute.
 */
tutao.entity.sys.CustomerInfo.prototype.TESTENDTIME_ATTRIBUTE_ID = 156;

/**
 * The id of the accountingInfo attribute.
 */
tutao.entity.sys.CustomerInfo.prototype.ACCOUNTINGINFO_ATTRIBUTE_ID = 159;

/**
 * The id of the customer attribute.
 */
tutao.entity.sys.CustomerInfo.prototype.CUSTOMER_ATTRIBUTE_ID = 158;

/**
 * Provides the id of this CustomerInfo.
 * @return {Array.<string>} The id of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this CustomerInfo.
 * @param {string} format The format of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this CustomerInfo.
 * @return {string} The format of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this CustomerInfo.
 * @param {string} permissions The permissions of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this CustomerInfo.
 * @return {string} The permissions of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the activationTime of this CustomerInfo.
 * @param {Date} activationTime The activationTime of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.setActivationTime = function(activationTime) {
  if (activationTime == null) {
    this._activationTime = null;
  } else {
    this._activationTime = String(activationTime.getTime());
  }
  return this;
};

/**
 * Provides the activationTime of this CustomerInfo.
 * @return {Date} The activationTime of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.getActivationTime = function() {
  if (this._activationTime == null) {
    return null;
  }
  if (isNaN(this._activationTime)) {
    throw new tutao.InvalidDataError('invalid time data: ' + this._activationTime);
  }
  return new Date(Number(this._activationTime));
};

/**
 * Sets the company of this CustomerInfo.
 * @param {string} company The company of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.setCompany = function(company) {
  this._company = company;
  return this;
};

/**
 * Provides the company of this CustomerInfo.
 * @return {string} The company of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.getCompany = function() {
  return this._company;
};

/**
 * Sets the creationTime of this CustomerInfo.
 * @param {Date} creationTime The creationTime of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.setCreationTime = function(creationTime) {
  this._creationTime = String(creationTime.getTime());
  return this;
};

/**
 * Provides the creationTime of this CustomerInfo.
 * @return {Date} The creationTime of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.getCreationTime = function() {
  if (isNaN(this._creationTime)) {
    throw new tutao.InvalidDataError('invalid time data: ' + this._creationTime);
  }
  return new Date(Number(this._creationTime));
};

/**
 * Sets the domain of this CustomerInfo.
 * @param {string} domain The domain of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.setDomain = function(domain) {
  this._domain = domain;
  return this;
};

/**
 * Provides the domain of this CustomerInfo.
 * @return {string} The domain of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.getDomain = function() {
  return this._domain;
};

/**
 * Sets the registrationMailAddress of this CustomerInfo.
 * @param {string} registrationMailAddress The registrationMailAddress of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.setRegistrationMailAddress = function(registrationMailAddress) {
  this._registrationMailAddress = registrationMailAddress;
  return this;
};

/**
 * Provides the registrationMailAddress of this CustomerInfo.
 * @return {string} The registrationMailAddress of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.getRegistrationMailAddress = function() {
  return this._registrationMailAddress;
};

/**
 * Sets the testEndTime of this CustomerInfo.
 * @param {Date} testEndTime The testEndTime of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.setTestEndTime = function(testEndTime) {
  if (testEndTime == null) {
    this._testEndTime = null;
  } else {
    this._testEndTime = String(testEndTime.getTime());
  }
  return this;
};

/**
 * Provides the testEndTime of this CustomerInfo.
 * @return {Date} The testEndTime of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.getTestEndTime = function() {
  if (this._testEndTime == null) {
    return null;
  }
  if (isNaN(this._testEndTime)) {
    throw new tutao.InvalidDataError('invalid time data: ' + this._testEndTime);
  }
  return new Date(Number(this._testEndTime));
};

/**
 * Sets the accountingInfo of this CustomerInfo.
 * @param {string} accountingInfo The accountingInfo of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.setAccountingInfo = function(accountingInfo) {
  this._accountingInfo = accountingInfo;
  return this;
};

/**
 * Provides the accountingInfo of this CustomerInfo.
 * @return {string} The accountingInfo of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.getAccountingInfo = function() {
  return this._accountingInfo;
};

/**
 * Loads the accountingInfo of this CustomerInfo.
 * @return {Promise.<tutao.entity.sys.AccountingInfo>} Resolves to the loaded accountingInfo of this CustomerInfo or an exception if the loading failed.
 */
tutao.entity.sys.CustomerInfo.prototype.loadAccountingInfo = function() {
  return tutao.entity.sys.AccountingInfo.load(this._accountingInfo);
};

/**
 * Sets the customer of this CustomerInfo.
 * @param {string} customer The customer of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.setCustomer = function(customer) {
  this._customer = customer;
  return this;
};

/**
 * Provides the customer of this CustomerInfo.
 * @return {string} The customer of this CustomerInfo.
 */
tutao.entity.sys.CustomerInfo.prototype.getCustomer = function() {
  return this._customer;
};

/**
 * Loads the customer of this CustomerInfo.
 * @return {Promise.<tutao.entity.sys.Customer>} Resolves to the loaded customer of this CustomerInfo or an exception if the loading failed.
 */
tutao.entity.sys.CustomerInfo.prototype.loadCustomer = function() {
  return tutao.entity.sys.Customer.load(this._customer);
};

/**
 * Loads a CustomerInfo from the server.
 * @param {Array.<string>} id The id of the CustomerInfo.
 * @return {Promise.<tutao.entity.sys.CustomerInfo>} Resolves to the CustomerInfo or an exception if the loading failed.
 */
tutao.entity.sys.CustomerInfo.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.CustomerInfo, tutao.entity.sys.CustomerInfo.PATH, id[1], id[0], {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple CustomerInfos from the server.
 * @param {Array.<Array.<string>>} ids The ids of the CustomerInfos to load.
 * @return {Promise.<Array.<tutao.entity.sys.CustomerInfo>>} Resolves to an array of CustomerInfo or rejects with an exception if the loading failed.
 */
tutao.entity.sys.CustomerInfo.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.CustomerInfo, tutao.entity.sys.CustomerInfo.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.sys.CustomerInfo.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 4;
  return tutao.locator.entityRestClient.putElement(tutao.entity.sys.CustomerInfo.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Updates this CustomerInfo on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.sys.CustomerInfo.prototype.update = function() {
  var self = this;
  return tutao.locator.entityRestClient.putElement(tutao.entity.sys.CustomerInfo.PATH, this, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function() {
    self._entityHelper.notifyObservers(false);
  });
};

/**
 * Provides a  list of CustomerInfos loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.sys.CustomerInfo>>} Resolves to an array of CustomerInfo or rejects with an exception if the loading failed.
 */
tutao.entity.sys.CustomerInfo.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.sys.CustomerInfo, tutao.entity.sys.CustomerInfo.PATH, listId, start, count, reverse, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.CustomerInfo.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.CustomerInfo.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.CustomerInfoEditable');

/**
 * Provides a knockout observable mechanism for a CustomerInfo.
 * @param {tutao.entity.sys.CustomerInfo} customerinfo The actual CustomerInfo.
 * @constructor
 */
tutao.entity.sys.CustomerInfoEditable = function(customerinfo) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	this._entity = customerinfo;
	this.activationTime = ko.observable(customerinfo.getActivationTime());
	this.company = ko.observable(customerinfo.getCompany());
	this.creationTime = ko.observable(customerinfo.getCreationTime());
	this.domain = ko.observable(customerinfo.getDomain());
	this.registrationMailAddress = ko.observable(customerinfo.getRegistrationMailAddress());
	this.testEndTime = ko.observable(customerinfo.getTestEndTime());

	this.lastUpdatedTimestamp = ko.observable(null);

	if (tutao.entity.sys.CustomerInfoExtension) {
		tutao.entity.sys.CustomerInfoExtension(this);
	}
};

/**
 * Provides the actual CustomerInfo.
 * @return {tutao.entity.sys.CustomerInfo} The CustomerInfo.
 */
tutao.entity.sys.CustomerInfoEditable.prototype.getCustomerInfo = function() {
	return this._entity;
};

/**
 * Updates the underlying CustomerInfo with the modified attributes.
 */
tutao.entity.sys.CustomerInfoEditable.prototype.update = function() {
	this._entity.setActivationTime(this.activationTime());
	this._entity.setCompany(this.company());
	this._entity.setCreationTime(this.creationTime());
	this._entity.setDomain(this.domain());
	this._entity.setRegistrationMailAddress(this.registrationMailAddress());
	this._entity.setTestEndTime(this.testEndTime());
	this.lastUpdatedTimestamp(new Date().getTime());
};

"use strict";

tutao.provide('tutao.entity.sys.CustomerInfoReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.CustomerInfoReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._sendMailDisabled = data.sendMailDisabled;
  } else {
    this.__format = "0";
    this._sendMailDisabled = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.CustomerInfoReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.CustomerInfoReturn.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.CustomerInfoReturn.PATH = '/rest/sys/customerinfoservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.CustomerInfoReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.CustomerInfoReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    sendMailDisabled: this._sendMailDisabled
  };
};

/**
 * The id of the CustomerInfoReturn type.
 */
tutao.entity.sys.CustomerInfoReturn.prototype.TYPE_ID = 550;

/**
 * The id of the sendMailDisabled attribute.
 */
tutao.entity.sys.CustomerInfoReturn.prototype.SENDMAILDISABLED_ATTRIBUTE_ID = 552;

/**
 * Sets the format of this CustomerInfoReturn.
 * @param {string} format The format of this CustomerInfoReturn.
 */
tutao.entity.sys.CustomerInfoReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this CustomerInfoReturn.
 * @return {string} The format of this CustomerInfoReturn.
 */
tutao.entity.sys.CustomerInfoReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the sendMailDisabled of this CustomerInfoReturn.
 * @param {boolean} sendMailDisabled The sendMailDisabled of this CustomerInfoReturn.
 */
tutao.entity.sys.CustomerInfoReturn.prototype.setSendMailDisabled = function(sendMailDisabled) {
  this._sendMailDisabled = sendMailDisabled ? '1' : '0';
  return this;
};

/**
 * Provides the sendMailDisabled of this CustomerInfoReturn.
 * @return {boolean} The sendMailDisabled of this CustomerInfoReturn.
 */
tutao.entity.sys.CustomerInfoReturn.prototype.getSendMailDisabled = function() {
  return this._sendMailDisabled == '1';
};

/**
 * Loads from the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.CustomerInfoReturn>} Resolves to CustomerInfoReturn or an exception if the loading failed.
 */
tutao.entity.sys.CustomerInfoReturn.load = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.CustomerInfoReturn, tutao.entity.sys.CustomerInfoReturn.PATH, null, null, parameters, headers);
};

"use strict";

tutao.provide('tutao.entity.sys.CustomerReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.CustomerReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._adminUser = data.adminUser;
    this._adminUserGroup = data.adminUserGroup;
  } else {
    this.__format = "0";
    this._adminUser = null;
    this._adminUserGroup = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.CustomerReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.CustomerReturn.MODEL_VERSION = '4';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.CustomerReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.CustomerReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    adminUser: this._adminUser, 
    adminUserGroup: this._adminUserGroup
  };
};

/**
 * The id of the CustomerReturn type.
 */
tutao.entity.sys.CustomerReturn.prototype.TYPE_ID = 370;

/**
 * The id of the adminUser attribute.
 */
tutao.entity.sys.CustomerReturn.prototype.ADMINUSER_ATTRIBUTE_ID = 372;

/**
 * The id of the adminUserGroup attribute.
 */
tutao.entity.sys.CustomerReturn.prototype.ADMINUSERGROUP_ATTRIBUTE_ID = 373;

/**
 * Sets the format of this CustomerReturn.
 * @param {string} format The format of this CustomerReturn.
 */
tutao.entity.sys.CustomerReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this CustomerReturn.
 * @return {string} The format of this CustomerReturn.
 */
tutao.entity.sys.CustomerReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the adminUser of this CustomerReturn.
 * @param {string} adminUser The adminUser of this CustomerReturn.
 */
tutao.entity.sys.CustomerReturn.prototype.setAdminUser = function(adminUser) {
  this._adminUser = adminUser;
  return this;
};

/**
 * Provides the adminUser of this CustomerReturn.
 * @return {string} The adminUser of this CustomerReturn.
 */
tutao.entity.sys.CustomerReturn.prototype.getAdminUser = function() {
  return this._adminUser;
};

/**
 * Loads the adminUser of this CustomerReturn.
 * @return {Promise.<tutao.entity.sys.User>} Resolves to the loaded adminUser of this CustomerReturn or an exception if the loading failed.
 */
tutao.entity.sys.CustomerReturn.prototype.loadAdminUser = function() {
  return tutao.entity.sys.User.load(this._adminUser);
};

/**
 * Sets the adminUserGroup of this CustomerReturn.
 * @param {string} adminUserGroup The adminUserGroup of this CustomerReturn.
 */
tutao.entity.sys.CustomerReturn.prototype.setAdminUserGroup = function(adminUserGroup) {
  this._adminUserGroup = adminUserGroup;
  return this;
};

/**
 * Provides the adminUserGroup of this CustomerReturn.
 * @return {string} The adminUserGroup of this CustomerReturn.
 */
tutao.entity.sys.CustomerReturn.prototype.getAdminUserGroup = function() {
  return this._adminUserGroup;
};

/**
 * Loads the adminUserGroup of this CustomerReturn.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded adminUserGroup of this CustomerReturn or an exception if the loading failed.
 */
tutao.entity.sys.CustomerReturn.prototype.loadAdminUserGroup = function() {
  return tutao.entity.sys.Group.load(this._adminUserGroup);
};

"use strict";

tutao.provide('tutao.entity.sys.DomainMailAddressAvailabilityData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.DomainMailAddressAvailabilityData = function(data) {
  if (data) {
    this.__format = data._format;
    this._mailAddress = data.mailAddress;
  } else {
    this.__format = "0";
    this._mailAddress = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.DomainMailAddressAvailabilityData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.DomainMailAddressAvailabilityData.MODEL_VERSION = '4';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.DomainMailAddressAvailabilityData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.DomainMailAddressAvailabilityData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    mailAddress: this._mailAddress
  };
};

/**
 * The id of the DomainMailAddressAvailabilityData type.
 */
tutao.entity.sys.DomainMailAddressAvailabilityData.prototype.TYPE_ID = 599;

/**
 * The id of the mailAddress attribute.
 */
tutao.entity.sys.DomainMailAddressAvailabilityData.prototype.MAILADDRESS_ATTRIBUTE_ID = 601;

/**
 * Sets the format of this DomainMailAddressAvailabilityData.
 * @param {string} format The format of this DomainMailAddressAvailabilityData.
 */
tutao.entity.sys.DomainMailAddressAvailabilityData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this DomainMailAddressAvailabilityData.
 * @return {string} The format of this DomainMailAddressAvailabilityData.
 */
tutao.entity.sys.DomainMailAddressAvailabilityData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the mailAddress of this DomainMailAddressAvailabilityData.
 * @param {string} mailAddress The mailAddress of this DomainMailAddressAvailabilityData.
 */
tutao.entity.sys.DomainMailAddressAvailabilityData.prototype.setMailAddress = function(mailAddress) {
  this._mailAddress = mailAddress;
  return this;
};

/**
 * Provides the mailAddress of this DomainMailAddressAvailabilityData.
 * @return {string} The mailAddress of this DomainMailAddressAvailabilityData.
 */
tutao.entity.sys.DomainMailAddressAvailabilityData.prototype.getMailAddress = function() {
  return this._mailAddress;
};

"use strict";

tutao.provide('tutao.entity.sys.DomainMailAddressAvailabilityReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.DomainMailAddressAvailabilityReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._available = data.available;
  } else {
    this.__format = "0";
    this._available = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.DomainMailAddressAvailabilityReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.DomainMailAddressAvailabilityReturn.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.DomainMailAddressAvailabilityReturn.PATH = '/rest/sys/domainmailaddressavailabilityservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.DomainMailAddressAvailabilityReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.DomainMailAddressAvailabilityReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    available: this._available
  };
};

/**
 * The id of the DomainMailAddressAvailabilityReturn type.
 */
tutao.entity.sys.DomainMailAddressAvailabilityReturn.prototype.TYPE_ID = 602;

/**
 * The id of the available attribute.
 */
tutao.entity.sys.DomainMailAddressAvailabilityReturn.prototype.AVAILABLE_ATTRIBUTE_ID = 604;

/**
 * Sets the format of this DomainMailAddressAvailabilityReturn.
 * @param {string} format The format of this DomainMailAddressAvailabilityReturn.
 */
tutao.entity.sys.DomainMailAddressAvailabilityReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this DomainMailAddressAvailabilityReturn.
 * @return {string} The format of this DomainMailAddressAvailabilityReturn.
 */
tutao.entity.sys.DomainMailAddressAvailabilityReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the available of this DomainMailAddressAvailabilityReturn.
 * @param {boolean} available The available of this DomainMailAddressAvailabilityReturn.
 */
tutao.entity.sys.DomainMailAddressAvailabilityReturn.prototype.setAvailable = function(available) {
  this._available = available ? '1' : '0';
  return this;
};

/**
 * Provides the available of this DomainMailAddressAvailabilityReturn.
 * @return {boolean} The available of this DomainMailAddressAvailabilityReturn.
 */
tutao.entity.sys.DomainMailAddressAvailabilityReturn.prototype.getAvailable = function() {
  return this._available == '1';
};

/**
 * Loads from the service.
 * @param {tutao.entity.sys.DomainMailAddressAvailabilityData} entity The entity to send to the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.DomainMailAddressAvailabilityReturn>} Resolves to DomainMailAddressAvailabilityReturn or an exception if the loading failed.
 */
tutao.entity.sys.DomainMailAddressAvailabilityReturn.load = function(entity, parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.getService(tutao.entity.sys.DomainMailAddressAvailabilityReturn, tutao.entity.sys.DomainMailAddressAvailabilityReturn.PATH, entity, parameters, headers);
};

"use strict";

tutao.provide('tutao.entity.sys.EntityUpdate');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.EntityUpdate = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._application = data.application;
    this._instanceId = data.instanceId;
    this._instanceListId = data.instanceListId;
    this._operation = data.operation;
    this._type = data.type;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._application = null;
    this._instanceId = null;
    this._instanceListId = null;
    this._operation = null;
    this._type = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.EntityUpdate.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.EntityUpdate.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    application: this._application, 
    instanceId: this._instanceId, 
    instanceListId: this._instanceListId, 
    operation: this._operation, 
    type: this._type
  };
};

/**
 * The id of the EntityUpdate type.
 */
tutao.entity.sys.EntityUpdate.prototype.TYPE_ID = 462;

/**
 * The id of the application attribute.
 */
tutao.entity.sys.EntityUpdate.prototype.APPLICATION_ATTRIBUTE_ID = 464;

/**
 * The id of the instanceId attribute.
 */
tutao.entity.sys.EntityUpdate.prototype.INSTANCEID_ATTRIBUTE_ID = 467;

/**
 * The id of the instanceListId attribute.
 */
tutao.entity.sys.EntityUpdate.prototype.INSTANCELISTID_ATTRIBUTE_ID = 466;

/**
 * The id of the operation attribute.
 */
tutao.entity.sys.EntityUpdate.prototype.OPERATION_ATTRIBUTE_ID = 624;

/**
 * The id of the type attribute.
 */
tutao.entity.sys.EntityUpdate.prototype.TYPE_ATTRIBUTE_ID = 465;

/**
 * Sets the id of this EntityUpdate.
 * @param {string} id The id of this EntityUpdate.
 */
tutao.entity.sys.EntityUpdate.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this EntityUpdate.
 * @return {string} The id of this EntityUpdate.
 */
tutao.entity.sys.EntityUpdate.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the application of this EntityUpdate.
 * @param {string} application The application of this EntityUpdate.
 */
tutao.entity.sys.EntityUpdate.prototype.setApplication = function(application) {
  this._application = application;
  return this;
};

/**
 * Provides the application of this EntityUpdate.
 * @return {string} The application of this EntityUpdate.
 */
tutao.entity.sys.EntityUpdate.prototype.getApplication = function() {
  return this._application;
};

/**
 * Sets the instanceId of this EntityUpdate.
 * @param {string} instanceId The instanceId of this EntityUpdate.
 */
tutao.entity.sys.EntityUpdate.prototype.setInstanceId = function(instanceId) {
  this._instanceId = instanceId;
  return this;
};

/**
 * Provides the instanceId of this EntityUpdate.
 * @return {string} The instanceId of this EntityUpdate.
 */
tutao.entity.sys.EntityUpdate.prototype.getInstanceId = function() {
  return this._instanceId;
};

/**
 * Sets the instanceListId of this EntityUpdate.
 * @param {string} instanceListId The instanceListId of this EntityUpdate.
 */
tutao.entity.sys.EntityUpdate.prototype.setInstanceListId = function(instanceListId) {
  this._instanceListId = instanceListId;
  return this;
};

/**
 * Provides the instanceListId of this EntityUpdate.
 * @return {string} The instanceListId of this EntityUpdate.
 */
tutao.entity.sys.EntityUpdate.prototype.getInstanceListId = function() {
  return this._instanceListId;
};

/**
 * Sets the operation of this EntityUpdate.
 * @param {string} operation The operation of this EntityUpdate.
 */
tutao.entity.sys.EntityUpdate.prototype.setOperation = function(operation) {
  this._operation = operation;
  return this;
};

/**
 * Provides the operation of this EntityUpdate.
 * @return {string} The operation of this EntityUpdate.
 */
tutao.entity.sys.EntityUpdate.prototype.getOperation = function() {
  return this._operation;
};

/**
 * Sets the type of this EntityUpdate.
 * @param {string} type The type of this EntityUpdate.
 */
tutao.entity.sys.EntityUpdate.prototype.setType = function(type) {
  this._type = type;
  return this;
};

/**
 * Provides the type of this EntityUpdate.
 * @return {string} The type of this EntityUpdate.
 */
tutao.entity.sys.EntityUpdate.prototype.getType = function() {
  return this._type;
};

"use strict";

tutao.provide('tutao.entity.sys.Exception');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.Exception = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._msg = data.msg;
    this._type = data.type;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._msg = null;
    this._type = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.Exception.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.Exception.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    msg: this._msg, 
    type: this._type
  };
};

/**
 * The id of the Exception type.
 */
tutao.entity.sys.Exception.prototype.TYPE_ID = 468;

/**
 * The id of the msg attribute.
 */
tutao.entity.sys.Exception.prototype.MSG_ATTRIBUTE_ID = 471;

/**
 * The id of the type attribute.
 */
tutao.entity.sys.Exception.prototype.TYPE_ATTRIBUTE_ID = 470;

/**
 * Sets the id of this Exception.
 * @param {string} id The id of this Exception.
 */
tutao.entity.sys.Exception.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this Exception.
 * @return {string} The id of this Exception.
 */
tutao.entity.sys.Exception.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the msg of this Exception.
 * @param {string} msg The msg of this Exception.
 */
tutao.entity.sys.Exception.prototype.setMsg = function(msg) {
  this._msg = msg;
  return this;
};

/**
 * Provides the msg of this Exception.
 * @return {string} The msg of this Exception.
 */
tutao.entity.sys.Exception.prototype.getMsg = function() {
  return this._msg;
};

/**
 * Sets the type of this Exception.
 * @param {string} type The type of this Exception.
 */
tutao.entity.sys.Exception.prototype.setType = function(type) {
  this._type = type;
  return this;
};

/**
 * Provides the type of this Exception.
 * @return {string} The type of this Exception.
 */
tutao.entity.sys.Exception.prototype.getType = function() {
  return this._type;
};

"use strict";

tutao.provide('tutao.entity.sys.ExternalUserReference');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.ExternalUserReference = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._user = data.user;
    this._userGroup = data.userGroup;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._user = null;
    this._userGroup = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.ExternalUserReference.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.ExternalUserReference.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.ExternalUserReference.PATH = '/rest/sys/externaluserreference';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.ExternalUserReference.ROOT_INSTANCE_ID = 'A3N5cwBn';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.ExternalUserReference.GENERATED_ID = false;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.ExternalUserReference.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.ExternalUserReference.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    user: this._user, 
    userGroup: this._userGroup
  };
};

/**
 * The id of the ExternalUserReference type.
 */
tutao.entity.sys.ExternalUserReference.prototype.TYPE_ID = 103;

/**
 * The id of the user attribute.
 */
tutao.entity.sys.ExternalUserReference.prototype.USER_ATTRIBUTE_ID = 108;

/**
 * The id of the userGroup attribute.
 */
tutao.entity.sys.ExternalUserReference.prototype.USERGROUP_ATTRIBUTE_ID = 109;

/**
 * Sets the custom id of this ExternalUserReference.
 * @param {Array.<string>} id The custom id of this ExternalUserReference.
 */
tutao.entity.sys.ExternalUserReference.prototype.setId = function(id) {
  this.__id = id;
};

/**
 * Provides the id of this ExternalUserReference.
 * @return {Array.<string>} The id of this ExternalUserReference.
 */
tutao.entity.sys.ExternalUserReference.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this ExternalUserReference.
 * @param {string} format The format of this ExternalUserReference.
 */
tutao.entity.sys.ExternalUserReference.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this ExternalUserReference.
 * @return {string} The format of this ExternalUserReference.
 */
tutao.entity.sys.ExternalUserReference.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this ExternalUserReference.
 * @param {string} permissions The permissions of this ExternalUserReference.
 */
tutao.entity.sys.ExternalUserReference.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this ExternalUserReference.
 * @return {string} The permissions of this ExternalUserReference.
 */
tutao.entity.sys.ExternalUserReference.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the user of this ExternalUserReference.
 * @param {string} user The user of this ExternalUserReference.
 */
tutao.entity.sys.ExternalUserReference.prototype.setUser = function(user) {
  this._user = user;
  return this;
};

/**
 * Provides the user of this ExternalUserReference.
 * @return {string} The user of this ExternalUserReference.
 */
tutao.entity.sys.ExternalUserReference.prototype.getUser = function() {
  return this._user;
};

/**
 * Loads the user of this ExternalUserReference.
 * @return {Promise.<tutao.entity.sys.User>} Resolves to the loaded user of this ExternalUserReference or an exception if the loading failed.
 */
tutao.entity.sys.ExternalUserReference.prototype.loadUser = function() {
  return tutao.entity.sys.User.load(this._user);
};

/**
 * Sets the userGroup of this ExternalUserReference.
 * @param {string} userGroup The userGroup of this ExternalUserReference.
 */
tutao.entity.sys.ExternalUserReference.prototype.setUserGroup = function(userGroup) {
  this._userGroup = userGroup;
  return this;
};

/**
 * Provides the userGroup of this ExternalUserReference.
 * @return {string} The userGroup of this ExternalUserReference.
 */
tutao.entity.sys.ExternalUserReference.prototype.getUserGroup = function() {
  return this._userGroup;
};

/**
 * Loads the userGroup of this ExternalUserReference.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded userGroup of this ExternalUserReference or an exception if the loading failed.
 */
tutao.entity.sys.ExternalUserReference.prototype.loadUserGroup = function() {
  return tutao.entity.sys.Group.load(this._userGroup);
};

/**
 * Loads a ExternalUserReference from the server.
 * @param {Array.<string>} id The id of the ExternalUserReference.
 * @return {Promise.<tutao.entity.sys.ExternalUserReference>} Resolves to the ExternalUserReference or an exception if the loading failed.
 */
tutao.entity.sys.ExternalUserReference.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.ExternalUserReference, tutao.entity.sys.ExternalUserReference.PATH, id[1], id[0], {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple ExternalUserReferences from the server.
 * @param {Array.<Array.<string>>} ids The ids of the ExternalUserReferences to load.
 * @return {Promise.<Array.<tutao.entity.sys.ExternalUserReference>>} Resolves to an array of ExternalUserReference or rejects with an exception if the loading failed.
 */
tutao.entity.sys.ExternalUserReference.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.ExternalUserReference, tutao.entity.sys.ExternalUserReference.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.sys.ExternalUserReference.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 4;
  return tutao.locator.entityRestClient.putElement(tutao.entity.sys.ExternalUserReference.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Provides a  list of ExternalUserReferences loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.sys.ExternalUserReference>>} Resolves to an array of ExternalUserReference or rejects with an exception if the loading failed.
 */
tutao.entity.sys.ExternalUserReference.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.sys.ExternalUserReference, tutao.entity.sys.ExternalUserReference.PATH, listId, start, count, reverse, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.ExternalUserReference.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.ExternalUserReference.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.Group');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.Group = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._adminGroupEncGKey = data.adminGroupEncGKey;
    this._enabled = data.enabled;
    this._type = data.type;
    this._admin = data.admin;
    this._customer = data.customer;
    this._groupInfo = data.groupInfo;
    this._invitations = data.invitations;
    this._keys = [];
    for (var i=0; i < data.keys.length; i++) {
      this._keys.push(new tutao.entity.sys.KeyPair(this, data.keys[i]));
    }
    this._members = data.members;
    this._user = data.user;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._adminGroupEncGKey = null;
    this._enabled = null;
    this._type = null;
    this._admin = null;
    this._customer = null;
    this._groupInfo = null;
    this._invitations = null;
    this._keys = [];
    this._members = null;
    this._user = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.Group.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.Group.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.Group.PATH = '/rest/sys/group';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.Group.ROOT_INSTANCE_ID = 'A3N5cwAF';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.Group.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.Group.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.Group.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    adminGroupEncGKey: this._adminGroupEncGKey, 
    enabled: this._enabled, 
    type: this._type, 
    admin: this._admin, 
    customer: this._customer, 
    groupInfo: this._groupInfo, 
    invitations: this._invitations, 
    keys: tutao.entity.EntityHelper.aggregatesToJsonData(this._keys), 
    members: this._members, 
    user: this._user
  };
};

/**
 * The id of the Group type.
 */
tutao.entity.sys.Group.prototype.TYPE_ID = 5;

/**
 * The id of the adminGroupEncGKey attribute.
 */
tutao.entity.sys.Group.prototype.ADMINGROUPENCGKEY_ATTRIBUTE_ID = 11;

/**
 * The id of the enabled attribute.
 */
tutao.entity.sys.Group.prototype.ENABLED_ATTRIBUTE_ID = 12;

/**
 * The id of the type attribute.
 */
tutao.entity.sys.Group.prototype.TYPE_ATTRIBUTE_ID = 10;

/**
 * The id of the admin attribute.
 */
tutao.entity.sys.Group.prototype.ADMIN_ATTRIBUTE_ID = 224;

/**
 * The id of the customer attribute.
 */
tutao.entity.sys.Group.prototype.CUSTOMER_ATTRIBUTE_ID = 226;

/**
 * The id of the groupInfo attribute.
 */
tutao.entity.sys.Group.prototype.GROUPINFO_ATTRIBUTE_ID = 227;

/**
 * The id of the invitations attribute.
 */
tutao.entity.sys.Group.prototype.INVITATIONS_ATTRIBUTE_ID = 228;

/**
 * The id of the keys attribute.
 */
tutao.entity.sys.Group.prototype.KEYS_ATTRIBUTE_ID = 13;

/**
 * The id of the members attribute.
 */
tutao.entity.sys.Group.prototype.MEMBERS_ATTRIBUTE_ID = 229;

/**
 * The id of the user attribute.
 */
tutao.entity.sys.Group.prototype.USER_ATTRIBUTE_ID = 225;

/**
 * Provides the id of this Group.
 * @return {string} The id of this Group.
 */
tutao.entity.sys.Group.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this Group.
 * @param {string} format The format of this Group.
 */
tutao.entity.sys.Group.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this Group.
 * @return {string} The format of this Group.
 */
tutao.entity.sys.Group.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this Group.
 * @param {string} permissions The permissions of this Group.
 */
tutao.entity.sys.Group.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this Group.
 * @return {string} The permissions of this Group.
 */
tutao.entity.sys.Group.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the adminGroupEncGKey of this Group.
 * @param {string} adminGroupEncGKey The adminGroupEncGKey of this Group.
 */
tutao.entity.sys.Group.prototype.setAdminGroupEncGKey = function(adminGroupEncGKey) {
  this._adminGroupEncGKey = adminGroupEncGKey;
  return this;
};

/**
 * Provides the adminGroupEncGKey of this Group.
 * @return {string} The adminGroupEncGKey of this Group.
 */
tutao.entity.sys.Group.prototype.getAdminGroupEncGKey = function() {
  return this._adminGroupEncGKey;
};

/**
 * Sets the enabled of this Group.
 * @param {boolean} enabled The enabled of this Group.
 */
tutao.entity.sys.Group.prototype.setEnabled = function(enabled) {
  this._enabled = enabled ? '1' : '0';
  return this;
};

/**
 * Provides the enabled of this Group.
 * @return {boolean} The enabled of this Group.
 */
tutao.entity.sys.Group.prototype.getEnabled = function() {
  return this._enabled == '1';
};

/**
 * Sets the type of this Group.
 * @param {string} type The type of this Group.
 */
tutao.entity.sys.Group.prototype.setType = function(type) {
  this._type = type;
  return this;
};

/**
 * Provides the type of this Group.
 * @return {string} The type of this Group.
 */
tutao.entity.sys.Group.prototype.getType = function() {
  return this._type;
};

/**
 * Sets the admin of this Group.
 * @param {string} admin The admin of this Group.
 */
tutao.entity.sys.Group.prototype.setAdmin = function(admin) {
  this._admin = admin;
  return this;
};

/**
 * Provides the admin of this Group.
 * @return {string} The admin of this Group.
 */
tutao.entity.sys.Group.prototype.getAdmin = function() {
  return this._admin;
};

/**
 * Loads the admin of this Group.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded admin of this Group or an exception if the loading failed.
 */
tutao.entity.sys.Group.prototype.loadAdmin = function() {
  return tutao.entity.sys.Group.load(this._admin);
};

/**
 * Sets the customer of this Group.
 * @param {string} customer The customer of this Group.
 */
tutao.entity.sys.Group.prototype.setCustomer = function(customer) {
  this._customer = customer;
  return this;
};

/**
 * Provides the customer of this Group.
 * @return {string} The customer of this Group.
 */
tutao.entity.sys.Group.prototype.getCustomer = function() {
  return this._customer;
};

/**
 * Loads the customer of this Group.
 * @return {Promise.<tutao.entity.sys.Customer>} Resolves to the loaded customer of this Group or an exception if the loading failed.
 */
tutao.entity.sys.Group.prototype.loadCustomer = function() {
  return tutao.entity.sys.Customer.load(this._customer);
};

/**
 * Sets the groupInfo of this Group.
 * @param {Array.<string>} groupInfo The groupInfo of this Group.
 */
tutao.entity.sys.Group.prototype.setGroupInfo = function(groupInfo) {
  this._groupInfo = groupInfo;
  return this;
};

/**
 * Provides the groupInfo of this Group.
 * @return {Array.<string>} The groupInfo of this Group.
 */
tutao.entity.sys.Group.prototype.getGroupInfo = function() {
  return this._groupInfo;
};

/**
 * Loads the groupInfo of this Group.
 * @return {Promise.<tutao.entity.sys.GroupInfo>} Resolves to the loaded groupInfo of this Group or an exception if the loading failed.
 */
tutao.entity.sys.Group.prototype.loadGroupInfo = function() {
  return tutao.entity.sys.GroupInfo.load(this._groupInfo);
};

/**
 * Sets the invitations of this Group.
 * @param {string} invitations The invitations of this Group.
 */
tutao.entity.sys.Group.prototype.setInvitations = function(invitations) {
  this._invitations = invitations;
  return this;
};

/**
 * Provides the invitations of this Group.
 * @return {string} The invitations of this Group.
 */
tutao.entity.sys.Group.prototype.getInvitations = function() {
  return this._invitations;
};

/**
 * Provides the keys of this Group.
 * @return {Array.<tutao.entity.sys.KeyPair>} The keys of this Group.
 */
tutao.entity.sys.Group.prototype.getKeys = function() {
  return this._keys;
};

/**
 * Sets the members of this Group.
 * @param {string} members The members of this Group.
 */
tutao.entity.sys.Group.prototype.setMembers = function(members) {
  this._members = members;
  return this;
};

/**
 * Provides the members of this Group.
 * @return {string} The members of this Group.
 */
tutao.entity.sys.Group.prototype.getMembers = function() {
  return this._members;
};

/**
 * Sets the user of this Group.
 * @param {string} user The user of this Group.
 */
tutao.entity.sys.Group.prototype.setUser = function(user) {
  this._user = user;
  return this;
};

/**
 * Provides the user of this Group.
 * @return {string} The user of this Group.
 */
tutao.entity.sys.Group.prototype.getUser = function() {
  return this._user;
};

/**
 * Loads the user of this Group.
 * @return {Promise.<tutao.entity.sys.User>} Resolves to the loaded user of this Group or an exception if the loading failed.
 */
tutao.entity.sys.Group.prototype.loadUser = function() {
  return tutao.entity.sys.User.load(this._user);
};

/**
 * Loads a Group from the server.
 * @param {string} id The id of the Group.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the Group or an exception if the loading failed.
 */
tutao.entity.sys.Group.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.Group, tutao.entity.sys.Group.PATH, id, null, {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple Groups from the server.
 * @param {Array.<string>} ids The ids of the Groups to load.
 * @return {Promise.<Array.<tutao.entity.sys.Group>>} Resolves to an array of Group or rejects with an exception if the loading failed.
 */
tutao.entity.sys.Group.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.Group, tutao.entity.sys.Group.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.Group.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.Group.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.GroupInfo');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.GroupInfo = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__listEncSessionKey = data._listEncSessionKey;
    this.__permissions = data._permissions;
    this._created = data.created;
    this._deleted = data.deleted;
    this._mailAddress = data.mailAddress;
    this._name = data.name;
    this._group = data.group;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__listEncSessionKey = null;
    this.__permissions = null;
    this._created = null;
    this._deleted = null;
    this._mailAddress = null;
    this._name = null;
    this._group = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.GroupInfo.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.GroupInfo.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.GroupInfo.PATH = '/rest/sys/groupinfo';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.GroupInfo.ROOT_INSTANCE_ID = 'A3N5cwAO';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.GroupInfo.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.GroupInfo.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.GroupInfo.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _listEncSessionKey: this.__listEncSessionKey, 
    _permissions: this.__permissions, 
    created: this._created, 
    deleted: this._deleted, 
    mailAddress: this._mailAddress, 
    name: this._name, 
    group: this._group
  };
};

/**
 * The id of the GroupInfo type.
 */
tutao.entity.sys.GroupInfo.prototype.TYPE_ID = 14;

/**
 * The id of the created attribute.
 */
tutao.entity.sys.GroupInfo.prototype.CREATED_ATTRIBUTE_ID = 23;

/**
 * The id of the deleted attribute.
 */
tutao.entity.sys.GroupInfo.prototype.DELETED_ATTRIBUTE_ID = 24;

/**
 * The id of the mailAddress attribute.
 */
tutao.entity.sys.GroupInfo.prototype.MAILADDRESS_ATTRIBUTE_ID = 22;

/**
 * The id of the name attribute.
 */
tutao.entity.sys.GroupInfo.prototype.NAME_ATTRIBUTE_ID = 21;

/**
 * The id of the group attribute.
 */
tutao.entity.sys.GroupInfo.prototype.GROUP_ATTRIBUTE_ID = 20;

/**
 * Provides the id of this GroupInfo.
 * @return {Array.<string>} The id of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this GroupInfo.
 * @param {string} format The format of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this GroupInfo.
 * @return {string} The format of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the listEncSessionKey of this GroupInfo.
 * @param {string} listEncSessionKey The listEncSessionKey of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.setListEncSessionKey = function(listEncSessionKey) {
  this.__listEncSessionKey = listEncSessionKey;
  return this;
};

/**
 * Provides the listEncSessionKey of this GroupInfo.
 * @return {string} The listEncSessionKey of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.getListEncSessionKey = function() {
  return this.__listEncSessionKey;
};

/**
 * Sets the permissions of this GroupInfo.
 * @param {string} permissions The permissions of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this GroupInfo.
 * @return {string} The permissions of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the created of this GroupInfo.
 * @param {Date} created The created of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.setCreated = function(created) {
  this._created = String(created.getTime());
  return this;
};

/**
 * Provides the created of this GroupInfo.
 * @return {Date} The created of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.getCreated = function() {
  if (isNaN(this._created)) {
    throw new tutao.InvalidDataError('invalid time data: ' + this._created);
  }
  return new Date(Number(this._created));
};

/**
 * Sets the deleted of this GroupInfo.
 * @param {Date} deleted The deleted of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.setDeleted = function(deleted) {
  if (deleted == null) {
    this._deleted = null;
  } else {
    this._deleted = String(deleted.getTime());
  }
  return this;
};

/**
 * Provides the deleted of this GroupInfo.
 * @return {Date} The deleted of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.getDeleted = function() {
  if (this._deleted == null) {
    return null;
  }
  if (isNaN(this._deleted)) {
    throw new tutao.InvalidDataError('invalid time data: ' + this._deleted);
  }
  return new Date(Number(this._deleted));
};

/**
 * Sets the mailAddress of this GroupInfo.
 * @param {string} mailAddress The mailAddress of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.setMailAddress = function(mailAddress) {
  this._mailAddress = mailAddress;
  return this;
};

/**
 * Provides the mailAddress of this GroupInfo.
 * @return {string} The mailAddress of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.getMailAddress = function() {
  return this._mailAddress;
};

/**
 * Sets the name of this GroupInfo.
 * @param {string} name The name of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.setName = function(name) {
  var dataToEncrypt = name;
  this._name = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the name of this GroupInfo.
 * @return {string} The name of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.getName = function() {
  if (this._name == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._name);
  return value;
};

/**
 * Sets the group of this GroupInfo.
 * @param {string} group The group of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.setGroup = function(group) {
  this._group = group;
  return this;
};

/**
 * Provides the group of this GroupInfo.
 * @return {string} The group of this GroupInfo.
 */
tutao.entity.sys.GroupInfo.prototype.getGroup = function() {
  return this._group;
};

/**
 * Loads the group of this GroupInfo.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded group of this GroupInfo or an exception if the loading failed.
 */
tutao.entity.sys.GroupInfo.prototype.loadGroup = function() {
  return tutao.entity.sys.Group.load(this._group);
};

/**
 * Loads a GroupInfo from the server.
 * @param {Array.<string>} id The id of the GroupInfo.
 * @return {Promise.<tutao.entity.sys.GroupInfo>} Resolves to the GroupInfo or an exception if the loading failed.
 */
tutao.entity.sys.GroupInfo.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.GroupInfo, tutao.entity.sys.GroupInfo.PATH, id[1], id[0], {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity._entityHelper.loadSessionKey();
  });
};

/**
 * Loads multiple GroupInfos from the server.
 * @param {Array.<Array.<string>>} ids The ids of the GroupInfos to load.
 * @return {Promise.<Array.<tutao.entity.sys.GroupInfo>>} Resolves to an array of GroupInfo or rejects with an exception if the loading failed.
 */
tutao.entity.sys.GroupInfo.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.GroupInfo, tutao.entity.sys.GroupInfo.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return tutao.entity.EntityHelper.loadSessionKeys(entities);
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.sys.GroupInfo.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 4;
  return tutao.locator.entityRestClient.putElement(tutao.entity.sys.GroupInfo.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Updates this GroupInfo on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.sys.GroupInfo.prototype.update = function() {
  var self = this;
  return tutao.locator.entityRestClient.putElement(tutao.entity.sys.GroupInfo.PATH, this, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function() {
    self._entityHelper.notifyObservers(false);
  });
};

/**
 * Provides a  list of GroupInfos loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.sys.GroupInfo>>} Resolves to an array of GroupInfo or rejects with an exception if the loading failed.
 */
tutao.entity.sys.GroupInfo.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.sys.GroupInfo, tutao.entity.sys.GroupInfo.PATH, listId, start, count, reverse, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return tutao.entity.EntityHelper.loadSessionKeys(entities);
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.GroupInfo.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.GroupInfo.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.GroupMember');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.GroupMember = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._group = data.group;
    this._user = data.user;
    this._userGroupInfo = data.userGroupInfo;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._group = null;
    this._user = null;
    this._userGroupInfo = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.GroupMember.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.GroupMember.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.GroupMember.PATH = '/rest/sys/groupmember';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.GroupMember.ROOT_INSTANCE_ID = 'A3N5cwAA2A';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.GroupMember.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.GroupMember.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.GroupMember.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    group: this._group, 
    user: this._user, 
    userGroupInfo: this._userGroupInfo
  };
};

/**
 * The id of the GroupMember type.
 */
tutao.entity.sys.GroupMember.prototype.TYPE_ID = 216;

/**
 * The id of the group attribute.
 */
tutao.entity.sys.GroupMember.prototype.GROUP_ATTRIBUTE_ID = 222;

/**
 * The id of the user attribute.
 */
tutao.entity.sys.GroupMember.prototype.USER_ATTRIBUTE_ID = 223;

/**
 * The id of the userGroupInfo attribute.
 */
tutao.entity.sys.GroupMember.prototype.USERGROUPINFO_ATTRIBUTE_ID = 221;

/**
 * Provides the id of this GroupMember.
 * @return {Array.<string>} The id of this GroupMember.
 */
tutao.entity.sys.GroupMember.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this GroupMember.
 * @param {string} format The format of this GroupMember.
 */
tutao.entity.sys.GroupMember.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this GroupMember.
 * @return {string} The format of this GroupMember.
 */
tutao.entity.sys.GroupMember.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this GroupMember.
 * @param {string} permissions The permissions of this GroupMember.
 */
tutao.entity.sys.GroupMember.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this GroupMember.
 * @return {string} The permissions of this GroupMember.
 */
tutao.entity.sys.GroupMember.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the group of this GroupMember.
 * @param {string} group The group of this GroupMember.
 */
tutao.entity.sys.GroupMember.prototype.setGroup = function(group) {
  this._group = group;
  return this;
};

/**
 * Provides the group of this GroupMember.
 * @return {string} The group of this GroupMember.
 */
tutao.entity.sys.GroupMember.prototype.getGroup = function() {
  return this._group;
};

/**
 * Loads the group of this GroupMember.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded group of this GroupMember or an exception if the loading failed.
 */
tutao.entity.sys.GroupMember.prototype.loadGroup = function() {
  return tutao.entity.sys.Group.load(this._group);
};

/**
 * Sets the user of this GroupMember.
 * @param {string} user The user of this GroupMember.
 */
tutao.entity.sys.GroupMember.prototype.setUser = function(user) {
  this._user = user;
  return this;
};

/**
 * Provides the user of this GroupMember.
 * @return {string} The user of this GroupMember.
 */
tutao.entity.sys.GroupMember.prototype.getUser = function() {
  return this._user;
};

/**
 * Loads the user of this GroupMember.
 * @return {Promise.<tutao.entity.sys.User>} Resolves to the loaded user of this GroupMember or an exception if the loading failed.
 */
tutao.entity.sys.GroupMember.prototype.loadUser = function() {
  return tutao.entity.sys.User.load(this._user);
};

/**
 * Sets the userGroupInfo of this GroupMember.
 * @param {Array.<string>} userGroupInfo The userGroupInfo of this GroupMember.
 */
tutao.entity.sys.GroupMember.prototype.setUserGroupInfo = function(userGroupInfo) {
  this._userGroupInfo = userGroupInfo;
  return this;
};

/**
 * Provides the userGroupInfo of this GroupMember.
 * @return {Array.<string>} The userGroupInfo of this GroupMember.
 */
tutao.entity.sys.GroupMember.prototype.getUserGroupInfo = function() {
  return this._userGroupInfo;
};

/**
 * Loads the userGroupInfo of this GroupMember.
 * @return {Promise.<tutao.entity.sys.GroupInfo>} Resolves to the loaded userGroupInfo of this GroupMember or an exception if the loading failed.
 */
tutao.entity.sys.GroupMember.prototype.loadUserGroupInfo = function() {
  return tutao.entity.sys.GroupInfo.load(this._userGroupInfo);
};

/**
 * Loads a GroupMember from the server.
 * @param {Array.<string>} id The id of the GroupMember.
 * @return {Promise.<tutao.entity.sys.GroupMember>} Resolves to the GroupMember or an exception if the loading failed.
 */
tutao.entity.sys.GroupMember.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.GroupMember, tutao.entity.sys.GroupMember.PATH, id[1], id[0], {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple GroupMembers from the server.
 * @param {Array.<Array.<string>>} ids The ids of the GroupMembers to load.
 * @return {Promise.<Array.<tutao.entity.sys.GroupMember>>} Resolves to an array of GroupMember or rejects with an exception if the loading failed.
 */
tutao.entity.sys.GroupMember.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.GroupMember, tutao.entity.sys.GroupMember.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.sys.GroupMember.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 4;
  return tutao.locator.entityRestClient.putElement(tutao.entity.sys.GroupMember.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Provides a  list of GroupMembers loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.sys.GroupMember>>} Resolves to an array of GroupMember or rejects with an exception if the loading failed.
 */
tutao.entity.sys.GroupMember.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.sys.GroupMember, tutao.entity.sys.GroupMember.PATH, listId, start, count, reverse, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.GroupMember.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.GroupMember.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.GroupMembership');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.GroupMembership = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._admin = data.admin;
    this._symEncGKey = data.symEncGKey;
    this._group = data.group;
    this._groupInfo = data.groupInfo;
    this._groupMember = data.groupMember;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._admin = null;
    this._symEncGKey = null;
    this._group = null;
    this._groupInfo = null;
    this._groupMember = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.GroupMembership.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.GroupMembership.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    admin: this._admin, 
    symEncGKey: this._symEncGKey, 
    group: this._group, 
    groupInfo: this._groupInfo, 
    groupMember: this._groupMember
  };
};

/**
 * The id of the GroupMembership type.
 */
tutao.entity.sys.GroupMembership.prototype.TYPE_ID = 25;

/**
 * The id of the admin attribute.
 */
tutao.entity.sys.GroupMembership.prototype.ADMIN_ATTRIBUTE_ID = 28;

/**
 * The id of the symEncGKey attribute.
 */
tutao.entity.sys.GroupMembership.prototype.SYMENCGKEY_ATTRIBUTE_ID = 27;

/**
 * The id of the group attribute.
 */
tutao.entity.sys.GroupMembership.prototype.GROUP_ATTRIBUTE_ID = 29;

/**
 * The id of the groupInfo attribute.
 */
tutao.entity.sys.GroupMembership.prototype.GROUPINFO_ATTRIBUTE_ID = 30;

/**
 * The id of the groupMember attribute.
 */
tutao.entity.sys.GroupMembership.prototype.GROUPMEMBER_ATTRIBUTE_ID = 230;

/**
 * Sets the id of this GroupMembership.
 * @param {string} id The id of this GroupMembership.
 */
tutao.entity.sys.GroupMembership.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this GroupMembership.
 * @return {string} The id of this GroupMembership.
 */
tutao.entity.sys.GroupMembership.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the admin of this GroupMembership.
 * @param {boolean} admin The admin of this GroupMembership.
 */
tutao.entity.sys.GroupMembership.prototype.setAdmin = function(admin) {
  this._admin = admin ? '1' : '0';
  return this;
};

/**
 * Provides the admin of this GroupMembership.
 * @return {boolean} The admin of this GroupMembership.
 */
tutao.entity.sys.GroupMembership.prototype.getAdmin = function() {
  return this._admin == '1';
};

/**
 * Sets the symEncGKey of this GroupMembership.
 * @param {string} symEncGKey The symEncGKey of this GroupMembership.
 */
tutao.entity.sys.GroupMembership.prototype.setSymEncGKey = function(symEncGKey) {
  this._symEncGKey = symEncGKey;
  return this;
};

/**
 * Provides the symEncGKey of this GroupMembership.
 * @return {string} The symEncGKey of this GroupMembership.
 */
tutao.entity.sys.GroupMembership.prototype.getSymEncGKey = function() {
  return this._symEncGKey;
};

/**
 * Sets the group of this GroupMembership.
 * @param {string} group The group of this GroupMembership.
 */
tutao.entity.sys.GroupMembership.prototype.setGroup = function(group) {
  this._group = group;
  return this;
};

/**
 * Provides the group of this GroupMembership.
 * @return {string} The group of this GroupMembership.
 */
tutao.entity.sys.GroupMembership.prototype.getGroup = function() {
  return this._group;
};

/**
 * Loads the group of this GroupMembership.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded group of this GroupMembership or an exception if the loading failed.
 */
tutao.entity.sys.GroupMembership.prototype.loadGroup = function() {
  return tutao.entity.sys.Group.load(this._group);
};

/**
 * Sets the groupInfo of this GroupMembership.
 * @param {Array.<string>} groupInfo The groupInfo of this GroupMembership.
 */
tutao.entity.sys.GroupMembership.prototype.setGroupInfo = function(groupInfo) {
  this._groupInfo = groupInfo;
  return this;
};

/**
 * Provides the groupInfo of this GroupMembership.
 * @return {Array.<string>} The groupInfo of this GroupMembership.
 */
tutao.entity.sys.GroupMembership.prototype.getGroupInfo = function() {
  return this._groupInfo;
};

/**
 * Loads the groupInfo of this GroupMembership.
 * @return {Promise.<tutao.entity.sys.GroupInfo>} Resolves to the loaded groupInfo of this GroupMembership or an exception if the loading failed.
 */
tutao.entity.sys.GroupMembership.prototype.loadGroupInfo = function() {
  return tutao.entity.sys.GroupInfo.load(this._groupInfo);
};

/**
 * Sets the groupMember of this GroupMembership.
 * @param {Array.<string>} groupMember The groupMember of this GroupMembership.
 */
tutao.entity.sys.GroupMembership.prototype.setGroupMember = function(groupMember) {
  this._groupMember = groupMember;
  return this;
};

/**
 * Provides the groupMember of this GroupMembership.
 * @return {Array.<string>} The groupMember of this GroupMembership.
 */
tutao.entity.sys.GroupMembership.prototype.getGroupMember = function() {
  return this._groupMember;
};

/**
 * Loads the groupMember of this GroupMembership.
 * @return {Promise.<tutao.entity.sys.GroupMember>} Resolves to the loaded groupMember of this GroupMembership or an exception if the loading failed.
 */
tutao.entity.sys.GroupMembership.prototype.loadGroupMember = function() {
  return tutao.entity.sys.GroupMember.load(this._groupMember);
};

"use strict";

tutao.provide('tutao.entity.sys.GroupRoot');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.GroupRoot = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._groupShareBucketId = data.groupShareBucketId;
    this._symEncShareBucketKey = data.symEncShareBucketKey;
    this._externalGroupInfos = data.externalGroupInfos;
    this._externalUserReferences = data.externalUserReferences;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._groupShareBucketId = null;
    this._symEncShareBucketKey = null;
    this._externalGroupInfos = null;
    this._externalUserReferences = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.GroupRoot.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.GroupRoot.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.GroupRoot.PATH = '/rest/sys/grouproot';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.GroupRoot.ROOT_INSTANCE_ID = 'A3N5cwBu';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.GroupRoot.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.GroupRoot.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.GroupRoot.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    groupShareBucketId: this._groupShareBucketId, 
    symEncShareBucketKey: this._symEncShareBucketKey, 
    externalGroupInfos: this._externalGroupInfos, 
    externalUserReferences: this._externalUserReferences
  };
};

/**
 * The id of the GroupRoot type.
 */
tutao.entity.sys.GroupRoot.prototype.TYPE_ID = 110;

/**
 * The id of the groupShareBucketId attribute.
 */
tutao.entity.sys.GroupRoot.prototype.GROUPSHAREBUCKETID_ATTRIBUTE_ID = 115;

/**
 * The id of the symEncShareBucketKey attribute.
 */
tutao.entity.sys.GroupRoot.prototype.SYMENCSHAREBUCKETKEY_ATTRIBUTE_ID = 598;

/**
 * The id of the externalGroupInfos attribute.
 */
tutao.entity.sys.GroupRoot.prototype.EXTERNALGROUPINFOS_ATTRIBUTE_ID = 116;

/**
 * The id of the externalUserReferences attribute.
 */
tutao.entity.sys.GroupRoot.prototype.EXTERNALUSERREFERENCES_ATTRIBUTE_ID = 117;

/**
 * Provides the id of this GroupRoot.
 * @return {string} The id of this GroupRoot.
 */
tutao.entity.sys.GroupRoot.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this GroupRoot.
 * @param {string} format The format of this GroupRoot.
 */
tutao.entity.sys.GroupRoot.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this GroupRoot.
 * @return {string} The format of this GroupRoot.
 */
tutao.entity.sys.GroupRoot.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this GroupRoot.
 * @param {string} permissions The permissions of this GroupRoot.
 */
tutao.entity.sys.GroupRoot.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this GroupRoot.
 * @return {string} The permissions of this GroupRoot.
 */
tutao.entity.sys.GroupRoot.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the groupShareBucketId of this GroupRoot.
 * @param {string} groupShareBucketId The groupShareBucketId of this GroupRoot.
 */
tutao.entity.sys.GroupRoot.prototype.setGroupShareBucketId = function(groupShareBucketId) {
  this._groupShareBucketId = groupShareBucketId;
  return this;
};

/**
 * Provides the groupShareBucketId of this GroupRoot.
 * @return {string} The groupShareBucketId of this GroupRoot.
 */
tutao.entity.sys.GroupRoot.prototype.getGroupShareBucketId = function() {
  return this._groupShareBucketId;
};

/**
 * Sets the symEncShareBucketKey of this GroupRoot.
 * @param {string} symEncShareBucketKey The symEncShareBucketKey of this GroupRoot.
 */
tutao.entity.sys.GroupRoot.prototype.setSymEncShareBucketKey = function(symEncShareBucketKey) {
  this._symEncShareBucketKey = symEncShareBucketKey;
  return this;
};

/**
 * Provides the symEncShareBucketKey of this GroupRoot.
 * @return {string} The symEncShareBucketKey of this GroupRoot.
 */
tutao.entity.sys.GroupRoot.prototype.getSymEncShareBucketKey = function() {
  return this._symEncShareBucketKey;
};

/**
 * Sets the externalGroupInfos of this GroupRoot.
 * @param {string} externalGroupInfos The externalGroupInfos of this GroupRoot.
 */
tutao.entity.sys.GroupRoot.prototype.setExternalGroupInfos = function(externalGroupInfos) {
  this._externalGroupInfos = externalGroupInfos;
  return this;
};

/**
 * Provides the externalGroupInfos of this GroupRoot.
 * @return {string} The externalGroupInfos of this GroupRoot.
 */
tutao.entity.sys.GroupRoot.prototype.getExternalGroupInfos = function() {
  return this._externalGroupInfos;
};

/**
 * Sets the externalUserReferences of this GroupRoot.
 * @param {string} externalUserReferences The externalUserReferences of this GroupRoot.
 */
tutao.entity.sys.GroupRoot.prototype.setExternalUserReferences = function(externalUserReferences) {
  this._externalUserReferences = externalUserReferences;
  return this;
};

/**
 * Provides the externalUserReferences of this GroupRoot.
 * @return {string} The externalUserReferences of this GroupRoot.
 */
tutao.entity.sys.GroupRoot.prototype.getExternalUserReferences = function() {
  return this._externalUserReferences;
};

/**
 * Loads a GroupRoot from the server.
 * @param {string} id The id of the GroupRoot.
 * @return {Promise.<tutao.entity.sys.GroupRoot>} Resolves to the GroupRoot or an exception if the loading failed.
 */
tutao.entity.sys.GroupRoot.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.GroupRoot, tutao.entity.sys.GroupRoot.PATH, id, null, {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple GroupRoots from the server.
 * @param {Array.<string>} ids The ids of the GroupRoots to load.
 * @return {Promise.<Array.<tutao.entity.sys.GroupRoot>>} Resolves to an array of GroupRoot or rejects with an exception if the loading failed.
 */
tutao.entity.sys.GroupRoot.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.GroupRoot, tutao.entity.sys.GroupRoot.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.GroupRoot.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.GroupRoot.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.IncomingShare');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.IncomingShare = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._app = data.app;
    this._referenceId = data.referenceId;
    this._referenceListId = data.referenceListId;
    this._shareType = data.shareType;
    this._bucketPermission = data.bucketPermission;
    this._ownerGroup = data.ownerGroup;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._app = null;
    this._referenceId = null;
    this._referenceListId = null;
    this._shareType = null;
    this._bucketPermission = null;
    this._ownerGroup = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.IncomingShare.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.IncomingShare.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.IncomingShare.PATH = '/rest/sys/incomingshare';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.IncomingShare.ROOT_INSTANCE_ID = 'A3N5cwABBA';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.IncomingShare.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.IncomingShare.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.IncomingShare.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    app: this._app, 
    referenceId: this._referenceId, 
    referenceListId: this._referenceListId, 
    shareType: this._shareType, 
    bucketPermission: this._bucketPermission, 
    ownerGroup: this._ownerGroup
  };
};

/**
 * The id of the IncomingShare type.
 */
tutao.entity.sys.IncomingShare.prototype.TYPE_ID = 260;

/**
 * The id of the app attribute.
 */
tutao.entity.sys.IncomingShare.prototype.APP_ATTRIBUTE_ID = 265;

/**
 * The id of the referenceId attribute.
 */
tutao.entity.sys.IncomingShare.prototype.REFERENCEID_ATTRIBUTE_ID = 268;

/**
 * The id of the referenceListId attribute.
 */
tutao.entity.sys.IncomingShare.prototype.REFERENCELISTID_ATTRIBUTE_ID = 267;

/**
 * The id of the shareType attribute.
 */
tutao.entity.sys.IncomingShare.prototype.SHARETYPE_ATTRIBUTE_ID = 266;

/**
 * The id of the bucketPermission attribute.
 */
tutao.entity.sys.IncomingShare.prototype.BUCKETPERMISSION_ATTRIBUTE_ID = 270;

/**
 * The id of the ownerGroup attribute.
 */
tutao.entity.sys.IncomingShare.prototype.OWNERGROUP_ATTRIBUTE_ID = 269;

/**
 * Provides the id of this IncomingShare.
 * @return {Array.<string>} The id of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this IncomingShare.
 * @param {string} format The format of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this IncomingShare.
 * @return {string} The format of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this IncomingShare.
 * @param {string} permissions The permissions of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this IncomingShare.
 * @return {string} The permissions of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the app of this IncomingShare.
 * @param {string} app The app of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.setApp = function(app) {
  this._app = app;
  return this;
};

/**
 * Provides the app of this IncomingShare.
 * @return {string} The app of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.getApp = function() {
  return this._app;
};

/**
 * Sets the referenceId of this IncomingShare.
 * @param {string} referenceId The referenceId of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.setReferenceId = function(referenceId) {
  this._referenceId = referenceId;
  return this;
};

/**
 * Provides the referenceId of this IncomingShare.
 * @return {string} The referenceId of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.getReferenceId = function() {
  return this._referenceId;
};

/**
 * Sets the referenceListId of this IncomingShare.
 * @param {string} referenceListId The referenceListId of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.setReferenceListId = function(referenceListId) {
  this._referenceListId = referenceListId;
  return this;
};

/**
 * Provides the referenceListId of this IncomingShare.
 * @return {string} The referenceListId of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.getReferenceListId = function() {
  return this._referenceListId;
};

/**
 * Sets the shareType of this IncomingShare.
 * @param {string} shareType The shareType of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.setShareType = function(shareType) {
  this._shareType = shareType;
  return this;
};

/**
 * Provides the shareType of this IncomingShare.
 * @return {string} The shareType of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.getShareType = function() {
  return this._shareType;
};

/**
 * Sets the bucketPermission of this IncomingShare.
 * @param {Array.<string>} bucketPermission The bucketPermission of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.setBucketPermission = function(bucketPermission) {
  this._bucketPermission = bucketPermission;
  return this;
};

/**
 * Provides the bucketPermission of this IncomingShare.
 * @return {Array.<string>} The bucketPermission of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.getBucketPermission = function() {
  return this._bucketPermission;
};

/**
 * Loads the bucketPermission of this IncomingShare.
 * @return {Promise.<tutao.entity.sys.BucketPermission>} Resolves to the loaded bucketPermission of this IncomingShare or an exception if the loading failed.
 */
tutao.entity.sys.IncomingShare.prototype.loadBucketPermission = function() {
  return tutao.entity.sys.BucketPermission.load(this._bucketPermission);
};

/**
 * Sets the ownerGroup of this IncomingShare.
 * @param {string} ownerGroup The ownerGroup of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.setOwnerGroup = function(ownerGroup) {
  this._ownerGroup = ownerGroup;
  return this;
};

/**
 * Provides the ownerGroup of this IncomingShare.
 * @return {string} The ownerGroup of this IncomingShare.
 */
tutao.entity.sys.IncomingShare.prototype.getOwnerGroup = function() {
  return this._ownerGroup;
};

/**
 * Loads the ownerGroup of this IncomingShare.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded ownerGroup of this IncomingShare or an exception if the loading failed.
 */
tutao.entity.sys.IncomingShare.prototype.loadOwnerGroup = function() {
  return tutao.entity.sys.Group.load(this._ownerGroup);
};

/**
 * Loads a IncomingShare from the server.
 * @param {Array.<string>} id The id of the IncomingShare.
 * @return {Promise.<tutao.entity.sys.IncomingShare>} Resolves to the IncomingShare or an exception if the loading failed.
 */
tutao.entity.sys.IncomingShare.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.IncomingShare, tutao.entity.sys.IncomingShare.PATH, id[1], id[0], {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple IncomingShares from the server.
 * @param {Array.<Array.<string>>} ids The ids of the IncomingShares to load.
 * @return {Promise.<Array.<tutao.entity.sys.IncomingShare>>} Resolves to an array of IncomingShare or rejects with an exception if the loading failed.
 */
tutao.entity.sys.IncomingShare.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.IncomingShare, tutao.entity.sys.IncomingShare.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.sys.IncomingShare.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 4;
  return tutao.locator.entityRestClient.putElement(tutao.entity.sys.IncomingShare.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Provides a  list of IncomingShares loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.sys.IncomingShare>>} Resolves to an array of IncomingShare or rejects with an exception if the loading failed.
 */
tutao.entity.sys.IncomingShare.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.sys.IncomingShare, tutao.entity.sys.IncomingShare.PATH, listId, start, count, reverse, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.IncomingShare.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.IncomingShare.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.InvoiceServiceData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.InvoiceServiceData = function(data) {
  if (data) {
    this.__format = data._format;
  } else {
    this.__format = "0";
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.InvoiceServiceData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.InvoiceServiceData.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.InvoiceServiceData.PATH = '/rest/sys/invoiceservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.InvoiceServiceData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.InvoiceServiceData.prototype.toJsonData = function() {
  return {
    _format: this.__format
  };
};

/**
 * The id of the InvoiceServiceData type.
 */
tutao.entity.sys.InvoiceServiceData.prototype.TYPE_ID = 594;

/**
 * Sets the format of this InvoiceServiceData.
 * @param {string} format The format of this InvoiceServiceData.
 */
tutao.entity.sys.InvoiceServiceData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this InvoiceServiceData.
 * @return {string} The format of this InvoiceServiceData.
 */
tutao.entity.sys.InvoiceServiceData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.InvoiceServiceData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.sys.InvoiceServiceData.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.sys.KeyPair');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.KeyPair = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._pubKey = data.pubKey;
    this._symEncPrivKey = data.symEncPrivKey;
    this._version = data.version;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._pubKey = null;
    this._symEncPrivKey = null;
    this._version = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.KeyPair.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.KeyPair.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    pubKey: this._pubKey, 
    symEncPrivKey: this._symEncPrivKey, 
    version: this._version
  };
};

/**
 * The id of the KeyPair type.
 */
tutao.entity.sys.KeyPair.prototype.TYPE_ID = 0;

/**
 * The id of the pubKey attribute.
 */
tutao.entity.sys.KeyPair.prototype.PUBKEY_ATTRIBUTE_ID = 2;

/**
 * The id of the symEncPrivKey attribute.
 */
tutao.entity.sys.KeyPair.prototype.SYMENCPRIVKEY_ATTRIBUTE_ID = 3;

/**
 * The id of the version attribute.
 */
tutao.entity.sys.KeyPair.prototype.VERSION_ATTRIBUTE_ID = 4;

/**
 * Sets the id of this KeyPair.
 * @param {string} id The id of this KeyPair.
 */
tutao.entity.sys.KeyPair.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this KeyPair.
 * @return {string} The id of this KeyPair.
 */
tutao.entity.sys.KeyPair.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the pubKey of this KeyPair.
 * @param {string} pubKey The pubKey of this KeyPair.
 */
tutao.entity.sys.KeyPair.prototype.setPubKey = function(pubKey) {
  this._pubKey = pubKey;
  return this;
};

/**
 * Provides the pubKey of this KeyPair.
 * @return {string} The pubKey of this KeyPair.
 */
tutao.entity.sys.KeyPair.prototype.getPubKey = function() {
  return this._pubKey;
};

/**
 * Sets the symEncPrivKey of this KeyPair.
 * @param {string} symEncPrivKey The symEncPrivKey of this KeyPair.
 */
tutao.entity.sys.KeyPair.prototype.setSymEncPrivKey = function(symEncPrivKey) {
  this._symEncPrivKey = symEncPrivKey;
  return this;
};

/**
 * Provides the symEncPrivKey of this KeyPair.
 * @return {string} The symEncPrivKey of this KeyPair.
 */
tutao.entity.sys.KeyPair.prototype.getSymEncPrivKey = function() {
  return this._symEncPrivKey;
};

/**
 * Sets the version of this KeyPair.
 * @param {string} version The version of this KeyPair.
 */
tutao.entity.sys.KeyPair.prototype.setVersion = function(version) {
  this._version = version;
  return this;
};

/**
 * Provides the version of this KeyPair.
 * @return {string} The version of this KeyPair.
 */
tutao.entity.sys.KeyPair.prototype.getVersion = function() {
  return this._version;
};

"use strict";

tutao.provide('tutao.entity.sys.ListVersionInfo');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.ListVersionInfo = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._operation = data.operation;
    this._timestamp = data.timestamp;
    this._author = data.author;
    this._authorGroupInfo = data.authorGroupInfo;
    this._version = data.version;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._operation = null;
    this._timestamp = null;
    this._author = null;
    this._authorGroupInfo = null;
    this._version = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.ListVersionInfo.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.ListVersionInfo.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.ListVersionInfo.PATH = '/rest/sys/listversioninfo';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.ListVersionInfo.ROOT_INSTANCE_ID = 'A3N5cwAA-g';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.ListVersionInfo.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.ListVersionInfo.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.ListVersionInfo.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    operation: this._operation, 
    timestamp: this._timestamp, 
    author: this._author, 
    authorGroupInfo: this._authorGroupInfo, 
    version: this._version
  };
};

/**
 * The id of the ListVersionInfo type.
 */
tutao.entity.sys.ListVersionInfo.prototype.TYPE_ID = 250;

/**
 * The id of the operation attribute.
 */
tutao.entity.sys.ListVersionInfo.prototype.OPERATION_ATTRIBUTE_ID = 256;

/**
 * The id of the timestamp attribute.
 */
tutao.entity.sys.ListVersionInfo.prototype.TIMESTAMP_ATTRIBUTE_ID = 255;

/**
 * The id of the author attribute.
 */
tutao.entity.sys.ListVersionInfo.prototype.AUTHOR_ATTRIBUTE_ID = 258;

/**
 * The id of the authorGroupInfo attribute.
 */
tutao.entity.sys.ListVersionInfo.prototype.AUTHORGROUPINFO_ATTRIBUTE_ID = 259;

/**
 * The id of the version attribute.
 */
tutao.entity.sys.ListVersionInfo.prototype.VERSION_ATTRIBUTE_ID = 257;

/**
 * Provides the id of this ListVersionInfo.
 * @return {Array.<string>} The id of this ListVersionInfo.
 */
tutao.entity.sys.ListVersionInfo.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this ListVersionInfo.
 * @param {string} format The format of this ListVersionInfo.
 */
tutao.entity.sys.ListVersionInfo.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this ListVersionInfo.
 * @return {string} The format of this ListVersionInfo.
 */
tutao.entity.sys.ListVersionInfo.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this ListVersionInfo.
 * @param {string} permissions The permissions of this ListVersionInfo.
 */
tutao.entity.sys.ListVersionInfo.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this ListVersionInfo.
 * @return {string} The permissions of this ListVersionInfo.
 */
tutao.entity.sys.ListVersionInfo.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the operation of this ListVersionInfo.
 * @param {string} operation The operation of this ListVersionInfo.
 */
tutao.entity.sys.ListVersionInfo.prototype.setOperation = function(operation) {
  this._operation = operation;
  return this;
};

/**
 * Provides the operation of this ListVersionInfo.
 * @return {string} The operation of this ListVersionInfo.
 */
tutao.entity.sys.ListVersionInfo.prototype.getOperation = function() {
  return this._operation;
};

/**
 * Sets the timestamp of this ListVersionInfo.
 * @param {Date} timestamp The timestamp of this ListVersionInfo.
 */
tutao.entity.sys.ListVersionInfo.prototype.setTimestamp = function(timestamp) {
  this._timestamp = String(timestamp.getTime());
  return this;
};

/**
 * Provides the timestamp of this ListVersionInfo.
 * @return {Date} The timestamp of this ListVersionInfo.
 */
tutao.entity.sys.ListVersionInfo.prototype.getTimestamp = function() {
  if (isNaN(this._timestamp)) {
    throw new tutao.InvalidDataError('invalid time data: ' + this._timestamp);
  }
  return new Date(Number(this._timestamp));
};

/**
 * Sets the author of this ListVersionInfo.
 * @param {string} author The author of this ListVersionInfo.
 */
tutao.entity.sys.ListVersionInfo.prototype.setAuthor = function(author) {
  this._author = author;
  return this;
};

/**
 * Provides the author of this ListVersionInfo.
 * @return {string} The author of this ListVersionInfo.
 */
tutao.entity.sys.ListVersionInfo.prototype.getAuthor = function() {
  return this._author;
};

/**
 * Loads the author of this ListVersionInfo.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded author of this ListVersionInfo or an exception if the loading failed.
 */
tutao.entity.sys.ListVersionInfo.prototype.loadAuthor = function() {
  return tutao.entity.sys.Group.load(this._author);
};

/**
 * Sets the authorGroupInfo of this ListVersionInfo.
 * @param {Array.<string>} authorGroupInfo The authorGroupInfo of this ListVersionInfo.
 */
tutao.entity.sys.ListVersionInfo.prototype.setAuthorGroupInfo = function(authorGroupInfo) {
  this._authorGroupInfo = authorGroupInfo;
  return this;
};

/**
 * Provides the authorGroupInfo of this ListVersionInfo.
 * @return {Array.<string>} The authorGroupInfo of this ListVersionInfo.
 */
tutao.entity.sys.ListVersionInfo.prototype.getAuthorGroupInfo = function() {
  return this._authorGroupInfo;
};

/**
 * Loads the authorGroupInfo of this ListVersionInfo.
 * @return {Promise.<tutao.entity.sys.GroupInfo>} Resolves to the loaded authorGroupInfo of this ListVersionInfo or an exception if the loading failed.
 */
tutao.entity.sys.ListVersionInfo.prototype.loadAuthorGroupInfo = function() {
  return tutao.entity.sys.GroupInfo.load(this._authorGroupInfo);
};

/**
 * Sets the version of this ListVersionInfo.
 * @param {Array.<string>} version The version of this ListVersionInfo.
 */
tutao.entity.sys.ListVersionInfo.prototype.setVersion = function(version) {
  this._version = version;
  return this;
};

/**
 * Provides the version of this ListVersionInfo.
 * @return {Array.<string>} The version of this ListVersionInfo.
 */
tutao.entity.sys.ListVersionInfo.prototype.getVersion = function() {
  return this._version;
};

/**
 * Loads a ListVersionInfo from the server.
 * @param {Array.<string>} id The id of the ListVersionInfo.
 * @return {Promise.<tutao.entity.sys.ListVersionInfo>} Resolves to the ListVersionInfo or an exception if the loading failed.
 */
tutao.entity.sys.ListVersionInfo.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.ListVersionInfo, tutao.entity.sys.ListVersionInfo.PATH, id[1], id[0], {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple ListVersionInfos from the server.
 * @param {Array.<Array.<string>>} ids The ids of the ListVersionInfos to load.
 * @return {Promise.<Array.<tutao.entity.sys.ListVersionInfo>>} Resolves to an array of ListVersionInfo or rejects with an exception if the loading failed.
 */
tutao.entity.sys.ListVersionInfo.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.ListVersionInfo, tutao.entity.sys.ListVersionInfo.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.sys.ListVersionInfo.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 4;
  return tutao.locator.entityRestClient.putElement(tutao.entity.sys.ListVersionInfo.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Provides a  list of ListVersionInfos loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.sys.ListVersionInfo>>} Resolves to an array of ListVersionInfo or rejects with an exception if the loading failed.
 */
tutao.entity.sys.ListVersionInfo.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.sys.ListVersionInfo, tutao.entity.sys.ListVersionInfo.PATH, listId, start, count, reverse, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.ListVersionInfo.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.ListVersionInfo.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.Login');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.Login = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._time = data.time;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._time = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.Login.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.Login.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.Login.PATH = '/rest/sys/login';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.Login.ROOT_INSTANCE_ID = 'A3N5cwAw';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.Login.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.Login.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.Login.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    time: this._time
  };
};

/**
 * The id of the Login type.
 */
tutao.entity.sys.Login.prototype.TYPE_ID = 48;

/**
 * The id of the time attribute.
 */
tutao.entity.sys.Login.prototype.TIME_ATTRIBUTE_ID = 53;

/**
 * Provides the id of this Login.
 * @return {Array.<string>} The id of this Login.
 */
tutao.entity.sys.Login.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this Login.
 * @param {string} format The format of this Login.
 */
tutao.entity.sys.Login.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this Login.
 * @return {string} The format of this Login.
 */
tutao.entity.sys.Login.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this Login.
 * @param {string} permissions The permissions of this Login.
 */
tutao.entity.sys.Login.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this Login.
 * @return {string} The permissions of this Login.
 */
tutao.entity.sys.Login.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the time of this Login.
 * @param {Date} time The time of this Login.
 */
tutao.entity.sys.Login.prototype.setTime = function(time) {
  this._time = String(time.getTime());
  return this;
};

/**
 * Provides the time of this Login.
 * @return {Date} The time of this Login.
 */
tutao.entity.sys.Login.prototype.getTime = function() {
  if (isNaN(this._time)) {
    throw new tutao.InvalidDataError('invalid time data: ' + this._time);
  }
  return new Date(Number(this._time));
};

/**
 * Loads a Login from the server.
 * @param {Array.<string>} id The id of the Login.
 * @return {Promise.<tutao.entity.sys.Login>} Resolves to the Login or an exception if the loading failed.
 */
tutao.entity.sys.Login.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.Login, tutao.entity.sys.Login.PATH, id[1], id[0], {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple Logins from the server.
 * @param {Array.<Array.<string>>} ids The ids of the Logins to load.
 * @return {Promise.<Array.<tutao.entity.sys.Login>>} Resolves to an array of Login or rejects with an exception if the loading failed.
 */
tutao.entity.sys.Login.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.Login, tutao.entity.sys.Login.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.sys.Login.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 4;
  return tutao.locator.entityRestClient.putElement(tutao.entity.sys.Login.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Provides a  list of Logins loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.sys.Login>>} Resolves to an array of Login or rejects with an exception if the loading failed.
 */
tutao.entity.sys.Login.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.sys.Login, tutao.entity.sys.Login.PATH, listId, start, count, reverse, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.Login.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.Login.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.LongConfigValue');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.LongConfigValue = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._name = data.name;
    this._value = data.value;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._name = null;
    this._value = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.LongConfigValue.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.LongConfigValue.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    name: this._name, 
    value: this._value
  };
};

/**
 * The id of the LongConfigValue type.
 */
tutao.entity.sys.LongConfigValue.prototype.TYPE_ID = 511;

/**
 * The id of the name attribute.
 */
tutao.entity.sys.LongConfigValue.prototype.NAME_ATTRIBUTE_ID = 513;

/**
 * The id of the value attribute.
 */
tutao.entity.sys.LongConfigValue.prototype.VALUE_ATTRIBUTE_ID = 514;

/**
 * Sets the id of this LongConfigValue.
 * @param {string} id The id of this LongConfigValue.
 */
tutao.entity.sys.LongConfigValue.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this LongConfigValue.
 * @return {string} The id of this LongConfigValue.
 */
tutao.entity.sys.LongConfigValue.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the name of this LongConfigValue.
 * @param {string} name The name of this LongConfigValue.
 */
tutao.entity.sys.LongConfigValue.prototype.setName = function(name) {
  this._name = name;
  return this;
};

/**
 * Provides the name of this LongConfigValue.
 * @return {string} The name of this LongConfigValue.
 */
tutao.entity.sys.LongConfigValue.prototype.getName = function() {
  return this._name;
};

/**
 * Sets the value of this LongConfigValue.
 * @param {string} value The value of this LongConfigValue.
 */
tutao.entity.sys.LongConfigValue.prototype.setValue = function(value) {
  this._value = value;
  return this;
};

/**
 * Provides the value of this LongConfigValue.
 * @return {string} The value of this LongConfigValue.
 */
tutao.entity.sys.LongConfigValue.prototype.getValue = function() {
  return this._value;
};

"use strict";

tutao.provide('tutao.entity.sys.MailAddressAvailabilityData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.MailAddressAvailabilityData = function(data) {
  if (data) {
    this.__format = data._format;
    this._mailAddress = data.mailAddress;
  } else {
    this.__format = "0";
    this._mailAddress = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.MailAddressAvailabilityData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.MailAddressAvailabilityData.MODEL_VERSION = '4';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.MailAddressAvailabilityData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.MailAddressAvailabilityData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    mailAddress: this._mailAddress
  };
};

/**
 * The id of the MailAddressAvailabilityData type.
 */
tutao.entity.sys.MailAddressAvailabilityData.prototype.TYPE_ID = 309;

/**
 * The id of the mailAddress attribute.
 */
tutao.entity.sys.MailAddressAvailabilityData.prototype.MAILADDRESS_ATTRIBUTE_ID = 311;

/**
 * Sets the format of this MailAddressAvailabilityData.
 * @param {string} format The format of this MailAddressAvailabilityData.
 */
tutao.entity.sys.MailAddressAvailabilityData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this MailAddressAvailabilityData.
 * @return {string} The format of this MailAddressAvailabilityData.
 */
tutao.entity.sys.MailAddressAvailabilityData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the mailAddress of this MailAddressAvailabilityData.
 * @param {string} mailAddress The mailAddress of this MailAddressAvailabilityData.
 */
tutao.entity.sys.MailAddressAvailabilityData.prototype.setMailAddress = function(mailAddress) {
  this._mailAddress = mailAddress;
  return this;
};

/**
 * Provides the mailAddress of this MailAddressAvailabilityData.
 * @return {string} The mailAddress of this MailAddressAvailabilityData.
 */
tutao.entity.sys.MailAddressAvailabilityData.prototype.getMailAddress = function() {
  return this._mailAddress;
};

"use strict";

tutao.provide('tutao.entity.sys.MailAddressAvailabilityReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.MailAddressAvailabilityReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._available = data.available;
  } else {
    this.__format = "0";
    this._available = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.MailAddressAvailabilityReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.MailAddressAvailabilityReturn.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.MailAddressAvailabilityReturn.PATH = '/rest/sys/mailaddressavailabilityservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.MailAddressAvailabilityReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.MailAddressAvailabilityReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    available: this._available
  };
};

/**
 * The id of the MailAddressAvailabilityReturn type.
 */
tutao.entity.sys.MailAddressAvailabilityReturn.prototype.TYPE_ID = 312;

/**
 * The id of the available attribute.
 */
tutao.entity.sys.MailAddressAvailabilityReturn.prototype.AVAILABLE_ATTRIBUTE_ID = 314;

/**
 * Sets the format of this MailAddressAvailabilityReturn.
 * @param {string} format The format of this MailAddressAvailabilityReturn.
 */
tutao.entity.sys.MailAddressAvailabilityReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this MailAddressAvailabilityReturn.
 * @return {string} The format of this MailAddressAvailabilityReturn.
 */
tutao.entity.sys.MailAddressAvailabilityReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the available of this MailAddressAvailabilityReturn.
 * @param {boolean} available The available of this MailAddressAvailabilityReturn.
 */
tutao.entity.sys.MailAddressAvailabilityReturn.prototype.setAvailable = function(available) {
  this._available = available ? '1' : '0';
  return this;
};

/**
 * Provides the available of this MailAddressAvailabilityReturn.
 * @return {boolean} The available of this MailAddressAvailabilityReturn.
 */
tutao.entity.sys.MailAddressAvailabilityReturn.prototype.getAvailable = function() {
  return this._available == '1';
};

/**
 * Loads from the service.
 * @param {tutao.entity.sys.MailAddressAvailabilityData} entity The entity to send to the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.MailAddressAvailabilityReturn>} Resolves to MailAddressAvailabilityReturn or an exception if the loading failed.
 */
tutao.entity.sys.MailAddressAvailabilityReturn.load = function(entity, parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.getService(tutao.entity.sys.MailAddressAvailabilityReturn, tutao.entity.sys.MailAddressAvailabilityReturn.PATH, entity, parameters, headers);
};

"use strict";

tutao.provide('tutao.entity.sys.MembershipAddData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.MembershipAddData = function(data) {
  if (data) {
    this.__format = data._format;
    this._symEncGKey = data.symEncGKey;
    this._group = data.group;
    this._user = data.user;
  } else {
    this.__format = "0";
    this._symEncGKey = null;
    this._group = null;
    this._user = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.MembershipAddData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.MembershipAddData.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.MembershipAddData.PATH = '/rest/sys/membershipservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.MembershipAddData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.MembershipAddData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    symEncGKey: this._symEncGKey, 
    group: this._group, 
    user: this._user
  };
};

/**
 * The id of the MembershipAddData type.
 */
tutao.entity.sys.MembershipAddData.prototype.TYPE_ID = 505;

/**
 * The id of the symEncGKey attribute.
 */
tutao.entity.sys.MembershipAddData.prototype.SYMENCGKEY_ATTRIBUTE_ID = 507;

/**
 * The id of the group attribute.
 */
tutao.entity.sys.MembershipAddData.prototype.GROUP_ATTRIBUTE_ID = 509;

/**
 * The id of the user attribute.
 */
tutao.entity.sys.MembershipAddData.prototype.USER_ATTRIBUTE_ID = 508;

/**
 * Sets the format of this MembershipAddData.
 * @param {string} format The format of this MembershipAddData.
 */
tutao.entity.sys.MembershipAddData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this MembershipAddData.
 * @return {string} The format of this MembershipAddData.
 */
tutao.entity.sys.MembershipAddData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the symEncGKey of this MembershipAddData.
 * @param {string} symEncGKey The symEncGKey of this MembershipAddData.
 */
tutao.entity.sys.MembershipAddData.prototype.setSymEncGKey = function(symEncGKey) {
  this._symEncGKey = symEncGKey;
  return this;
};

/**
 * Provides the symEncGKey of this MembershipAddData.
 * @return {string} The symEncGKey of this MembershipAddData.
 */
tutao.entity.sys.MembershipAddData.prototype.getSymEncGKey = function() {
  return this._symEncGKey;
};

/**
 * Sets the group of this MembershipAddData.
 * @param {string} group The group of this MembershipAddData.
 */
tutao.entity.sys.MembershipAddData.prototype.setGroup = function(group) {
  this._group = group;
  return this;
};

/**
 * Provides the group of this MembershipAddData.
 * @return {string} The group of this MembershipAddData.
 */
tutao.entity.sys.MembershipAddData.prototype.getGroup = function() {
  return this._group;
};

/**
 * Loads the group of this MembershipAddData.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded group of this MembershipAddData or an exception if the loading failed.
 */
tutao.entity.sys.MembershipAddData.prototype.loadGroup = function() {
  return tutao.entity.sys.Group.load(this._group);
};

/**
 * Sets the user of this MembershipAddData.
 * @param {string} user The user of this MembershipAddData.
 */
tutao.entity.sys.MembershipAddData.prototype.setUser = function(user) {
  this._user = user;
  return this;
};

/**
 * Provides the user of this MembershipAddData.
 * @return {string} The user of this MembershipAddData.
 */
tutao.entity.sys.MembershipAddData.prototype.getUser = function() {
  return this._user;
};

/**
 * Loads the user of this MembershipAddData.
 * @return {Promise.<tutao.entity.sys.User>} Resolves to the loaded user of this MembershipAddData or an exception if the loading failed.
 */
tutao.entity.sys.MembershipAddData.prototype.loadUser = function() {
  return tutao.entity.sys.User.load(this._user);
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.MembershipAddData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.sys.MembershipAddData.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.sys.OutgoingShare');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.OutgoingShare = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._app = data.app;
    this._referenceId = data.referenceId;
    this._referenceListId = data.referenceListId;
    this._shareType = data.shareType;
    this._shareholderMailAddress = data.shareholderMailAddress;
    this._bucketPermission = data.bucketPermission;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._app = null;
    this._referenceId = null;
    this._referenceListId = null;
    this._shareType = null;
    this._shareholderMailAddress = null;
    this._bucketPermission = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.OutgoingShare.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.OutgoingShare.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.OutgoingShare.PATH = '/rest/sys/outgoingshare';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.OutgoingShare.ROOT_INSTANCE_ID = 'A3N5cwABDw';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.OutgoingShare.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.OutgoingShare.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.OutgoingShare.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    app: this._app, 
    referenceId: this._referenceId, 
    referenceListId: this._referenceListId, 
    shareType: this._shareType, 
    shareholderMailAddress: this._shareholderMailAddress, 
    bucketPermission: this._bucketPermission
  };
};

/**
 * The id of the OutgoingShare type.
 */
tutao.entity.sys.OutgoingShare.prototype.TYPE_ID = 271;

/**
 * The id of the app attribute.
 */
tutao.entity.sys.OutgoingShare.prototype.APP_ATTRIBUTE_ID = 276;

/**
 * The id of the referenceId attribute.
 */
tutao.entity.sys.OutgoingShare.prototype.REFERENCEID_ATTRIBUTE_ID = 279;

/**
 * The id of the referenceListId attribute.
 */
tutao.entity.sys.OutgoingShare.prototype.REFERENCELISTID_ATTRIBUTE_ID = 278;

/**
 * The id of the shareType attribute.
 */
tutao.entity.sys.OutgoingShare.prototype.SHARETYPE_ATTRIBUTE_ID = 277;

/**
 * The id of the shareholderMailAddress attribute.
 */
tutao.entity.sys.OutgoingShare.prototype.SHAREHOLDERMAILADDRESS_ATTRIBUTE_ID = 280;

/**
 * The id of the bucketPermission attribute.
 */
tutao.entity.sys.OutgoingShare.prototype.BUCKETPERMISSION_ATTRIBUTE_ID = 281;

/**
 * Provides the id of this OutgoingShare.
 * @return {Array.<string>} The id of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this OutgoingShare.
 * @param {string} format The format of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this OutgoingShare.
 * @return {string} The format of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this OutgoingShare.
 * @param {string} permissions The permissions of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this OutgoingShare.
 * @return {string} The permissions of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the app of this OutgoingShare.
 * @param {string} app The app of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.setApp = function(app) {
  this._app = app;
  return this;
};

/**
 * Provides the app of this OutgoingShare.
 * @return {string} The app of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.getApp = function() {
  return this._app;
};

/**
 * Sets the referenceId of this OutgoingShare.
 * @param {string} referenceId The referenceId of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.setReferenceId = function(referenceId) {
  this._referenceId = referenceId;
  return this;
};

/**
 * Provides the referenceId of this OutgoingShare.
 * @return {string} The referenceId of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.getReferenceId = function() {
  return this._referenceId;
};

/**
 * Sets the referenceListId of this OutgoingShare.
 * @param {string} referenceListId The referenceListId of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.setReferenceListId = function(referenceListId) {
  this._referenceListId = referenceListId;
  return this;
};

/**
 * Provides the referenceListId of this OutgoingShare.
 * @return {string} The referenceListId of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.getReferenceListId = function() {
  return this._referenceListId;
};

/**
 * Sets the shareType of this OutgoingShare.
 * @param {string} shareType The shareType of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.setShareType = function(shareType) {
  this._shareType = shareType;
  return this;
};

/**
 * Provides the shareType of this OutgoingShare.
 * @return {string} The shareType of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.getShareType = function() {
  return this._shareType;
};

/**
 * Sets the shareholderMailAddress of this OutgoingShare.
 * @param {string} shareholderMailAddress The shareholderMailAddress of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.setShareholderMailAddress = function(shareholderMailAddress) {
  this._shareholderMailAddress = shareholderMailAddress;
  return this;
};

/**
 * Provides the shareholderMailAddress of this OutgoingShare.
 * @return {string} The shareholderMailAddress of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.getShareholderMailAddress = function() {
  return this._shareholderMailAddress;
};

/**
 * Sets the bucketPermission of this OutgoingShare.
 * @param {Array.<string>} bucketPermission The bucketPermission of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.setBucketPermission = function(bucketPermission) {
  this._bucketPermission = bucketPermission;
  return this;
};

/**
 * Provides the bucketPermission of this OutgoingShare.
 * @return {Array.<string>} The bucketPermission of this OutgoingShare.
 */
tutao.entity.sys.OutgoingShare.prototype.getBucketPermission = function() {
  return this._bucketPermission;
};

/**
 * Loads the bucketPermission of this OutgoingShare.
 * @return {Promise.<tutao.entity.sys.BucketPermission>} Resolves to the loaded bucketPermission of this OutgoingShare or an exception if the loading failed.
 */
tutao.entity.sys.OutgoingShare.prototype.loadBucketPermission = function() {
  return tutao.entity.sys.BucketPermission.load(this._bucketPermission);
};

/**
 * Loads a OutgoingShare from the server.
 * @param {Array.<string>} id The id of the OutgoingShare.
 * @return {Promise.<tutao.entity.sys.OutgoingShare>} Resolves to the OutgoingShare or an exception if the loading failed.
 */
tutao.entity.sys.OutgoingShare.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.OutgoingShare, tutao.entity.sys.OutgoingShare.PATH, id[1], id[0], {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple OutgoingShares from the server.
 * @param {Array.<Array.<string>>} ids The ids of the OutgoingShares to load.
 * @return {Promise.<Array.<tutao.entity.sys.OutgoingShare>>} Resolves to an array of OutgoingShare or rejects with an exception if the loading failed.
 */
tutao.entity.sys.OutgoingShare.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.OutgoingShare, tutao.entity.sys.OutgoingShare.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.sys.OutgoingShare.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 4;
  return tutao.locator.entityRestClient.putElement(tutao.entity.sys.OutgoingShare.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Provides a  list of OutgoingShares loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.sys.OutgoingShare>>} Resolves to an array of OutgoingShare or rejects with an exception if the loading failed.
 */
tutao.entity.sys.OutgoingShare.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.sys.OutgoingShare, tutao.entity.sys.OutgoingShare.PATH, listId, start, count, reverse, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.OutgoingShare.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.OutgoingShare.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.Permission');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.Permission = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._bucketEncSessionKey = data.bucketEncSessionKey;
    this._ops = data.ops;
    this._symEncSessionKey = data.symEncSessionKey;
    this._type = data.type;
    this._bucket = (data.bucket) ? new tutao.entity.sys.Bucket(this, data.bucket) : null;
    this._group = data.group;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._bucketEncSessionKey = null;
    this._ops = null;
    this._symEncSessionKey = null;
    this._type = null;
    this._bucket = null;
    this._group = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.Permission.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.Permission.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.Permission.PATH = '/rest/sys/permission';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.Permission.ROOT_INSTANCE_ID = 'A3N5cwAAhA';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.Permission.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.Permission.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.Permission.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    bucketEncSessionKey: this._bucketEncSessionKey, 
    ops: this._ops, 
    symEncSessionKey: this._symEncSessionKey, 
    type: this._type, 
    bucket: tutao.entity.EntityHelper.aggregatesToJsonData(this._bucket), 
    group: this._group
  };
};

/**
 * The id of the Permission type.
 */
tutao.entity.sys.Permission.prototype.TYPE_ID = 132;

/**
 * The id of the bucketEncSessionKey attribute.
 */
tutao.entity.sys.Permission.prototype.BUCKETENCSESSIONKEY_ATTRIBUTE_ID = 139;

/**
 * The id of the ops attribute.
 */
tutao.entity.sys.Permission.prototype.OPS_ATTRIBUTE_ID = 140;

/**
 * The id of the symEncSessionKey attribute.
 */
tutao.entity.sys.Permission.prototype.SYMENCSESSIONKEY_ATTRIBUTE_ID = 138;

/**
 * The id of the type attribute.
 */
tutao.entity.sys.Permission.prototype.TYPE_ATTRIBUTE_ID = 137;

/**
 * The id of the bucket attribute.
 */
tutao.entity.sys.Permission.prototype.BUCKET_ATTRIBUTE_ID = 142;

/**
 * The id of the group attribute.
 */
tutao.entity.sys.Permission.prototype.GROUP_ATTRIBUTE_ID = 141;

/**
 * Provides the id of this Permission.
 * @return {Array.<string>} The id of this Permission.
 */
tutao.entity.sys.Permission.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this Permission.
 * @param {string} format The format of this Permission.
 */
tutao.entity.sys.Permission.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this Permission.
 * @return {string} The format of this Permission.
 */
tutao.entity.sys.Permission.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this Permission.
 * @param {string} permissions The permissions of this Permission.
 */
tutao.entity.sys.Permission.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this Permission.
 * @return {string} The permissions of this Permission.
 */
tutao.entity.sys.Permission.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the bucketEncSessionKey of this Permission.
 * @param {string} bucketEncSessionKey The bucketEncSessionKey of this Permission.
 */
tutao.entity.sys.Permission.prototype.setBucketEncSessionKey = function(bucketEncSessionKey) {
  this._bucketEncSessionKey = bucketEncSessionKey;
  return this;
};

/**
 * Provides the bucketEncSessionKey of this Permission.
 * @return {string} The bucketEncSessionKey of this Permission.
 */
tutao.entity.sys.Permission.prototype.getBucketEncSessionKey = function() {
  return this._bucketEncSessionKey;
};

/**
 * Sets the ops of this Permission.
 * @param {string} ops The ops of this Permission.
 */
tutao.entity.sys.Permission.prototype.setOps = function(ops) {
  this._ops = ops;
  return this;
};

/**
 * Provides the ops of this Permission.
 * @return {string} The ops of this Permission.
 */
tutao.entity.sys.Permission.prototype.getOps = function() {
  return this._ops;
};

/**
 * Sets the symEncSessionKey of this Permission.
 * @param {string} symEncSessionKey The symEncSessionKey of this Permission.
 */
tutao.entity.sys.Permission.prototype.setSymEncSessionKey = function(symEncSessionKey) {
  this._symEncSessionKey = symEncSessionKey;
  return this;
};

/**
 * Provides the symEncSessionKey of this Permission.
 * @return {string} The symEncSessionKey of this Permission.
 */
tutao.entity.sys.Permission.prototype.getSymEncSessionKey = function() {
  return this._symEncSessionKey;
};

/**
 * Sets the type of this Permission.
 * @param {string} type The type of this Permission.
 */
tutao.entity.sys.Permission.prototype.setType = function(type) {
  this._type = type;
  return this;
};

/**
 * Provides the type of this Permission.
 * @return {string} The type of this Permission.
 */
tutao.entity.sys.Permission.prototype.getType = function() {
  return this._type;
};

/**
 * Sets the bucket of this Permission.
 * @param {tutao.entity.sys.Bucket} bucket The bucket of this Permission.
 */
tutao.entity.sys.Permission.prototype.setBucket = function(bucket) {
  this._bucket = bucket;
  return this;
};

/**
 * Provides the bucket of this Permission.
 * @return {tutao.entity.sys.Bucket} The bucket of this Permission.
 */
tutao.entity.sys.Permission.prototype.getBucket = function() {
  return this._bucket;
};

/**
 * Sets the group of this Permission.
 * @param {string} group The group of this Permission.
 */
tutao.entity.sys.Permission.prototype.setGroup = function(group) {
  this._group = group;
  return this;
};

/**
 * Provides the group of this Permission.
 * @return {string} The group of this Permission.
 */
tutao.entity.sys.Permission.prototype.getGroup = function() {
  return this._group;
};

/**
 * Loads the group of this Permission.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded group of this Permission or an exception if the loading failed.
 */
tutao.entity.sys.Permission.prototype.loadGroup = function() {
  return tutao.entity.sys.Group.load(this._group);
};

/**
 * Loads a Permission from the server.
 * @param {Array.<string>} id The id of the Permission.
 * @return {Promise.<tutao.entity.sys.Permission>} Resolves to the Permission or an exception if the loading failed.
 */
tutao.entity.sys.Permission.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.Permission, tutao.entity.sys.Permission.PATH, id[1], id[0], {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple Permissions from the server.
 * @param {Array.<Array.<string>>} ids The ids of the Permissions to load.
 * @return {Promise.<Array.<tutao.entity.sys.Permission>>} Resolves to an array of Permission or rejects with an exception if the loading failed.
 */
tutao.entity.sys.Permission.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.Permission, tutao.entity.sys.Permission.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.sys.Permission.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 4;
  return tutao.locator.entityRestClient.putElement(tutao.entity.sys.Permission.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Provides a  list of Permissions loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.sys.Permission>>} Resolves to an array of Permission or rejects with an exception if the loading failed.
 */
tutao.entity.sys.Permission.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.sys.Permission, tutao.entity.sys.Permission.PATH, listId, start, count, reverse, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.Permission.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.Permission.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.PhoneNumber');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.PhoneNumber = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._number = data.number;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._number = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.PhoneNumber.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.PhoneNumber.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    number: this._number
  };
};

/**
 * The id of the PhoneNumber type.
 */
tutao.entity.sys.PhoneNumber.prototype.TYPE_ID = 63;

/**
 * The id of the number attribute.
 */
tutao.entity.sys.PhoneNumber.prototype.NUMBER_ATTRIBUTE_ID = 65;

/**
 * Sets the id of this PhoneNumber.
 * @param {string} id The id of this PhoneNumber.
 */
tutao.entity.sys.PhoneNumber.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this PhoneNumber.
 * @return {string} The id of this PhoneNumber.
 */
tutao.entity.sys.PhoneNumber.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the number of this PhoneNumber.
 * @param {string} number The number of this PhoneNumber.
 */
tutao.entity.sys.PhoneNumber.prototype.setNumber = function(number) {
  this._number = number;
  return this;
};

/**
 * Provides the number of this PhoneNumber.
 * @return {string} The number of this PhoneNumber.
 */
tutao.entity.sys.PhoneNumber.prototype.getNumber = function() {
  return this._number;
};

"use strict";

tutao.provide('tutao.entity.sys.PhoneNumberTypeData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.PhoneNumberTypeData = function(data) {
  if (data) {
    this.__format = data._format;
    this._phoneNumber = data.phoneNumber;
  } else {
    this.__format = "0";
    this._phoneNumber = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.PhoneNumberTypeData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.PhoneNumberTypeData.MODEL_VERSION = '4';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.PhoneNumberTypeData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.PhoneNumberTypeData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    phoneNumber: this._phoneNumber
  };
};

/**
 * The id of the PhoneNumberTypeData type.
 */
tutao.entity.sys.PhoneNumberTypeData.prototype.TYPE_ID = 617;

/**
 * The id of the phoneNumber attribute.
 */
tutao.entity.sys.PhoneNumberTypeData.prototype.PHONENUMBER_ATTRIBUTE_ID = 619;

/**
 * Sets the format of this PhoneNumberTypeData.
 * @param {string} format The format of this PhoneNumberTypeData.
 */
tutao.entity.sys.PhoneNumberTypeData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this PhoneNumberTypeData.
 * @return {string} The format of this PhoneNumberTypeData.
 */
tutao.entity.sys.PhoneNumberTypeData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the phoneNumber of this PhoneNumberTypeData.
 * @param {string} phoneNumber The phoneNumber of this PhoneNumberTypeData.
 */
tutao.entity.sys.PhoneNumberTypeData.prototype.setPhoneNumber = function(phoneNumber) {
  this._phoneNumber = phoneNumber;
  return this;
};

/**
 * Provides the phoneNumber of this PhoneNumberTypeData.
 * @return {string} The phoneNumber of this PhoneNumberTypeData.
 */
tutao.entity.sys.PhoneNumberTypeData.prototype.getPhoneNumber = function() {
  return this._phoneNumber;
};

"use strict";

tutao.provide('tutao.entity.sys.PhoneNumberTypeReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.PhoneNumberTypeReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._type = data.type;
  } else {
    this.__format = "0";
    this._type = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.PhoneNumberTypeReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.PhoneNumberTypeReturn.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.PhoneNumberTypeReturn.PATH = '/rest/sys/phonenumbertypeservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.PhoneNumberTypeReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.PhoneNumberTypeReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    type: this._type
  };
};

/**
 * The id of the PhoneNumberTypeReturn type.
 */
tutao.entity.sys.PhoneNumberTypeReturn.prototype.TYPE_ID = 620;

/**
 * The id of the type attribute.
 */
tutao.entity.sys.PhoneNumberTypeReturn.prototype.TYPE_ATTRIBUTE_ID = 622;

/**
 * Sets the format of this PhoneNumberTypeReturn.
 * @param {string} format The format of this PhoneNumberTypeReturn.
 */
tutao.entity.sys.PhoneNumberTypeReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this PhoneNumberTypeReturn.
 * @return {string} The format of this PhoneNumberTypeReturn.
 */
tutao.entity.sys.PhoneNumberTypeReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the type of this PhoneNumberTypeReturn.
 * @param {string} type The type of this PhoneNumberTypeReturn.
 */
tutao.entity.sys.PhoneNumberTypeReturn.prototype.setType = function(type) {
  this._type = type;
  return this;
};

/**
 * Provides the type of this PhoneNumberTypeReturn.
 * @return {string} The type of this PhoneNumberTypeReturn.
 */
tutao.entity.sys.PhoneNumberTypeReturn.prototype.getType = function() {
  return this._type;
};

/**
 * Loads from the service.
 * @param {tutao.entity.sys.PhoneNumberTypeData} entity The entity to send to the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.PhoneNumberTypeReturn>} Resolves to PhoneNumberTypeReturn or an exception if the loading failed.
 */
tutao.entity.sys.PhoneNumberTypeReturn.load = function(entity, parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.getService(tutao.entity.sys.PhoneNumberTypeReturn, tutao.entity.sys.PhoneNumberTypeReturn.PATH, entity, parameters, headers);
};

"use strict";

tutao.provide('tutao.entity.sys.PublicKeyData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.PublicKeyData = function(data) {
  if (data) {
    this.__format = data._format;
    this._mailAddress = data.mailAddress;
  } else {
    this.__format = "0";
    this._mailAddress = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.PublicKeyData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.PublicKeyData.MODEL_VERSION = '4';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.PublicKeyData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.PublicKeyData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    mailAddress: this._mailAddress
  };
};

/**
 * The id of the PublicKeyData type.
 */
tutao.entity.sys.PublicKeyData.prototype.TYPE_ID = 409;

/**
 * The id of the mailAddress attribute.
 */
tutao.entity.sys.PublicKeyData.prototype.MAILADDRESS_ATTRIBUTE_ID = 411;

/**
 * Sets the format of this PublicKeyData.
 * @param {string} format The format of this PublicKeyData.
 */
tutao.entity.sys.PublicKeyData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this PublicKeyData.
 * @return {string} The format of this PublicKeyData.
 */
tutao.entity.sys.PublicKeyData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the mailAddress of this PublicKeyData.
 * @param {string} mailAddress The mailAddress of this PublicKeyData.
 */
tutao.entity.sys.PublicKeyData.prototype.setMailAddress = function(mailAddress) {
  this._mailAddress = mailAddress;
  return this;
};

/**
 * Provides the mailAddress of this PublicKeyData.
 * @return {string} The mailAddress of this PublicKeyData.
 */
tutao.entity.sys.PublicKeyData.prototype.getMailAddress = function() {
  return this._mailAddress;
};

"use strict";

tutao.provide('tutao.entity.sys.PublicKeyReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.PublicKeyReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._pubKey = data.pubKey;
    this._pubKeyVersion = data.pubKeyVersion;
  } else {
    this.__format = "0";
    this._pubKey = null;
    this._pubKeyVersion = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.PublicKeyReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.PublicKeyReturn.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.PublicKeyReturn.PATH = '/rest/sys/publickeyservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.PublicKeyReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.PublicKeyReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    pubKey: this._pubKey, 
    pubKeyVersion: this._pubKeyVersion
  };
};

/**
 * The id of the PublicKeyReturn type.
 */
tutao.entity.sys.PublicKeyReturn.prototype.TYPE_ID = 412;

/**
 * The id of the pubKey attribute.
 */
tutao.entity.sys.PublicKeyReturn.prototype.PUBKEY_ATTRIBUTE_ID = 414;

/**
 * The id of the pubKeyVersion attribute.
 */
tutao.entity.sys.PublicKeyReturn.prototype.PUBKEYVERSION_ATTRIBUTE_ID = 415;

/**
 * Sets the format of this PublicKeyReturn.
 * @param {string} format The format of this PublicKeyReturn.
 */
tutao.entity.sys.PublicKeyReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this PublicKeyReturn.
 * @return {string} The format of this PublicKeyReturn.
 */
tutao.entity.sys.PublicKeyReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the pubKey of this PublicKeyReturn.
 * @param {string} pubKey The pubKey of this PublicKeyReturn.
 */
tutao.entity.sys.PublicKeyReturn.prototype.setPubKey = function(pubKey) {
  this._pubKey = pubKey;
  return this;
};

/**
 * Provides the pubKey of this PublicKeyReturn.
 * @return {string} The pubKey of this PublicKeyReturn.
 */
tutao.entity.sys.PublicKeyReturn.prototype.getPubKey = function() {
  return this._pubKey;
};

/**
 * Sets the pubKeyVersion of this PublicKeyReturn.
 * @param {string} pubKeyVersion The pubKeyVersion of this PublicKeyReturn.
 */
tutao.entity.sys.PublicKeyReturn.prototype.setPubKeyVersion = function(pubKeyVersion) {
  this._pubKeyVersion = pubKeyVersion;
  return this;
};

/**
 * Provides the pubKeyVersion of this PublicKeyReturn.
 * @return {string} The pubKeyVersion of this PublicKeyReturn.
 */
tutao.entity.sys.PublicKeyReturn.prototype.getPubKeyVersion = function() {
  return this._pubKeyVersion;
};

/**
 * Loads from the service.
 * @param {tutao.entity.sys.PublicKeyData} entity The entity to send to the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.PublicKeyReturn>} Resolves to PublicKeyReturn or an exception if the loading failed.
 */
tutao.entity.sys.PublicKeyReturn.load = function(entity, parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.getService(tutao.entity.sys.PublicKeyReturn, tutao.entity.sys.PublicKeyReturn.PATH, entity, parameters, headers);
};

"use strict";

tutao.provide('tutao.entity.sys.RegistrationConfigReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.RegistrationConfigReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._freeEnabled = data.freeEnabled;
    this._starterEnabled = data.starterEnabled;
  } else {
    this.__format = "0";
    this._freeEnabled = null;
    this._starterEnabled = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.RegistrationConfigReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.RegistrationConfigReturn.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.RegistrationConfigReturn.PATH = '/rest/sys/registrationconfigservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.RegistrationConfigReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.RegistrationConfigReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    freeEnabled: this._freeEnabled, 
    starterEnabled: this._starterEnabled
  };
};

/**
 * The id of the RegistrationConfigReturn type.
 */
tutao.entity.sys.RegistrationConfigReturn.prototype.TYPE_ID = 606;

/**
 * The id of the freeEnabled attribute.
 */
tutao.entity.sys.RegistrationConfigReturn.prototype.FREEENABLED_ATTRIBUTE_ID = 609;

/**
 * The id of the starterEnabled attribute.
 */
tutao.entity.sys.RegistrationConfigReturn.prototype.STARTERENABLED_ATTRIBUTE_ID = 608;

/**
 * Sets the format of this RegistrationConfigReturn.
 * @param {string} format The format of this RegistrationConfigReturn.
 */
tutao.entity.sys.RegistrationConfigReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this RegistrationConfigReturn.
 * @return {string} The format of this RegistrationConfigReturn.
 */
tutao.entity.sys.RegistrationConfigReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the freeEnabled of this RegistrationConfigReturn.
 * @param {boolean} freeEnabled The freeEnabled of this RegistrationConfigReturn.
 */
tutao.entity.sys.RegistrationConfigReturn.prototype.setFreeEnabled = function(freeEnabled) {
  this._freeEnabled = freeEnabled ? '1' : '0';
  return this;
};

/**
 * Provides the freeEnabled of this RegistrationConfigReturn.
 * @return {boolean} The freeEnabled of this RegistrationConfigReturn.
 */
tutao.entity.sys.RegistrationConfigReturn.prototype.getFreeEnabled = function() {
  return this._freeEnabled == '1';
};

/**
 * Sets the starterEnabled of this RegistrationConfigReturn.
 * @param {boolean} starterEnabled The starterEnabled of this RegistrationConfigReturn.
 */
tutao.entity.sys.RegistrationConfigReturn.prototype.setStarterEnabled = function(starterEnabled) {
  this._starterEnabled = starterEnabled ? '1' : '0';
  return this;
};

/**
 * Provides the starterEnabled of this RegistrationConfigReturn.
 * @return {boolean} The starterEnabled of this RegistrationConfigReturn.
 */
tutao.entity.sys.RegistrationConfigReturn.prototype.getStarterEnabled = function() {
  return this._starterEnabled == '1';
};

/**
 * Loads from the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.RegistrationConfigReturn>} Resolves to RegistrationConfigReturn or an exception if the loading failed.
 */
tutao.entity.sys.RegistrationConfigReturn.load = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.RegistrationConfigReturn, tutao.entity.sys.RegistrationConfigReturn.PATH, null, null, parameters, headers);
};

"use strict";

tutao.provide('tutao.entity.sys.RegistrationData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.RegistrationData = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._accountType = data.accountType;
    this._code = data.code;
    this._company = data.company;
    this._domain = data.domain;
    this._domainVerificationMailSentOn = data.domainVerificationMailSentOn;
    this._groupName = data.groupName;
    this._language = data.language;
    this._mailAddress = data.mailAddress;
    this._mobilePhoneNumber = data.mobilePhoneNumber;
    this._state = data.state;
    this._verifyCount = data.verifyCount;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._accountType = null;
    this._code = null;
    this._company = null;
    this._domain = null;
    this._domainVerificationMailSentOn = null;
    this._groupName = null;
    this._language = null;
    this._mailAddress = null;
    this._mobilePhoneNumber = null;
    this._state = null;
    this._verifyCount = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.RegistrationData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.RegistrationData.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.RegistrationData.PATH = '/rest/sys/registrationdata';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.RegistrationData.ROOT_INSTANCE_ID = 'A3N5cwAAoQ';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.RegistrationData.GENERATED_ID = false;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.RegistrationData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.RegistrationData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    accountType: this._accountType, 
    code: this._code, 
    company: this._company, 
    domain: this._domain, 
    domainVerificationMailSentOn: this._domainVerificationMailSentOn, 
    groupName: this._groupName, 
    language: this._language, 
    mailAddress: this._mailAddress, 
    mobilePhoneNumber: this._mobilePhoneNumber, 
    state: this._state, 
    verifyCount: this._verifyCount
  };
};

/**
 * The id of the RegistrationData type.
 */
tutao.entity.sys.RegistrationData.prototype.TYPE_ID = 161;

/**
 * The id of the accountType attribute.
 */
tutao.entity.sys.RegistrationData.prototype.ACCOUNTTYPE_ATTRIBUTE_ID = 166;

/**
 * The id of the code attribute.
 */
tutao.entity.sys.RegistrationData.prototype.CODE_ATTRIBUTE_ID = 176;

/**
 * The id of the company attribute.
 */
tutao.entity.sys.RegistrationData.prototype.COMPANY_ATTRIBUTE_ID = 169;

/**
 * The id of the domain attribute.
 */
tutao.entity.sys.RegistrationData.prototype.DOMAIN_ATTRIBUTE_ID = 170;

/**
 * The id of the domainVerificationMailSentOn attribute.
 */
tutao.entity.sys.RegistrationData.prototype.DOMAINVERIFICATIONMAILSENTON_ATTRIBUTE_ID = 168;

/**
 * The id of the groupName attribute.
 */
tutao.entity.sys.RegistrationData.prototype.GROUPNAME_ATTRIBUTE_ID = 171;

/**
 * The id of the language attribute.
 */
tutao.entity.sys.RegistrationData.prototype.LANGUAGE_ATTRIBUTE_ID = 167;

/**
 * The id of the mailAddress attribute.
 */
tutao.entity.sys.RegistrationData.prototype.MAILADDRESS_ATTRIBUTE_ID = 173;

/**
 * The id of the mobilePhoneNumber attribute.
 */
tutao.entity.sys.RegistrationData.prototype.MOBILEPHONENUMBER_ATTRIBUTE_ID = 172;

/**
 * The id of the state attribute.
 */
tutao.entity.sys.RegistrationData.prototype.STATE_ATTRIBUTE_ID = 174;

/**
 * The id of the verifyCount attribute.
 */
tutao.entity.sys.RegistrationData.prototype.VERIFYCOUNT_ATTRIBUTE_ID = 175;

/**
 * Sets the custom id of this RegistrationData.
 * @param {Array.<string>} id The custom id of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.setId = function(id) {
  this.__id = id;
};

/**
 * Provides the id of this RegistrationData.
 * @return {Array.<string>} The id of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this RegistrationData.
 * @param {string} format The format of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this RegistrationData.
 * @return {string} The format of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this RegistrationData.
 * @param {string} permissions The permissions of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this RegistrationData.
 * @return {string} The permissions of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the accountType of this RegistrationData.
 * @param {string} accountType The accountType of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.setAccountType = function(accountType) {
  this._accountType = accountType;
  return this;
};

/**
 * Provides the accountType of this RegistrationData.
 * @return {string} The accountType of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.getAccountType = function() {
  return this._accountType;
};

/**
 * Sets the code of this RegistrationData.
 * @param {string} code The code of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.setCode = function(code) {
  this._code = code;
  return this;
};

/**
 * Provides the code of this RegistrationData.
 * @return {string} The code of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.getCode = function() {
  return this._code;
};

/**
 * Sets the company of this RegistrationData.
 * @param {string} company The company of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.setCompany = function(company) {
  this._company = company;
  return this;
};

/**
 * Provides the company of this RegistrationData.
 * @return {string} The company of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.getCompany = function() {
  return this._company;
};

/**
 * Sets the domain of this RegistrationData.
 * @param {string} domain The domain of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.setDomain = function(domain) {
  this._domain = domain;
  return this;
};

/**
 * Provides the domain of this RegistrationData.
 * @return {string} The domain of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.getDomain = function() {
  return this._domain;
};

/**
 * Sets the domainVerificationMailSentOn of this RegistrationData.
 * @param {Date} domainVerificationMailSentOn The domainVerificationMailSentOn of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.setDomainVerificationMailSentOn = function(domainVerificationMailSentOn) {
  if (domainVerificationMailSentOn == null) {
    this._domainVerificationMailSentOn = null;
  } else {
    this._domainVerificationMailSentOn = String(domainVerificationMailSentOn.getTime());
  }
  return this;
};

/**
 * Provides the domainVerificationMailSentOn of this RegistrationData.
 * @return {Date} The domainVerificationMailSentOn of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.getDomainVerificationMailSentOn = function() {
  if (this._domainVerificationMailSentOn == null) {
    return null;
  }
  if (isNaN(this._domainVerificationMailSentOn)) {
    throw new tutao.InvalidDataError('invalid time data: ' + this._domainVerificationMailSentOn);
  }
  return new Date(Number(this._domainVerificationMailSentOn));
};

/**
 * Sets the groupName of this RegistrationData.
 * @param {string} groupName The groupName of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.setGroupName = function(groupName) {
  this._groupName = groupName;
  return this;
};

/**
 * Provides the groupName of this RegistrationData.
 * @return {string} The groupName of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.getGroupName = function() {
  return this._groupName;
};

/**
 * Sets the language of this RegistrationData.
 * @param {string} language The language of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.setLanguage = function(language) {
  this._language = language;
  return this;
};

/**
 * Provides the language of this RegistrationData.
 * @return {string} The language of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.getLanguage = function() {
  return this._language;
};

/**
 * Sets the mailAddress of this RegistrationData.
 * @param {string} mailAddress The mailAddress of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.setMailAddress = function(mailAddress) {
  this._mailAddress = mailAddress;
  return this;
};

/**
 * Provides the mailAddress of this RegistrationData.
 * @return {string} The mailAddress of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.getMailAddress = function() {
  return this._mailAddress;
};

/**
 * Sets the mobilePhoneNumber of this RegistrationData.
 * @param {string} mobilePhoneNumber The mobilePhoneNumber of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.setMobilePhoneNumber = function(mobilePhoneNumber) {
  this._mobilePhoneNumber = mobilePhoneNumber;
  return this;
};

/**
 * Provides the mobilePhoneNumber of this RegistrationData.
 * @return {string} The mobilePhoneNumber of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.getMobilePhoneNumber = function() {
  return this._mobilePhoneNumber;
};

/**
 * Sets the state of this RegistrationData.
 * @param {string} state The state of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.setState = function(state) {
  this._state = state;
  return this;
};

/**
 * Provides the state of this RegistrationData.
 * @return {string} The state of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.getState = function() {
  return this._state;
};

/**
 * Sets the verifyCount of this RegistrationData.
 * @param {string} verifyCount The verifyCount of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.setVerifyCount = function(verifyCount) {
  this._verifyCount = verifyCount;
  return this;
};

/**
 * Provides the verifyCount of this RegistrationData.
 * @return {string} The verifyCount of this RegistrationData.
 */
tutao.entity.sys.RegistrationData.prototype.getVerifyCount = function() {
  return this._verifyCount;
};

/**
 * Loads a RegistrationData from the server.
 * @param {Array.<string>} id The id of the RegistrationData.
 * @return {Promise.<tutao.entity.sys.RegistrationData>} Resolves to the RegistrationData or an exception if the loading failed.
 */
tutao.entity.sys.RegistrationData.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.RegistrationData, tutao.entity.sys.RegistrationData.PATH, id[1], id[0], {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple RegistrationDatas from the server.
 * @param {Array.<Array.<string>>} ids The ids of the RegistrationDatas to load.
 * @return {Promise.<Array.<tutao.entity.sys.RegistrationData>>} Resolves to an array of RegistrationData or rejects with an exception if the loading failed.
 */
tutao.entity.sys.RegistrationData.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.RegistrationData, tutao.entity.sys.RegistrationData.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.sys.RegistrationData.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 4;
  return tutao.locator.entityRestClient.putElement(tutao.entity.sys.RegistrationData.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Deletes this RegistrationData on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the delete failed.
 */
tutao.entity.sys.RegistrationData.prototype.erase = function() {
  var self = this;
  return tutao.locator.entityRestClient.deleteElement(tutao.entity.sys.RegistrationData.PATH, this.__id[1], this.__id[0], {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(data) {
    self._entityHelper.notifyObservers(true);
  });
};

/**
 * Provides a  list of RegistrationDatas loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.sys.RegistrationData>>} Resolves to an array of RegistrationData or rejects with an exception if the loading failed.
 */
tutao.entity.sys.RegistrationData.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.sys.RegistrationData, tutao.entity.sys.RegistrationData.PATH, listId, start, count, reverse, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.RegistrationData.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.RegistrationData.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.RegistrationReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.RegistrationReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._authToken = data.authToken;
  } else {
    this.__format = "0";
    this._authToken = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.RegistrationReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.RegistrationReturn.MODEL_VERSION = '4';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.RegistrationReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.RegistrationReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    authToken: this._authToken
  };
};

/**
 * The id of the RegistrationReturn type.
 */
tutao.entity.sys.RegistrationReturn.prototype.TYPE_ID = 326;

/**
 * The id of the authToken attribute.
 */
tutao.entity.sys.RegistrationReturn.prototype.AUTHTOKEN_ATTRIBUTE_ID = 328;

/**
 * Sets the format of this RegistrationReturn.
 * @param {string} format The format of this RegistrationReturn.
 */
tutao.entity.sys.RegistrationReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this RegistrationReturn.
 * @return {string} The format of this RegistrationReturn.
 */
tutao.entity.sys.RegistrationReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the authToken of this RegistrationReturn.
 * @param {string} authToken The authToken of this RegistrationReturn.
 */
tutao.entity.sys.RegistrationReturn.prototype.setAuthToken = function(authToken) {
  this._authToken = authToken;
  return this;
};

/**
 * Provides the authToken of this RegistrationReturn.
 * @return {string} The authToken of this RegistrationReturn.
 */
tutao.entity.sys.RegistrationReturn.prototype.getAuthToken = function() {
  return this._authToken;
};

"use strict";

tutao.provide('tutao.entity.sys.RegistrationServiceData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.RegistrationServiceData = function(data) {
  if (data) {
    this.__format = data._format;
    this._accountType = data.accountType;
    this._company = data.company;
    this._domain = data.domain;
    this._groupName = data.groupName;
    this._language = data.language;
    this._mailAddress = data.mailAddress;
    this._mobilePhoneNumber = data.mobilePhoneNumber;
    this._state = data.state;
  } else {
    this.__format = "0";
    this._accountType = null;
    this._company = null;
    this._domain = null;
    this._groupName = null;
    this._language = null;
    this._mailAddress = null;
    this._mobilePhoneNumber = null;
    this._state = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.RegistrationServiceData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.RegistrationServiceData.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.RegistrationServiceData.PATH = '/rest/sys/registrationservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.RegistrationServiceData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.RegistrationServiceData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    accountType: this._accountType, 
    company: this._company, 
    domain: this._domain, 
    groupName: this._groupName, 
    language: this._language, 
    mailAddress: this._mailAddress, 
    mobilePhoneNumber: this._mobilePhoneNumber, 
    state: this._state
  };
};

/**
 * The id of the RegistrationServiceData type.
 */
tutao.entity.sys.RegistrationServiceData.prototype.TYPE_ID = 316;

/**
 * The id of the accountType attribute.
 */
tutao.entity.sys.RegistrationServiceData.prototype.ACCOUNTTYPE_ATTRIBUTE_ID = 318;

/**
 * The id of the company attribute.
 */
tutao.entity.sys.RegistrationServiceData.prototype.COMPANY_ATTRIBUTE_ID = 321;

/**
 * The id of the domain attribute.
 */
tutao.entity.sys.RegistrationServiceData.prototype.DOMAIN_ATTRIBUTE_ID = 322;

/**
 * The id of the groupName attribute.
 */
tutao.entity.sys.RegistrationServiceData.prototype.GROUPNAME_ATTRIBUTE_ID = 320;

/**
 * The id of the language attribute.
 */
tutao.entity.sys.RegistrationServiceData.prototype.LANGUAGE_ATTRIBUTE_ID = 319;

/**
 * The id of the mailAddress attribute.
 */
tutao.entity.sys.RegistrationServiceData.prototype.MAILADDRESS_ATTRIBUTE_ID = 324;

/**
 * The id of the mobilePhoneNumber attribute.
 */
tutao.entity.sys.RegistrationServiceData.prototype.MOBILEPHONENUMBER_ATTRIBUTE_ID = 323;

/**
 * The id of the state attribute.
 */
tutao.entity.sys.RegistrationServiceData.prototype.STATE_ATTRIBUTE_ID = 325;

/**
 * Sets the format of this RegistrationServiceData.
 * @param {string} format The format of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this RegistrationServiceData.
 * @return {string} The format of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the accountType of this RegistrationServiceData.
 * @param {string} accountType The accountType of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.setAccountType = function(accountType) {
  this._accountType = accountType;
  return this;
};

/**
 * Provides the accountType of this RegistrationServiceData.
 * @return {string} The accountType of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.getAccountType = function() {
  return this._accountType;
};

/**
 * Sets the company of this RegistrationServiceData.
 * @param {string} company The company of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.setCompany = function(company) {
  this._company = company;
  return this;
};

/**
 * Provides the company of this RegistrationServiceData.
 * @return {string} The company of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.getCompany = function() {
  return this._company;
};

/**
 * Sets the domain of this RegistrationServiceData.
 * @param {string} domain The domain of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.setDomain = function(domain) {
  this._domain = domain;
  return this;
};

/**
 * Provides the domain of this RegistrationServiceData.
 * @return {string} The domain of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.getDomain = function() {
  return this._domain;
};

/**
 * Sets the groupName of this RegistrationServiceData.
 * @param {string} groupName The groupName of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.setGroupName = function(groupName) {
  this._groupName = groupName;
  return this;
};

/**
 * Provides the groupName of this RegistrationServiceData.
 * @return {string} The groupName of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.getGroupName = function() {
  return this._groupName;
};

/**
 * Sets the language of this RegistrationServiceData.
 * @param {string} language The language of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.setLanguage = function(language) {
  this._language = language;
  return this;
};

/**
 * Provides the language of this RegistrationServiceData.
 * @return {string} The language of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.getLanguage = function() {
  return this._language;
};

/**
 * Sets the mailAddress of this RegistrationServiceData.
 * @param {string} mailAddress The mailAddress of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.setMailAddress = function(mailAddress) {
  this._mailAddress = mailAddress;
  return this;
};

/**
 * Provides the mailAddress of this RegistrationServiceData.
 * @return {string} The mailAddress of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.getMailAddress = function() {
  return this._mailAddress;
};

/**
 * Sets the mobilePhoneNumber of this RegistrationServiceData.
 * @param {string} mobilePhoneNumber The mobilePhoneNumber of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.setMobilePhoneNumber = function(mobilePhoneNumber) {
  this._mobilePhoneNumber = mobilePhoneNumber;
  return this;
};

/**
 * Provides the mobilePhoneNumber of this RegistrationServiceData.
 * @return {string} The mobilePhoneNumber of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.getMobilePhoneNumber = function() {
  return this._mobilePhoneNumber;
};

/**
 * Sets the state of this RegistrationServiceData.
 * @param {string} state The state of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.setState = function(state) {
  this._state = state;
  return this;
};

/**
 * Provides the state of this RegistrationServiceData.
 * @return {string} The state of this RegistrationServiceData.
 */
tutao.entity.sys.RegistrationServiceData.prototype.getState = function() {
  return this._state;
};

/**
 * Loads from the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.RegistrationServiceData>} Resolves to RegistrationServiceData or an exception if the loading failed.
 */
tutao.entity.sys.RegistrationServiceData.load = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.RegistrationServiceData, tutao.entity.sys.RegistrationServiceData.PATH, null, null, parameters, headers);
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.RegistrationReturn=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.RegistrationServiceData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.sys.RegistrationServiceData.PATH, this, parameters, headers, tutao.entity.sys.RegistrationReturn);
};

"use strict";

tutao.provide('tutao.entity.sys.RegistrationVerifyDomainDataPost');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPost = function(data) {
  if (data) {
    this.__format = data._format;
    this._currentAdminMailAddress = data.currentAdminMailAddress;
    this._language = data.language;
  } else {
    this.__format = "0";
    this._currentAdminMailAddress = null;
    this._language = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.RegistrationVerifyDomainDataPost.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.RegistrationVerifyDomainDataPost.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.RegistrationVerifyDomainDataPost.PATH = '/rest/sys/registrationverifydomainservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.RegistrationVerifyDomainDataPost.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPost.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    currentAdminMailAddress: this._currentAdminMailAddress, 
    language: this._language
  };
};

/**
 * The id of the RegistrationVerifyDomainDataPost type.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPost.prototype.TYPE_ID = 330;

/**
 * The id of the currentAdminMailAddress attribute.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPost.prototype.CURRENTADMINMAILADDRESS_ATTRIBUTE_ID = 333;

/**
 * The id of the language attribute.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPost.prototype.LANGUAGE_ATTRIBUTE_ID = 332;

/**
 * Sets the format of this RegistrationVerifyDomainDataPost.
 * @param {string} format The format of this RegistrationVerifyDomainDataPost.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPost.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this RegistrationVerifyDomainDataPost.
 * @return {string} The format of this RegistrationVerifyDomainDataPost.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPost.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the currentAdminMailAddress of this RegistrationVerifyDomainDataPost.
 * @param {string} currentAdminMailAddress The currentAdminMailAddress of this RegistrationVerifyDomainDataPost.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPost.prototype.setCurrentAdminMailAddress = function(currentAdminMailAddress) {
  this._currentAdminMailAddress = currentAdminMailAddress;
  return this;
};

/**
 * Provides the currentAdminMailAddress of this RegistrationVerifyDomainDataPost.
 * @return {string} The currentAdminMailAddress of this RegistrationVerifyDomainDataPost.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPost.prototype.getCurrentAdminMailAddress = function() {
  return this._currentAdminMailAddress;
};

/**
 * Sets the language of this RegistrationVerifyDomainDataPost.
 * @param {string} language The language of this RegistrationVerifyDomainDataPost.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPost.prototype.setLanguage = function(language) {
  this._language = language;
  return this;
};

/**
 * Provides the language of this RegistrationVerifyDomainDataPost.
 * @return {string} The language of this RegistrationVerifyDomainDataPost.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPost.prototype.getLanguage = function() {
  return this._language;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.RegistrationVerifyDomainPostReturn=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPost.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.sys.RegistrationVerifyDomainDataPost.PATH, this, parameters, headers, tutao.entity.sys.RegistrationVerifyDomainPostReturn);
};

"use strict";

tutao.provide('tutao.entity.sys.RegistrationVerifyDomainDataPut');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPut = function(data) {
  if (data) {
    this.__format = data._format;
    this._authToken = data.authToken;
  } else {
    this.__format = "0";
    this._authToken = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.RegistrationVerifyDomainDataPut.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.RegistrationVerifyDomainDataPut.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.RegistrationVerifyDomainDataPut.PATH = '/rest/sys/registrationverifydomainservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.RegistrationVerifyDomainDataPut.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPut.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    authToken: this._authToken
  };
};

/**
 * The id of the RegistrationVerifyDomainDataPut type.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPut.prototype.TYPE_ID = 334;

/**
 * The id of the authToken attribute.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPut.prototype.AUTHTOKEN_ATTRIBUTE_ID = 336;

/**
 * Sets the format of this RegistrationVerifyDomainDataPut.
 * @param {string} format The format of this RegistrationVerifyDomainDataPut.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPut.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this RegistrationVerifyDomainDataPut.
 * @return {string} The format of this RegistrationVerifyDomainDataPut.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPut.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the authToken of this RegistrationVerifyDomainDataPut.
 * @param {string} authToken The authToken of this RegistrationVerifyDomainDataPut.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPut.prototype.setAuthToken = function(authToken) {
  this._authToken = authToken;
  return this;
};

/**
 * Provides the authToken of this RegistrationVerifyDomainDataPut.
 * @return {string} The authToken of this RegistrationVerifyDomainDataPut.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPut.prototype.getAuthToken = function() {
  return this._authToken;
};

/**
 * Updates this service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.RegistrationVerifyDomainDataPut.prototype.update = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.putService(tutao.entity.sys.RegistrationVerifyDomainDataPut.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.sys.RegistrationVerifyDomainPostReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.RegistrationVerifyDomainPostReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._mailSent = data.mailSent;
  } else {
    this.__format = "0";
    this._mailSent = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.RegistrationVerifyDomainPostReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.RegistrationVerifyDomainPostReturn.MODEL_VERSION = '4';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.RegistrationVerifyDomainPostReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.RegistrationVerifyDomainPostReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    mailSent: this._mailSent
  };
};

/**
 * The id of the RegistrationVerifyDomainPostReturn type.
 */
tutao.entity.sys.RegistrationVerifyDomainPostReturn.prototype.TYPE_ID = 337;

/**
 * The id of the mailSent attribute.
 */
tutao.entity.sys.RegistrationVerifyDomainPostReturn.prototype.MAILSENT_ATTRIBUTE_ID = 339;

/**
 * Sets the format of this RegistrationVerifyDomainPostReturn.
 * @param {string} format The format of this RegistrationVerifyDomainPostReturn.
 */
tutao.entity.sys.RegistrationVerifyDomainPostReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this RegistrationVerifyDomainPostReturn.
 * @return {string} The format of this RegistrationVerifyDomainPostReturn.
 */
tutao.entity.sys.RegistrationVerifyDomainPostReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the mailSent of this RegistrationVerifyDomainPostReturn.
 * @param {boolean} mailSent The mailSent of this RegistrationVerifyDomainPostReturn.
 */
tutao.entity.sys.RegistrationVerifyDomainPostReturn.prototype.setMailSent = function(mailSent) {
  this._mailSent = mailSent ? '1' : '0';
  return this;
};

/**
 * Provides the mailSent of this RegistrationVerifyDomainPostReturn.
 * @return {boolean} The mailSent of this RegistrationVerifyDomainPostReturn.
 */
tutao.entity.sys.RegistrationVerifyDomainPostReturn.prototype.getMailSent = function() {
  return this._mailSent == '1';
};

"use strict";

tutao.provide('tutao.entity.sys.ResetPasswordData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.ResetPasswordData = function(data) {
  if (data) {
    this.__format = data._format;
    this._pwEncUserGroupKey = data.pwEncUserGroupKey;
    this._salt = data.salt;
    this._verifier = data.verifier;
    this._user = data.user;
  } else {
    this.__format = "0";
    this._pwEncUserGroupKey = null;
    this._salt = null;
    this._verifier = null;
    this._user = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.ResetPasswordData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.ResetPasswordData.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.ResetPasswordData.PATH = '/rest/sys/resetpasswordservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.ResetPasswordData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.ResetPasswordData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    pwEncUserGroupKey: this._pwEncUserGroupKey, 
    salt: this._salt, 
    verifier: this._verifier, 
    user: this._user
  };
};

/**
 * The id of the ResetPasswordData type.
 */
tutao.entity.sys.ResetPasswordData.prototype.TYPE_ID = 584;

/**
 * The id of the pwEncUserGroupKey attribute.
 */
tutao.entity.sys.ResetPasswordData.prototype.PWENCUSERGROUPKEY_ATTRIBUTE_ID = 588;

/**
 * The id of the salt attribute.
 */
tutao.entity.sys.ResetPasswordData.prototype.SALT_ATTRIBUTE_ID = 587;

/**
 * The id of the verifier attribute.
 */
tutao.entity.sys.ResetPasswordData.prototype.VERIFIER_ATTRIBUTE_ID = 586;

/**
 * The id of the user attribute.
 */
tutao.entity.sys.ResetPasswordData.prototype.USER_ATTRIBUTE_ID = 589;

/**
 * Sets the format of this ResetPasswordData.
 * @param {string} format The format of this ResetPasswordData.
 */
tutao.entity.sys.ResetPasswordData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this ResetPasswordData.
 * @return {string} The format of this ResetPasswordData.
 */
tutao.entity.sys.ResetPasswordData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the pwEncUserGroupKey of this ResetPasswordData.
 * @param {string} pwEncUserGroupKey The pwEncUserGroupKey of this ResetPasswordData.
 */
tutao.entity.sys.ResetPasswordData.prototype.setPwEncUserGroupKey = function(pwEncUserGroupKey) {
  this._pwEncUserGroupKey = pwEncUserGroupKey;
  return this;
};

/**
 * Provides the pwEncUserGroupKey of this ResetPasswordData.
 * @return {string} The pwEncUserGroupKey of this ResetPasswordData.
 */
tutao.entity.sys.ResetPasswordData.prototype.getPwEncUserGroupKey = function() {
  return this._pwEncUserGroupKey;
};

/**
 * Sets the salt of this ResetPasswordData.
 * @param {string} salt The salt of this ResetPasswordData.
 */
tutao.entity.sys.ResetPasswordData.prototype.setSalt = function(salt) {
  this._salt = salt;
  return this;
};

/**
 * Provides the salt of this ResetPasswordData.
 * @return {string} The salt of this ResetPasswordData.
 */
tutao.entity.sys.ResetPasswordData.prototype.getSalt = function() {
  return this._salt;
};

/**
 * Sets the verifier of this ResetPasswordData.
 * @param {string} verifier The verifier of this ResetPasswordData.
 */
tutao.entity.sys.ResetPasswordData.prototype.setVerifier = function(verifier) {
  this._verifier = verifier;
  return this;
};

/**
 * Provides the verifier of this ResetPasswordData.
 * @return {string} The verifier of this ResetPasswordData.
 */
tutao.entity.sys.ResetPasswordData.prototype.getVerifier = function() {
  return this._verifier;
};

/**
 * Sets the user of this ResetPasswordData.
 * @param {string} user The user of this ResetPasswordData.
 */
tutao.entity.sys.ResetPasswordData.prototype.setUser = function(user) {
  this._user = user;
  return this;
};

/**
 * Provides the user of this ResetPasswordData.
 * @return {string} The user of this ResetPasswordData.
 */
tutao.entity.sys.ResetPasswordData.prototype.getUser = function() {
  return this._user;
};

/**
 * Loads the user of this ResetPasswordData.
 * @return {Promise.<tutao.entity.sys.User>} Resolves to the loaded user of this ResetPasswordData or an exception if the loading failed.
 */
tutao.entity.sys.ResetPasswordData.prototype.loadUser = function() {
  return tutao.entity.sys.User.load(this._user);
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.ResetPasswordData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.sys.ResetPasswordData.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.sys.RootInstance');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.RootInstance = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._reference = data.reference;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._reference = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.RootInstance.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.RootInstance.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.RootInstance.PATH = '/rest/sys/rootinstance';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.RootInstance.ROOT_INSTANCE_ID = 'A3N5cwAA5w';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.RootInstance.GENERATED_ID = false;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.RootInstance.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.RootInstance.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    reference: this._reference
  };
};

/**
 * The id of the RootInstance type.
 */
tutao.entity.sys.RootInstance.prototype.TYPE_ID = 231;

/**
 * The id of the reference attribute.
 */
tutao.entity.sys.RootInstance.prototype.REFERENCE_ATTRIBUTE_ID = 236;

/**
 * Sets the custom id of this RootInstance.
 * @param {Array.<string>} id The custom id of this RootInstance.
 */
tutao.entity.sys.RootInstance.prototype.setId = function(id) {
  this.__id = id;
};

/**
 * Provides the id of this RootInstance.
 * @return {Array.<string>} The id of this RootInstance.
 */
tutao.entity.sys.RootInstance.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this RootInstance.
 * @param {string} format The format of this RootInstance.
 */
tutao.entity.sys.RootInstance.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this RootInstance.
 * @return {string} The format of this RootInstance.
 */
tutao.entity.sys.RootInstance.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this RootInstance.
 * @param {string} permissions The permissions of this RootInstance.
 */
tutao.entity.sys.RootInstance.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this RootInstance.
 * @return {string} The permissions of this RootInstance.
 */
tutao.entity.sys.RootInstance.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the reference of this RootInstance.
 * @param {string} reference The reference of this RootInstance.
 */
tutao.entity.sys.RootInstance.prototype.setReference = function(reference) {
  this._reference = reference;
  return this;
};

/**
 * Provides the reference of this RootInstance.
 * @return {string} The reference of this RootInstance.
 */
tutao.entity.sys.RootInstance.prototype.getReference = function() {
  return this._reference;
};

/**
 * Loads a RootInstance from the server.
 * @param {Array.<string>} id The id of the RootInstance.
 * @return {Promise.<tutao.entity.sys.RootInstance>} Resolves to the RootInstance or an exception if the loading failed.
 */
tutao.entity.sys.RootInstance.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.RootInstance, tutao.entity.sys.RootInstance.PATH, id[1], id[0], {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple RootInstances from the server.
 * @param {Array.<Array.<string>>} ids The ids of the RootInstances to load.
 * @return {Promise.<Array.<tutao.entity.sys.RootInstance>>} Resolves to an array of RootInstance or rejects with an exception if the loading failed.
 */
tutao.entity.sys.RootInstance.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.RootInstance, tutao.entity.sys.RootInstance.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.sys.RootInstance.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 4;
  return tutao.locator.entityRestClient.putElement(tutao.entity.sys.RootInstance.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Provides a  list of RootInstances loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.sys.RootInstance>>} Resolves to an array of RootInstance or rejects with an exception if the loading failed.
 */
tutao.entity.sys.RootInstance.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.sys.RootInstance, tutao.entity.sys.RootInstance.PATH, listId, start, count, reverse, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.RootInstance.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.RootInstance.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.SaltData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.SaltData = function(data) {
  if (data) {
    this.__format = data._format;
    this._mailAddress = data.mailAddress;
  } else {
    this.__format = "0";
    this._mailAddress = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.SaltData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.SaltData.MODEL_VERSION = '4';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.SaltData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.SaltData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    mailAddress: this._mailAddress
  };
};

/**
 * The id of the SaltData type.
 */
tutao.entity.sys.SaltData.prototype.TYPE_ID = 417;

/**
 * The id of the mailAddress attribute.
 */
tutao.entity.sys.SaltData.prototype.MAILADDRESS_ATTRIBUTE_ID = 419;

/**
 * Sets the format of this SaltData.
 * @param {string} format The format of this SaltData.
 */
tutao.entity.sys.SaltData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this SaltData.
 * @return {string} The format of this SaltData.
 */
tutao.entity.sys.SaltData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the mailAddress of this SaltData.
 * @param {string} mailAddress The mailAddress of this SaltData.
 */
tutao.entity.sys.SaltData.prototype.setMailAddress = function(mailAddress) {
  this._mailAddress = mailAddress;
  return this;
};

/**
 * Provides the mailAddress of this SaltData.
 * @return {string} The mailAddress of this SaltData.
 */
tutao.entity.sys.SaltData.prototype.getMailAddress = function() {
  return this._mailAddress;
};

"use strict";

tutao.provide('tutao.entity.sys.SaltReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.SaltReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._salt = data.salt;
  } else {
    this.__format = "0";
    this._salt = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.SaltReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.SaltReturn.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.SaltReturn.PATH = '/rest/sys/saltservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.SaltReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.SaltReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    salt: this._salt
  };
};

/**
 * The id of the SaltReturn type.
 */
tutao.entity.sys.SaltReturn.prototype.TYPE_ID = 420;

/**
 * The id of the salt attribute.
 */
tutao.entity.sys.SaltReturn.prototype.SALT_ATTRIBUTE_ID = 422;

/**
 * Sets the format of this SaltReturn.
 * @param {string} format The format of this SaltReturn.
 */
tutao.entity.sys.SaltReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this SaltReturn.
 * @return {string} The format of this SaltReturn.
 */
tutao.entity.sys.SaltReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the salt of this SaltReturn.
 * @param {string} salt The salt of this SaltReturn.
 */
tutao.entity.sys.SaltReturn.prototype.setSalt = function(salt) {
  this._salt = salt;
  return this;
};

/**
 * Provides the salt of this SaltReturn.
 * @return {string} The salt of this SaltReturn.
 */
tutao.entity.sys.SaltReturn.prototype.getSalt = function() {
  return this._salt;
};

/**
 * Loads from the service.
 * @param {tutao.entity.sys.SaltData} entity The entity to send to the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.SaltReturn>} Resolves to SaltReturn or an exception if the loading failed.
 */
tutao.entity.sys.SaltReturn.load = function(entity, parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.getService(tutao.entity.sys.SaltReturn, tutao.entity.sys.SaltReturn.PATH, entity, parameters, headers);
};

"use strict";

tutao.provide('tutao.entity.sys.SecondFactorAuthAllowedReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.SecondFactorAuthAllowedReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._allowed = data.allowed;
  } else {
    this.__format = "0";
    this._allowed = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.SecondFactorAuthAllowedReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.SecondFactorAuthAllowedReturn.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.SecondFactorAuthAllowedReturn.PATH = '/rest/sys/secondfactorauthallowedservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.SecondFactorAuthAllowedReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.SecondFactorAuthAllowedReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    allowed: this._allowed
  };
};

/**
 * The id of the SecondFactorAuthAllowedReturn type.
 */
tutao.entity.sys.SecondFactorAuthAllowedReturn.prototype.TYPE_ID = 546;

/**
 * The id of the allowed attribute.
 */
tutao.entity.sys.SecondFactorAuthAllowedReturn.prototype.ALLOWED_ATTRIBUTE_ID = 548;

/**
 * Sets the format of this SecondFactorAuthAllowedReturn.
 * @param {string} format The format of this SecondFactorAuthAllowedReturn.
 */
tutao.entity.sys.SecondFactorAuthAllowedReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this SecondFactorAuthAllowedReturn.
 * @return {string} The format of this SecondFactorAuthAllowedReturn.
 */
tutao.entity.sys.SecondFactorAuthAllowedReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the allowed of this SecondFactorAuthAllowedReturn.
 * @param {boolean} allowed The allowed of this SecondFactorAuthAllowedReturn.
 */
tutao.entity.sys.SecondFactorAuthAllowedReturn.prototype.setAllowed = function(allowed) {
  this._allowed = allowed ? '1' : '0';
  return this;
};

/**
 * Provides the allowed of this SecondFactorAuthAllowedReturn.
 * @return {boolean} The allowed of this SecondFactorAuthAllowedReturn.
 */
tutao.entity.sys.SecondFactorAuthAllowedReturn.prototype.getAllowed = function() {
  return this._allowed == '1';
};

/**
 * Loads from the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.SecondFactorAuthAllowedReturn>} Resolves to SecondFactorAuthAllowedReturn or an exception if the loading failed.
 */
tutao.entity.sys.SecondFactorAuthAllowedReturn.load = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.SecondFactorAuthAllowedReturn, tutao.entity.sys.SecondFactorAuthAllowedReturn.PATH, null, null, parameters, headers);
};

"use strict";

tutao.provide('tutao.entity.sys.SecondFactorAuthData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.SecondFactorAuthData = function(data) {
  if (data) {
    this.__format = data._format;
    this._language = data.language;
    this._service = data.service;
  } else {
    this.__format = "0";
    this._language = null;
    this._service = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.SecondFactorAuthData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.SecondFactorAuthData.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.SecondFactorAuthData.PATH = '/rest/sys/secondfactorauthservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.SecondFactorAuthData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.SecondFactorAuthData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    language: this._language, 
    service: this._service
  };
};

/**
 * The id of the SecondFactorAuthData type.
 */
tutao.entity.sys.SecondFactorAuthData.prototype.TYPE_ID = 541;

/**
 * The id of the language attribute.
 */
tutao.entity.sys.SecondFactorAuthData.prototype.LANGUAGE_ATTRIBUTE_ID = 543;

/**
 * The id of the service attribute.
 */
tutao.entity.sys.SecondFactorAuthData.prototype.SERVICE_ATTRIBUTE_ID = 544;

/**
 * Sets the format of this SecondFactorAuthData.
 * @param {string} format The format of this SecondFactorAuthData.
 */
tutao.entity.sys.SecondFactorAuthData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this SecondFactorAuthData.
 * @return {string} The format of this SecondFactorAuthData.
 */
tutao.entity.sys.SecondFactorAuthData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the language of this SecondFactorAuthData.
 * @param {string} language The language of this SecondFactorAuthData.
 */
tutao.entity.sys.SecondFactorAuthData.prototype.setLanguage = function(language) {
  this._language = language;
  return this;
};

/**
 * Provides the language of this SecondFactorAuthData.
 * @return {string} The language of this SecondFactorAuthData.
 */
tutao.entity.sys.SecondFactorAuthData.prototype.getLanguage = function() {
  return this._language;
};

/**
 * Sets the service of this SecondFactorAuthData.
 * @param {string} service The service of this SecondFactorAuthData.
 */
tutao.entity.sys.SecondFactorAuthData.prototype.setService = function(service) {
  this._service = service;
  return this;
};

/**
 * Provides the service of this SecondFactorAuthData.
 * @return {string} The service of this SecondFactorAuthData.
 */
tutao.entity.sys.SecondFactorAuthData.prototype.getService = function() {
  return this._service;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.SecondFactorAuthData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.sys.SecondFactorAuthData.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.sys.SendRegistrationCodeData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.SendRegistrationCodeData = function(data) {
  if (data) {
    this.__format = data._format;
    this._accountType = data.accountType;
    this._authToken = data.authToken;
    this._language = data.language;
    this._mobilePhoneNumber = data.mobilePhoneNumber;
  } else {
    this.__format = "0";
    this._accountType = null;
    this._authToken = null;
    this._language = null;
    this._mobilePhoneNumber = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.SendRegistrationCodeData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.SendRegistrationCodeData.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.SendRegistrationCodeData.PATH = '/rest/sys/sendregistrationcodeservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    accountType: this._accountType, 
    authToken: this._authToken, 
    language: this._language, 
    mobilePhoneNumber: this._mobilePhoneNumber
  };
};

/**
 * The id of the SendRegistrationCodeData type.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.TYPE_ID = 341;

/**
 * The id of the accountType attribute.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.ACCOUNTTYPE_ATTRIBUTE_ID = 345;

/**
 * The id of the authToken attribute.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.AUTHTOKEN_ATTRIBUTE_ID = 343;

/**
 * The id of the language attribute.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.LANGUAGE_ATTRIBUTE_ID = 344;

/**
 * The id of the mobilePhoneNumber attribute.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.MOBILEPHONENUMBER_ATTRIBUTE_ID = 346;

/**
 * Sets the format of this SendRegistrationCodeData.
 * @param {string} format The format of this SendRegistrationCodeData.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this SendRegistrationCodeData.
 * @return {string} The format of this SendRegistrationCodeData.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the accountType of this SendRegistrationCodeData.
 * @param {string} accountType The accountType of this SendRegistrationCodeData.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.setAccountType = function(accountType) {
  this._accountType = accountType;
  return this;
};

/**
 * Provides the accountType of this SendRegistrationCodeData.
 * @return {string} The accountType of this SendRegistrationCodeData.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.getAccountType = function() {
  return this._accountType;
};

/**
 * Sets the authToken of this SendRegistrationCodeData.
 * @param {string} authToken The authToken of this SendRegistrationCodeData.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.setAuthToken = function(authToken) {
  this._authToken = authToken;
  return this;
};

/**
 * Provides the authToken of this SendRegistrationCodeData.
 * @return {string} The authToken of this SendRegistrationCodeData.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.getAuthToken = function() {
  return this._authToken;
};

/**
 * Sets the language of this SendRegistrationCodeData.
 * @param {string} language The language of this SendRegistrationCodeData.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.setLanguage = function(language) {
  this._language = language;
  return this;
};

/**
 * Provides the language of this SendRegistrationCodeData.
 * @return {string} The language of this SendRegistrationCodeData.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.getLanguage = function() {
  return this._language;
};

/**
 * Sets the mobilePhoneNumber of this SendRegistrationCodeData.
 * @param {string} mobilePhoneNumber The mobilePhoneNumber of this SendRegistrationCodeData.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.setMobilePhoneNumber = function(mobilePhoneNumber) {
  this._mobilePhoneNumber = mobilePhoneNumber;
  return this;
};

/**
 * Provides the mobilePhoneNumber of this SendRegistrationCodeData.
 * @return {string} The mobilePhoneNumber of this SendRegistrationCodeData.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.getMobilePhoneNumber = function() {
  return this._mobilePhoneNumber;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.SendRegistrationCodeReturn=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.SendRegistrationCodeData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.sys.SendRegistrationCodeData.PATH, this, parameters, headers, tutao.entity.sys.SendRegistrationCodeReturn);
};

"use strict";

tutao.provide('tutao.entity.sys.SendRegistrationCodeReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.SendRegistrationCodeReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._authToken = data.authToken;
  } else {
    this.__format = "0";
    this._authToken = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.SendRegistrationCodeReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.SendRegistrationCodeReturn.MODEL_VERSION = '4';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.SendRegistrationCodeReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.SendRegistrationCodeReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    authToken: this._authToken
  };
};

/**
 * The id of the SendRegistrationCodeReturn type.
 */
tutao.entity.sys.SendRegistrationCodeReturn.prototype.TYPE_ID = 347;

/**
 * The id of the authToken attribute.
 */
tutao.entity.sys.SendRegistrationCodeReturn.prototype.AUTHTOKEN_ATTRIBUTE_ID = 349;

/**
 * Sets the format of this SendRegistrationCodeReturn.
 * @param {string} format The format of this SendRegistrationCodeReturn.
 */
tutao.entity.sys.SendRegistrationCodeReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this SendRegistrationCodeReturn.
 * @return {string} The format of this SendRegistrationCodeReturn.
 */
tutao.entity.sys.SendRegistrationCodeReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the authToken of this SendRegistrationCodeReturn.
 * @param {string} authToken The authToken of this SendRegistrationCodeReturn.
 */
tutao.entity.sys.SendRegistrationCodeReturn.prototype.setAuthToken = function(authToken) {
  this._authToken = authToken;
  return this;
};

/**
 * Provides the authToken of this SendRegistrationCodeReturn.
 * @return {string} The authToken of this SendRegistrationCodeReturn.
 */
tutao.entity.sys.SendRegistrationCodeReturn.prototype.getAuthToken = function() {
  return this._authToken;
};

"use strict";

tutao.provide('tutao.entity.sys.ShareData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.ShareData = function(data) {
  if (data) {
    this.__format = data._format;
    this._app = data.app;
    this._bucket = data.bucket;
    this._instancePermissions = data.instancePermissions;
    this._ownerGroupId = data.ownerGroupId;
    this._pubEncBucketKey = data.pubEncBucketKey;
    this._pubKeyVersion = data.pubKeyVersion;
    this._shareType = data.shareType;
    this._shareholderMailAddress = data.shareholderMailAddress;
    this._writePermission = data.writePermission;
  } else {
    this.__format = "0";
    this._app = null;
    this._bucket = null;
    this._instancePermissions = null;
    this._ownerGroupId = null;
    this._pubEncBucketKey = null;
    this._pubKeyVersion = null;
    this._shareType = null;
    this._shareholderMailAddress = null;
    this._writePermission = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.ShareData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.ShareData.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.ShareData.PATH = '/rest/sys/shareservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.ShareData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.ShareData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    app: this._app, 
    bucket: this._bucket, 
    instancePermissions: this._instancePermissions, 
    ownerGroupId: this._ownerGroupId, 
    pubEncBucketKey: this._pubEncBucketKey, 
    pubKeyVersion: this._pubKeyVersion, 
    shareType: this._shareType, 
    shareholderMailAddress: this._shareholderMailAddress, 
    writePermission: this._writePermission
  };
};

/**
 * The id of the ShareData type.
 */
tutao.entity.sys.ShareData.prototype.TYPE_ID = 289;

/**
 * The id of the app attribute.
 */
tutao.entity.sys.ShareData.prototype.APP_ATTRIBUTE_ID = 292;

/**
 * The id of the bucket attribute.
 */
tutao.entity.sys.ShareData.prototype.BUCKET_ATTRIBUTE_ID = 296;

/**
 * The id of the instancePermissions attribute.
 */
tutao.entity.sys.ShareData.prototype.INSTANCEPERMISSIONS_ATTRIBUTE_ID = 295;

/**
 * The id of the ownerGroupId attribute.
 */
tutao.entity.sys.ShareData.prototype.OWNERGROUPID_ATTRIBUTE_ID = 291;

/**
 * The id of the pubEncBucketKey attribute.
 */
tutao.entity.sys.ShareData.prototype.PUBENCBUCKETKEY_ATTRIBUTE_ID = 298;

/**
 * The id of the pubKeyVersion attribute.
 */
tutao.entity.sys.ShareData.prototype.PUBKEYVERSION_ATTRIBUTE_ID = 299;

/**
 * The id of the shareType attribute.
 */
tutao.entity.sys.ShareData.prototype.SHARETYPE_ATTRIBUTE_ID = 293;

/**
 * The id of the shareholderMailAddress attribute.
 */
tutao.entity.sys.ShareData.prototype.SHAREHOLDERMAILADDRESS_ATTRIBUTE_ID = 294;

/**
 * The id of the writePermission attribute.
 */
tutao.entity.sys.ShareData.prototype.WRITEPERMISSION_ATTRIBUTE_ID = 297;

/**
 * Sets the format of this ShareData.
 * @param {string} format The format of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this ShareData.
 * @return {string} The format of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the app of this ShareData.
 * @param {string} app The app of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.setApp = function(app) {
  this._app = app;
  return this;
};

/**
 * Provides the app of this ShareData.
 * @return {string} The app of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.getApp = function() {
  return this._app;
};

/**
 * Sets the bucket of this ShareData.
 * @param {string} bucket The bucket of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.setBucket = function(bucket) {
  this._bucket = bucket;
  return this;
};

/**
 * Provides the bucket of this ShareData.
 * @return {string} The bucket of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.getBucket = function() {
  return this._bucket;
};

/**
 * Sets the instancePermissions of this ShareData.
 * @param {string} instancePermissions The instancePermissions of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.setInstancePermissions = function(instancePermissions) {
  this._instancePermissions = instancePermissions;
  return this;
};

/**
 * Provides the instancePermissions of this ShareData.
 * @return {string} The instancePermissions of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.getInstancePermissions = function() {
  return this._instancePermissions;
};

/**
 * Sets the ownerGroupId of this ShareData.
 * @param {string} ownerGroupId The ownerGroupId of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.setOwnerGroupId = function(ownerGroupId) {
  this._ownerGroupId = ownerGroupId;
  return this;
};

/**
 * Provides the ownerGroupId of this ShareData.
 * @return {string} The ownerGroupId of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.getOwnerGroupId = function() {
  return this._ownerGroupId;
};

/**
 * Sets the pubEncBucketKey of this ShareData.
 * @param {string} pubEncBucketKey The pubEncBucketKey of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.setPubEncBucketKey = function(pubEncBucketKey) {
  this._pubEncBucketKey = pubEncBucketKey;
  return this;
};

/**
 * Provides the pubEncBucketKey of this ShareData.
 * @return {string} The pubEncBucketKey of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.getPubEncBucketKey = function() {
  return this._pubEncBucketKey;
};

/**
 * Sets the pubKeyVersion of this ShareData.
 * @param {string} pubKeyVersion The pubKeyVersion of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.setPubKeyVersion = function(pubKeyVersion) {
  this._pubKeyVersion = pubKeyVersion;
  return this;
};

/**
 * Provides the pubKeyVersion of this ShareData.
 * @return {string} The pubKeyVersion of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.getPubKeyVersion = function() {
  return this._pubKeyVersion;
};

/**
 * Sets the shareType of this ShareData.
 * @param {string} shareType The shareType of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.setShareType = function(shareType) {
  this._shareType = shareType;
  return this;
};

/**
 * Provides the shareType of this ShareData.
 * @return {string} The shareType of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.getShareType = function() {
  return this._shareType;
};

/**
 * Sets the shareholderMailAddress of this ShareData.
 * @param {string} shareholderMailAddress The shareholderMailAddress of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.setShareholderMailAddress = function(shareholderMailAddress) {
  this._shareholderMailAddress = shareholderMailAddress;
  return this;
};

/**
 * Provides the shareholderMailAddress of this ShareData.
 * @return {string} The shareholderMailAddress of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.getShareholderMailAddress = function() {
  return this._shareholderMailAddress;
};

/**
 * Sets the writePermission of this ShareData.
 * @param {boolean} writePermission The writePermission of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.setWritePermission = function(writePermission) {
  this._writePermission = writePermission ? '1' : '0';
  return this;
};

/**
 * Provides the writePermission of this ShareData.
 * @return {boolean} The writePermission of this ShareData.
 */
tutao.entity.sys.ShareData.prototype.getWritePermission = function() {
  return this._writePermission == '1';
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.ShareData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.sys.ShareData.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.sys.Shares');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.Shares = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._incoming = data.incoming;
    this._outgoing = data.outgoing;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._incoming = null;
    this._outgoing = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.Shares.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.Shares.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.Shares.PATH = '/rest/sys/shares';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.Shares.ROOT_INSTANCE_ID = 'A3N5cwABGg';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.Shares.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.Shares.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.Shares.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    incoming: this._incoming, 
    outgoing: this._outgoing
  };
};

/**
 * The id of the Shares type.
 */
tutao.entity.sys.Shares.prototype.TYPE_ID = 282;

/**
 * The id of the incoming attribute.
 */
tutao.entity.sys.Shares.prototype.INCOMING_ATTRIBUTE_ID = 287;

/**
 * The id of the outgoing attribute.
 */
tutao.entity.sys.Shares.prototype.OUTGOING_ATTRIBUTE_ID = 288;

/**
 * Provides the id of this Shares.
 * @return {string} The id of this Shares.
 */
tutao.entity.sys.Shares.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this Shares.
 * @param {string} format The format of this Shares.
 */
tutao.entity.sys.Shares.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this Shares.
 * @return {string} The format of this Shares.
 */
tutao.entity.sys.Shares.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this Shares.
 * @param {string} permissions The permissions of this Shares.
 */
tutao.entity.sys.Shares.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this Shares.
 * @return {string} The permissions of this Shares.
 */
tutao.entity.sys.Shares.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the incoming of this Shares.
 * @param {string} incoming The incoming of this Shares.
 */
tutao.entity.sys.Shares.prototype.setIncoming = function(incoming) {
  this._incoming = incoming;
  return this;
};

/**
 * Provides the incoming of this Shares.
 * @return {string} The incoming of this Shares.
 */
tutao.entity.sys.Shares.prototype.getIncoming = function() {
  return this._incoming;
};

/**
 * Sets the outgoing of this Shares.
 * @param {string} outgoing The outgoing of this Shares.
 */
tutao.entity.sys.Shares.prototype.setOutgoing = function(outgoing) {
  this._outgoing = outgoing;
  return this;
};

/**
 * Provides the outgoing of this Shares.
 * @return {string} The outgoing of this Shares.
 */
tutao.entity.sys.Shares.prototype.getOutgoing = function() {
  return this._outgoing;
};

/**
 * Loads a Shares from the server.
 * @param {string} id The id of the Shares.
 * @return {Promise.<tutao.entity.sys.Shares>} Resolves to the Shares or an exception if the loading failed.
 */
tutao.entity.sys.Shares.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.Shares, tutao.entity.sys.Shares.PATH, id, null, {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple Sharess from the server.
 * @param {Array.<string>} ids The ids of the Sharess to load.
 * @return {Promise.<Array.<tutao.entity.sys.Shares>>} Resolves to an array of Shares or rejects with an exception if the loading failed.
 */
tutao.entity.sys.Shares.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.Shares, tutao.entity.sys.Shares.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.Shares.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.Shares.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.SmsMonitorReceiverData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.SmsMonitorReceiverData = function(data) {
  if (data) {
    this.__format = data._format;
  } else {
    this.__format = "0";
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.SmsMonitorReceiverData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.SmsMonitorReceiverData.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.SmsMonitorReceiverData.PATH = '/rest/sys/smsmonitorreceiverservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.SmsMonitorReceiverData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.SmsMonitorReceiverData.prototype.toJsonData = function() {
  return {
    _format: this.__format
  };
};

/**
 * The id of the SmsMonitorReceiverData type.
 */
tutao.entity.sys.SmsMonitorReceiverData.prototype.TYPE_ID = 502;

/**
 * Sets the format of this SmsMonitorReceiverData.
 * @param {string} format The format of this SmsMonitorReceiverData.
 */
tutao.entity.sys.SmsMonitorReceiverData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this SmsMonitorReceiverData.
 * @return {string} The format of this SmsMonitorReceiverData.
 */
tutao.entity.sys.SmsMonitorReceiverData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Loads from the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.SmsMonitorReceiverData>} Resolves to SmsMonitorReceiverData or an exception if the loading failed.
 */
tutao.entity.sys.SmsMonitorReceiverData.load = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.SmsMonitorReceiverData, tutao.entity.sys.SmsMonitorReceiverData.PATH, null, null, parameters, headers);
};

"use strict";

tutao.provide('tutao.entity.sys.SmsMonitorTriggerData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.SmsMonitorTriggerData = function(data) {
  if (data) {
    this.__format = data._format;
    this._networkOperatorIds = data.networkOperatorIds;
    this._smsFacadeIds = data.smsFacadeIds;
  } else {
    this.__format = "0";
    this._networkOperatorIds = null;
    this._smsFacadeIds = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.SmsMonitorTriggerData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.SmsMonitorTriggerData.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.SmsMonitorTriggerData.PATH = '/rest/sys/smsmonitortriggerservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.SmsMonitorTriggerData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.SmsMonitorTriggerData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    networkOperatorIds: this._networkOperatorIds, 
    smsFacadeIds: this._smsFacadeIds
  };
};

/**
 * The id of the SmsMonitorTriggerData type.
 */
tutao.entity.sys.SmsMonitorTriggerData.prototype.TYPE_ID = 497;

/**
 * The id of the networkOperatorIds attribute.
 */
tutao.entity.sys.SmsMonitorTriggerData.prototype.NETWORKOPERATORIDS_ATTRIBUTE_ID = 500;

/**
 * The id of the smsFacadeIds attribute.
 */
tutao.entity.sys.SmsMonitorTriggerData.prototype.SMSFACADEIDS_ATTRIBUTE_ID = 499;

/**
 * Sets the format of this SmsMonitorTriggerData.
 * @param {string} format The format of this SmsMonitorTriggerData.
 */
tutao.entity.sys.SmsMonitorTriggerData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this SmsMonitorTriggerData.
 * @return {string} The format of this SmsMonitorTriggerData.
 */
tutao.entity.sys.SmsMonitorTriggerData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the networkOperatorIds of this SmsMonitorTriggerData.
 * @param {string} networkOperatorIds The networkOperatorIds of this SmsMonitorTriggerData.
 */
tutao.entity.sys.SmsMonitorTriggerData.prototype.setNetworkOperatorIds = function(networkOperatorIds) {
  this._networkOperatorIds = networkOperatorIds;
  return this;
};

/**
 * Provides the networkOperatorIds of this SmsMonitorTriggerData.
 * @return {string} The networkOperatorIds of this SmsMonitorTriggerData.
 */
tutao.entity.sys.SmsMonitorTriggerData.prototype.getNetworkOperatorIds = function() {
  return this._networkOperatorIds;
};

/**
 * Sets the smsFacadeIds of this SmsMonitorTriggerData.
 * @param {string} smsFacadeIds The smsFacadeIds of this SmsMonitorTriggerData.
 */
tutao.entity.sys.SmsMonitorTriggerData.prototype.setSmsFacadeIds = function(smsFacadeIds) {
  this._smsFacadeIds = smsFacadeIds;
  return this;
};

/**
 * Provides the smsFacadeIds of this SmsMonitorTriggerData.
 * @return {string} The smsFacadeIds of this SmsMonitorTriggerData.
 */
tutao.entity.sys.SmsMonitorTriggerData.prototype.getSmsFacadeIds = function() {
  return this._smsFacadeIds;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.SmsMonitorTriggerData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.sys.SmsMonitorTriggerData.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.sys.StringConfigValue');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.StringConfigValue = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._name = data.name;
    this._value = data.value;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._name = null;
    this._value = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.StringConfigValue.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.StringConfigValue.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    name: this._name, 
    value: this._value
  };
};

/**
 * The id of the StringConfigValue type.
 */
tutao.entity.sys.StringConfigValue.prototype.TYPE_ID = 515;

/**
 * The id of the name attribute.
 */
tutao.entity.sys.StringConfigValue.prototype.NAME_ATTRIBUTE_ID = 517;

/**
 * The id of the value attribute.
 */
tutao.entity.sys.StringConfigValue.prototype.VALUE_ATTRIBUTE_ID = 518;

/**
 * Sets the id of this StringConfigValue.
 * @param {string} id The id of this StringConfigValue.
 */
tutao.entity.sys.StringConfigValue.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this StringConfigValue.
 * @return {string} The id of this StringConfigValue.
 */
tutao.entity.sys.StringConfigValue.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the name of this StringConfigValue.
 * @param {string} name The name of this StringConfigValue.
 */
tutao.entity.sys.StringConfigValue.prototype.setName = function(name) {
  this._name = name;
  return this;
};

/**
 * Provides the name of this StringConfigValue.
 * @return {string} The name of this StringConfigValue.
 */
tutao.entity.sys.StringConfigValue.prototype.getName = function() {
  return this._name;
};

/**
 * Sets the value of this StringConfigValue.
 * @param {string} value The value of this StringConfigValue.
 */
tutao.entity.sys.StringConfigValue.prototype.setValue = function(value) {
  this._value = value;
  return this;
};

/**
 * Provides the value of this StringConfigValue.
 * @return {string} The value of this StringConfigValue.
 */
tutao.entity.sys.StringConfigValue.prototype.getValue = function() {
  return this._value;
};

"use strict";

tutao.provide('tutao.entity.sys.System');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.System = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._lastInvoiceNbr = data.lastInvoiceNbr;
    this._freeCustomerInfos = data.freeCustomerInfos;
    this._freeGroup = data.freeGroup;
    this._premiumCustomerInfos = data.premiumCustomerInfos;
    this._premiumGroup = data.premiumGroup;
    this._registrationDataList = data.registrationDataList;
    this._starterCustomerInfos = data.starterCustomerInfos;
    this._starterGroup = data.starterGroup;
    this._streamCustomerInfos = data.streamCustomerInfos;
    this._streamGroup = data.streamGroup;
    this._systemAdminGroup = data.systemAdminGroup;
    this._systemCustomer = data.systemCustomer;
    this._systemCustomerInfo = data.systemCustomerInfo;
    this._systemUserGroup = data.systemUserGroup;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._lastInvoiceNbr = null;
    this._freeCustomerInfos = null;
    this._freeGroup = null;
    this._premiumCustomerInfos = null;
    this._premiumGroup = null;
    this._registrationDataList = null;
    this._starterCustomerInfos = null;
    this._starterGroup = null;
    this._streamCustomerInfos = null;
    this._streamGroup = null;
    this._systemAdminGroup = null;
    this._systemCustomer = null;
    this._systemCustomerInfo = null;
    this._systemUserGroup = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.System.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.System.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.System.PATH = '/rest/sys/system';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.System.ROOT_INSTANCE_ID = 'A3N5cwAAsQ';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.System.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.System.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.System.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    lastInvoiceNbr: this._lastInvoiceNbr, 
    freeCustomerInfos: this._freeCustomerInfos, 
    freeGroup: this._freeGroup, 
    premiumCustomerInfos: this._premiumCustomerInfos, 
    premiumGroup: this._premiumGroup, 
    registrationDataList: this._registrationDataList, 
    starterCustomerInfos: this._starterCustomerInfos, 
    starterGroup: this._starterGroup, 
    streamCustomerInfos: this._streamCustomerInfos, 
    streamGroup: this._streamGroup, 
    systemAdminGroup: this._systemAdminGroup, 
    systemCustomer: this._systemCustomer, 
    systemCustomerInfo: this._systemCustomerInfo, 
    systemUserGroup: this._systemUserGroup
  };
};

/**
 * The id of the System type.
 */
tutao.entity.sys.System.prototype.TYPE_ID = 177;

/**
 * The id of the lastInvoiceNbr attribute.
 */
tutao.entity.sys.System.prototype.LASTINVOICENBR_ATTRIBUTE_ID = 591;

/**
 * The id of the freeCustomerInfos attribute.
 */
tutao.entity.sys.System.prototype.FREECUSTOMERINFOS_ATTRIBUTE_ID = 183;

/**
 * The id of the freeGroup attribute.
 */
tutao.entity.sys.System.prototype.FREEGROUP_ATTRIBUTE_ID = 191;

/**
 * The id of the premiumCustomerInfos attribute.
 */
tutao.entity.sys.System.prototype.PREMIUMCUSTOMERINFOS_ATTRIBUTE_ID = 185;

/**
 * The id of the premiumGroup attribute.
 */
tutao.entity.sys.System.prototype.PREMIUMGROUP_ATTRIBUTE_ID = 190;

/**
 * The id of the registrationDataList attribute.
 */
tutao.entity.sys.System.prototype.REGISTRATIONDATALIST_ATTRIBUTE_ID = 194;

/**
 * The id of the starterCustomerInfos attribute.
 */
tutao.entity.sys.System.prototype.STARTERCUSTOMERINFOS_ATTRIBUTE_ID = 184;

/**
 * The id of the starterGroup attribute.
 */
tutao.entity.sys.System.prototype.STARTERGROUP_ATTRIBUTE_ID = 192;

/**
 * The id of the streamCustomerInfos attribute.
 */
tutao.entity.sys.System.prototype.STREAMCUSTOMERINFOS_ATTRIBUTE_ID = 186;

/**
 * The id of the streamGroup attribute.
 */
tutao.entity.sys.System.prototype.STREAMGROUP_ATTRIBUTE_ID = 193;

/**
 * The id of the systemAdminGroup attribute.
 */
tutao.entity.sys.System.prototype.SYSTEMADMINGROUP_ATTRIBUTE_ID = 189;

/**
 * The id of the systemCustomer attribute.
 */
tutao.entity.sys.System.prototype.SYSTEMCUSTOMER_ATTRIBUTE_ID = 187;

/**
 * The id of the systemCustomerInfo attribute.
 */
tutao.entity.sys.System.prototype.SYSTEMCUSTOMERINFO_ATTRIBUTE_ID = 182;

/**
 * The id of the systemUserGroup attribute.
 */
tutao.entity.sys.System.prototype.SYSTEMUSERGROUP_ATTRIBUTE_ID = 188;

/**
 * Provides the id of this System.
 * @return {string} The id of this System.
 */
tutao.entity.sys.System.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this System.
 * @param {string} format The format of this System.
 */
tutao.entity.sys.System.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this System.
 * @return {string} The format of this System.
 */
tutao.entity.sys.System.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this System.
 * @param {string} permissions The permissions of this System.
 */
tutao.entity.sys.System.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this System.
 * @return {string} The permissions of this System.
 */
tutao.entity.sys.System.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the lastInvoiceNbr of this System.
 * @param {string} lastInvoiceNbr The lastInvoiceNbr of this System.
 */
tutao.entity.sys.System.prototype.setLastInvoiceNbr = function(lastInvoiceNbr) {
  this._lastInvoiceNbr = lastInvoiceNbr;
  return this;
};

/**
 * Provides the lastInvoiceNbr of this System.
 * @return {string} The lastInvoiceNbr of this System.
 */
tutao.entity.sys.System.prototype.getLastInvoiceNbr = function() {
  return this._lastInvoiceNbr;
};

/**
 * Sets the freeCustomerInfos of this System.
 * @param {string} freeCustomerInfos The freeCustomerInfos of this System.
 */
tutao.entity.sys.System.prototype.setFreeCustomerInfos = function(freeCustomerInfos) {
  this._freeCustomerInfos = freeCustomerInfos;
  return this;
};

/**
 * Provides the freeCustomerInfos of this System.
 * @return {string} The freeCustomerInfos of this System.
 */
tutao.entity.sys.System.prototype.getFreeCustomerInfos = function() {
  return this._freeCustomerInfos;
};

/**
 * Sets the freeGroup of this System.
 * @param {string} freeGroup The freeGroup of this System.
 */
tutao.entity.sys.System.prototype.setFreeGroup = function(freeGroup) {
  this._freeGroup = freeGroup;
  return this;
};

/**
 * Provides the freeGroup of this System.
 * @return {string} The freeGroup of this System.
 */
tutao.entity.sys.System.prototype.getFreeGroup = function() {
  return this._freeGroup;
};

/**
 * Loads the freeGroup of this System.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded freeGroup of this System or an exception if the loading failed.
 */
tutao.entity.sys.System.prototype.loadFreeGroup = function() {
  return tutao.entity.sys.Group.load(this._freeGroup);
};

/**
 * Sets the premiumCustomerInfos of this System.
 * @param {string} premiumCustomerInfos The premiumCustomerInfos of this System.
 */
tutao.entity.sys.System.prototype.setPremiumCustomerInfos = function(premiumCustomerInfos) {
  this._premiumCustomerInfos = premiumCustomerInfos;
  return this;
};

/**
 * Provides the premiumCustomerInfos of this System.
 * @return {string} The premiumCustomerInfos of this System.
 */
tutao.entity.sys.System.prototype.getPremiumCustomerInfos = function() {
  return this._premiumCustomerInfos;
};

/**
 * Sets the premiumGroup of this System.
 * @param {string} premiumGroup The premiumGroup of this System.
 */
tutao.entity.sys.System.prototype.setPremiumGroup = function(premiumGroup) {
  this._premiumGroup = premiumGroup;
  return this;
};

/**
 * Provides the premiumGroup of this System.
 * @return {string} The premiumGroup of this System.
 */
tutao.entity.sys.System.prototype.getPremiumGroup = function() {
  return this._premiumGroup;
};

/**
 * Loads the premiumGroup of this System.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded premiumGroup of this System or an exception if the loading failed.
 */
tutao.entity.sys.System.prototype.loadPremiumGroup = function() {
  return tutao.entity.sys.Group.load(this._premiumGroup);
};

/**
 * Sets the registrationDataList of this System.
 * @param {string} registrationDataList The registrationDataList of this System.
 */
tutao.entity.sys.System.prototype.setRegistrationDataList = function(registrationDataList) {
  this._registrationDataList = registrationDataList;
  return this;
};

/**
 * Provides the registrationDataList of this System.
 * @return {string} The registrationDataList of this System.
 */
tutao.entity.sys.System.prototype.getRegistrationDataList = function() {
  return this._registrationDataList;
};

/**
 * Sets the starterCustomerInfos of this System.
 * @param {string} starterCustomerInfos The starterCustomerInfos of this System.
 */
tutao.entity.sys.System.prototype.setStarterCustomerInfos = function(starterCustomerInfos) {
  this._starterCustomerInfos = starterCustomerInfos;
  return this;
};

/**
 * Provides the starterCustomerInfos of this System.
 * @return {string} The starterCustomerInfos of this System.
 */
tutao.entity.sys.System.prototype.getStarterCustomerInfos = function() {
  return this._starterCustomerInfos;
};

/**
 * Sets the starterGroup of this System.
 * @param {string} starterGroup The starterGroup of this System.
 */
tutao.entity.sys.System.prototype.setStarterGroup = function(starterGroup) {
  this._starterGroup = starterGroup;
  return this;
};

/**
 * Provides the starterGroup of this System.
 * @return {string} The starterGroup of this System.
 */
tutao.entity.sys.System.prototype.getStarterGroup = function() {
  return this._starterGroup;
};

/**
 * Loads the starterGroup of this System.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded starterGroup of this System or an exception if the loading failed.
 */
tutao.entity.sys.System.prototype.loadStarterGroup = function() {
  return tutao.entity.sys.Group.load(this._starterGroup);
};

/**
 * Sets the streamCustomerInfos of this System.
 * @param {string} streamCustomerInfos The streamCustomerInfos of this System.
 */
tutao.entity.sys.System.prototype.setStreamCustomerInfos = function(streamCustomerInfos) {
  this._streamCustomerInfos = streamCustomerInfos;
  return this;
};

/**
 * Provides the streamCustomerInfos of this System.
 * @return {string} The streamCustomerInfos of this System.
 */
tutao.entity.sys.System.prototype.getStreamCustomerInfos = function() {
  return this._streamCustomerInfos;
};

/**
 * Sets the streamGroup of this System.
 * @param {string} streamGroup The streamGroup of this System.
 */
tutao.entity.sys.System.prototype.setStreamGroup = function(streamGroup) {
  this._streamGroup = streamGroup;
  return this;
};

/**
 * Provides the streamGroup of this System.
 * @return {string} The streamGroup of this System.
 */
tutao.entity.sys.System.prototype.getStreamGroup = function() {
  return this._streamGroup;
};

/**
 * Loads the streamGroup of this System.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded streamGroup of this System or an exception if the loading failed.
 */
tutao.entity.sys.System.prototype.loadStreamGroup = function() {
  return tutao.entity.sys.Group.load(this._streamGroup);
};

/**
 * Sets the systemAdminGroup of this System.
 * @param {string} systemAdminGroup The systemAdminGroup of this System.
 */
tutao.entity.sys.System.prototype.setSystemAdminGroup = function(systemAdminGroup) {
  this._systemAdminGroup = systemAdminGroup;
  return this;
};

/**
 * Provides the systemAdminGroup of this System.
 * @return {string} The systemAdminGroup of this System.
 */
tutao.entity.sys.System.prototype.getSystemAdminGroup = function() {
  return this._systemAdminGroup;
};

/**
 * Loads the systemAdminGroup of this System.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded systemAdminGroup of this System or an exception if the loading failed.
 */
tutao.entity.sys.System.prototype.loadSystemAdminGroup = function() {
  return tutao.entity.sys.Group.load(this._systemAdminGroup);
};

/**
 * Sets the systemCustomer of this System.
 * @param {string} systemCustomer The systemCustomer of this System.
 */
tutao.entity.sys.System.prototype.setSystemCustomer = function(systemCustomer) {
  this._systemCustomer = systemCustomer;
  return this;
};

/**
 * Provides the systemCustomer of this System.
 * @return {string} The systemCustomer of this System.
 */
tutao.entity.sys.System.prototype.getSystemCustomer = function() {
  return this._systemCustomer;
};

/**
 * Loads the systemCustomer of this System.
 * @return {Promise.<tutao.entity.sys.Customer>} Resolves to the loaded systemCustomer of this System or an exception if the loading failed.
 */
tutao.entity.sys.System.prototype.loadSystemCustomer = function() {
  return tutao.entity.sys.Customer.load(this._systemCustomer);
};

/**
 * Sets the systemCustomerInfo of this System.
 * @param {string} systemCustomerInfo The systemCustomerInfo of this System.
 */
tutao.entity.sys.System.prototype.setSystemCustomerInfo = function(systemCustomerInfo) {
  this._systemCustomerInfo = systemCustomerInfo;
  return this;
};

/**
 * Provides the systemCustomerInfo of this System.
 * @return {string} The systemCustomerInfo of this System.
 */
tutao.entity.sys.System.prototype.getSystemCustomerInfo = function() {
  return this._systemCustomerInfo;
};

/**
 * Sets the systemUserGroup of this System.
 * @param {string} systemUserGroup The systemUserGroup of this System.
 */
tutao.entity.sys.System.prototype.setSystemUserGroup = function(systemUserGroup) {
  this._systemUserGroup = systemUserGroup;
  return this;
};

/**
 * Provides the systemUserGroup of this System.
 * @return {string} The systemUserGroup of this System.
 */
tutao.entity.sys.System.prototype.getSystemUserGroup = function() {
  return this._systemUserGroup;
};

/**
 * Loads the systemUserGroup of this System.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded systemUserGroup of this System or an exception if the loading failed.
 */
tutao.entity.sys.System.prototype.loadSystemUserGroup = function() {
  return tutao.entity.sys.Group.load(this._systemUserGroup);
};

/**
 * Loads a System from the server.
 * @param {string} id The id of the System.
 * @return {Promise.<tutao.entity.sys.System>} Resolves to the System or an exception if the loading failed.
 */
tutao.entity.sys.System.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.System, tutao.entity.sys.System.PATH, id, null, {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple Systems from the server.
 * @param {Array.<string>} ids The ids of the Systems to load.
 * @return {Promise.<Array.<tutao.entity.sys.System>>} Resolves to an array of System or rejects with an exception if the loading failed.
 */
tutao.entity.sys.System.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.System, tutao.entity.sys.System.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.System.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.System.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.SystemKeysReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.SystemKeysReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._freeGroupKey = data.freeGroupKey;
    this._premiumGroupKey = data.premiumGroupKey;
    this._starterGroupKey = data.starterGroupKey;
    this._systemAdminPubKey = data.systemAdminPubKey;
    this._systemAdminPubKeyVersion = data.systemAdminPubKeyVersion;
  } else {
    this.__format = "0";
    this._freeGroupKey = null;
    this._premiumGroupKey = null;
    this._starterGroupKey = null;
    this._systemAdminPubKey = null;
    this._systemAdminPubKeyVersion = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.SystemKeysReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.SystemKeysReturn.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.SystemKeysReturn.PATH = '/rest/sys/systemkeysservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.SystemKeysReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.SystemKeysReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    freeGroupKey: this._freeGroupKey, 
    premiumGroupKey: this._premiumGroupKey, 
    starterGroupKey: this._starterGroupKey, 
    systemAdminPubKey: this._systemAdminPubKey, 
    systemAdminPubKeyVersion: this._systemAdminPubKeyVersion
  };
};

/**
 * The id of the SystemKeysReturn type.
 */
tutao.entity.sys.SystemKeysReturn.prototype.TYPE_ID = 301;

/**
 * The id of the freeGroupKey attribute.
 */
tutao.entity.sys.SystemKeysReturn.prototype.FREEGROUPKEY_ATTRIBUTE_ID = 305;

/**
 * The id of the premiumGroupKey attribute.
 */
tutao.entity.sys.SystemKeysReturn.prototype.PREMIUMGROUPKEY_ATTRIBUTE_ID = 306;

/**
 * The id of the starterGroupKey attribute.
 */
tutao.entity.sys.SystemKeysReturn.prototype.STARTERGROUPKEY_ATTRIBUTE_ID = 307;

/**
 * The id of the systemAdminPubKey attribute.
 */
tutao.entity.sys.SystemKeysReturn.prototype.SYSTEMADMINPUBKEY_ATTRIBUTE_ID = 303;

/**
 * The id of the systemAdminPubKeyVersion attribute.
 */
tutao.entity.sys.SystemKeysReturn.prototype.SYSTEMADMINPUBKEYVERSION_ATTRIBUTE_ID = 304;

/**
 * Sets the format of this SystemKeysReturn.
 * @param {string} format The format of this SystemKeysReturn.
 */
tutao.entity.sys.SystemKeysReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this SystemKeysReturn.
 * @return {string} The format of this SystemKeysReturn.
 */
tutao.entity.sys.SystemKeysReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the freeGroupKey of this SystemKeysReturn.
 * @param {string} freeGroupKey The freeGroupKey of this SystemKeysReturn.
 */
tutao.entity.sys.SystemKeysReturn.prototype.setFreeGroupKey = function(freeGroupKey) {
  this._freeGroupKey = freeGroupKey;
  return this;
};

/**
 * Provides the freeGroupKey of this SystemKeysReturn.
 * @return {string} The freeGroupKey of this SystemKeysReturn.
 */
tutao.entity.sys.SystemKeysReturn.prototype.getFreeGroupKey = function() {
  return this._freeGroupKey;
};

/**
 * Sets the premiumGroupKey of this SystemKeysReturn.
 * @param {string} premiumGroupKey The premiumGroupKey of this SystemKeysReturn.
 */
tutao.entity.sys.SystemKeysReturn.prototype.setPremiumGroupKey = function(premiumGroupKey) {
  this._premiumGroupKey = premiumGroupKey;
  return this;
};

/**
 * Provides the premiumGroupKey of this SystemKeysReturn.
 * @return {string} The premiumGroupKey of this SystemKeysReturn.
 */
tutao.entity.sys.SystemKeysReturn.prototype.getPremiumGroupKey = function() {
  return this._premiumGroupKey;
};

/**
 * Sets the starterGroupKey of this SystemKeysReturn.
 * @param {string} starterGroupKey The starterGroupKey of this SystemKeysReturn.
 */
tutao.entity.sys.SystemKeysReturn.prototype.setStarterGroupKey = function(starterGroupKey) {
  this._starterGroupKey = starterGroupKey;
  return this;
};

/**
 * Provides the starterGroupKey of this SystemKeysReturn.
 * @return {string} The starterGroupKey of this SystemKeysReturn.
 */
tutao.entity.sys.SystemKeysReturn.prototype.getStarterGroupKey = function() {
  return this._starterGroupKey;
};

/**
 * Sets the systemAdminPubKey of this SystemKeysReturn.
 * @param {string} systemAdminPubKey The systemAdminPubKey of this SystemKeysReturn.
 */
tutao.entity.sys.SystemKeysReturn.prototype.setSystemAdminPubKey = function(systemAdminPubKey) {
  this._systemAdminPubKey = systemAdminPubKey;
  return this;
};

/**
 * Provides the systemAdminPubKey of this SystemKeysReturn.
 * @return {string} The systemAdminPubKey of this SystemKeysReturn.
 */
tutao.entity.sys.SystemKeysReturn.prototype.getSystemAdminPubKey = function() {
  return this._systemAdminPubKey;
};

/**
 * Sets the systemAdminPubKeyVersion of this SystemKeysReturn.
 * @param {string} systemAdminPubKeyVersion The systemAdminPubKeyVersion of this SystemKeysReturn.
 */
tutao.entity.sys.SystemKeysReturn.prototype.setSystemAdminPubKeyVersion = function(systemAdminPubKeyVersion) {
  this._systemAdminPubKeyVersion = systemAdminPubKeyVersion;
  return this;
};

/**
 * Provides the systemAdminPubKeyVersion of this SystemKeysReturn.
 * @return {string} The systemAdminPubKeyVersion of this SystemKeysReturn.
 */
tutao.entity.sys.SystemKeysReturn.prototype.getSystemAdminPubKeyVersion = function() {
  return this._systemAdminPubKeyVersion;
};

/**
 * Loads from the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.SystemKeysReturn>} Resolves to SystemKeysReturn or an exception if the loading failed.
 */
tutao.entity.sys.SystemKeysReturn.load = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.SystemKeysReturn, tutao.entity.sys.SystemKeysReturn.PATH, null, null, parameters, headers);
};

"use strict";

tutao.provide('tutao.entity.sys.TimeRangeConfigValue');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.TimeRangeConfigValue = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._end = data.end;
    this._identifier = data.identifier;
    this._start = data.start;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._end = null;
    this._identifier = null;
    this._start = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.TimeRangeConfigValue.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.TimeRangeConfigValue.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    end: this._end, 
    identifier: this._identifier, 
    start: this._start
  };
};

/**
 * The id of the TimeRangeConfigValue type.
 */
tutao.entity.sys.TimeRangeConfigValue.prototype.TYPE_ID = 519;

/**
 * The id of the end attribute.
 */
tutao.entity.sys.TimeRangeConfigValue.prototype.END_ATTRIBUTE_ID = 523;

/**
 * The id of the identifier attribute.
 */
tutao.entity.sys.TimeRangeConfigValue.prototype.IDENTIFIER_ATTRIBUTE_ID = 521;

/**
 * The id of the start attribute.
 */
tutao.entity.sys.TimeRangeConfigValue.prototype.START_ATTRIBUTE_ID = 522;

/**
 * Sets the id of this TimeRangeConfigValue.
 * @param {string} id The id of this TimeRangeConfigValue.
 */
tutao.entity.sys.TimeRangeConfigValue.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this TimeRangeConfigValue.
 * @return {string} The id of this TimeRangeConfigValue.
 */
tutao.entity.sys.TimeRangeConfigValue.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the end of this TimeRangeConfigValue.
 * @param {Date} end The end of this TimeRangeConfigValue.
 */
tutao.entity.sys.TimeRangeConfigValue.prototype.setEnd = function(end) {
  if (end == null) {
    this._end = null;
  } else {
    this._end = String(end.getTime());
  }
  return this;
};

/**
 * Provides the end of this TimeRangeConfigValue.
 * @return {Date} The end of this TimeRangeConfigValue.
 */
tutao.entity.sys.TimeRangeConfigValue.prototype.getEnd = function() {
  if (this._end == null) {
    return null;
  }
  if (isNaN(this._end)) {
    throw new tutao.InvalidDataError('invalid time data: ' + this._end);
  }
  return new Date(Number(this._end));
};

/**
 * Sets the identifier of this TimeRangeConfigValue.
 * @param {string} identifier The identifier of this TimeRangeConfigValue.
 */
tutao.entity.sys.TimeRangeConfigValue.prototype.setIdentifier = function(identifier) {
  this._identifier = identifier;
  return this;
};

/**
 * Provides the identifier of this TimeRangeConfigValue.
 * @return {string} The identifier of this TimeRangeConfigValue.
 */
tutao.entity.sys.TimeRangeConfigValue.prototype.getIdentifier = function() {
  return this._identifier;
};

/**
 * Sets the start of this TimeRangeConfigValue.
 * @param {Date} start The start of this TimeRangeConfigValue.
 */
tutao.entity.sys.TimeRangeConfigValue.prototype.setStart = function(start) {
  if (start == null) {
    this._start = null;
  } else {
    this._start = String(start.getTime());
  }
  return this;
};

/**
 * Provides the start of this TimeRangeConfigValue.
 * @return {Date} The start of this TimeRangeConfigValue.
 */
tutao.entity.sys.TimeRangeConfigValue.prototype.getStart = function() {
  if (this._start == null) {
    return null;
  }
  if (isNaN(this._start)) {
    throw new tutao.InvalidDataError('invalid time data: ' + this._start);
  }
  return new Date(Number(this._start));
};

"use strict";

tutao.provide('tutao.entity.sys.TimeRangeListConfigValue');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.TimeRangeListConfigValue = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._name = data.name;
    this._timeRanges = [];
    for (var i=0; i < data.timeRanges.length; i++) {
      this._timeRanges.push(new tutao.entity.sys.TimeRangeConfigValue(parent, data.timeRanges[i]));
    }
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._name = null;
    this._timeRanges = [];
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.TimeRangeListConfigValue.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.TimeRangeListConfigValue.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    name: this._name, 
    timeRanges: tutao.entity.EntityHelper.aggregatesToJsonData(this._timeRanges)
  };
};

/**
 * The id of the TimeRangeListConfigValue type.
 */
tutao.entity.sys.TimeRangeListConfigValue.prototype.TYPE_ID = 524;

/**
 * The id of the name attribute.
 */
tutao.entity.sys.TimeRangeListConfigValue.prototype.NAME_ATTRIBUTE_ID = 526;

/**
 * The id of the timeRanges attribute.
 */
tutao.entity.sys.TimeRangeListConfigValue.prototype.TIMERANGES_ATTRIBUTE_ID = 527;

/**
 * Sets the id of this TimeRangeListConfigValue.
 * @param {string} id The id of this TimeRangeListConfigValue.
 */
tutao.entity.sys.TimeRangeListConfigValue.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this TimeRangeListConfigValue.
 * @return {string} The id of this TimeRangeListConfigValue.
 */
tutao.entity.sys.TimeRangeListConfigValue.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the name of this TimeRangeListConfigValue.
 * @param {string} name The name of this TimeRangeListConfigValue.
 */
tutao.entity.sys.TimeRangeListConfigValue.prototype.setName = function(name) {
  this._name = name;
  return this;
};

/**
 * Provides the name of this TimeRangeListConfigValue.
 * @return {string} The name of this TimeRangeListConfigValue.
 */
tutao.entity.sys.TimeRangeListConfigValue.prototype.getName = function() {
  return this._name;
};

/**
 * Provides the timeRanges of this TimeRangeListConfigValue.
 * @return {Array.<tutao.entity.sys.TimeRangeConfigValue>} The timeRanges of this TimeRangeListConfigValue.
 */
tutao.entity.sys.TimeRangeListConfigValue.prototype.getTimeRanges = function() {
  return this._timeRanges;
};

"use strict";

tutao.provide('tutao.entity.sys.UpdatePermissionKeyData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.UpdatePermissionKeyData = function(data) {
  if (data) {
    this.__format = data._format;
    this._bucketEncSessionKey = data.bucketEncSessionKey;
    this._symEncBucketKey = data.symEncBucketKey;
    this._symEncSessionKey = data.symEncSessionKey;
    this._bucketPermission = data.bucketPermission;
    this._permission = data.permission;
  } else {
    this.__format = "0";
    this._bucketEncSessionKey = null;
    this._symEncBucketKey = null;
    this._symEncSessionKey = null;
    this._bucketPermission = null;
    this._permission = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.UpdatePermissionKeyData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.UpdatePermissionKeyData.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.UpdatePermissionKeyData.PATH = '/rest/sys/updatepermissionkeyservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    bucketEncSessionKey: this._bucketEncSessionKey, 
    symEncBucketKey: this._symEncBucketKey, 
    symEncSessionKey: this._symEncSessionKey, 
    bucketPermission: this._bucketPermission, 
    permission: this._permission
  };
};

/**
 * The id of the UpdatePermissionKeyData type.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.TYPE_ID = 445;

/**
 * The id of the bucketEncSessionKey attribute.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.BUCKETENCSESSIONKEY_ATTRIBUTE_ID = 448;

/**
 * The id of the symEncBucketKey attribute.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.SYMENCBUCKETKEY_ATTRIBUTE_ID = 449;

/**
 * The id of the symEncSessionKey attribute.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.SYMENCSESSIONKEY_ATTRIBUTE_ID = 447;

/**
 * The id of the bucketPermission attribute.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.BUCKETPERMISSION_ATTRIBUTE_ID = 451;

/**
 * The id of the permission attribute.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.PERMISSION_ATTRIBUTE_ID = 450;

/**
 * Sets the format of this UpdatePermissionKeyData.
 * @param {string} format The format of this UpdatePermissionKeyData.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this UpdatePermissionKeyData.
 * @return {string} The format of this UpdatePermissionKeyData.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the bucketEncSessionKey of this UpdatePermissionKeyData.
 * @param {string} bucketEncSessionKey The bucketEncSessionKey of this UpdatePermissionKeyData.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.setBucketEncSessionKey = function(bucketEncSessionKey) {
  this._bucketEncSessionKey = bucketEncSessionKey;
  return this;
};

/**
 * Provides the bucketEncSessionKey of this UpdatePermissionKeyData.
 * @return {string} The bucketEncSessionKey of this UpdatePermissionKeyData.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.getBucketEncSessionKey = function() {
  return this._bucketEncSessionKey;
};

/**
 * Sets the symEncBucketKey of this UpdatePermissionKeyData.
 * @param {string} symEncBucketKey The symEncBucketKey of this UpdatePermissionKeyData.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.setSymEncBucketKey = function(symEncBucketKey) {
  this._symEncBucketKey = symEncBucketKey;
  return this;
};

/**
 * Provides the symEncBucketKey of this UpdatePermissionKeyData.
 * @return {string} The symEncBucketKey of this UpdatePermissionKeyData.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.getSymEncBucketKey = function() {
  return this._symEncBucketKey;
};

/**
 * Sets the symEncSessionKey of this UpdatePermissionKeyData.
 * @param {string} symEncSessionKey The symEncSessionKey of this UpdatePermissionKeyData.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.setSymEncSessionKey = function(symEncSessionKey) {
  this._symEncSessionKey = symEncSessionKey;
  return this;
};

/**
 * Provides the symEncSessionKey of this UpdatePermissionKeyData.
 * @return {string} The symEncSessionKey of this UpdatePermissionKeyData.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.getSymEncSessionKey = function() {
  return this._symEncSessionKey;
};

/**
 * Sets the bucketPermission of this UpdatePermissionKeyData.
 * @param {Array.<string>} bucketPermission The bucketPermission of this UpdatePermissionKeyData.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.setBucketPermission = function(bucketPermission) {
  this._bucketPermission = bucketPermission;
  return this;
};

/**
 * Provides the bucketPermission of this UpdatePermissionKeyData.
 * @return {Array.<string>} The bucketPermission of this UpdatePermissionKeyData.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.getBucketPermission = function() {
  return this._bucketPermission;
};

/**
 * Loads the bucketPermission of this UpdatePermissionKeyData.
 * @return {Promise.<tutao.entity.sys.BucketPermission>} Resolves to the loaded bucketPermission of this UpdatePermissionKeyData or an exception if the loading failed.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.loadBucketPermission = function() {
  return tutao.entity.sys.BucketPermission.load(this._bucketPermission);
};

/**
 * Sets the permission of this UpdatePermissionKeyData.
 * @param {Array.<string>} permission The permission of this UpdatePermissionKeyData.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.setPermission = function(permission) {
  this._permission = permission;
  return this;
};

/**
 * Provides the permission of this UpdatePermissionKeyData.
 * @return {Array.<string>} The permission of this UpdatePermissionKeyData.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.getPermission = function() {
  return this._permission;
};

/**
 * Loads the permission of this UpdatePermissionKeyData.
 * @return {Promise.<tutao.entity.sys.Permission>} Resolves to the loaded permission of this UpdatePermissionKeyData or an exception if the loading failed.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.loadPermission = function() {
  return tutao.entity.sys.Permission.load(this._permission);
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.UpdatePermissionKeyData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.sys.UpdatePermissionKeyData.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.sys.User');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.User = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._accountType = data.accountType;
    this._enabled = data.enabled;
    this._salt = data.salt;
    this._userEncClientKey = data.userEncClientKey;
    this._verifier = data.verifier;
    this._authenticatedDevices = [];
    for (var i=0; i < data.authenticatedDevices.length; i++) {
      this._authenticatedDevices.push(new tutao.entity.sys.AuthenticatedDevice(this, data.authenticatedDevices[i]));
    }
    this._customer = data.customer;
    this._externalAuthInfo = (data.externalAuthInfo) ? new tutao.entity.sys.UserExternalAuthInfo(this, data.externalAuthInfo) : null;
    this._failedLogins = data.failedLogins;
    this._memberships = [];
    for (var i=0; i < data.memberships.length; i++) {
      this._memberships.push(new tutao.entity.sys.GroupMembership(this, data.memberships[i]));
    }
    this._phoneNumbers = [];
    for (var i=0; i < data.phoneNumbers.length; i++) {
      this._phoneNumbers.push(new tutao.entity.sys.PhoneNumber(this, data.phoneNumbers[i]));
    }
    this._secondFactorAuthentications = data.secondFactorAuthentications;
    this._successfulLogins = data.successfulLogins;
    this._userGroup = (data.userGroup) ? new tutao.entity.sys.GroupMembership(this, data.userGroup) : null;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._accountType = null;
    this._enabled = null;
    this._salt = null;
    this._userEncClientKey = null;
    this._verifier = null;
    this._authenticatedDevices = [];
    this._customer = null;
    this._externalAuthInfo = null;
    this._failedLogins = null;
    this._memberships = [];
    this._phoneNumbers = [];
    this._secondFactorAuthentications = null;
    this._successfulLogins = null;
    this._userGroup = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.User.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.User.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.User.PATH = '/rest/sys/user';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.sys.User.ROOT_INSTANCE_ID = 'A3N5cwBU';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.sys.User.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.User.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.User.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    accountType: this._accountType, 
    enabled: this._enabled, 
    salt: this._salt, 
    userEncClientKey: this._userEncClientKey, 
    verifier: this._verifier, 
    authenticatedDevices: tutao.entity.EntityHelper.aggregatesToJsonData(this._authenticatedDevices), 
    customer: this._customer, 
    externalAuthInfo: tutao.entity.EntityHelper.aggregatesToJsonData(this._externalAuthInfo), 
    failedLogins: this._failedLogins, 
    memberships: tutao.entity.EntityHelper.aggregatesToJsonData(this._memberships), 
    phoneNumbers: tutao.entity.EntityHelper.aggregatesToJsonData(this._phoneNumbers), 
    secondFactorAuthentications: this._secondFactorAuthentications, 
    successfulLogins: this._successfulLogins, 
    userGroup: tutao.entity.EntityHelper.aggregatesToJsonData(this._userGroup)
  };
};

/**
 * The id of the User type.
 */
tutao.entity.sys.User.prototype.TYPE_ID = 84;

/**
 * The id of the accountType attribute.
 */
tutao.entity.sys.User.prototype.ACCOUNTTYPE_ATTRIBUTE_ID = 92;

/**
 * The id of the enabled attribute.
 */
tutao.entity.sys.User.prototype.ENABLED_ATTRIBUTE_ID = 93;

/**
 * The id of the salt attribute.
 */
tutao.entity.sys.User.prototype.SALT_ATTRIBUTE_ID = 90;

/**
 * The id of the userEncClientKey attribute.
 */
tutao.entity.sys.User.prototype.USERENCCLIENTKEY_ATTRIBUTE_ID = 89;

/**
 * The id of the verifier attribute.
 */
tutao.entity.sys.User.prototype.VERIFIER_ATTRIBUTE_ID = 91;

/**
 * The id of the authenticatedDevices attribute.
 */
tutao.entity.sys.User.prototype.AUTHENTICATEDDEVICES_ATTRIBUTE_ID = 97;

/**
 * The id of the customer attribute.
 */
tutao.entity.sys.User.prototype.CUSTOMER_ATTRIBUTE_ID = 99;

/**
 * The id of the externalAuthInfo attribute.
 */
tutao.entity.sys.User.prototype.EXTERNALAUTHINFO_ATTRIBUTE_ID = 98;

/**
 * The id of the failedLogins attribute.
 */
tutao.entity.sys.User.prototype.FAILEDLOGINS_ATTRIBUTE_ID = 101;

/**
 * The id of the memberships attribute.
 */
tutao.entity.sys.User.prototype.MEMBERSHIPS_ATTRIBUTE_ID = 96;

/**
 * The id of the phoneNumbers attribute.
 */
tutao.entity.sys.User.prototype.PHONENUMBERS_ATTRIBUTE_ID = 94;

/**
 * The id of the secondFactorAuthentications attribute.
 */
tutao.entity.sys.User.prototype.SECONDFACTORAUTHENTICATIONS_ATTRIBUTE_ID = 102;

/**
 * The id of the successfulLogins attribute.
 */
tutao.entity.sys.User.prototype.SUCCESSFULLOGINS_ATTRIBUTE_ID = 100;

/**
 * The id of the userGroup attribute.
 */
tutao.entity.sys.User.prototype.USERGROUP_ATTRIBUTE_ID = 95;

/**
 * Provides the id of this User.
 * @return {string} The id of this User.
 */
tutao.entity.sys.User.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this User.
 * @param {string} format The format of this User.
 */
tutao.entity.sys.User.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this User.
 * @return {string} The format of this User.
 */
tutao.entity.sys.User.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this User.
 * @param {string} permissions The permissions of this User.
 */
tutao.entity.sys.User.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this User.
 * @return {string} The permissions of this User.
 */
tutao.entity.sys.User.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the accountType of this User.
 * @param {string} accountType The accountType of this User.
 */
tutao.entity.sys.User.prototype.setAccountType = function(accountType) {
  this._accountType = accountType;
  return this;
};

/**
 * Provides the accountType of this User.
 * @return {string} The accountType of this User.
 */
tutao.entity.sys.User.prototype.getAccountType = function() {
  return this._accountType;
};

/**
 * Sets the enabled of this User.
 * @param {boolean} enabled The enabled of this User.
 */
tutao.entity.sys.User.prototype.setEnabled = function(enabled) {
  this._enabled = enabled ? '1' : '0';
  return this;
};

/**
 * Provides the enabled of this User.
 * @return {boolean} The enabled of this User.
 */
tutao.entity.sys.User.prototype.getEnabled = function() {
  return this._enabled == '1';
};

/**
 * Sets the salt of this User.
 * @param {string} salt The salt of this User.
 */
tutao.entity.sys.User.prototype.setSalt = function(salt) {
  this._salt = salt;
  return this;
};

/**
 * Provides the salt of this User.
 * @return {string} The salt of this User.
 */
tutao.entity.sys.User.prototype.getSalt = function() {
  return this._salt;
};

/**
 * Sets the userEncClientKey of this User.
 * @param {string} userEncClientKey The userEncClientKey of this User.
 */
tutao.entity.sys.User.prototype.setUserEncClientKey = function(userEncClientKey) {
  this._userEncClientKey = userEncClientKey;
  return this;
};

/**
 * Provides the userEncClientKey of this User.
 * @return {string} The userEncClientKey of this User.
 */
tutao.entity.sys.User.prototype.getUserEncClientKey = function() {
  return this._userEncClientKey;
};

/**
 * Sets the verifier of this User.
 * @param {string} verifier The verifier of this User.
 */
tutao.entity.sys.User.prototype.setVerifier = function(verifier) {
  this._verifier = verifier;
  return this;
};

/**
 * Provides the verifier of this User.
 * @return {string} The verifier of this User.
 */
tutao.entity.sys.User.prototype.getVerifier = function() {
  return this._verifier;
};

/**
 * Provides the authenticatedDevices of this User.
 * @return {Array.<tutao.entity.sys.AuthenticatedDevice>} The authenticatedDevices of this User.
 */
tutao.entity.sys.User.prototype.getAuthenticatedDevices = function() {
  return this._authenticatedDevices;
};

/**
 * Sets the customer of this User.
 * @param {string} customer The customer of this User.
 */
tutao.entity.sys.User.prototype.setCustomer = function(customer) {
  this._customer = customer;
  return this;
};

/**
 * Provides the customer of this User.
 * @return {string} The customer of this User.
 */
tutao.entity.sys.User.prototype.getCustomer = function() {
  return this._customer;
};

/**
 * Loads the customer of this User.
 * @return {Promise.<tutao.entity.sys.Customer>} Resolves to the loaded customer of this User or an exception if the loading failed.
 */
tutao.entity.sys.User.prototype.loadCustomer = function() {
  return tutao.entity.sys.Customer.load(this._customer);
};

/**
 * Sets the externalAuthInfo of this User.
 * @param {tutao.entity.sys.UserExternalAuthInfo} externalAuthInfo The externalAuthInfo of this User.
 */
tutao.entity.sys.User.prototype.setExternalAuthInfo = function(externalAuthInfo) {
  this._externalAuthInfo = externalAuthInfo;
  return this;
};

/**
 * Provides the externalAuthInfo of this User.
 * @return {tutao.entity.sys.UserExternalAuthInfo} The externalAuthInfo of this User.
 */
tutao.entity.sys.User.prototype.getExternalAuthInfo = function() {
  return this._externalAuthInfo;
};

/**
 * Sets the failedLogins of this User.
 * @param {string} failedLogins The failedLogins of this User.
 */
tutao.entity.sys.User.prototype.setFailedLogins = function(failedLogins) {
  this._failedLogins = failedLogins;
  return this;
};

/**
 * Provides the failedLogins of this User.
 * @return {string} The failedLogins of this User.
 */
tutao.entity.sys.User.prototype.getFailedLogins = function() {
  return this._failedLogins;
};

/**
 * Provides the memberships of this User.
 * @return {Array.<tutao.entity.sys.GroupMembership>} The memberships of this User.
 */
tutao.entity.sys.User.prototype.getMemberships = function() {
  return this._memberships;
};

/**
 * Provides the phoneNumbers of this User.
 * @return {Array.<tutao.entity.sys.PhoneNumber>} The phoneNumbers of this User.
 */
tutao.entity.sys.User.prototype.getPhoneNumbers = function() {
  return this._phoneNumbers;
};

/**
 * Sets the secondFactorAuthentications of this User.
 * @param {string} secondFactorAuthentications The secondFactorAuthentications of this User.
 */
tutao.entity.sys.User.prototype.setSecondFactorAuthentications = function(secondFactorAuthentications) {
  this._secondFactorAuthentications = secondFactorAuthentications;
  return this;
};

/**
 * Provides the secondFactorAuthentications of this User.
 * @return {string} The secondFactorAuthentications of this User.
 */
tutao.entity.sys.User.prototype.getSecondFactorAuthentications = function() {
  return this._secondFactorAuthentications;
};

/**
 * Sets the successfulLogins of this User.
 * @param {string} successfulLogins The successfulLogins of this User.
 */
tutao.entity.sys.User.prototype.setSuccessfulLogins = function(successfulLogins) {
  this._successfulLogins = successfulLogins;
  return this;
};

/**
 * Provides the successfulLogins of this User.
 * @return {string} The successfulLogins of this User.
 */
tutao.entity.sys.User.prototype.getSuccessfulLogins = function() {
  return this._successfulLogins;
};

/**
 * Sets the userGroup of this User.
 * @param {tutao.entity.sys.GroupMembership} userGroup The userGroup of this User.
 */
tutao.entity.sys.User.prototype.setUserGroup = function(userGroup) {
  this._userGroup = userGroup;
  return this;
};

/**
 * Provides the userGroup of this User.
 * @return {tutao.entity.sys.GroupMembership} The userGroup of this User.
 */
tutao.entity.sys.User.prototype.getUserGroup = function() {
  return this._userGroup;
};

/**
 * Loads a User from the server.
 * @param {string} id The id of the User.
 * @return {Promise.<tutao.entity.sys.User>} Resolves to the User or an exception if the loading failed.
 */
tutao.entity.sys.User.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.sys.User, tutao.entity.sys.User.PATH, id, null, {"v" : 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple Users from the server.
 * @param {Array.<string>} ids The ids of the Users to load.
 * @return {Promise.<Array.<tutao.entity.sys.User>>} Resolves to an array of User or rejects with an exception if the loading failed.
 */
tutao.entity.sys.User.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.sys.User, tutao.entity.sys.User.PATH, ids, {"v": 4}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.sys.User.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.sys.User.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.sys.UserData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.UserData = function(data) {
  if (data) {
    this.__format = data._format;
    this._mobilePhoneNumber = data.mobilePhoneNumber;
    this._salt = data.salt;
    this._userEncClientKey = data.userEncClientKey;
    this._userEncCustomerGroupKey = data.userEncCustomerGroupKey;
    this._verifier = data.verifier;
    this._userGroupData = (data.userGroupData) ? new tutao.entity.sys.CreateGroupData(this, data.userGroupData) : null;
  } else {
    this.__format = "0";
    this._mobilePhoneNumber = null;
    this._salt = null;
    this._userEncClientKey = null;
    this._userEncCustomerGroupKey = null;
    this._verifier = null;
    this._userGroupData = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.UserData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.UserData.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.UserData.PATH = '/rest/sys/userservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.UserData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.UserData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    mobilePhoneNumber: this._mobilePhoneNumber, 
    salt: this._salt, 
    userEncClientKey: this._userEncClientKey, 
    userEncCustomerGroupKey: this._userEncCustomerGroupKey, 
    verifier: this._verifier, 
    userGroupData: tutao.entity.EntityHelper.aggregatesToJsonData(this._userGroupData)
  };
};

/**
 * The id of the UserData type.
 */
tutao.entity.sys.UserData.prototype.TYPE_ID = 396;

/**
 * The id of the mobilePhoneNumber attribute.
 */
tutao.entity.sys.UserData.prototype.MOBILEPHONENUMBER_ATTRIBUTE_ID = 403;

/**
 * The id of the salt attribute.
 */
tutao.entity.sys.UserData.prototype.SALT_ATTRIBUTE_ID = 401;

/**
 * The id of the userEncClientKey attribute.
 */
tutao.entity.sys.UserData.prototype.USERENCCLIENTKEY_ATTRIBUTE_ID = 398;

/**
 * The id of the userEncCustomerGroupKey attribute.
 */
tutao.entity.sys.UserData.prototype.USERENCCUSTOMERGROUPKEY_ATTRIBUTE_ID = 399;

/**
 * The id of the verifier attribute.
 */
tutao.entity.sys.UserData.prototype.VERIFIER_ATTRIBUTE_ID = 402;

/**
 * The id of the userGroupData attribute.
 */
tutao.entity.sys.UserData.prototype.USERGROUPDATA_ATTRIBUTE_ID = 400;

/**
 * Sets the format of this UserData.
 * @param {string} format The format of this UserData.
 */
tutao.entity.sys.UserData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this UserData.
 * @return {string} The format of this UserData.
 */
tutao.entity.sys.UserData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the mobilePhoneNumber of this UserData.
 * @param {string} mobilePhoneNumber The mobilePhoneNumber of this UserData.
 */
tutao.entity.sys.UserData.prototype.setMobilePhoneNumber = function(mobilePhoneNumber) {
  this._mobilePhoneNumber = mobilePhoneNumber;
  return this;
};

/**
 * Provides the mobilePhoneNumber of this UserData.
 * @return {string} The mobilePhoneNumber of this UserData.
 */
tutao.entity.sys.UserData.prototype.getMobilePhoneNumber = function() {
  return this._mobilePhoneNumber;
};

/**
 * Sets the salt of this UserData.
 * @param {string} salt The salt of this UserData.
 */
tutao.entity.sys.UserData.prototype.setSalt = function(salt) {
  this._salt = salt;
  return this;
};

/**
 * Provides the salt of this UserData.
 * @return {string} The salt of this UserData.
 */
tutao.entity.sys.UserData.prototype.getSalt = function() {
  return this._salt;
};

/**
 * Sets the userEncClientKey of this UserData.
 * @param {string} userEncClientKey The userEncClientKey of this UserData.
 */
tutao.entity.sys.UserData.prototype.setUserEncClientKey = function(userEncClientKey) {
  this._userEncClientKey = userEncClientKey;
  return this;
};

/**
 * Provides the userEncClientKey of this UserData.
 * @return {string} The userEncClientKey of this UserData.
 */
tutao.entity.sys.UserData.prototype.getUserEncClientKey = function() {
  return this._userEncClientKey;
};

/**
 * Sets the userEncCustomerGroupKey of this UserData.
 * @param {string} userEncCustomerGroupKey The userEncCustomerGroupKey of this UserData.
 */
tutao.entity.sys.UserData.prototype.setUserEncCustomerGroupKey = function(userEncCustomerGroupKey) {
  this._userEncCustomerGroupKey = userEncCustomerGroupKey;
  return this;
};

/**
 * Provides the userEncCustomerGroupKey of this UserData.
 * @return {string} The userEncCustomerGroupKey of this UserData.
 */
tutao.entity.sys.UserData.prototype.getUserEncCustomerGroupKey = function() {
  return this._userEncCustomerGroupKey;
};

/**
 * Sets the verifier of this UserData.
 * @param {string} verifier The verifier of this UserData.
 */
tutao.entity.sys.UserData.prototype.setVerifier = function(verifier) {
  this._verifier = verifier;
  return this;
};

/**
 * Provides the verifier of this UserData.
 * @return {string} The verifier of this UserData.
 */
tutao.entity.sys.UserData.prototype.getVerifier = function() {
  return this._verifier;
};

/**
 * Sets the userGroupData of this UserData.
 * @param {tutao.entity.sys.CreateGroupData} userGroupData The userGroupData of this UserData.
 */
tutao.entity.sys.UserData.prototype.setUserGroupData = function(userGroupData) {
  this._userGroupData = userGroupData;
  return this;
};

/**
 * Provides the userGroupData of this UserData.
 * @return {tutao.entity.sys.CreateGroupData} The userGroupData of this UserData.
 */
tutao.entity.sys.UserData.prototype.getUserGroupData = function() {
  return this._userGroupData;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.UserReturn=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.UserData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.sys.UserData.PATH, this, parameters, headers, tutao.entity.sys.UserReturn);
};

"use strict";

tutao.provide('tutao.entity.sys.UserDataDelete');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.UserDataDelete = function(data) {
  if (data) {
    this.__format = data._format;
    this._restore = data.restore;
    this._user = data.user;
  } else {
    this.__format = "0";
    this._restore = null;
    this._user = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.UserDataDelete.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.UserDataDelete.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.UserDataDelete.PATH = '/rest/sys/userservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.UserDataDelete.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.UserDataDelete.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    restore: this._restore, 
    user: this._user
  };
};

/**
 * The id of the UserDataDelete type.
 */
tutao.entity.sys.UserDataDelete.prototype.TYPE_ID = 404;

/**
 * The id of the restore attribute.
 */
tutao.entity.sys.UserDataDelete.prototype.RESTORE_ATTRIBUTE_ID = 406;

/**
 * The id of the user attribute.
 */
tutao.entity.sys.UserDataDelete.prototype.USER_ATTRIBUTE_ID = 407;

/**
 * Sets the format of this UserDataDelete.
 * @param {string} format The format of this UserDataDelete.
 */
tutao.entity.sys.UserDataDelete.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this UserDataDelete.
 * @return {string} The format of this UserDataDelete.
 */
tutao.entity.sys.UserDataDelete.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the restore of this UserDataDelete.
 * @param {boolean} restore The restore of this UserDataDelete.
 */
tutao.entity.sys.UserDataDelete.prototype.setRestore = function(restore) {
  this._restore = restore ? '1' : '0';
  return this;
};

/**
 * Provides the restore of this UserDataDelete.
 * @return {boolean} The restore of this UserDataDelete.
 */
tutao.entity.sys.UserDataDelete.prototype.getRestore = function() {
  return this._restore == '1';
};

/**
 * Sets the user of this UserDataDelete.
 * @param {string} user The user of this UserDataDelete.
 */
tutao.entity.sys.UserDataDelete.prototype.setUser = function(user) {
  this._user = user;
  return this;
};

/**
 * Provides the user of this UserDataDelete.
 * @return {string} The user of this UserDataDelete.
 */
tutao.entity.sys.UserDataDelete.prototype.getUser = function() {
  return this._user;
};

/**
 * Loads the user of this UserDataDelete.
 * @return {Promise.<tutao.entity.sys.User>} Resolves to the loaded user of this UserDataDelete or an exception if the loading failed.
 */
tutao.entity.sys.UserDataDelete.prototype.loadUser = function() {
  return tutao.entity.sys.User.load(this._user);
};

/**
 * Invokes DELETE on a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.UserDataDelete=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.UserDataDelete.prototype.erase = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.deleteService(tutao.entity.sys.UserDataDelete.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.sys.UserExternalAuthInfo');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.UserExternalAuthInfo = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._authUpdateCounter = data.authUpdateCounter;
    this._autoAuthenticationId = data.autoAuthenticationId;
    this._autoTransmitPassword = data.autoTransmitPassword;
    this._latestSaltHash = data.latestSaltHash;
    this._variableAuthInfo = data.variableAuthInfo;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._authUpdateCounter = null;
    this._autoAuthenticationId = null;
    this._autoTransmitPassword = null;
    this._latestSaltHash = null;
    this._variableAuthInfo = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.UserExternalAuthInfo.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    authUpdateCounter: this._authUpdateCounter, 
    autoAuthenticationId: this._autoAuthenticationId, 
    autoTransmitPassword: this._autoTransmitPassword, 
    latestSaltHash: this._latestSaltHash, 
    variableAuthInfo: this._variableAuthInfo
  };
};

/**
 * The id of the UserExternalAuthInfo type.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.TYPE_ID = 77;

/**
 * The id of the authUpdateCounter attribute.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.AUTHUPDATECOUNTER_ATTRIBUTE_ID = 82;

/**
 * The id of the autoAuthenticationId attribute.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.AUTOAUTHENTICATIONID_ATTRIBUTE_ID = 79;

/**
 * The id of the autoTransmitPassword attribute.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.AUTOTRANSMITPASSWORD_ATTRIBUTE_ID = 81;

/**
 * The id of the latestSaltHash attribute.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.LATESTSALTHASH_ATTRIBUTE_ID = 80;

/**
 * The id of the variableAuthInfo attribute.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.VARIABLEAUTHINFO_ATTRIBUTE_ID = 83;

/**
 * Sets the id of this UserExternalAuthInfo.
 * @param {string} id The id of this UserExternalAuthInfo.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this UserExternalAuthInfo.
 * @return {string} The id of this UserExternalAuthInfo.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the authUpdateCounter of this UserExternalAuthInfo.
 * @param {string} authUpdateCounter The authUpdateCounter of this UserExternalAuthInfo.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.setAuthUpdateCounter = function(authUpdateCounter) {
  this._authUpdateCounter = authUpdateCounter;
  return this;
};

/**
 * Provides the authUpdateCounter of this UserExternalAuthInfo.
 * @return {string} The authUpdateCounter of this UserExternalAuthInfo.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.getAuthUpdateCounter = function() {
  return this._authUpdateCounter;
};

/**
 * Sets the autoAuthenticationId of this UserExternalAuthInfo.
 * @param {string} autoAuthenticationId The autoAuthenticationId of this UserExternalAuthInfo.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.setAutoAuthenticationId = function(autoAuthenticationId) {
  this._autoAuthenticationId = autoAuthenticationId;
  return this;
};

/**
 * Provides the autoAuthenticationId of this UserExternalAuthInfo.
 * @return {string} The autoAuthenticationId of this UserExternalAuthInfo.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.getAutoAuthenticationId = function() {
  return this._autoAuthenticationId;
};

/**
 * Sets the autoTransmitPassword of this UserExternalAuthInfo.
 * @param {string} autoTransmitPassword The autoTransmitPassword of this UserExternalAuthInfo.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.setAutoTransmitPassword = function(autoTransmitPassword) {
  this._autoTransmitPassword = autoTransmitPassword;
  return this;
};

/**
 * Provides the autoTransmitPassword of this UserExternalAuthInfo.
 * @return {string} The autoTransmitPassword of this UserExternalAuthInfo.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.getAutoTransmitPassword = function() {
  return this._autoTransmitPassword;
};

/**
 * Sets the latestSaltHash of this UserExternalAuthInfo.
 * @param {string} latestSaltHash The latestSaltHash of this UserExternalAuthInfo.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.setLatestSaltHash = function(latestSaltHash) {
  this._latestSaltHash = latestSaltHash;
  return this;
};

/**
 * Provides the latestSaltHash of this UserExternalAuthInfo.
 * @return {string} The latestSaltHash of this UserExternalAuthInfo.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.getLatestSaltHash = function() {
  return this._latestSaltHash;
};

/**
 * Sets the variableAuthInfo of this UserExternalAuthInfo.
 * @param {string} variableAuthInfo The variableAuthInfo of this UserExternalAuthInfo.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.setVariableAuthInfo = function(variableAuthInfo) {
  this._variableAuthInfo = variableAuthInfo;
  return this;
};

/**
 * Provides the variableAuthInfo of this UserExternalAuthInfo.
 * @return {string} The variableAuthInfo of this UserExternalAuthInfo.
 */
tutao.entity.sys.UserExternalAuthInfo.prototype.getVariableAuthInfo = function() {
  return this._variableAuthInfo;
};

"use strict";

tutao.provide('tutao.entity.sys.UserIdData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.UserIdData = function(data) {
  if (data) {
    this.__format = data._format;
    this._mailAddress = data.mailAddress;
  } else {
    this.__format = "0";
    this._mailAddress = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.UserIdData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.UserIdData.MODEL_VERSION = '4';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.UserIdData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.UserIdData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    mailAddress: this._mailAddress
  };
};

/**
 * The id of the UserIdData type.
 */
tutao.entity.sys.UserIdData.prototype.TYPE_ID = 424;

/**
 * The id of the mailAddress attribute.
 */
tutao.entity.sys.UserIdData.prototype.MAILADDRESS_ATTRIBUTE_ID = 426;

/**
 * Sets the format of this UserIdData.
 * @param {string} format The format of this UserIdData.
 */
tutao.entity.sys.UserIdData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this UserIdData.
 * @return {string} The format of this UserIdData.
 */
tutao.entity.sys.UserIdData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the mailAddress of this UserIdData.
 * @param {string} mailAddress The mailAddress of this UserIdData.
 */
tutao.entity.sys.UserIdData.prototype.setMailAddress = function(mailAddress) {
  this._mailAddress = mailAddress;
  return this;
};

/**
 * Provides the mailAddress of this UserIdData.
 * @return {string} The mailAddress of this UserIdData.
 */
tutao.entity.sys.UserIdData.prototype.getMailAddress = function() {
  return this._mailAddress;
};

"use strict";

tutao.provide('tutao.entity.sys.UserIdReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.UserIdReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._userId = data.userId;
  } else {
    this.__format = "0";
    this._userId = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.UserIdReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.UserIdReturn.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.UserIdReturn.PATH = '/rest/sys/useridservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.UserIdReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.UserIdReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    userId: this._userId
  };
};

/**
 * The id of the UserIdReturn type.
 */
tutao.entity.sys.UserIdReturn.prototype.TYPE_ID = 427;

/**
 * The id of the userId attribute.
 */
tutao.entity.sys.UserIdReturn.prototype.USERID_ATTRIBUTE_ID = 429;

/**
 * Sets the format of this UserIdReturn.
 * @param {string} format The format of this UserIdReturn.
 */
tutao.entity.sys.UserIdReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this UserIdReturn.
 * @return {string} The format of this UserIdReturn.
 */
tutao.entity.sys.UserIdReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the userId of this UserIdReturn.
 * @param {string} userId The userId of this UserIdReturn.
 */
tutao.entity.sys.UserIdReturn.prototype.setUserId = function(userId) {
  this._userId = userId;
  return this;
};

/**
 * Provides the userId of this UserIdReturn.
 * @return {string} The userId of this UserIdReturn.
 */
tutao.entity.sys.UserIdReturn.prototype.getUserId = function() {
  return this._userId;
};

/**
 * Loads the userId of this UserIdReturn.
 * @return {Promise.<tutao.entity.sys.User>} Resolves to the loaded userId of this UserIdReturn or an exception if the loading failed.
 */
tutao.entity.sys.UserIdReturn.prototype.loadUserId = function() {
  return tutao.entity.sys.User.load(this._userId);
};

/**
 * Loads from the service.
 * @param {tutao.entity.sys.UserIdData} entity The entity to send to the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.UserIdReturn>} Resolves to UserIdReturn or an exception if the loading failed.
 */
tutao.entity.sys.UserIdReturn.load = function(entity, parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.getService(tutao.entity.sys.UserIdReturn, tutao.entity.sys.UserIdReturn.PATH, entity, parameters, headers);
};

"use strict";

tutao.provide('tutao.entity.sys.UserReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.UserReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._user = data.user;
    this._userGroup = data.userGroup;
  } else {
    this.__format = "0";
    this._user = null;
    this._userGroup = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.UserReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.UserReturn.MODEL_VERSION = '4';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.UserReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.UserReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    user: this._user, 
    userGroup: this._userGroup
  };
};

/**
 * The id of the UserReturn type.
 */
tutao.entity.sys.UserReturn.prototype.TYPE_ID = 392;

/**
 * The id of the user attribute.
 */
tutao.entity.sys.UserReturn.prototype.USER_ATTRIBUTE_ID = 394;

/**
 * The id of the userGroup attribute.
 */
tutao.entity.sys.UserReturn.prototype.USERGROUP_ATTRIBUTE_ID = 395;

/**
 * Sets the format of this UserReturn.
 * @param {string} format The format of this UserReturn.
 */
tutao.entity.sys.UserReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this UserReturn.
 * @return {string} The format of this UserReturn.
 */
tutao.entity.sys.UserReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the user of this UserReturn.
 * @param {string} user The user of this UserReturn.
 */
tutao.entity.sys.UserReturn.prototype.setUser = function(user) {
  this._user = user;
  return this;
};

/**
 * Provides the user of this UserReturn.
 * @return {string} The user of this UserReturn.
 */
tutao.entity.sys.UserReturn.prototype.getUser = function() {
  return this._user;
};

/**
 * Loads the user of this UserReturn.
 * @return {Promise.<tutao.entity.sys.User>} Resolves to the loaded user of this UserReturn or an exception if the loading failed.
 */
tutao.entity.sys.UserReturn.prototype.loadUser = function() {
  return tutao.entity.sys.User.load(this._user);
};

/**
 * Sets the userGroup of this UserReturn.
 * @param {string} userGroup The userGroup of this UserReturn.
 */
tutao.entity.sys.UserReturn.prototype.setUserGroup = function(userGroup) {
  this._userGroup = userGroup;
  return this;
};

/**
 * Provides the userGroup of this UserReturn.
 * @return {string} The userGroup of this UserReturn.
 */
tutao.entity.sys.UserReturn.prototype.getUserGroup = function() {
  return this._userGroup;
};

/**
 * Loads the userGroup of this UserReturn.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded userGroup of this UserReturn or an exception if the loading failed.
 */
tutao.entity.sys.UserReturn.prototype.loadUserGroup = function() {
  return tutao.entity.sys.Group.load(this._userGroup);
};

"use strict";

tutao.provide('tutao.entity.sys.VerifyRegistrationCodeData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.VerifyRegistrationCodeData = function(data) {
  if (data) {
    this.__format = data._format;
    this._authToken = data.authToken;
    this._code = data.code;
  } else {
    this.__format = "0";
    this._authToken = null;
    this._code = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.VerifyRegistrationCodeData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.VerifyRegistrationCodeData.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.VerifyRegistrationCodeData.PATH = '/rest/sys/verifyregistrationcodeservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.VerifyRegistrationCodeData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.VerifyRegistrationCodeData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    authToken: this._authToken, 
    code: this._code
  };
};

/**
 * The id of the VerifyRegistrationCodeData type.
 */
tutao.entity.sys.VerifyRegistrationCodeData.prototype.TYPE_ID = 351;

/**
 * The id of the authToken attribute.
 */
tutao.entity.sys.VerifyRegistrationCodeData.prototype.AUTHTOKEN_ATTRIBUTE_ID = 353;

/**
 * The id of the code attribute.
 */
tutao.entity.sys.VerifyRegistrationCodeData.prototype.CODE_ATTRIBUTE_ID = 354;

/**
 * Sets the format of this VerifyRegistrationCodeData.
 * @param {string} format The format of this VerifyRegistrationCodeData.
 */
tutao.entity.sys.VerifyRegistrationCodeData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this VerifyRegistrationCodeData.
 * @return {string} The format of this VerifyRegistrationCodeData.
 */
tutao.entity.sys.VerifyRegistrationCodeData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the authToken of this VerifyRegistrationCodeData.
 * @param {string} authToken The authToken of this VerifyRegistrationCodeData.
 */
tutao.entity.sys.VerifyRegistrationCodeData.prototype.setAuthToken = function(authToken) {
  this._authToken = authToken;
  return this;
};

/**
 * Provides the authToken of this VerifyRegistrationCodeData.
 * @return {string} The authToken of this VerifyRegistrationCodeData.
 */
tutao.entity.sys.VerifyRegistrationCodeData.prototype.getAuthToken = function() {
  return this._authToken;
};

/**
 * Sets the code of this VerifyRegistrationCodeData.
 * @param {string} code The code of this VerifyRegistrationCodeData.
 */
tutao.entity.sys.VerifyRegistrationCodeData.prototype.setCode = function(code) {
  this._code = code;
  return this;
};

/**
 * Provides the code of this VerifyRegistrationCodeData.
 * @return {string} The code of this VerifyRegistrationCodeData.
 */
tutao.entity.sys.VerifyRegistrationCodeData.prototype.getCode = function() {
  return this._code;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.sys.VerifyRegistrationCodeData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.sys.VerifyRegistrationCodeData.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.sys.Version');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.Version = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._operation = data.operation;
    this._timestamp = data.timestamp;
    this._version = data.version;
    this._author = data.author;
    this._authorGroupInfo = data.authorGroupInfo;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._operation = null;
    this._timestamp = null;
    this._version = null;
    this._author = null;
    this._authorGroupInfo = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.sys.Version.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.Version.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    operation: this._operation, 
    timestamp: this._timestamp, 
    version: this._version, 
    author: this._author, 
    authorGroupInfo: this._authorGroupInfo
  };
};

/**
 * The id of the Version type.
 */
tutao.entity.sys.Version.prototype.TYPE_ID = 480;

/**
 * The id of the operation attribute.
 */
tutao.entity.sys.Version.prototype.OPERATION_ATTRIBUTE_ID = 484;

/**
 * The id of the timestamp attribute.
 */
tutao.entity.sys.Version.prototype.TIMESTAMP_ATTRIBUTE_ID = 483;

/**
 * The id of the version attribute.
 */
tutao.entity.sys.Version.prototype.VERSION_ATTRIBUTE_ID = 482;

/**
 * The id of the author attribute.
 */
tutao.entity.sys.Version.prototype.AUTHOR_ATTRIBUTE_ID = 485;

/**
 * The id of the authorGroupInfo attribute.
 */
tutao.entity.sys.Version.prototype.AUTHORGROUPINFO_ATTRIBUTE_ID = 486;

/**
 * Sets the id of this Version.
 * @param {string} id The id of this Version.
 */
tutao.entity.sys.Version.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this Version.
 * @return {string} The id of this Version.
 */
tutao.entity.sys.Version.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the operation of this Version.
 * @param {string} operation The operation of this Version.
 */
tutao.entity.sys.Version.prototype.setOperation = function(operation) {
  this._operation = operation;
  return this;
};

/**
 * Provides the operation of this Version.
 * @return {string} The operation of this Version.
 */
tutao.entity.sys.Version.prototype.getOperation = function() {
  return this._operation;
};

/**
 * Sets the timestamp of this Version.
 * @param {Date} timestamp The timestamp of this Version.
 */
tutao.entity.sys.Version.prototype.setTimestamp = function(timestamp) {
  this._timestamp = String(timestamp.getTime());
  return this;
};

/**
 * Provides the timestamp of this Version.
 * @return {Date} The timestamp of this Version.
 */
tutao.entity.sys.Version.prototype.getTimestamp = function() {
  if (isNaN(this._timestamp)) {
    throw new tutao.InvalidDataError('invalid time data: ' + this._timestamp);
  }
  return new Date(Number(this._timestamp));
};

/**
 * Sets the version of this Version.
 * @param {string} version The version of this Version.
 */
tutao.entity.sys.Version.prototype.setVersion = function(version) {
  this._version = version;
  return this;
};

/**
 * Provides the version of this Version.
 * @return {string} The version of this Version.
 */
tutao.entity.sys.Version.prototype.getVersion = function() {
  return this._version;
};

/**
 * Sets the author of this Version.
 * @param {string} author The author of this Version.
 */
tutao.entity.sys.Version.prototype.setAuthor = function(author) {
  this._author = author;
  return this;
};

/**
 * Provides the author of this Version.
 * @return {string} The author of this Version.
 */
tutao.entity.sys.Version.prototype.getAuthor = function() {
  return this._author;
};

/**
 * Loads the author of this Version.
 * @return {Promise.<tutao.entity.sys.Group>} Resolves to the loaded author of this Version or an exception if the loading failed.
 */
tutao.entity.sys.Version.prototype.loadAuthor = function() {
  return tutao.entity.sys.Group.load(this._author);
};

/**
 * Sets the authorGroupInfo of this Version.
 * @param {Array.<string>} authorGroupInfo The authorGroupInfo of this Version.
 */
tutao.entity.sys.Version.prototype.setAuthorGroupInfo = function(authorGroupInfo) {
  this._authorGroupInfo = authorGroupInfo;
  return this;
};

/**
 * Provides the authorGroupInfo of this Version.
 * @return {Array.<string>} The authorGroupInfo of this Version.
 */
tutao.entity.sys.Version.prototype.getAuthorGroupInfo = function() {
  return this._authorGroupInfo;
};

/**
 * Loads the authorGroupInfo of this Version.
 * @return {Promise.<tutao.entity.sys.GroupInfo>} Resolves to the loaded authorGroupInfo of this Version or an exception if the loading failed.
 */
tutao.entity.sys.Version.prototype.loadAuthorGroupInfo = function() {
  return tutao.entity.sys.GroupInfo.load(this._authorGroupInfo);
};

"use strict";

tutao.provide('tutao.entity.sys.VersionData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.VersionData = function(data) {
  if (data) {
    this.__format = data._format;
    this._application = data.application;
    this._id = data.id;
    this._listId = data.listId;
    this._typeId = data.typeId;
  } else {
    this.__format = "0";
    this._application = null;
    this._id = null;
    this._listId = null;
    this._typeId = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.VersionData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.VersionData.MODEL_VERSION = '4';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.VersionData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.VersionData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    application: this._application, 
    id: this._id, 
    listId: this._listId, 
    typeId: this._typeId
  };
};

/**
 * The id of the VersionData type.
 */
tutao.entity.sys.VersionData.prototype.TYPE_ID = 487;

/**
 * The id of the application attribute.
 */
tutao.entity.sys.VersionData.prototype.APPLICATION_ATTRIBUTE_ID = 489;

/**
 * The id of the id attribute.
 */
tutao.entity.sys.VersionData.prototype.ID_ATTRIBUTE_ID = 491;

/**
 * The id of the listId attribute.
 */
tutao.entity.sys.VersionData.prototype.LISTID_ATTRIBUTE_ID = 492;

/**
 * The id of the typeId attribute.
 */
tutao.entity.sys.VersionData.prototype.TYPEID_ATTRIBUTE_ID = 490;

/**
 * Sets the format of this VersionData.
 * @param {string} format The format of this VersionData.
 */
tutao.entity.sys.VersionData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this VersionData.
 * @return {string} The format of this VersionData.
 */
tutao.entity.sys.VersionData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the application of this VersionData.
 * @param {string} application The application of this VersionData.
 */
tutao.entity.sys.VersionData.prototype.setApplication = function(application) {
  this._application = application;
  return this;
};

/**
 * Provides the application of this VersionData.
 * @return {string} The application of this VersionData.
 */
tutao.entity.sys.VersionData.prototype.getApplication = function() {
  return this._application;
};

/**
 * Sets the id of this VersionData.
 * @param {string} id The id of this VersionData.
 */
tutao.entity.sys.VersionData.prototype.setId = function(id) {
  this._id = id;
  return this;
};

/**
 * Provides the id of this VersionData.
 * @return {string} The id of this VersionData.
 */
tutao.entity.sys.VersionData.prototype.getId = function() {
  return this._id;
};

/**
 * Sets the listId of this VersionData.
 * @param {string} listId The listId of this VersionData.
 */
tutao.entity.sys.VersionData.prototype.setListId = function(listId) {
  this._listId = listId;
  return this;
};

/**
 * Provides the listId of this VersionData.
 * @return {string} The listId of this VersionData.
 */
tutao.entity.sys.VersionData.prototype.getListId = function() {
  return this._listId;
};

/**
 * Sets the typeId of this VersionData.
 * @param {string} typeId The typeId of this VersionData.
 */
tutao.entity.sys.VersionData.prototype.setTypeId = function(typeId) {
  this._typeId = typeId;
  return this;
};

/**
 * Provides the typeId of this VersionData.
 * @return {string} The typeId of this VersionData.
 */
tutao.entity.sys.VersionData.prototype.getTypeId = function() {
  return this._typeId;
};

"use strict";

tutao.provide('tutao.entity.sys.VersionReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.VersionReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._versions = [];
    for (var i=0; i < data.versions.length; i++) {
      this._versions.push(new tutao.entity.sys.Version(this, data.versions[i]));
    }
  } else {
    this.__format = "0";
    this._versions = [];
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.VersionReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.VersionReturn.MODEL_VERSION = '4';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.sys.VersionReturn.PATH = '/rest/sys/versionservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.VersionReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.VersionReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    versions: tutao.entity.EntityHelper.aggregatesToJsonData(this._versions)
  };
};

/**
 * The id of the VersionReturn type.
 */
tutao.entity.sys.VersionReturn.prototype.TYPE_ID = 493;

/**
 * The id of the versions attribute.
 */
tutao.entity.sys.VersionReturn.prototype.VERSIONS_ATTRIBUTE_ID = 495;

/**
 * Sets the format of this VersionReturn.
 * @param {string} format The format of this VersionReturn.
 */
tutao.entity.sys.VersionReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this VersionReturn.
 * @return {string} The format of this VersionReturn.
 */
tutao.entity.sys.VersionReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Provides the versions of this VersionReturn.
 * @return {Array.<tutao.entity.sys.Version>} The versions of this VersionReturn.
 */
tutao.entity.sys.VersionReturn.prototype.getVersions = function() {
  return this._versions;
};

/**
 * Loads from the service.
 * @param {tutao.entity.sys.VersionData} entity The entity to send to the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.sys.VersionReturn>} Resolves to VersionReturn or an exception if the loading failed.
 */
tutao.entity.sys.VersionReturn.load = function(entity, parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 4;
  return tutao.locator.entityRestClient.getService(tutao.entity.sys.VersionReturn, tutao.entity.sys.VersionReturn.PATH, entity, parameters, headers);
};

"use strict";

tutao.provide('tutao.entity.sys.WebsocketWrapper');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.sys.WebsocketWrapper = function(data) {
  if (data) {
    this.__format = data._format;
    this._msgId = data.msgId;
    this._type = data.type;
    this._authentication = (data.authentication) ? new tutao.entity.sys.Authentication(this, data.authentication) : null;
    this._chat = (data.chat) ? new tutao.entity.sys.Chat(this, data.chat) : null;
    this._entityUpdate = (data.entityUpdate) ? new tutao.entity.sys.EntityUpdate(this, data.entityUpdate) : null;
    this._exception = (data.exception) ? new tutao.entity.sys.Exception(this, data.exception) : null;
  } else {
    this.__format = "0";
    this._msgId = null;
    this._type = null;
    this._authentication = null;
    this._chat = null;
    this._entityUpdate = null;
    this._exception = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.sys.WebsocketWrapper.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.sys.WebsocketWrapper.MODEL_VERSION = '4';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.sys.WebsocketWrapper.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.sys.WebsocketWrapper.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    msgId: this._msgId, 
    type: this._type, 
    authentication: tutao.entity.EntityHelper.aggregatesToJsonData(this._authentication), 
    chat: tutao.entity.EntityHelper.aggregatesToJsonData(this._chat), 
    entityUpdate: tutao.entity.EntityHelper.aggregatesToJsonData(this._entityUpdate), 
    exception: tutao.entity.EntityHelper.aggregatesToJsonData(this._exception)
  };
};

/**
 * The id of the WebsocketWrapper type.
 */
tutao.entity.sys.WebsocketWrapper.prototype.TYPE_ID = 472;

/**
 * The id of the msgId attribute.
 */
tutao.entity.sys.WebsocketWrapper.prototype.MSGID_ATTRIBUTE_ID = 474;

/**
 * The id of the type attribute.
 */
tutao.entity.sys.WebsocketWrapper.prototype.TYPE_ATTRIBUTE_ID = 475;

/**
 * The id of the authentication attribute.
 */
tutao.entity.sys.WebsocketWrapper.prototype.AUTHENTICATION_ATTRIBUTE_ID = 476;

/**
 * The id of the chat attribute.
 */
tutao.entity.sys.WebsocketWrapper.prototype.CHAT_ATTRIBUTE_ID = 477;

/**
 * The id of the entityUpdate attribute.
 */
tutao.entity.sys.WebsocketWrapper.prototype.ENTITYUPDATE_ATTRIBUTE_ID = 478;

/**
 * The id of the exception attribute.
 */
tutao.entity.sys.WebsocketWrapper.prototype.EXCEPTION_ATTRIBUTE_ID = 479;

/**
 * Sets the format of this WebsocketWrapper.
 * @param {string} format The format of this WebsocketWrapper.
 */
tutao.entity.sys.WebsocketWrapper.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this WebsocketWrapper.
 * @return {string} The format of this WebsocketWrapper.
 */
tutao.entity.sys.WebsocketWrapper.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the msgId of this WebsocketWrapper.
 * @param {string} msgId The msgId of this WebsocketWrapper.
 */
tutao.entity.sys.WebsocketWrapper.prototype.setMsgId = function(msgId) {
  this._msgId = msgId;
  return this;
};

/**
 * Provides the msgId of this WebsocketWrapper.
 * @return {string} The msgId of this WebsocketWrapper.
 */
tutao.entity.sys.WebsocketWrapper.prototype.getMsgId = function() {
  return this._msgId;
};

/**
 * Sets the type of this WebsocketWrapper.
 * @param {string} type The type of this WebsocketWrapper.
 */
tutao.entity.sys.WebsocketWrapper.prototype.setType = function(type) {
  this._type = type;
  return this;
};

/**
 * Provides the type of this WebsocketWrapper.
 * @return {string} The type of this WebsocketWrapper.
 */
tutao.entity.sys.WebsocketWrapper.prototype.getType = function() {
  return this._type;
};

/**
 * Sets the authentication of this WebsocketWrapper.
 * @param {tutao.entity.sys.Authentication} authentication The authentication of this WebsocketWrapper.
 */
tutao.entity.sys.WebsocketWrapper.prototype.setAuthentication = function(authentication) {
  this._authentication = authentication;
  return this;
};

/**
 * Provides the authentication of this WebsocketWrapper.
 * @return {tutao.entity.sys.Authentication} The authentication of this WebsocketWrapper.
 */
tutao.entity.sys.WebsocketWrapper.prototype.getAuthentication = function() {
  return this._authentication;
};

/**
 * Sets the chat of this WebsocketWrapper.
 * @param {tutao.entity.sys.Chat} chat The chat of this WebsocketWrapper.
 */
tutao.entity.sys.WebsocketWrapper.prototype.setChat = function(chat) {
  this._chat = chat;
  return this;
};

/**
 * Provides the chat of this WebsocketWrapper.
 * @return {tutao.entity.sys.Chat} The chat of this WebsocketWrapper.
 */
tutao.entity.sys.WebsocketWrapper.prototype.getChat = function() {
  return this._chat;
};

/**
 * Sets the entityUpdate of this WebsocketWrapper.
 * @param {tutao.entity.sys.EntityUpdate} entityUpdate The entityUpdate of this WebsocketWrapper.
 */
tutao.entity.sys.WebsocketWrapper.prototype.setEntityUpdate = function(entityUpdate) {
  this._entityUpdate = entityUpdate;
  return this;
};

/**
 * Provides the entityUpdate of this WebsocketWrapper.
 * @return {tutao.entity.sys.EntityUpdate} The entityUpdate of this WebsocketWrapper.
 */
tutao.entity.sys.WebsocketWrapper.prototype.getEntityUpdate = function() {
  return this._entityUpdate;
};

/**
 * Sets the exception of this WebsocketWrapper.
 * @param {tutao.entity.sys.Exception} exception The exception of this WebsocketWrapper.
 */
tutao.entity.sys.WebsocketWrapper.prototype.setException = function(exception) {
  this._exception = exception;
  return this;
};

/**
 * Provides the exception of this WebsocketWrapper.
 * @return {tutao.entity.sys.Exception} The exception of this WebsocketWrapper.
 */
tutao.entity.sys.WebsocketWrapper.prototype.getException = function() {
  return this._exception;
};

"use strict";

tutao.provide('tutao.entity.tutanota.Attachment');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.Attachment = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._bucketEncFileSessionKey = data.bucketEncFileSessionKey;
    this._fileName = data.fileName;
    this._listEncFileSessionKey = data.listEncFileSessionKey;
    this._mimeType = data.mimeType;
    this._file = data.file;
    this._fileData = data.fileData;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._bucketEncFileSessionKey = null;
    this._fileName = null;
    this._listEncFileSessionKey = null;
    this._mimeType = null;
    this._file = null;
    this._fileData = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.Attachment.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.Attachment.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    bucketEncFileSessionKey: this._bucketEncFileSessionKey, 
    fileName: this._fileName, 
    listEncFileSessionKey: this._listEncFileSessionKey, 
    mimeType: this._mimeType, 
    file: this._file, 
    fileData: this._fileData
  };
};

/**
 * The id of the Attachment type.
 */
tutao.entity.tutanota.Attachment.prototype.TYPE_ID = 175;

/**
 * The id of the bucketEncFileSessionKey attribute.
 */
tutao.entity.tutanota.Attachment.prototype.BUCKETENCFILESESSIONKEY_ATTRIBUTE_ID = 178;

/**
 * The id of the fileName attribute.
 */
tutao.entity.tutanota.Attachment.prototype.FILENAME_ATTRIBUTE_ID = 180;

/**
 * The id of the listEncFileSessionKey attribute.
 */
tutao.entity.tutanota.Attachment.prototype.LISTENCFILESESSIONKEY_ATTRIBUTE_ID = 177;

/**
 * The id of the mimeType attribute.
 */
tutao.entity.tutanota.Attachment.prototype.MIMETYPE_ATTRIBUTE_ID = 181;

/**
 * The id of the file attribute.
 */
tutao.entity.tutanota.Attachment.prototype.FILE_ATTRIBUTE_ID = 179;

/**
 * The id of the fileData attribute.
 */
tutao.entity.tutanota.Attachment.prototype.FILEDATA_ATTRIBUTE_ID = 182;

/**
 * Sets the id of this Attachment.
 * @param {string} id The id of this Attachment.
 */
tutao.entity.tutanota.Attachment.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this Attachment.
 * @return {string} The id of this Attachment.
 */
tutao.entity.tutanota.Attachment.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the bucketEncFileSessionKey of this Attachment.
 * @param {string} bucketEncFileSessionKey The bucketEncFileSessionKey of this Attachment.
 */
tutao.entity.tutanota.Attachment.prototype.setBucketEncFileSessionKey = function(bucketEncFileSessionKey) {
  this._bucketEncFileSessionKey = bucketEncFileSessionKey;
  return this;
};

/**
 * Provides the bucketEncFileSessionKey of this Attachment.
 * @return {string} The bucketEncFileSessionKey of this Attachment.
 */
tutao.entity.tutanota.Attachment.prototype.getBucketEncFileSessionKey = function() {
  return this._bucketEncFileSessionKey;
};

/**
 * Sets the fileName of this Attachment.
 * @param {string} fileName The fileName of this Attachment.
 */
tutao.entity.tutanota.Attachment.prototype.setFileName = function(fileName) {
  this._fileName = fileName;
  return this;
};

/**
 * Provides the fileName of this Attachment.
 * @return {string} The fileName of this Attachment.
 */
tutao.entity.tutanota.Attachment.prototype.getFileName = function() {
  return this._fileName;
};

/**
 * Sets the listEncFileSessionKey of this Attachment.
 * @param {string} listEncFileSessionKey The listEncFileSessionKey of this Attachment.
 */
tutao.entity.tutanota.Attachment.prototype.setListEncFileSessionKey = function(listEncFileSessionKey) {
  this._listEncFileSessionKey = listEncFileSessionKey;
  return this;
};

/**
 * Provides the listEncFileSessionKey of this Attachment.
 * @return {string} The listEncFileSessionKey of this Attachment.
 */
tutao.entity.tutanota.Attachment.prototype.getListEncFileSessionKey = function() {
  return this._listEncFileSessionKey;
};

/**
 * Sets the mimeType of this Attachment.
 * @param {string} mimeType The mimeType of this Attachment.
 */
tutao.entity.tutanota.Attachment.prototype.setMimeType = function(mimeType) {
  this._mimeType = mimeType;
  return this;
};

/**
 * Provides the mimeType of this Attachment.
 * @return {string} The mimeType of this Attachment.
 */
tutao.entity.tutanota.Attachment.prototype.getMimeType = function() {
  return this._mimeType;
};

/**
 * Sets the file of this Attachment.
 * @param {Array.<string>} file The file of this Attachment.
 */
tutao.entity.tutanota.Attachment.prototype.setFile = function(file) {
  this._file = file;
  return this;
};

/**
 * Provides the file of this Attachment.
 * @return {Array.<string>} The file of this Attachment.
 */
tutao.entity.tutanota.Attachment.prototype.getFile = function() {
  return this._file;
};

/**
 * Loads the file of this Attachment.
 * @return {Promise.<tutao.entity.tutanota.File>} Resolves to the loaded file of this Attachment or an exception if the loading failed.
 */
tutao.entity.tutanota.Attachment.prototype.loadFile = function() {
  return tutao.entity.tutanota.File.load(this._file);
};

/**
 * Sets the fileData of this Attachment.
 * @param {string} fileData The fileData of this Attachment.
 */
tutao.entity.tutanota.Attachment.prototype.setFileData = function(fileData) {
  this._fileData = fileData;
  return this;
};

/**
 * Provides the fileData of this Attachment.
 * @return {string} The fileData of this Attachment.
 */
tutao.entity.tutanota.Attachment.prototype.getFileData = function() {
  return this._fileData;
};

/**
 * Loads the fileData of this Attachment.
 * @return {Promise.<tutao.entity.tutanota.FileData>} Resolves to the loaded fileData of this Attachment or an exception if the loading failed.
 */
tutao.entity.tutanota.Attachment.prototype.loadFileData = function() {
  return tutao.entity.tutanota.FileData.load(this._fileData);
};

"use strict";

tutao.provide('tutao.entity.tutanota.AttachmentFromExternal');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.AttachmentFromExternal = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._fileName = data.fileName;
    this._mimeType = data.mimeType;
    this._recipientBucketEncFileSessionKey = data.recipientBucketEncFileSessionKey;
    this._senderBucketEncFileSessionKey = data.senderBucketEncFileSessionKey;
    this._fileData = data.fileData;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._fileName = null;
    this._mimeType = null;
    this._recipientBucketEncFileSessionKey = null;
    this._senderBucketEncFileSessionKey = null;
    this._fileData = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.AttachmentFromExternal.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    fileName: this._fileName, 
    mimeType: this._mimeType, 
    recipientBucketEncFileSessionKey: this._recipientBucketEncFileSessionKey, 
    senderBucketEncFileSessionKey: this._senderBucketEncFileSessionKey, 
    fileData: this._fileData
  };
};

/**
 * The id of the AttachmentFromExternal type.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.TYPE_ID = 253;

/**
 * The id of the fileName attribute.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.FILENAME_ATTRIBUTE_ID = 257;

/**
 * The id of the mimeType attribute.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.MIMETYPE_ATTRIBUTE_ID = 258;

/**
 * The id of the recipientBucketEncFileSessionKey attribute.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.RECIPIENTBUCKETENCFILESESSIONKEY_ATTRIBUTE_ID = 256;

/**
 * The id of the senderBucketEncFileSessionKey attribute.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.SENDERBUCKETENCFILESESSIONKEY_ATTRIBUTE_ID = 255;

/**
 * The id of the fileData attribute.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.FILEDATA_ATTRIBUTE_ID = 259;

/**
 * Sets the id of this AttachmentFromExternal.
 * @param {string} id The id of this AttachmentFromExternal.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this AttachmentFromExternal.
 * @return {string} The id of this AttachmentFromExternal.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the fileName of this AttachmentFromExternal.
 * @param {string} fileName The fileName of this AttachmentFromExternal.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.setFileName = function(fileName) {
  this._fileName = fileName;
  return this;
};

/**
 * Provides the fileName of this AttachmentFromExternal.
 * @return {string} The fileName of this AttachmentFromExternal.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.getFileName = function() {
  return this._fileName;
};

/**
 * Sets the mimeType of this AttachmentFromExternal.
 * @param {string} mimeType The mimeType of this AttachmentFromExternal.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.setMimeType = function(mimeType) {
  this._mimeType = mimeType;
  return this;
};

/**
 * Provides the mimeType of this AttachmentFromExternal.
 * @return {string} The mimeType of this AttachmentFromExternal.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.getMimeType = function() {
  return this._mimeType;
};

/**
 * Sets the recipientBucketEncFileSessionKey of this AttachmentFromExternal.
 * @param {string} recipientBucketEncFileSessionKey The recipientBucketEncFileSessionKey of this AttachmentFromExternal.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.setRecipientBucketEncFileSessionKey = function(recipientBucketEncFileSessionKey) {
  this._recipientBucketEncFileSessionKey = recipientBucketEncFileSessionKey;
  return this;
};

/**
 * Provides the recipientBucketEncFileSessionKey of this AttachmentFromExternal.
 * @return {string} The recipientBucketEncFileSessionKey of this AttachmentFromExternal.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.getRecipientBucketEncFileSessionKey = function() {
  return this._recipientBucketEncFileSessionKey;
};

/**
 * Sets the senderBucketEncFileSessionKey of this AttachmentFromExternal.
 * @param {string} senderBucketEncFileSessionKey The senderBucketEncFileSessionKey of this AttachmentFromExternal.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.setSenderBucketEncFileSessionKey = function(senderBucketEncFileSessionKey) {
  this._senderBucketEncFileSessionKey = senderBucketEncFileSessionKey;
  return this;
};

/**
 * Provides the senderBucketEncFileSessionKey of this AttachmentFromExternal.
 * @return {string} The senderBucketEncFileSessionKey of this AttachmentFromExternal.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.getSenderBucketEncFileSessionKey = function() {
  return this._senderBucketEncFileSessionKey;
};

/**
 * Sets the fileData of this AttachmentFromExternal.
 * @param {string} fileData The fileData of this AttachmentFromExternal.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.setFileData = function(fileData) {
  this._fileData = fileData;
  return this;
};

/**
 * Provides the fileData of this AttachmentFromExternal.
 * @return {string} The fileData of this AttachmentFromExternal.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.getFileData = function() {
  return this._fileData;
};

/**
 * Loads the fileData of this AttachmentFromExternal.
 * @return {Promise.<tutao.entity.tutanota.FileData>} Resolves to the loaded fileData of this AttachmentFromExternal or an exception if the loading failed.
 */
tutao.entity.tutanota.AttachmentFromExternal.prototype.loadFileData = function() {
  return tutao.entity.tutanota.FileData.load(this._fileData);
};

"use strict";

tutao.provide('tutao.entity.tutanota.Contact');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.Contact = function(data) {
  if (data) {
    this.__area = data._area;
    this.__format = data._format;
    this.__id = data._id;
    this.__listEncSessionKey = data._listEncSessionKey;
    this.__owner = data._owner;
    this.__permissions = data._permissions;
    this._autoTransmitPassword = data.autoTransmitPassword;
    this._birthday = data.birthday;
    this._comment = data.comment;
    this._company = data.company;
    this._firstName = data.firstName;
    this._lastName = data.lastName;
    this._presharedPassword = data.presharedPassword;
    this._title = data.title;
    this._addresses = [];
    for (var i=0; i < data.addresses.length; i++) {
      this._addresses.push(new tutao.entity.tutanota.ContactAddress(this, data.addresses[i]));
    }
    this._mailAddresses = [];
    for (var i=0; i < data.mailAddresses.length; i++) {
      this._mailAddresses.push(new tutao.entity.tutanota.ContactMailAddress(this, data.mailAddresses[i]));
    }
    this._phoneNumbers = [];
    for (var i=0; i < data.phoneNumbers.length; i++) {
      this._phoneNumbers.push(new tutao.entity.tutanota.ContactPhoneNumber(this, data.phoneNumbers[i]));
    }
    this._socialIds = [];
    for (var i=0; i < data.socialIds.length; i++) {
      this._socialIds.push(new tutao.entity.tutanota.ContactSocialId(this, data.socialIds[i]));
    }
  } else {
    this.__area = null;
    this.__format = "0";
    this.__id = null;
    this.__listEncSessionKey = null;
    this.__owner = null;
    this.__permissions = null;
    this._autoTransmitPassword = null;
    this._birthday = null;
    this._comment = null;
    this._company = null;
    this._firstName = null;
    this._lastName = null;
    this._presharedPassword = null;
    this._title = null;
    this._addresses = [];
    this._mailAddresses = [];
    this._phoneNumbers = [];
    this._socialIds = [];
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.Contact.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.Contact.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.Contact.PATH = '/rest/tutanota/contact';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.tutanota.Contact.ROOT_INSTANCE_ID = 'CHR1dGFub3RhAEA';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.tutanota.Contact.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.Contact.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.Contact.prototype.toJsonData = function() {
  return {
    _area: this.__area, 
    _format: this.__format, 
    _id: this.__id, 
    _listEncSessionKey: this.__listEncSessionKey, 
    _owner: this.__owner, 
    _permissions: this.__permissions, 
    autoTransmitPassword: this._autoTransmitPassword, 
    birthday: this._birthday, 
    comment: this._comment, 
    company: this._company, 
    firstName: this._firstName, 
    lastName: this._lastName, 
    presharedPassword: this._presharedPassword, 
    title: this._title, 
    addresses: tutao.entity.EntityHelper.aggregatesToJsonData(this._addresses), 
    mailAddresses: tutao.entity.EntityHelper.aggregatesToJsonData(this._mailAddresses), 
    phoneNumbers: tutao.entity.EntityHelper.aggregatesToJsonData(this._phoneNumbers), 
    socialIds: tutao.entity.EntityHelper.aggregatesToJsonData(this._socialIds)
  };
};

/**
 * The id of the Contact type.
 */
tutao.entity.tutanota.Contact.prototype.TYPE_ID = 64;

/**
 * The id of the _area attribute.
 */
tutao.entity.tutanota.Contact.prototype._AREA_ATTRIBUTE_ID = 71;

/**
 * The id of the _owner attribute.
 */
tutao.entity.tutanota.Contact.prototype._OWNER_ATTRIBUTE_ID = 70;

/**
 * The id of the autoTransmitPassword attribute.
 */
tutao.entity.tutanota.Contact.prototype.AUTOTRANSMITPASSWORD_ATTRIBUTE_ID = 78;

/**
 * The id of the birthday attribute.
 */
tutao.entity.tutanota.Contact.prototype.BIRTHDAY_ATTRIBUTE_ID = 76;

/**
 * The id of the comment attribute.
 */
tutao.entity.tutanota.Contact.prototype.COMMENT_ATTRIBUTE_ID = 77;

/**
 * The id of the company attribute.
 */
tutao.entity.tutanota.Contact.prototype.COMPANY_ATTRIBUTE_ID = 74;

/**
 * The id of the firstName attribute.
 */
tutao.entity.tutanota.Contact.prototype.FIRSTNAME_ATTRIBUTE_ID = 72;

/**
 * The id of the lastName attribute.
 */
tutao.entity.tutanota.Contact.prototype.LASTNAME_ATTRIBUTE_ID = 73;

/**
 * The id of the presharedPassword attribute.
 */
tutao.entity.tutanota.Contact.prototype.PRESHAREDPASSWORD_ATTRIBUTE_ID = 79;

/**
 * The id of the title attribute.
 */
tutao.entity.tutanota.Contact.prototype.TITLE_ATTRIBUTE_ID = 75;

/**
 * The id of the addresses attribute.
 */
tutao.entity.tutanota.Contact.prototype.ADDRESSES_ATTRIBUTE_ID = 82;

/**
 * The id of the mailAddresses attribute.
 */
tutao.entity.tutanota.Contact.prototype.MAILADDRESSES_ATTRIBUTE_ID = 80;

/**
 * The id of the phoneNumbers attribute.
 */
tutao.entity.tutanota.Contact.prototype.PHONENUMBERS_ATTRIBUTE_ID = 81;

/**
 * The id of the socialIds attribute.
 */
tutao.entity.tutanota.Contact.prototype.SOCIALIDS_ATTRIBUTE_ID = 83;

/**
 * Provides the id of this Contact.
 * @return {Array.<string>} The id of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the area of this Contact.
 * @param {string} area The area of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.setArea = function(area) {
  this.__area = area;
  return this;
};

/**
 * Provides the area of this Contact.
 * @return {string} The area of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getArea = function() {
  return this.__area;
};

/**
 * Sets the format of this Contact.
 * @param {string} format The format of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this Contact.
 * @return {string} The format of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the listEncSessionKey of this Contact.
 * @param {string} listEncSessionKey The listEncSessionKey of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.setListEncSessionKey = function(listEncSessionKey) {
  this.__listEncSessionKey = listEncSessionKey;
  return this;
};

/**
 * Provides the listEncSessionKey of this Contact.
 * @return {string} The listEncSessionKey of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getListEncSessionKey = function() {
  return this.__listEncSessionKey;
};

/**
 * Sets the owner of this Contact.
 * @param {string} owner The owner of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.setOwner = function(owner) {
  this.__owner = owner;
  return this;
};

/**
 * Provides the owner of this Contact.
 * @return {string} The owner of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getOwner = function() {
  return this.__owner;
};

/**
 * Sets the permissions of this Contact.
 * @param {string} permissions The permissions of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this Contact.
 * @return {string} The permissions of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the autoTransmitPassword of this Contact.
 * @param {string} autoTransmitPassword The autoTransmitPassword of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.setAutoTransmitPassword = function(autoTransmitPassword) {
  var dataToEncrypt = autoTransmitPassword;
  this._autoTransmitPassword = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the autoTransmitPassword of this Contact.
 * @return {string} The autoTransmitPassword of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getAutoTransmitPassword = function() {
  if (this._autoTransmitPassword == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._autoTransmitPassword);
  return value;
};

/**
 * Sets the birthday of this Contact.
 * @param {Date} birthday The birthday of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.setBirthday = function(birthday) {
  if (birthday == null) {
    this._birthday = null;
  } else {
    var dataToEncrypt = String(birthday.getTime());
    this._birthday = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  }
  return this;
};

/**
 * Provides the birthday of this Contact.
 * @return {Date} The birthday of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getBirthday = function() {
  if (this._birthday == null) {
    return null;
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._birthday);
  if (isNaN(value)) {
    throw new tutao.InvalidDataError('invalid time data: ' + value);
  }
  return new Date(Number(value));
};

/**
 * Sets the comment of this Contact.
 * @param {string} comment The comment of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.setComment = function(comment) {
  var dataToEncrypt = comment;
  this._comment = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the comment of this Contact.
 * @return {string} The comment of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getComment = function() {
  if (this._comment == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._comment);
  return value;
};

/**
 * Sets the company of this Contact.
 * @param {string} company The company of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.setCompany = function(company) {
  var dataToEncrypt = company;
  this._company = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the company of this Contact.
 * @return {string} The company of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getCompany = function() {
  if (this._company == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._company);
  return value;
};

/**
 * Sets the firstName of this Contact.
 * @param {string} firstName The firstName of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.setFirstName = function(firstName) {
  var dataToEncrypt = firstName;
  this._firstName = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the firstName of this Contact.
 * @return {string} The firstName of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getFirstName = function() {
  if (this._firstName == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._firstName);
  return value;
};

/**
 * Sets the lastName of this Contact.
 * @param {string} lastName The lastName of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.setLastName = function(lastName) {
  var dataToEncrypt = lastName;
  this._lastName = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the lastName of this Contact.
 * @return {string} The lastName of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getLastName = function() {
  if (this._lastName == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._lastName);
  return value;
};

/**
 * Sets the presharedPassword of this Contact.
 * @param {string} presharedPassword The presharedPassword of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.setPresharedPassword = function(presharedPassword) {
  if (presharedPassword == null) {
    this._presharedPassword = null;
  } else {
    var dataToEncrypt = presharedPassword;
    this._presharedPassword = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  }
  return this;
};

/**
 * Provides the presharedPassword of this Contact.
 * @return {string} The presharedPassword of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getPresharedPassword = function() {
  if (this._presharedPassword == null) {
    return null;
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._presharedPassword);
  return value;
};

/**
 * Sets the title of this Contact.
 * @param {string} title The title of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.setTitle = function(title) {
  var dataToEncrypt = title;
  this._title = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the title of this Contact.
 * @return {string} The title of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getTitle = function() {
  if (this._title == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._title);
  return value;
};

/**
 * Provides the addresses of this Contact.
 * @return {Array.<tutao.entity.tutanota.ContactAddress>} The addresses of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getAddresses = function() {
  return this._addresses;
};

/**
 * Provides the mailAddresses of this Contact.
 * @return {Array.<tutao.entity.tutanota.ContactMailAddress>} The mailAddresses of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getMailAddresses = function() {
  return this._mailAddresses;
};

/**
 * Provides the phoneNumbers of this Contact.
 * @return {Array.<tutao.entity.tutanota.ContactPhoneNumber>} The phoneNumbers of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getPhoneNumbers = function() {
  return this._phoneNumbers;
};

/**
 * Provides the socialIds of this Contact.
 * @return {Array.<tutao.entity.tutanota.ContactSocialId>} The socialIds of this Contact.
 */
tutao.entity.tutanota.Contact.prototype.getSocialIds = function() {
  return this._socialIds;
};

/**
 * Loads a Contact from the server.
 * @param {Array.<string>} id The id of the Contact.
 * @return {Promise.<tutao.entity.tutanota.Contact>} Resolves to the Contact or an exception if the loading failed.
 */
tutao.entity.tutanota.Contact.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.tutanota.Contact, tutao.entity.tutanota.Contact.PATH, id[1], id[0], {"v" : 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity._entityHelper.loadSessionKey();
  });
};

/**
 * Loads a version of this Contact from the server.
 * @param {string} versionId The id of the requested version.
 * @return {Promise.<tutao.entity.tutanota.Contact>} Resolves to Contact or an exception if the loading failed.
 */
tutao.entity.tutanota.Contact.prototype.loadVersion = function(versionId) {
  var map = {};
  map["version"] = versionId;
  map["v"] = 5;
  return tutao.locator.entityRestClient.getElement(tutao.entity.tutanota.Contact, tutao.entity.tutanota.Contact.PATH, this.getId()[1], this.getId()[0], map, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Loads information about all versions of this Contact from the server.
 * @return {Promise.<tutao.entity.sys.VersionReturn>} Resolves to an tutao.entity.sys.VersionReturn or an exception if the loading failed.
 */
tutao.entity.tutanota.Contact.prototype.loadVersionInfo = function() {
  var versionData = new tutao.entity.sys.VersionData()
    .setApplication("tutanota")
    .setType(64)
    .setId(this.getId()[1]);
  versionData.setListId(this.getId()[0]);
  return tutao.entity.sys.VersionReturn.load(versionData, {}, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Loads multiple Contacts from the server.
 * @param {Array.<Array.<string>>} ids The ids of the Contacts to load.
 * @return {Promise.<Array.<tutao.entity.tutanota.Contact>>} Resolves to an array of Contact or rejects with an exception if the loading failed.
 */
tutao.entity.tutanota.Contact.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.tutanota.Contact, tutao.entity.tutanota.Contact.PATH, ids, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return tutao.entity.EntityHelper.loadSessionKeys(entities);
  });
};

/**
 * Stores Contact on the server and updates this instance with _id and _permission values generated on the server.
 * @param {string} listId The list id of the Contact.
 * @return {Promise.<>} Resolves when finished, rejected if the post failed.
 */
tutao.entity.tutanota.Contact.prototype.setup = function(listId) {
  var self = this;
  return this._entityHelper.createListEncSessionKey(listId).then(function(listEncSessionKey) {
    self.setListEncSessionKey(listEncSessionKey);
    self._entityHelper.notifyObservers(false);
    return tutao.locator.entityRestClient.postElement(tutao.entity.tutanota.Contact.PATH, self, listId, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
      self.__id = [listId, entity.getGeneratedId()];
      self.setPermissions(entity.getPermissionListId());
    });
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.tutanota.Contact.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 5;
  return tutao.locator.entityRestClient.putElement(tutao.entity.tutanota.Contact.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Updates this Contact on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.tutanota.Contact.prototype.update = function() {
  var self = this;
  return tutao.locator.entityRestClient.putElement(tutao.entity.tutanota.Contact.PATH, this, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function() {
    self._entityHelper.notifyObservers(false);
  });
};

/**
 * Deletes this Contact on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the delete failed.
 */
tutao.entity.tutanota.Contact.prototype.erase = function() {
  var self = this;
  return tutao.locator.entityRestClient.deleteElement(tutao.entity.tutanota.Contact.PATH, this.__id[1], this.__id[0], {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(data) {
    self._entityHelper.notifyObservers(true);
  });
};

/**
 * Creates a new Contact list on the server.
 * @param {tutao.entity.BucketData} bucketData The bucket data for which the share permission on the list shall be created.
 * @return {Promise.<string=>} Resolves to the id of the new tutao.entity.tutanota.Contact list or rejects with an exception if the createList failed.
 */
tutao.entity.tutanota.Contact.createList = function(bucketData) {
  var params = tutao.entity.EntityHelper.createPostListPermissionMap(bucketData, true);
  params["v"] = 5;
  return tutao.locator.entityRestClient.postList(tutao.entity.tutanota.Contact.PATH, params, tutao.entity.EntityHelper.createAuthHeaders()).then(function(returnEntity) {
    return returnEntity.getGeneratedId();
  });
};

/**
 * Provides a  list of Contacts loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.tutanota.Contact>>} Resolves to an array of Contact or rejects with an exception if the loading failed.
 */
tutao.entity.tutanota.Contact.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.tutanota.Contact, tutao.entity.tutanota.Contact.PATH, listId, start, count, reverse, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return tutao.entity.EntityHelper.loadSessionKeys(entities);
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.tutanota.Contact.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.tutanota.Contact.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.tutanota.ContactAddress');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.ContactAddress = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._address = data.address;
    this._customTypeName = data.customTypeName;
    this._type = data.type;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._address = null;
    this._customTypeName = null;
    this._type = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.ContactAddress.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.ContactAddress.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    address: this._address, 
    customTypeName: this._customTypeName, 
    type: this._type
  };
};

/**
 * The id of the ContactAddress type.
 */
tutao.entity.tutanota.ContactAddress.prototype.TYPE_ID = 54;

/**
 * The id of the address attribute.
 */
tutao.entity.tutanota.ContactAddress.prototype.ADDRESS_ATTRIBUTE_ID = 57;

/**
 * The id of the customTypeName attribute.
 */
tutao.entity.tutanota.ContactAddress.prototype.CUSTOMTYPENAME_ATTRIBUTE_ID = 58;

/**
 * The id of the type attribute.
 */
tutao.entity.tutanota.ContactAddress.prototype.TYPE_ATTRIBUTE_ID = 56;

/**
 * Sets the id of this ContactAddress.
 * @param {string} id The id of this ContactAddress.
 */
tutao.entity.tutanota.ContactAddress.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this ContactAddress.
 * @return {string} The id of this ContactAddress.
 */
tutao.entity.tutanota.ContactAddress.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the address of this ContactAddress.
 * @param {string} address The address of this ContactAddress.
 */
tutao.entity.tutanota.ContactAddress.prototype.setAddress = function(address) {
  var dataToEncrypt = address;
  this._address = tutao.locator.aesCrypter.encryptUtf8(this._parent._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the address of this ContactAddress.
 * @return {string} The address of this ContactAddress.
 */
tutao.entity.tutanota.ContactAddress.prototype.getAddress = function() {
  if (this._address == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._parent._entityHelper.getSessionKey(), this._address);
  return value;
};

/**
 * Sets the customTypeName of this ContactAddress.
 * @param {string} customTypeName The customTypeName of this ContactAddress.
 */
tutao.entity.tutanota.ContactAddress.prototype.setCustomTypeName = function(customTypeName) {
  var dataToEncrypt = customTypeName;
  this._customTypeName = tutao.locator.aesCrypter.encryptUtf8(this._parent._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the customTypeName of this ContactAddress.
 * @return {string} The customTypeName of this ContactAddress.
 */
tutao.entity.tutanota.ContactAddress.prototype.getCustomTypeName = function() {
  if (this._customTypeName == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._parent._entityHelper.getSessionKey(), this._customTypeName);
  return value;
};

/**
 * Sets the type of this ContactAddress.
 * @param {string} type The type of this ContactAddress.
 */
tutao.entity.tutanota.ContactAddress.prototype.setType = function(type) {
  var dataToEncrypt = type;
  this._type = tutao.locator.aesCrypter.encryptUtf8(this._parent._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the type of this ContactAddress.
 * @return {string} The type of this ContactAddress.
 */
tutao.entity.tutanota.ContactAddress.prototype.getType = function() {
  if (this._type == "") {
    return "0";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._parent._entityHelper.getSessionKey(), this._type);
  return value;
};

"use strict";

tutao.provide('tutao.entity.tutanota.ContactAddressEditable');

/**
 * Provides a knockout observable mechanism for a ContactAddress.
 * @param {tutao.entity.tutanota.ContactAddress} contactaddress The actual ContactAddress.
 * @constructor
 */
tutao.entity.tutanota.ContactAddressEditable = function(contactaddress) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	this._entity = contactaddress;
	this._id = ko.observable(contactaddress.getId());
	this.address = ko.observable(contactaddress.getAddress());
	this.customTypeName = ko.observable(contactaddress.getCustomTypeName());
	this.type = ko.observable(contactaddress.getType());

	this.lastUpdatedTimestamp = ko.observable(null);

	if (tutao.entity.tutanota.ContactAddressExtension) {
		tutao.entity.tutanota.ContactAddressExtension(this);
	}
};

/**
 * Provides the actual ContactAddress.
 * @return {tutao.entity.tutanota.ContactAddress} The ContactAddress.
 */
tutao.entity.tutanota.ContactAddressEditable.prototype.getContactAddress = function() {
	return this._entity;
};

/**
 * Updates the underlying ContactAddress with the modified attributes.
 */
tutao.entity.tutanota.ContactAddressEditable.prototype.update = function() {
	this._entity.setId(this._id());
	this._entity.setAddress(this.address());
	this._entity.setCustomTypeName(this.customTypeName());
	this._entity.setType(this.type());
	this.lastUpdatedTimestamp(new Date().getTime());
};

"use strict";

tutao.provide('tutao.entity.tutanota.ContactEditable');

/**
 * Provides a knockout observable mechanism for a Contact.
 * @param {tutao.entity.tutanota.Contact} contact The actual Contact.
 * @constructor
 */
tutao.entity.tutanota.ContactEditable = function(contact) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	this._entity = contact;
	this._area = ko.observable(contact.getArea());
	this._owner = ko.observable(contact.getOwner());
	this.autoTransmitPassword = ko.observable(contact.getAutoTransmitPassword());
	this.birthday = ko.observable(contact.getBirthday());
	this.comment = ko.observable(contact.getComment());
	this.company = ko.observable(contact.getCompany());
	this.firstName = ko.observable(contact.getFirstName());
	this.lastName = ko.observable(contact.getLastName());
	this.presharedPassword = ko.observable(contact.getPresharedPassword());
	this.title = ko.observable(contact.getTitle());
	this.addresses = ko.observableArray();
	for (var i = 0; i < contact.getAddresses().length; i++) {
		this.addresses.push(new tutao.entity.tutanota.ContactAddressEditable(contact.getAddresses()[i]));
	}
	this.mailAddresses = ko.observableArray();
	for (var i = 0; i < contact.getMailAddresses().length; i++) {
		this.mailAddresses.push(new tutao.entity.tutanota.ContactMailAddressEditable(contact.getMailAddresses()[i]));
	}
	this.phoneNumbers = ko.observableArray();
	for (var i = 0; i < contact.getPhoneNumbers().length; i++) {
		this.phoneNumbers.push(new tutao.entity.tutanota.ContactPhoneNumberEditable(contact.getPhoneNumbers()[i]));
	}
	this.socialIds = ko.observableArray();
	for (var i = 0; i < contact.getSocialIds().length; i++) {
		this.socialIds.push(new tutao.entity.tutanota.ContactSocialIdEditable(contact.getSocialIds()[i]));
	}

	this.lastUpdatedTimestamp = ko.observable(null);

	if (tutao.entity.tutanota.ContactExtension) {
		tutao.entity.tutanota.ContactExtension(this);
	}
};

/**
 * Provides the actual Contact.
 * @return {tutao.entity.tutanota.Contact} The Contact.
 */
tutao.entity.tutanota.ContactEditable.prototype.getContact = function() {
	return this._entity;
};

/**
 * Updates the underlying Contact with the modified attributes.
 */
tutao.entity.tutanota.ContactEditable.prototype.update = function() {
	this._entity.setArea(this._area());
	this._entity.setOwner(this._owner());
	this._entity.setAutoTransmitPassword(this.autoTransmitPassword());
	this._entity.setBirthday(this.birthday());
	this._entity.setComment(this.comment());
	this._entity.setCompany(this.company());
	this._entity.setFirstName(this.firstName());
	this._entity.setLastName(this.lastName());
	this._entity.setPresharedPassword(this.presharedPassword());
	this._entity.setTitle(this.title());
	this._entity.getAddresses().length = 0;
	for (var i = 0; i < this.addresses().length; i++) {
		this.addresses()[i].update();
		this._entity.getAddresses().push(this.addresses()[i].getContactAddress());
	}
	this._entity.getMailAddresses().length = 0;
	for (var i = 0; i < this.mailAddresses().length; i++) {
		this.mailAddresses()[i].update();
		this._entity.getMailAddresses().push(this.mailAddresses()[i].getContactMailAddress());
	}
	this._entity.getPhoneNumbers().length = 0;
	for (var i = 0; i < this.phoneNumbers().length; i++) {
		this.phoneNumbers()[i].update();
		this._entity.getPhoneNumbers().push(this.phoneNumbers()[i].getContactPhoneNumber());
	}
	this._entity.getSocialIds().length = 0;
	for (var i = 0; i < this.socialIds().length; i++) {
		this.socialIds()[i].update();
		this._entity.getSocialIds().push(this.socialIds()[i].getContactSocialId());
	}
	this.lastUpdatedTimestamp(new Date().getTime());
};

"use strict";

tutao.provide('tutao.entity.tutanota.ContactList');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.ContactList = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._shareBucketId = data.shareBucketId;
    this._symEncShareBucketKey = data.symEncShareBucketKey;
    this._contacts = data.contacts;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._shareBucketId = null;
    this._symEncShareBucketKey = null;
    this._contacts = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.ContactList.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.ContactList.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.ContactList.PATH = '/rest/tutanota/contactlist';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.tutanota.ContactList.ROOT_INSTANCE_ID = 'CHR1dGFub3RhAACZ';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.tutanota.ContactList.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.ContactList.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.ContactList.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    shareBucketId: this._shareBucketId, 
    symEncShareBucketKey: this._symEncShareBucketKey, 
    contacts: this._contacts
  };
};

/**
 * The id of the ContactList type.
 */
tutao.entity.tutanota.ContactList.prototype.TYPE_ID = 153;

/**
 * The id of the shareBucketId attribute.
 */
tutao.entity.tutanota.ContactList.prototype.SHAREBUCKETID_ATTRIBUTE_ID = 158;

/**
 * The id of the symEncShareBucketKey attribute.
 */
tutao.entity.tutanota.ContactList.prototype.SYMENCSHAREBUCKETKEY_ATTRIBUTE_ID = 159;

/**
 * The id of the contacts attribute.
 */
tutao.entity.tutanota.ContactList.prototype.CONTACTS_ATTRIBUTE_ID = 160;

/**
 * Provides the id of this ContactList.
 * @return {string} The id of this ContactList.
 */
tutao.entity.tutanota.ContactList.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this ContactList.
 * @param {string} format The format of this ContactList.
 */
tutao.entity.tutanota.ContactList.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this ContactList.
 * @return {string} The format of this ContactList.
 */
tutao.entity.tutanota.ContactList.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this ContactList.
 * @param {string} permissions The permissions of this ContactList.
 */
tutao.entity.tutanota.ContactList.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this ContactList.
 * @return {string} The permissions of this ContactList.
 */
tutao.entity.tutanota.ContactList.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the shareBucketId of this ContactList.
 * @param {string} shareBucketId The shareBucketId of this ContactList.
 */
tutao.entity.tutanota.ContactList.prototype.setShareBucketId = function(shareBucketId) {
  this._shareBucketId = shareBucketId;
  return this;
};

/**
 * Provides the shareBucketId of this ContactList.
 * @return {string} The shareBucketId of this ContactList.
 */
tutao.entity.tutanota.ContactList.prototype.getShareBucketId = function() {
  return this._shareBucketId;
};

/**
 * Sets the symEncShareBucketKey of this ContactList.
 * @param {string} symEncShareBucketKey The symEncShareBucketKey of this ContactList.
 */
tutao.entity.tutanota.ContactList.prototype.setSymEncShareBucketKey = function(symEncShareBucketKey) {
  this._symEncShareBucketKey = symEncShareBucketKey;
  return this;
};

/**
 * Provides the symEncShareBucketKey of this ContactList.
 * @return {string} The symEncShareBucketKey of this ContactList.
 */
tutao.entity.tutanota.ContactList.prototype.getSymEncShareBucketKey = function() {
  return this._symEncShareBucketKey;
};

/**
 * Sets the contacts of this ContactList.
 * @param {string} contacts The contacts of this ContactList.
 */
tutao.entity.tutanota.ContactList.prototype.setContacts = function(contacts) {
  this._contacts = contacts;
  return this;
};

/**
 * Provides the contacts of this ContactList.
 * @return {string} The contacts of this ContactList.
 */
tutao.entity.tutanota.ContactList.prototype.getContacts = function() {
  return this._contacts;
};

/**
 * Loads a ContactList from the server.
 * @param {string} id The id of the ContactList.
 * @return {Promise.<tutao.entity.tutanota.ContactList>} Resolves to the ContactList or an exception if the loading failed.
 */
tutao.entity.tutanota.ContactList.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.tutanota.ContactList, tutao.entity.tutanota.ContactList.PATH, id, null, {"v" : 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity._entityHelper.loadSessionKey();
  });
};

/**
 * Loads multiple ContactLists from the server.
 * @param {Array.<string>} ids The ids of the ContactLists to load.
 * @return {Promise.<Array.<tutao.entity.tutanota.ContactList>>} Resolves to an array of ContactList or rejects with an exception if the loading failed.
 */
tutao.entity.tutanota.ContactList.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.tutanota.ContactList, tutao.entity.tutanota.ContactList.PATH, ids, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return tutao.entity.EntityHelper.loadSessionKeys(entities);
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.tutanota.ContactList.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.tutanota.ContactList.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.tutanota.ContactMailAddress');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.ContactMailAddress = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._address = data.address;
    this._customTypeName = data.customTypeName;
    this._type = data.type;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._address = null;
    this._customTypeName = null;
    this._type = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.ContactMailAddress.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.ContactMailAddress.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    address: this._address, 
    customTypeName: this._customTypeName, 
    type: this._type
  };
};

/**
 * The id of the ContactMailAddress type.
 */
tutao.entity.tutanota.ContactMailAddress.prototype.TYPE_ID = 44;

/**
 * The id of the address attribute.
 */
tutao.entity.tutanota.ContactMailAddress.prototype.ADDRESS_ATTRIBUTE_ID = 47;

/**
 * The id of the customTypeName attribute.
 */
tutao.entity.tutanota.ContactMailAddress.prototype.CUSTOMTYPENAME_ATTRIBUTE_ID = 48;

/**
 * The id of the type attribute.
 */
tutao.entity.tutanota.ContactMailAddress.prototype.TYPE_ATTRIBUTE_ID = 46;

/**
 * Sets the id of this ContactMailAddress.
 * @param {string} id The id of this ContactMailAddress.
 */
tutao.entity.tutanota.ContactMailAddress.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this ContactMailAddress.
 * @return {string} The id of this ContactMailAddress.
 */
tutao.entity.tutanota.ContactMailAddress.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the address of this ContactMailAddress.
 * @param {string} address The address of this ContactMailAddress.
 */
tutao.entity.tutanota.ContactMailAddress.prototype.setAddress = function(address) {
  var dataToEncrypt = address;
  this._address = tutao.locator.aesCrypter.encryptUtf8(this._parent._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the address of this ContactMailAddress.
 * @return {string} The address of this ContactMailAddress.
 */
tutao.entity.tutanota.ContactMailAddress.prototype.getAddress = function() {
  if (this._address == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._parent._entityHelper.getSessionKey(), this._address);
  return value;
};

/**
 * Sets the customTypeName of this ContactMailAddress.
 * @param {string} customTypeName The customTypeName of this ContactMailAddress.
 */
tutao.entity.tutanota.ContactMailAddress.prototype.setCustomTypeName = function(customTypeName) {
  var dataToEncrypt = customTypeName;
  this._customTypeName = tutao.locator.aesCrypter.encryptUtf8(this._parent._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the customTypeName of this ContactMailAddress.
 * @return {string} The customTypeName of this ContactMailAddress.
 */
tutao.entity.tutanota.ContactMailAddress.prototype.getCustomTypeName = function() {
  if (this._customTypeName == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._parent._entityHelper.getSessionKey(), this._customTypeName);
  return value;
};

/**
 * Sets the type of this ContactMailAddress.
 * @param {string} type The type of this ContactMailAddress.
 */
tutao.entity.tutanota.ContactMailAddress.prototype.setType = function(type) {
  var dataToEncrypt = type;
  this._type = tutao.locator.aesCrypter.encryptUtf8(this._parent._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the type of this ContactMailAddress.
 * @return {string} The type of this ContactMailAddress.
 */
tutao.entity.tutanota.ContactMailAddress.prototype.getType = function() {
  if (this._type == "") {
    return "0";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._parent._entityHelper.getSessionKey(), this._type);
  return value;
};

"use strict";

tutao.provide('tutao.entity.tutanota.ContactMailAddressEditable');

/**
 * Provides a knockout observable mechanism for a ContactMailAddress.
 * @param {tutao.entity.tutanota.ContactMailAddress} contactmailaddress The actual ContactMailAddress.
 * @constructor
 */
tutao.entity.tutanota.ContactMailAddressEditable = function(contactmailaddress) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	this._entity = contactmailaddress;
	this._id = ko.observable(contactmailaddress.getId());
	this.address = ko.observable(contactmailaddress.getAddress());
	this.customTypeName = ko.observable(contactmailaddress.getCustomTypeName());
	this.type = ko.observable(contactmailaddress.getType());

	this.lastUpdatedTimestamp = ko.observable(null);

	if (tutao.entity.tutanota.ContactMailAddressExtension) {
		tutao.entity.tutanota.ContactMailAddressExtension(this);
	}
};

/**
 * Provides the actual ContactMailAddress.
 * @return {tutao.entity.tutanota.ContactMailAddress} The ContactMailAddress.
 */
tutao.entity.tutanota.ContactMailAddressEditable.prototype.getContactMailAddress = function() {
	return this._entity;
};

/**
 * Updates the underlying ContactMailAddress with the modified attributes.
 */
tutao.entity.tutanota.ContactMailAddressEditable.prototype.update = function() {
	this._entity.setId(this._id());
	this._entity.setAddress(this.address());
	this._entity.setCustomTypeName(this.customTypeName());
	this._entity.setType(this.type());
	this.lastUpdatedTimestamp(new Date().getTime());
};

"use strict";

tutao.provide('tutao.entity.tutanota.ContactPhoneNumber');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.ContactPhoneNumber = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._customTypeName = data.customTypeName;
    this._number = data.number;
    this._type = data.type;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._customTypeName = null;
    this._number = null;
    this._type = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.ContactPhoneNumber.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.ContactPhoneNumber.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    customTypeName: this._customTypeName, 
    number: this._number, 
    type: this._type
  };
};

/**
 * The id of the ContactPhoneNumber type.
 */
tutao.entity.tutanota.ContactPhoneNumber.prototype.TYPE_ID = 49;

/**
 * The id of the customTypeName attribute.
 */
tutao.entity.tutanota.ContactPhoneNumber.prototype.CUSTOMTYPENAME_ATTRIBUTE_ID = 53;

/**
 * The id of the number attribute.
 */
tutao.entity.tutanota.ContactPhoneNumber.prototype.NUMBER_ATTRIBUTE_ID = 52;

/**
 * The id of the type attribute.
 */
tutao.entity.tutanota.ContactPhoneNumber.prototype.TYPE_ATTRIBUTE_ID = 51;

/**
 * Sets the id of this ContactPhoneNumber.
 * @param {string} id The id of this ContactPhoneNumber.
 */
tutao.entity.tutanota.ContactPhoneNumber.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this ContactPhoneNumber.
 * @return {string} The id of this ContactPhoneNumber.
 */
tutao.entity.tutanota.ContactPhoneNumber.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the customTypeName of this ContactPhoneNumber.
 * @param {string} customTypeName The customTypeName of this ContactPhoneNumber.
 */
tutao.entity.tutanota.ContactPhoneNumber.prototype.setCustomTypeName = function(customTypeName) {
  var dataToEncrypt = customTypeName;
  this._customTypeName = tutao.locator.aesCrypter.encryptUtf8(this._parent._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the customTypeName of this ContactPhoneNumber.
 * @return {string} The customTypeName of this ContactPhoneNumber.
 */
tutao.entity.tutanota.ContactPhoneNumber.prototype.getCustomTypeName = function() {
  if (this._customTypeName == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._parent._entityHelper.getSessionKey(), this._customTypeName);
  return value;
};

/**
 * Sets the number of this ContactPhoneNumber.
 * @param {string} number The number of this ContactPhoneNumber.
 */
tutao.entity.tutanota.ContactPhoneNumber.prototype.setNumber = function(number) {
  var dataToEncrypt = number;
  this._number = tutao.locator.aesCrypter.encryptUtf8(this._parent._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the number of this ContactPhoneNumber.
 * @return {string} The number of this ContactPhoneNumber.
 */
tutao.entity.tutanota.ContactPhoneNumber.prototype.getNumber = function() {
  if (this._number == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._parent._entityHelper.getSessionKey(), this._number);
  return value;
};

/**
 * Sets the type of this ContactPhoneNumber.
 * @param {string} type The type of this ContactPhoneNumber.
 */
tutao.entity.tutanota.ContactPhoneNumber.prototype.setType = function(type) {
  var dataToEncrypt = type;
  this._type = tutao.locator.aesCrypter.encryptUtf8(this._parent._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the type of this ContactPhoneNumber.
 * @return {string} The type of this ContactPhoneNumber.
 */
tutao.entity.tutanota.ContactPhoneNumber.prototype.getType = function() {
  if (this._type == "") {
    return "0";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._parent._entityHelper.getSessionKey(), this._type);
  return value;
};

"use strict";

tutao.provide('tutao.entity.tutanota.ContactPhoneNumberEditable');

/**
 * Provides a knockout observable mechanism for a ContactPhoneNumber.
 * @param {tutao.entity.tutanota.ContactPhoneNumber} contactphonenumber The actual ContactPhoneNumber.
 * @constructor
 */
tutao.entity.tutanota.ContactPhoneNumberEditable = function(contactphonenumber) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	this._entity = contactphonenumber;
	this._id = ko.observable(contactphonenumber.getId());
	this.customTypeName = ko.observable(contactphonenumber.getCustomTypeName());
	this.number = ko.observable(contactphonenumber.getNumber());
	this.type = ko.observable(contactphonenumber.getType());

	this.lastUpdatedTimestamp = ko.observable(null);

	if (tutao.entity.tutanota.ContactPhoneNumberExtension) {
		tutao.entity.tutanota.ContactPhoneNumberExtension(this);
	}
};

/**
 * Provides the actual ContactPhoneNumber.
 * @return {tutao.entity.tutanota.ContactPhoneNumber} The ContactPhoneNumber.
 */
tutao.entity.tutanota.ContactPhoneNumberEditable.prototype.getContactPhoneNumber = function() {
	return this._entity;
};

/**
 * Updates the underlying ContactPhoneNumber with the modified attributes.
 */
tutao.entity.tutanota.ContactPhoneNumberEditable.prototype.update = function() {
	this._entity.setId(this._id());
	this._entity.setCustomTypeName(this.customTypeName());
	this._entity.setNumber(this.number());
	this._entity.setType(this.type());
	this.lastUpdatedTimestamp(new Date().getTime());
};

"use strict";

tutao.provide('tutao.entity.tutanota.ContactSocialId');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.ContactSocialId = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._customTypeName = data.customTypeName;
    this._socialId = data.socialId;
    this._type = data.type;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._customTypeName = null;
    this._socialId = null;
    this._type = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.ContactSocialId.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.ContactSocialId.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    customTypeName: this._customTypeName, 
    socialId: this._socialId, 
    type: this._type
  };
};

/**
 * The id of the ContactSocialId type.
 */
tutao.entity.tutanota.ContactSocialId.prototype.TYPE_ID = 59;

/**
 * The id of the customTypeName attribute.
 */
tutao.entity.tutanota.ContactSocialId.prototype.CUSTOMTYPENAME_ATTRIBUTE_ID = 63;

/**
 * The id of the socialId attribute.
 */
tutao.entity.tutanota.ContactSocialId.prototype.SOCIALID_ATTRIBUTE_ID = 62;

/**
 * The id of the type attribute.
 */
tutao.entity.tutanota.ContactSocialId.prototype.TYPE_ATTRIBUTE_ID = 61;

/**
 * Sets the id of this ContactSocialId.
 * @param {string} id The id of this ContactSocialId.
 */
tutao.entity.tutanota.ContactSocialId.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this ContactSocialId.
 * @return {string} The id of this ContactSocialId.
 */
tutao.entity.tutanota.ContactSocialId.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the customTypeName of this ContactSocialId.
 * @param {string} customTypeName The customTypeName of this ContactSocialId.
 */
tutao.entity.tutanota.ContactSocialId.prototype.setCustomTypeName = function(customTypeName) {
  var dataToEncrypt = customTypeName;
  this._customTypeName = tutao.locator.aesCrypter.encryptUtf8(this._parent._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the customTypeName of this ContactSocialId.
 * @return {string} The customTypeName of this ContactSocialId.
 */
tutao.entity.tutanota.ContactSocialId.prototype.getCustomTypeName = function() {
  if (this._customTypeName == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._parent._entityHelper.getSessionKey(), this._customTypeName);
  return value;
};

/**
 * Sets the socialId of this ContactSocialId.
 * @param {string} socialId The socialId of this ContactSocialId.
 */
tutao.entity.tutanota.ContactSocialId.prototype.setSocialId = function(socialId) {
  var dataToEncrypt = socialId;
  this._socialId = tutao.locator.aesCrypter.encryptUtf8(this._parent._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the socialId of this ContactSocialId.
 * @return {string} The socialId of this ContactSocialId.
 */
tutao.entity.tutanota.ContactSocialId.prototype.getSocialId = function() {
  if (this._socialId == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._parent._entityHelper.getSessionKey(), this._socialId);
  return value;
};

/**
 * Sets the type of this ContactSocialId.
 * @param {string} type The type of this ContactSocialId.
 */
tutao.entity.tutanota.ContactSocialId.prototype.setType = function(type) {
  var dataToEncrypt = type;
  this._type = tutao.locator.aesCrypter.encryptUtf8(this._parent._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the type of this ContactSocialId.
 * @return {string} The type of this ContactSocialId.
 */
tutao.entity.tutanota.ContactSocialId.prototype.getType = function() {
  if (this._type == "") {
    return "0";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._parent._entityHelper.getSessionKey(), this._type);
  return value;
};

"use strict";

tutao.provide('tutao.entity.tutanota.ContactSocialIdEditable');

/**
 * Provides a knockout observable mechanism for a ContactSocialId.
 * @param {tutao.entity.tutanota.ContactSocialId} contactsocialid The actual ContactSocialId.
 * @constructor
 */
tutao.entity.tutanota.ContactSocialIdEditable = function(contactsocialid) {
	tutao.util.FunctionUtils.bindPrototypeMethodsToThis(this);
	this._entity = contactsocialid;
	this._id = ko.observable(contactsocialid.getId());
	this.customTypeName = ko.observable(contactsocialid.getCustomTypeName());
	this.socialId = ko.observable(contactsocialid.getSocialId());
	this.type = ko.observable(contactsocialid.getType());

	this.lastUpdatedTimestamp = ko.observable(null);

	if (tutao.entity.tutanota.ContactSocialIdExtension) {
		tutao.entity.tutanota.ContactSocialIdExtension(this);
	}
};

/**
 * Provides the actual ContactSocialId.
 * @return {tutao.entity.tutanota.ContactSocialId} The ContactSocialId.
 */
tutao.entity.tutanota.ContactSocialIdEditable.prototype.getContactSocialId = function() {
	return this._entity;
};

/**
 * Updates the underlying ContactSocialId with the modified attributes.
 */
tutao.entity.tutanota.ContactSocialIdEditable.prototype.update = function() {
	this._entity.setId(this._id());
	this._entity.setCustomTypeName(this.customTypeName());
	this._entity.setSocialId(this.socialId());
	this._entity.setType(this.type());
	this.lastUpdatedTimestamp(new Date().getTime());
};

"use strict";

tutao.provide('tutao.entity.tutanota.ConversationEntry');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.ConversationEntry = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._conversationType = data.conversationType;
    this._messageId = data.messageId;
    this._mail = data.mail;
    this._previous = data.previous;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._conversationType = null;
    this._messageId = null;
    this._mail = null;
    this._previous = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.ConversationEntry.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.ConversationEntry.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.ConversationEntry.PATH = '/rest/tutanota/conversationentry';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.tutanota.ConversationEntry.ROOT_INSTANCE_ID = 'CHR1dGFub3RhAFQ';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.tutanota.ConversationEntry.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.ConversationEntry.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.ConversationEntry.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    conversationType: this._conversationType, 
    messageId: this._messageId, 
    mail: this._mail, 
    previous: this._previous
  };
};

/**
 * The id of the ConversationEntry type.
 */
tutao.entity.tutanota.ConversationEntry.prototype.TYPE_ID = 84;

/**
 * The id of the conversationType attribute.
 */
tutao.entity.tutanota.ConversationEntry.prototype.CONVERSATIONTYPE_ATTRIBUTE_ID = 122;

/**
 * The id of the messageId attribute.
 */
tutao.entity.tutanota.ConversationEntry.prototype.MESSAGEID_ATTRIBUTE_ID = 121;

/**
 * The id of the mail attribute.
 */
tutao.entity.tutanota.ConversationEntry.prototype.MAIL_ATTRIBUTE_ID = 124;

/**
 * The id of the previous attribute.
 */
tutao.entity.tutanota.ConversationEntry.prototype.PREVIOUS_ATTRIBUTE_ID = 123;

/**
 * Provides the id of this ConversationEntry.
 * @return {Array.<string>} The id of this ConversationEntry.
 */
tutao.entity.tutanota.ConversationEntry.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this ConversationEntry.
 * @param {string} format The format of this ConversationEntry.
 */
tutao.entity.tutanota.ConversationEntry.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this ConversationEntry.
 * @return {string} The format of this ConversationEntry.
 */
tutao.entity.tutanota.ConversationEntry.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this ConversationEntry.
 * @param {string} permissions The permissions of this ConversationEntry.
 */
tutao.entity.tutanota.ConversationEntry.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this ConversationEntry.
 * @return {string} The permissions of this ConversationEntry.
 */
tutao.entity.tutanota.ConversationEntry.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the conversationType of this ConversationEntry.
 * @param {string} conversationType The conversationType of this ConversationEntry.
 */
tutao.entity.tutanota.ConversationEntry.prototype.setConversationType = function(conversationType) {
  this._conversationType = conversationType;
  return this;
};

/**
 * Provides the conversationType of this ConversationEntry.
 * @return {string} The conversationType of this ConversationEntry.
 */
tutao.entity.tutanota.ConversationEntry.prototype.getConversationType = function() {
  return this._conversationType;
};

/**
 * Sets the messageId of this ConversationEntry.
 * @param {string} messageId The messageId of this ConversationEntry.
 */
tutao.entity.tutanota.ConversationEntry.prototype.setMessageId = function(messageId) {
  this._messageId = messageId;
  return this;
};

/**
 * Provides the messageId of this ConversationEntry.
 * @return {string} The messageId of this ConversationEntry.
 */
tutao.entity.tutanota.ConversationEntry.prototype.getMessageId = function() {
  return this._messageId;
};

/**
 * Sets the mail of this ConversationEntry.
 * @param {Array.<string>} mail The mail of this ConversationEntry.
 */
tutao.entity.tutanota.ConversationEntry.prototype.setMail = function(mail) {
  this._mail = mail;
  return this;
};

/**
 * Provides the mail of this ConversationEntry.
 * @return {Array.<string>} The mail of this ConversationEntry.
 */
tutao.entity.tutanota.ConversationEntry.prototype.getMail = function() {
  return this._mail;
};

/**
 * Loads the mail of this ConversationEntry.
 * @return {Promise.<tutao.entity.tutanota.Mail>} Resolves to the loaded mail of this ConversationEntry or an exception if the loading failed.
 */
tutao.entity.tutanota.ConversationEntry.prototype.loadMail = function() {
  return tutao.entity.tutanota.Mail.load(this._mail);
};

/**
 * Sets the previous of this ConversationEntry.
 * @param {Array.<string>} previous The previous of this ConversationEntry.
 */
tutao.entity.tutanota.ConversationEntry.prototype.setPrevious = function(previous) {
  this._previous = previous;
  return this;
};

/**
 * Provides the previous of this ConversationEntry.
 * @return {Array.<string>} The previous of this ConversationEntry.
 */
tutao.entity.tutanota.ConversationEntry.prototype.getPrevious = function() {
  return this._previous;
};

/**
 * Loads the previous of this ConversationEntry.
 * @return {Promise.<tutao.entity.tutanota.ConversationEntry>} Resolves to the loaded previous of this ConversationEntry or an exception if the loading failed.
 */
tutao.entity.tutanota.ConversationEntry.prototype.loadPrevious = function() {
  return tutao.entity.tutanota.ConversationEntry.load(this._previous);
};

/**
 * Loads a ConversationEntry from the server.
 * @param {Array.<string>} id The id of the ConversationEntry.
 * @return {Promise.<tutao.entity.tutanota.ConversationEntry>} Resolves to the ConversationEntry or an exception if the loading failed.
 */
tutao.entity.tutanota.ConversationEntry.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.tutanota.ConversationEntry, tutao.entity.tutanota.ConversationEntry.PATH, id[1], id[0], {"v" : 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple ConversationEntrys from the server.
 * @param {Array.<Array.<string>>} ids The ids of the ConversationEntrys to load.
 * @return {Promise.<Array.<tutao.entity.tutanota.ConversationEntry>>} Resolves to an array of ConversationEntry or rejects with an exception if the loading failed.
 */
tutao.entity.tutanota.ConversationEntry.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.tutanota.ConversationEntry, tutao.entity.tutanota.ConversationEntry.PATH, ids, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.tutanota.ConversationEntry.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 5;
  return tutao.locator.entityRestClient.putElement(tutao.entity.tutanota.ConversationEntry.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Provides a  list of ConversationEntrys loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.tutanota.ConversationEntry>>} Resolves to an array of ConversationEntry or rejects with an exception if the loading failed.
 */
tutao.entity.tutanota.ConversationEntry.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.tutanota.ConversationEntry, tutao.entity.tutanota.ConversationEntry.PATH, listId, start, count, reverse, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.tutanota.ConversationEntry.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.tutanota.ConversationEntry.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.tutanota.CreateExternalUserGroupData');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.CreateExternalUserGroupData = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._adminEncGKey = data.adminEncGKey;
    this._encryptedName = data.encryptedName;
    this._groupInfoListEncSessionKey = data.groupInfoListEncSessionKey;
    this._mailAddress = data.mailAddress;
    this._symEncGKey = data.symEncGKey;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._adminEncGKey = null;
    this._encryptedName = null;
    this._groupInfoListEncSessionKey = null;
    this._mailAddress = null;
    this._symEncGKey = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.CreateExternalUserGroupData.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    adminEncGKey: this._adminEncGKey, 
    encryptedName: this._encryptedName, 
    groupInfoListEncSessionKey: this._groupInfoListEncSessionKey, 
    mailAddress: this._mailAddress, 
    symEncGKey: this._symEncGKey
  };
};

/**
 * The id of the CreateExternalUserGroupData type.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.TYPE_ID = 138;

/**
 * The id of the adminEncGKey attribute.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.ADMINENCGKEY_ATTRIBUTE_ID = 143;

/**
 * The id of the encryptedName attribute.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.ENCRYPTEDNAME_ATTRIBUTE_ID = 140;

/**
 * The id of the groupInfoListEncSessionKey attribute.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.GROUPINFOLISTENCSESSIONKEY_ATTRIBUTE_ID = 144;

/**
 * The id of the mailAddress attribute.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.MAILADDRESS_ATTRIBUTE_ID = 141;

/**
 * The id of the symEncGKey attribute.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.SYMENCGKEY_ATTRIBUTE_ID = 142;

/**
 * Sets the id of this CreateExternalUserGroupData.
 * @param {string} id The id of this CreateExternalUserGroupData.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this CreateExternalUserGroupData.
 * @return {string} The id of this CreateExternalUserGroupData.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the adminEncGKey of this CreateExternalUserGroupData.
 * @param {string} adminEncGKey The adminEncGKey of this CreateExternalUserGroupData.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.setAdminEncGKey = function(adminEncGKey) {
  this._adminEncGKey = adminEncGKey;
  return this;
};

/**
 * Provides the adminEncGKey of this CreateExternalUserGroupData.
 * @return {string} The adminEncGKey of this CreateExternalUserGroupData.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.getAdminEncGKey = function() {
  return this._adminEncGKey;
};

/**
 * Sets the encryptedName of this CreateExternalUserGroupData.
 * @param {string} encryptedName The encryptedName of this CreateExternalUserGroupData.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.setEncryptedName = function(encryptedName) {
  this._encryptedName = encryptedName;
  return this;
};

/**
 * Provides the encryptedName of this CreateExternalUserGroupData.
 * @return {string} The encryptedName of this CreateExternalUserGroupData.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.getEncryptedName = function() {
  return this._encryptedName;
};

/**
 * Sets the groupInfoListEncSessionKey of this CreateExternalUserGroupData.
 * @param {string} groupInfoListEncSessionKey The groupInfoListEncSessionKey of this CreateExternalUserGroupData.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.setGroupInfoListEncSessionKey = function(groupInfoListEncSessionKey) {
  this._groupInfoListEncSessionKey = groupInfoListEncSessionKey;
  return this;
};

/**
 * Provides the groupInfoListEncSessionKey of this CreateExternalUserGroupData.
 * @return {string} The groupInfoListEncSessionKey of this CreateExternalUserGroupData.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.getGroupInfoListEncSessionKey = function() {
  return this._groupInfoListEncSessionKey;
};

/**
 * Sets the mailAddress of this CreateExternalUserGroupData.
 * @param {string} mailAddress The mailAddress of this CreateExternalUserGroupData.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.setMailAddress = function(mailAddress) {
  this._mailAddress = mailAddress;
  return this;
};

/**
 * Provides the mailAddress of this CreateExternalUserGroupData.
 * @return {string} The mailAddress of this CreateExternalUserGroupData.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.getMailAddress = function() {
  return this._mailAddress;
};

/**
 * Sets the symEncGKey of this CreateExternalUserGroupData.
 * @param {string} symEncGKey The symEncGKey of this CreateExternalUserGroupData.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.setSymEncGKey = function(symEncGKey) {
  this._symEncGKey = symEncGKey;
  return this;
};

/**
 * Provides the symEncGKey of this CreateExternalUserGroupData.
 * @return {string} The symEncGKey of this CreateExternalUserGroupData.
 */
tutao.entity.tutanota.CreateExternalUserGroupData.prototype.getSymEncGKey = function() {
  return this._symEncGKey;
};

"use strict";

tutao.provide('tutao.entity.tutanota.CreateFileData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.CreateFileData = function(data) {
  if (data) {
    this.__format = data._format;
    this._fileName = data.fileName;
    this._group = data.group;
    this._listEncSessionKey = data.listEncSessionKey;
    this._mimeType = data.mimeType;
    this._fileData = data.fileData;
    this._parentFolder = data.parentFolder;
  } else {
    this.__format = "0";
    this._fileName = null;
    this._group = null;
    this._listEncSessionKey = null;
    this._mimeType = null;
    this._fileData = null;
    this._parentFolder = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.CreateFileData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.CreateFileData.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.CreateFileData.PATH = '/rest/tutanota/createfileservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.CreateFileData.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.CreateFileData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    fileName: this._fileName, 
    group: this._group, 
    listEncSessionKey: this._listEncSessionKey, 
    mimeType: this._mimeType, 
    fileData: this._fileData, 
    parentFolder: this._parentFolder
  };
};

/**
 * The id of the CreateFileData type.
 */
tutao.entity.tutanota.CreateFileData.prototype.TYPE_ID = 346;

/**
 * The id of the fileName attribute.
 */
tutao.entity.tutanota.CreateFileData.prototype.FILENAME_ATTRIBUTE_ID = 348;

/**
 * The id of the group attribute.
 */
tutao.entity.tutanota.CreateFileData.prototype.GROUP_ATTRIBUTE_ID = 350;

/**
 * The id of the listEncSessionKey attribute.
 */
tutao.entity.tutanota.CreateFileData.prototype.LISTENCSESSIONKEY_ATTRIBUTE_ID = 351;

/**
 * The id of the mimeType attribute.
 */
tutao.entity.tutanota.CreateFileData.prototype.MIMETYPE_ATTRIBUTE_ID = 349;

/**
 * The id of the fileData attribute.
 */
tutao.entity.tutanota.CreateFileData.prototype.FILEDATA_ATTRIBUTE_ID = 352;

/**
 * The id of the parentFolder attribute.
 */
tutao.entity.tutanota.CreateFileData.prototype.PARENTFOLDER_ATTRIBUTE_ID = 353;

/**
 * Sets the format of this CreateFileData.
 * @param {string} format The format of this CreateFileData.
 */
tutao.entity.tutanota.CreateFileData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this CreateFileData.
 * @return {string} The format of this CreateFileData.
 */
tutao.entity.tutanota.CreateFileData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the fileName of this CreateFileData.
 * @param {string} fileName The fileName of this CreateFileData.
 */
tutao.entity.tutanota.CreateFileData.prototype.setFileName = function(fileName) {
  var dataToEncrypt = fileName;
  this._fileName = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the fileName of this CreateFileData.
 * @return {string} The fileName of this CreateFileData.
 */
tutao.entity.tutanota.CreateFileData.prototype.getFileName = function() {
  if (this._fileName == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._fileName);
  return value;
};

/**
 * Sets the group of this CreateFileData.
 * @param {string} group The group of this CreateFileData.
 */
tutao.entity.tutanota.CreateFileData.prototype.setGroup = function(group) {
  this._group = group;
  return this;
};

/**
 * Provides the group of this CreateFileData.
 * @return {string} The group of this CreateFileData.
 */
tutao.entity.tutanota.CreateFileData.prototype.getGroup = function() {
  return this._group;
};

/**
 * Sets the listEncSessionKey of this CreateFileData.
 * @param {string} listEncSessionKey The listEncSessionKey of this CreateFileData.
 */
tutao.entity.tutanota.CreateFileData.prototype.setListEncSessionKey = function(listEncSessionKey) {
  this._listEncSessionKey = listEncSessionKey;
  return this;
};

/**
 * Provides the listEncSessionKey of this CreateFileData.
 * @return {string} The listEncSessionKey of this CreateFileData.
 */
tutao.entity.tutanota.CreateFileData.prototype.getListEncSessionKey = function() {
  return this._listEncSessionKey;
};

/**
 * Sets the mimeType of this CreateFileData.
 * @param {string} mimeType The mimeType of this CreateFileData.
 */
tutao.entity.tutanota.CreateFileData.prototype.setMimeType = function(mimeType) {
  var dataToEncrypt = mimeType;
  this._mimeType = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the mimeType of this CreateFileData.
 * @return {string} The mimeType of this CreateFileData.
 */
tutao.entity.tutanota.CreateFileData.prototype.getMimeType = function() {
  if (this._mimeType == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._mimeType);
  return value;
};

/**
 * Sets the fileData of this CreateFileData.
 * @param {string} fileData The fileData of this CreateFileData.
 */
tutao.entity.tutanota.CreateFileData.prototype.setFileData = function(fileData) {
  this._fileData = fileData;
  return this;
};

/**
 * Provides the fileData of this CreateFileData.
 * @return {string} The fileData of this CreateFileData.
 */
tutao.entity.tutanota.CreateFileData.prototype.getFileData = function() {
  return this._fileData;
};

/**
 * Loads the fileData of this CreateFileData.
 * @return {Promise.<tutao.entity.tutanota.FileData>} Resolves to the loaded fileData of this CreateFileData or an exception if the loading failed.
 */
tutao.entity.tutanota.CreateFileData.prototype.loadFileData = function() {
  return tutao.entity.tutanota.FileData.load(this._fileData);
};

/**
 * Sets the parentFolder of this CreateFileData.
 * @param {Array.<string>} parentFolder The parentFolder of this CreateFileData.
 */
tutao.entity.tutanota.CreateFileData.prototype.setParentFolder = function(parentFolder) {
  this._parentFolder = parentFolder;
  return this;
};

/**
 * Provides the parentFolder of this CreateFileData.
 * @return {Array.<string>} The parentFolder of this CreateFileData.
 */
tutao.entity.tutanota.CreateFileData.prototype.getParentFolder = function() {
  return this._parentFolder;
};

/**
 * Loads the parentFolder of this CreateFileData.
 * @return {Promise.<tutao.entity.tutanota.File>} Resolves to the loaded parentFolder of this CreateFileData or an exception if the loading failed.
 */
tutao.entity.tutanota.CreateFileData.prototype.loadParentFolder = function() {
  return tutao.entity.tutanota.File.load(this._parentFolder);
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.tutanota.CreateFileReturn=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.CreateFileData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.tutanota.CreateFileData.PATH, this, parameters, headers, tutao.entity.tutanota.CreateFileReturn);
};

"use strict";

tutao.provide('tutao.entity.tutanota.CreateFileReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.CreateFileReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._file = data.file;
  } else {
    this.__format = "0";
    this._file = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.CreateFileReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.CreateFileReturn.MODEL_VERSION = '5';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.CreateFileReturn.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.CreateFileReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    file: this._file
  };
};

/**
 * The id of the CreateFileReturn type.
 */
tutao.entity.tutanota.CreateFileReturn.prototype.TYPE_ID = 354;

/**
 * The id of the file attribute.
 */
tutao.entity.tutanota.CreateFileReturn.prototype.FILE_ATTRIBUTE_ID = 356;

/**
 * Sets the format of this CreateFileReturn.
 * @param {string} format The format of this CreateFileReturn.
 */
tutao.entity.tutanota.CreateFileReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this CreateFileReturn.
 * @return {string} The format of this CreateFileReturn.
 */
tutao.entity.tutanota.CreateFileReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the file of this CreateFileReturn.
 * @param {Array.<string>} file The file of this CreateFileReturn.
 */
tutao.entity.tutanota.CreateFileReturn.prototype.setFile = function(file) {
  this._file = file;
  return this;
};

/**
 * Provides the file of this CreateFileReturn.
 * @return {Array.<string>} The file of this CreateFileReturn.
 */
tutao.entity.tutanota.CreateFileReturn.prototype.getFile = function() {
  return this._file;
};

/**
 * Loads the file of this CreateFileReturn.
 * @return {Promise.<tutao.entity.tutanota.File>} Resolves to the loaded file of this CreateFileReturn or an exception if the loading failed.
 */
tutao.entity.tutanota.CreateFileReturn.prototype.loadFile = function() {
  return tutao.entity.tutanota.File.load(this._file);
};

"use strict";

tutao.provide('tutao.entity.tutanota.CreateFolderData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.CreateFolderData = function(data) {
  if (data) {
    this.__format = data._format;
    this._fileName = data.fileName;
    this._group = data.group;
    this._listEncSessionKey = data.listEncSessionKey;
    this._symEncSessionKey = data.symEncSessionKey;
    this._parentFolder = data.parentFolder;
  } else {
    this.__format = "0";
    this._fileName = null;
    this._group = null;
    this._listEncSessionKey = null;
    this._symEncSessionKey = null;
    this._parentFolder = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.CreateFolderData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.CreateFolderData.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.CreateFolderData.PATH = '/rest/tutanota/createfolderservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.CreateFolderData.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.CreateFolderData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    fileName: this._fileName, 
    group: this._group, 
    listEncSessionKey: this._listEncSessionKey, 
    symEncSessionKey: this._symEncSessionKey, 
    parentFolder: this._parentFolder
  };
};

/**
 * The id of the CreateFolderData type.
 */
tutao.entity.tutanota.CreateFolderData.prototype.TYPE_ID = 358;

/**
 * The id of the fileName attribute.
 */
tutao.entity.tutanota.CreateFolderData.prototype.FILENAME_ATTRIBUTE_ID = 360;

/**
 * The id of the group attribute.
 */
tutao.entity.tutanota.CreateFolderData.prototype.GROUP_ATTRIBUTE_ID = 361;

/**
 * The id of the listEncSessionKey attribute.
 */
tutao.entity.tutanota.CreateFolderData.prototype.LISTENCSESSIONKEY_ATTRIBUTE_ID = 363;

/**
 * The id of the symEncSessionKey attribute.
 */
tutao.entity.tutanota.CreateFolderData.prototype.SYMENCSESSIONKEY_ATTRIBUTE_ID = 362;

/**
 * The id of the parentFolder attribute.
 */
tutao.entity.tutanota.CreateFolderData.prototype.PARENTFOLDER_ATTRIBUTE_ID = 364;

/**
 * Sets the format of this CreateFolderData.
 * @param {string} format The format of this CreateFolderData.
 */
tutao.entity.tutanota.CreateFolderData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this CreateFolderData.
 * @return {string} The format of this CreateFolderData.
 */
tutao.entity.tutanota.CreateFolderData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the fileName of this CreateFolderData.
 * @param {string} fileName The fileName of this CreateFolderData.
 */
tutao.entity.tutanota.CreateFolderData.prototype.setFileName = function(fileName) {
  var dataToEncrypt = fileName;
  this._fileName = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the fileName of this CreateFolderData.
 * @return {string} The fileName of this CreateFolderData.
 */
tutao.entity.tutanota.CreateFolderData.prototype.getFileName = function() {
  if (this._fileName == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._fileName);
  return value;
};

/**
 * Sets the group of this CreateFolderData.
 * @param {string} group The group of this CreateFolderData.
 */
tutao.entity.tutanota.CreateFolderData.prototype.setGroup = function(group) {
  this._group = group;
  return this;
};

/**
 * Provides the group of this CreateFolderData.
 * @return {string} The group of this CreateFolderData.
 */
tutao.entity.tutanota.CreateFolderData.prototype.getGroup = function() {
  return this._group;
};

/**
 * Sets the listEncSessionKey of this CreateFolderData.
 * @param {string} listEncSessionKey The listEncSessionKey of this CreateFolderData.
 */
tutao.entity.tutanota.CreateFolderData.prototype.setListEncSessionKey = function(listEncSessionKey) {
  this._listEncSessionKey = listEncSessionKey;
  return this;
};

/**
 * Provides the listEncSessionKey of this CreateFolderData.
 * @return {string} The listEncSessionKey of this CreateFolderData.
 */
tutao.entity.tutanota.CreateFolderData.prototype.getListEncSessionKey = function() {
  return this._listEncSessionKey;
};

/**
 * Sets the symEncSessionKey of this CreateFolderData.
 * @param {string} symEncSessionKey The symEncSessionKey of this CreateFolderData.
 */
tutao.entity.tutanota.CreateFolderData.prototype.setSymEncSessionKey = function(symEncSessionKey) {
  this._symEncSessionKey = symEncSessionKey;
  return this;
};

/**
 * Provides the symEncSessionKey of this CreateFolderData.
 * @return {string} The symEncSessionKey of this CreateFolderData.
 */
tutao.entity.tutanota.CreateFolderData.prototype.getSymEncSessionKey = function() {
  return this._symEncSessionKey;
};

/**
 * Sets the parentFolder of this CreateFolderData.
 * @param {Array.<string>} parentFolder The parentFolder of this CreateFolderData.
 */
tutao.entity.tutanota.CreateFolderData.prototype.setParentFolder = function(parentFolder) {
  this._parentFolder = parentFolder;
  return this;
};

/**
 * Provides the parentFolder of this CreateFolderData.
 * @return {Array.<string>} The parentFolder of this CreateFolderData.
 */
tutao.entity.tutanota.CreateFolderData.prototype.getParentFolder = function() {
  return this._parentFolder;
};

/**
 * Loads the parentFolder of this CreateFolderData.
 * @return {Promise.<tutao.entity.tutanota.File>} Resolves to the loaded parentFolder of this CreateFolderData or an exception if the loading failed.
 */
tutao.entity.tutanota.CreateFolderData.prototype.loadParentFolder = function() {
  return tutao.entity.tutanota.File.load(this._parentFolder);
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.tutanota.CreateFolderReturn=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.CreateFolderData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.tutanota.CreateFolderData.PATH, this, parameters, headers, tutao.entity.tutanota.CreateFolderReturn);
};

"use strict";

tutao.provide('tutao.entity.tutanota.CreateFolderReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.CreateFolderReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._file = data.file;
  } else {
    this.__format = "0";
    this._file = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.CreateFolderReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.CreateFolderReturn.MODEL_VERSION = '5';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.CreateFolderReturn.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.CreateFolderReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    file: this._file
  };
};

/**
 * The id of the CreateFolderReturn type.
 */
tutao.entity.tutanota.CreateFolderReturn.prototype.TYPE_ID = 365;

/**
 * The id of the file attribute.
 */
tutao.entity.tutanota.CreateFolderReturn.prototype.FILE_ATTRIBUTE_ID = 367;

/**
 * Sets the format of this CreateFolderReturn.
 * @param {string} format The format of this CreateFolderReturn.
 */
tutao.entity.tutanota.CreateFolderReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this CreateFolderReturn.
 * @return {string} The format of this CreateFolderReturn.
 */
tutao.entity.tutanota.CreateFolderReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the file of this CreateFolderReturn.
 * @param {Array.<string>} file The file of this CreateFolderReturn.
 */
tutao.entity.tutanota.CreateFolderReturn.prototype.setFile = function(file) {
  this._file = file;
  return this;
};

/**
 * Provides the file of this CreateFolderReturn.
 * @return {Array.<string>} The file of this CreateFolderReturn.
 */
tutao.entity.tutanota.CreateFolderReturn.prototype.getFile = function() {
  return this._file;
};

/**
 * Loads the file of this CreateFolderReturn.
 * @return {Promise.<tutao.entity.tutanota.File>} Resolves to the loaded file of this CreateFolderReturn or an exception if the loading failed.
 */
tutao.entity.tutanota.CreateFolderReturn.prototype.loadFile = function() {
  return tutao.entity.tutanota.File.load(this._file);
};

"use strict";

tutao.provide('tutao.entity.tutanota.DataBlock');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.DataBlock = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._blockData = data.blockData;
    this._size = data.size;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._blockData = null;
    this._size = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.DataBlock.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.DataBlock.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    blockData: this._blockData, 
    size: this._size
  };
};

/**
 * The id of the DataBlock type.
 */
tutao.entity.tutanota.DataBlock.prototype.TYPE_ID = 0;

/**
 * The id of the blockData attribute.
 */
tutao.entity.tutanota.DataBlock.prototype.BLOCKDATA_ATTRIBUTE_ID = 3;

/**
 * The id of the size attribute.
 */
tutao.entity.tutanota.DataBlock.prototype.SIZE_ATTRIBUTE_ID = 2;

/**
 * Sets the id of this DataBlock.
 * @param {string} id The id of this DataBlock.
 */
tutao.entity.tutanota.DataBlock.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this DataBlock.
 * @return {string} The id of this DataBlock.
 */
tutao.entity.tutanota.DataBlock.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the blockData of this DataBlock.
 * @param {string} blockData The blockData of this DataBlock.
 */
tutao.entity.tutanota.DataBlock.prototype.setBlockData = function(blockData) {
  this._blockData = blockData;
  return this;
};

/**
 * Provides the blockData of this DataBlock.
 * @return {string} The blockData of this DataBlock.
 */
tutao.entity.tutanota.DataBlock.prototype.getBlockData = function() {
  return this._blockData;
};

/**
 * Sets the size of this DataBlock.
 * @param {string} size The size of this DataBlock.
 */
tutao.entity.tutanota.DataBlock.prototype.setSize = function(size) {
  this._size = size;
  return this;
};

/**
 * Provides the size of this DataBlock.
 * @return {string} The size of this DataBlock.
 */
tutao.entity.tutanota.DataBlock.prototype.getSize = function() {
  return this._size;
};

"use strict";

tutao.provide('tutao.entity.tutanota.DeleteFileData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.DeleteFileData = function(data) {
  if (data) {
    this.__format = data._format;
    this._group = data.group;
    this._file = data.file;
  } else {
    this.__format = "0";
    this._group = null;
    this._file = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.DeleteFileData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.DeleteFileData.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.DeleteFileData.PATH = '/rest/tutanota/deletefileservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.DeleteFileData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.DeleteFileData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    group: this._group, 
    file: this._file
  };
};

/**
 * The id of the DeleteFileData type.
 */
tutao.entity.tutanota.DeleteFileData.prototype.TYPE_ID = 374;

/**
 * The id of the group attribute.
 */
tutao.entity.tutanota.DeleteFileData.prototype.GROUP_ATTRIBUTE_ID = 376;

/**
 * The id of the file attribute.
 */
tutao.entity.tutanota.DeleteFileData.prototype.FILE_ATTRIBUTE_ID = 377;

/**
 * Sets the format of this DeleteFileData.
 * @param {string} format The format of this DeleteFileData.
 */
tutao.entity.tutanota.DeleteFileData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this DeleteFileData.
 * @return {string} The format of this DeleteFileData.
 */
tutao.entity.tutanota.DeleteFileData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the group of this DeleteFileData.
 * @param {string} group The group of this DeleteFileData.
 */
tutao.entity.tutanota.DeleteFileData.prototype.setGroup = function(group) {
  this._group = group;
  return this;
};

/**
 * Provides the group of this DeleteFileData.
 * @return {string} The group of this DeleteFileData.
 */
tutao.entity.tutanota.DeleteFileData.prototype.getGroup = function() {
  return this._group;
};

/**
 * Sets the file of this DeleteFileData.
 * @param {Array.<string>} file The file of this DeleteFileData.
 */
tutao.entity.tutanota.DeleteFileData.prototype.setFile = function(file) {
  this._file = file;
  return this;
};

/**
 * Provides the file of this DeleteFileData.
 * @return {Array.<string>} The file of this DeleteFileData.
 */
tutao.entity.tutanota.DeleteFileData.prototype.getFile = function() {
  return this._file;
};

/**
 * Loads the file of this DeleteFileData.
 * @return {Promise.<tutao.entity.tutanota.File>} Resolves to the loaded file of this DeleteFileData or an exception if the loading failed.
 */
tutao.entity.tutanota.DeleteFileData.prototype.loadFile = function() {
  return tutao.entity.tutanota.File.load(this._file);
};

/**
 * Updates this service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.DeleteFileData.prototype.update = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  return tutao.locator.entityRestClient.putService(tutao.entity.tutanota.DeleteFileData.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.tutanota.DeleteMailData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.DeleteMailData = function(data) {
  if (data) {
    this.__format = data._format;
    this._mails = data.mails;
  } else {
    this.__format = "0";
    this._mails = [];
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.DeleteMailData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.DeleteMailData.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.DeleteMailData.PATH = '/rest/tutanota/mailservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.DeleteMailData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.DeleteMailData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    mails: this._mails
  };
};

/**
 * The id of the DeleteMailData type.
 */
tutao.entity.tutanota.DeleteMailData.prototype.TYPE_ID = 419;

/**
 * The id of the mails attribute.
 */
tutao.entity.tutanota.DeleteMailData.prototype.MAILS_ATTRIBUTE_ID = 421;

/**
 * Sets the format of this DeleteMailData.
 * @param {string} format The format of this DeleteMailData.
 */
tutao.entity.tutanota.DeleteMailData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this DeleteMailData.
 * @return {string} The format of this DeleteMailData.
 */
tutao.entity.tutanota.DeleteMailData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Provides the mails of this DeleteMailData.
 * @return {Array.<Array.<string>>} The mails of this DeleteMailData.
 */
tutao.entity.tutanota.DeleteMailData.prototype.getMails = function() {
  return this._mails;
};

/**
 * Invokes DELETE on a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.tutanota.DeleteMailData=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.DeleteMailData.prototype.erase = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.deleteService(tutao.entity.tutanota.DeleteMailData.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.tutanota.ExternalUserData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.ExternalUserData = function(data) {
  if (data) {
    this.__format = data._format;
    this._externalUserEncGroupInfoSessionKey = data.externalUserEncGroupInfoSessionKey;
    this._groupEncEntropy = data.groupEncEntropy;
    this._groupEncMailListKey = data.groupEncMailListKey;
    this._userEncClientKey = data.userEncClientKey;
    this._verifier = data.verifier;
    this._userGroupData = (data.userGroupData) ? new tutao.entity.tutanota.CreateExternalUserGroupData(this, data.userGroupData) : null;
  } else {
    this.__format = "0";
    this._externalUserEncGroupInfoSessionKey = null;
    this._groupEncEntropy = null;
    this._groupEncMailListKey = null;
    this._userEncClientKey = null;
    this._verifier = null;
    this._userGroupData = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.ExternalUserData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.ExternalUserData.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.ExternalUserData.PATH = '/rest/tutanota/externaluserservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.ExternalUserData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.ExternalUserData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    externalUserEncGroupInfoSessionKey: this._externalUserEncGroupInfoSessionKey, 
    groupEncEntropy: this._groupEncEntropy, 
    groupEncMailListKey: this._groupEncMailListKey, 
    userEncClientKey: this._userEncClientKey, 
    verifier: this._verifier, 
    userGroupData: tutao.entity.EntityHelper.aggregatesToJsonData(this._userGroupData)
  };
};

/**
 * The id of the ExternalUserData type.
 */
tutao.entity.tutanota.ExternalUserData.prototype.TYPE_ID = 145;

/**
 * The id of the externalUserEncGroupInfoSessionKey attribute.
 */
tutao.entity.tutanota.ExternalUserData.prototype.EXTERNALUSERENCGROUPINFOSESSIONKEY_ATTRIBUTE_ID = 150;

/**
 * The id of the groupEncEntropy attribute.
 */
tutao.entity.tutanota.ExternalUserData.prototype.GROUPENCENTROPY_ATTRIBUTE_ID = 412;

/**
 * The id of the groupEncMailListKey attribute.
 */
tutao.entity.tutanota.ExternalUserData.prototype.GROUPENCMAILLISTKEY_ATTRIBUTE_ID = 148;

/**
 * The id of the userEncClientKey attribute.
 */
tutao.entity.tutanota.ExternalUserData.prototype.USERENCCLIENTKEY_ATTRIBUTE_ID = 147;

/**
 * The id of the verifier attribute.
 */
tutao.entity.tutanota.ExternalUserData.prototype.VERIFIER_ATTRIBUTE_ID = 149;

/**
 * The id of the userGroupData attribute.
 */
tutao.entity.tutanota.ExternalUserData.prototype.USERGROUPDATA_ATTRIBUTE_ID = 151;

/**
 * Sets the format of this ExternalUserData.
 * @param {string} format The format of this ExternalUserData.
 */
tutao.entity.tutanota.ExternalUserData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this ExternalUserData.
 * @return {string} The format of this ExternalUserData.
 */
tutao.entity.tutanota.ExternalUserData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the externalUserEncGroupInfoSessionKey of this ExternalUserData.
 * @param {string} externalUserEncGroupInfoSessionKey The externalUserEncGroupInfoSessionKey of this ExternalUserData.
 */
tutao.entity.tutanota.ExternalUserData.prototype.setExternalUserEncGroupInfoSessionKey = function(externalUserEncGroupInfoSessionKey) {
  this._externalUserEncGroupInfoSessionKey = externalUserEncGroupInfoSessionKey;
  return this;
};

/**
 * Provides the externalUserEncGroupInfoSessionKey of this ExternalUserData.
 * @return {string} The externalUserEncGroupInfoSessionKey of this ExternalUserData.
 */
tutao.entity.tutanota.ExternalUserData.prototype.getExternalUserEncGroupInfoSessionKey = function() {
  return this._externalUserEncGroupInfoSessionKey;
};

/**
 * Sets the groupEncEntropy of this ExternalUserData.
 * @param {string} groupEncEntropy The groupEncEntropy of this ExternalUserData.
 */
tutao.entity.tutanota.ExternalUserData.prototype.setGroupEncEntropy = function(groupEncEntropy) {
  this._groupEncEntropy = groupEncEntropy;
  return this;
};

/**
 * Provides the groupEncEntropy of this ExternalUserData.
 * @return {string} The groupEncEntropy of this ExternalUserData.
 */
tutao.entity.tutanota.ExternalUserData.prototype.getGroupEncEntropy = function() {
  return this._groupEncEntropy;
};

/**
 * Sets the groupEncMailListKey of this ExternalUserData.
 * @param {string} groupEncMailListKey The groupEncMailListKey of this ExternalUserData.
 */
tutao.entity.tutanota.ExternalUserData.prototype.setGroupEncMailListKey = function(groupEncMailListKey) {
  this._groupEncMailListKey = groupEncMailListKey;
  return this;
};

/**
 * Provides the groupEncMailListKey of this ExternalUserData.
 * @return {string} The groupEncMailListKey of this ExternalUserData.
 */
tutao.entity.tutanota.ExternalUserData.prototype.getGroupEncMailListKey = function() {
  return this._groupEncMailListKey;
};

/**
 * Sets the userEncClientKey of this ExternalUserData.
 * @param {string} userEncClientKey The userEncClientKey of this ExternalUserData.
 */
tutao.entity.tutanota.ExternalUserData.prototype.setUserEncClientKey = function(userEncClientKey) {
  this._userEncClientKey = userEncClientKey;
  return this;
};

/**
 * Provides the userEncClientKey of this ExternalUserData.
 * @return {string} The userEncClientKey of this ExternalUserData.
 */
tutao.entity.tutanota.ExternalUserData.prototype.getUserEncClientKey = function() {
  return this._userEncClientKey;
};

/**
 * Sets the verifier of this ExternalUserData.
 * @param {string} verifier The verifier of this ExternalUserData.
 */
tutao.entity.tutanota.ExternalUserData.prototype.setVerifier = function(verifier) {
  this._verifier = verifier;
  return this;
};

/**
 * Provides the verifier of this ExternalUserData.
 * @return {string} The verifier of this ExternalUserData.
 */
tutao.entity.tutanota.ExternalUserData.prototype.getVerifier = function() {
  return this._verifier;
};

/**
 * Sets the userGroupData of this ExternalUserData.
 * @param {tutao.entity.tutanota.CreateExternalUserGroupData} userGroupData The userGroupData of this ExternalUserData.
 */
tutao.entity.tutanota.ExternalUserData.prototype.setUserGroupData = function(userGroupData) {
  this._userGroupData = userGroupData;
  return this;
};

/**
 * Provides the userGroupData of this ExternalUserData.
 * @return {tutao.entity.tutanota.CreateExternalUserGroupData} The userGroupData of this ExternalUserData.
 */
tutao.entity.tutanota.ExternalUserData.prototype.getUserGroupData = function() {
  return this._userGroupData;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.ExternalUserData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.tutanota.ExternalUserData.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.tutanota.FeedbackData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.FeedbackData = function(data) {
  if (data) {
    this.__format = data._format;
    this._image = data.image;
    this._msg = data.msg;
    this._useragent = data.useragent;
  } else {
    this.__format = "0";
    this._image = null;
    this._msg = null;
    this._useragent = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.FeedbackData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.FeedbackData.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.FeedbackData.PATH = '/rest/tutanota/feedbackservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.FeedbackData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.FeedbackData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    image: this._image, 
    msg: this._msg, 
    useragent: this._useragent
  };
};

/**
 * The id of the FeedbackData type.
 */
tutao.entity.tutanota.FeedbackData.prototype.TYPE_ID = 379;

/**
 * The id of the image attribute.
 */
tutao.entity.tutanota.FeedbackData.prototype.IMAGE_ATTRIBUTE_ID = 383;

/**
 * The id of the msg attribute.
 */
tutao.entity.tutanota.FeedbackData.prototype.MSG_ATTRIBUTE_ID = 381;

/**
 * The id of the useragent attribute.
 */
tutao.entity.tutanota.FeedbackData.prototype.USERAGENT_ATTRIBUTE_ID = 382;

/**
 * Sets the format of this FeedbackData.
 * @param {string} format The format of this FeedbackData.
 */
tutao.entity.tutanota.FeedbackData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this FeedbackData.
 * @return {string} The format of this FeedbackData.
 */
tutao.entity.tutanota.FeedbackData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the image of this FeedbackData.
 * @param {string} image The image of this FeedbackData.
 */
tutao.entity.tutanota.FeedbackData.prototype.setImage = function(image) {
  this._image = image;
  return this;
};

/**
 * Provides the image of this FeedbackData.
 * @return {string} The image of this FeedbackData.
 */
tutao.entity.tutanota.FeedbackData.prototype.getImage = function() {
  return this._image;
};

/**
 * Sets the msg of this FeedbackData.
 * @param {string} msg The msg of this FeedbackData.
 */
tutao.entity.tutanota.FeedbackData.prototype.setMsg = function(msg) {
  this._msg = msg;
  return this;
};

/**
 * Provides the msg of this FeedbackData.
 * @return {string} The msg of this FeedbackData.
 */
tutao.entity.tutanota.FeedbackData.prototype.getMsg = function() {
  return this._msg;
};

/**
 * Sets the useragent of this FeedbackData.
 * @param {string} useragent The useragent of this FeedbackData.
 */
tutao.entity.tutanota.FeedbackData.prototype.setUseragent = function(useragent) {
  this._useragent = useragent;
  return this;
};

/**
 * Provides the useragent of this FeedbackData.
 * @return {string} The useragent of this FeedbackData.
 */
tutao.entity.tutanota.FeedbackData.prototype.getUseragent = function() {
  return this._useragent;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.FeedbackData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.tutanota.FeedbackData.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.tutanota.File');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.File = function(data) {
  if (data) {
    this.__area = data._area;
    this.__format = data._format;
    this.__id = data._id;
    this.__listEncSessionKey = data._listEncSessionKey;
    this.__owner = data._owner;
    this.__permissions = data._permissions;
    this._mimeType = data.mimeType;
    this._name = data.name;
    this._size = data.size;
    this._data = data.data;
    this._parent = data.parent;
    this._subFiles = (data.subFiles) ? new tutao.entity.tutanota.Subfiles(this, data.subFiles) : null;
  } else {
    this.__area = null;
    this.__format = "0";
    this.__id = null;
    this.__listEncSessionKey = null;
    this.__owner = null;
    this.__permissions = null;
    this._mimeType = null;
    this._name = null;
    this._size = null;
    this._data = null;
    this._parent = null;
    this._subFiles = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.File.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.File.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.File.PATH = '/rest/tutanota/file';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.tutanota.File.ROOT_INSTANCE_ID = 'CHR1dGFub3RhAA0';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.tutanota.File.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.File.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.File.prototype.toJsonData = function() {
  return {
    _area: this.__area, 
    _format: this.__format, 
    _id: this.__id, 
    _listEncSessionKey: this.__listEncSessionKey, 
    _owner: this.__owner, 
    _permissions: this.__permissions, 
    mimeType: this._mimeType, 
    name: this._name, 
    size: this._size, 
    data: this._data, 
    parent: this._parent, 
    subFiles: tutao.entity.EntityHelper.aggregatesToJsonData(this._subFiles)
  };
};

/**
 * The id of the File type.
 */
tutao.entity.tutanota.File.prototype.TYPE_ID = 13;

/**
 * The id of the _area attribute.
 */
tutao.entity.tutanota.File.prototype._AREA_ATTRIBUTE_ID = 20;

/**
 * The id of the _owner attribute.
 */
tutao.entity.tutanota.File.prototype._OWNER_ATTRIBUTE_ID = 19;

/**
 * The id of the mimeType attribute.
 */
tutao.entity.tutanota.File.prototype.MIMETYPE_ATTRIBUTE_ID = 23;

/**
 * The id of the name attribute.
 */
tutao.entity.tutanota.File.prototype.NAME_ATTRIBUTE_ID = 21;

/**
 * The id of the size attribute.
 */
tutao.entity.tutanota.File.prototype.SIZE_ATTRIBUTE_ID = 22;

/**
 * The id of the data attribute.
 */
tutao.entity.tutanota.File.prototype.DATA_ATTRIBUTE_ID = 24;

/**
 * The id of the parent attribute.
 */
tutao.entity.tutanota.File.prototype.PARENT_ATTRIBUTE_ID = 25;

/**
 * The id of the subFiles attribute.
 */
tutao.entity.tutanota.File.prototype.SUBFILES_ATTRIBUTE_ID = 26;

/**
 * Provides the id of this File.
 * @return {Array.<string>} The id of this File.
 */
tutao.entity.tutanota.File.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the area of this File.
 * @param {string} area The area of this File.
 */
tutao.entity.tutanota.File.prototype.setArea = function(area) {
  this.__area = area;
  return this;
};

/**
 * Provides the area of this File.
 * @return {string} The area of this File.
 */
tutao.entity.tutanota.File.prototype.getArea = function() {
  return this.__area;
};

/**
 * Sets the format of this File.
 * @param {string} format The format of this File.
 */
tutao.entity.tutanota.File.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this File.
 * @return {string} The format of this File.
 */
tutao.entity.tutanota.File.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the listEncSessionKey of this File.
 * @param {string} listEncSessionKey The listEncSessionKey of this File.
 */
tutao.entity.tutanota.File.prototype.setListEncSessionKey = function(listEncSessionKey) {
  this.__listEncSessionKey = listEncSessionKey;
  return this;
};

/**
 * Provides the listEncSessionKey of this File.
 * @return {string} The listEncSessionKey of this File.
 */
tutao.entity.tutanota.File.prototype.getListEncSessionKey = function() {
  return this.__listEncSessionKey;
};

/**
 * Sets the owner of this File.
 * @param {string} owner The owner of this File.
 */
tutao.entity.tutanota.File.prototype.setOwner = function(owner) {
  this.__owner = owner;
  return this;
};

/**
 * Provides the owner of this File.
 * @return {string} The owner of this File.
 */
tutao.entity.tutanota.File.prototype.getOwner = function() {
  return this.__owner;
};

/**
 * Sets the permissions of this File.
 * @param {string} permissions The permissions of this File.
 */
tutao.entity.tutanota.File.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this File.
 * @return {string} The permissions of this File.
 */
tutao.entity.tutanota.File.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the mimeType of this File.
 * @param {string} mimeType The mimeType of this File.
 */
tutao.entity.tutanota.File.prototype.setMimeType = function(mimeType) {
  if (mimeType == null) {
    this._mimeType = null;
  } else {
    var dataToEncrypt = mimeType;
    this._mimeType = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  }
  return this;
};

/**
 * Provides the mimeType of this File.
 * @return {string} The mimeType of this File.
 */
tutao.entity.tutanota.File.prototype.getMimeType = function() {
  if (this._mimeType == null) {
    return null;
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._mimeType);
  return value;
};

/**
 * Sets the name of this File.
 * @param {string} name The name of this File.
 */
tutao.entity.tutanota.File.prototype.setName = function(name) {
  var dataToEncrypt = name;
  this._name = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the name of this File.
 * @return {string} The name of this File.
 */
tutao.entity.tutanota.File.prototype.getName = function() {
  if (this._name == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._name);
  return value;
};

/**
 * Sets the size of this File.
 * @param {string} size The size of this File.
 */
tutao.entity.tutanota.File.prototype.setSize = function(size) {
  this._size = size;
  return this;
};

/**
 * Provides the size of this File.
 * @return {string} The size of this File.
 */
tutao.entity.tutanota.File.prototype.getSize = function() {
  return this._size;
};

/**
 * Sets the data of this File.
 * @param {string} data The data of this File.
 */
tutao.entity.tutanota.File.prototype.setData = function(data) {
  this._data = data;
  return this;
};

/**
 * Provides the data of this File.
 * @return {string} The data of this File.
 */
tutao.entity.tutanota.File.prototype.getData = function() {
  return this._data;
};

/**
 * Loads the data of this File.
 * @return {Promise.<tutao.entity.tutanota.FileData>} Resolves to the loaded data of this File or an exception if the loading failed.
 */
tutao.entity.tutanota.File.prototype.loadData = function() {
  return tutao.entity.tutanota.FileData.load(this._data);
};

/**
 * Sets the parent of this File.
 * @param {Array.<string>} parent The parent of this File.
 */
tutao.entity.tutanota.File.prototype.setParent = function(parent) {
  this._parent = parent;
  return this;
};

/**
 * Provides the parent of this File.
 * @return {Array.<string>} The parent of this File.
 */
tutao.entity.tutanota.File.prototype.getParent = function() {
  return this._parent;
};

/**
 * Loads the parent of this File.
 * @return {Promise.<tutao.entity.tutanota.File>} Resolves to the loaded parent of this File or an exception if the loading failed.
 */
tutao.entity.tutanota.File.prototype.loadParent = function() {
  return tutao.entity.tutanota.File.load(this._parent);
};

/**
 * Sets the subFiles of this File.
 * @param {tutao.entity.tutanota.Subfiles} subFiles The subFiles of this File.
 */
tutao.entity.tutanota.File.prototype.setSubFiles = function(subFiles) {
  this._subFiles = subFiles;
  return this;
};

/**
 * Provides the subFiles of this File.
 * @return {tutao.entity.tutanota.Subfiles} The subFiles of this File.
 */
tutao.entity.tutanota.File.prototype.getSubFiles = function() {
  return this._subFiles;
};

/**
 * Loads a File from the server.
 * @param {Array.<string>} id The id of the File.
 * @return {Promise.<tutao.entity.tutanota.File>} Resolves to the File or an exception if the loading failed.
 */
tutao.entity.tutanota.File.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.tutanota.File, tutao.entity.tutanota.File.PATH, id[1], id[0], {"v" : 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity._entityHelper.loadSessionKey();
  });
};

/**
 * Loads multiple Files from the server.
 * @param {Array.<Array.<string>>} ids The ids of the Files to load.
 * @return {Promise.<Array.<tutao.entity.tutanota.File>>} Resolves to an array of File or rejects with an exception if the loading failed.
 */
tutao.entity.tutanota.File.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.tutanota.File, tutao.entity.tutanota.File.PATH, ids, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return tutao.entity.EntityHelper.loadSessionKeys(entities);
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.tutanota.File.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 5;
  return tutao.locator.entityRestClient.putElement(tutao.entity.tutanota.File.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Updates this File on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.tutanota.File.prototype.update = function() {
  var self = this;
  return tutao.locator.entityRestClient.putElement(tutao.entity.tutanota.File.PATH, this, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function() {
    self._entityHelper.notifyObservers(false);
  });
};

/**
 * Provides a  list of Files loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.tutanota.File>>} Resolves to an array of File or rejects with an exception if the loading failed.
 */
tutao.entity.tutanota.File.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.tutanota.File, tutao.entity.tutanota.File.PATH, listId, start, count, reverse, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return tutao.entity.EntityHelper.loadSessionKeys(entities);
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.tutanota.File.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.tutanota.File.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.tutanota.FileData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.FileData = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._size = data.size;
    this._unreferenced = data.unreferenced;
    this._blocks = [];
    for (var i=0; i < data.blocks.length; i++) {
      this._blocks.push(new tutao.entity.tutanota.DataBlock(this, data.blocks[i]));
    }
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._size = null;
    this._unreferenced = null;
    this._blocks = [];
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.FileData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.FileData.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.FileData.PATH = '/rest/tutanota/filedata';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.tutanota.FileData.ROOT_INSTANCE_ID = 'CHR1dGFub3RhAAQ';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.tutanota.FileData.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.FileData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.FileData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    size: this._size, 
    unreferenced: this._unreferenced, 
    blocks: tutao.entity.EntityHelper.aggregatesToJsonData(this._blocks)
  };
};

/**
 * The id of the FileData type.
 */
tutao.entity.tutanota.FileData.prototype.TYPE_ID = 4;

/**
 * The id of the size attribute.
 */
tutao.entity.tutanota.FileData.prototype.SIZE_ATTRIBUTE_ID = 9;

/**
 * The id of the unreferenced attribute.
 */
tutao.entity.tutanota.FileData.prototype.UNREFERENCED_ATTRIBUTE_ID = 409;

/**
 * The id of the blocks attribute.
 */
tutao.entity.tutanota.FileData.prototype.BLOCKS_ATTRIBUTE_ID = 10;

/**
 * Provides the id of this FileData.
 * @return {string} The id of this FileData.
 */
tutao.entity.tutanota.FileData.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this FileData.
 * @param {string} format The format of this FileData.
 */
tutao.entity.tutanota.FileData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this FileData.
 * @return {string} The format of this FileData.
 */
tutao.entity.tutanota.FileData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this FileData.
 * @param {string} permissions The permissions of this FileData.
 */
tutao.entity.tutanota.FileData.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this FileData.
 * @return {string} The permissions of this FileData.
 */
tutao.entity.tutanota.FileData.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the size of this FileData.
 * @param {string} size The size of this FileData.
 */
tutao.entity.tutanota.FileData.prototype.setSize = function(size) {
  this._size = size;
  return this;
};

/**
 * Provides the size of this FileData.
 * @return {string} The size of this FileData.
 */
tutao.entity.tutanota.FileData.prototype.getSize = function() {
  return this._size;
};

/**
 * Sets the unreferenced of this FileData.
 * @param {boolean} unreferenced The unreferenced of this FileData.
 */
tutao.entity.tutanota.FileData.prototype.setUnreferenced = function(unreferenced) {
  this._unreferenced = unreferenced ? '1' : '0';
  return this;
};

/**
 * Provides the unreferenced of this FileData.
 * @return {boolean} The unreferenced of this FileData.
 */
tutao.entity.tutanota.FileData.prototype.getUnreferenced = function() {
  return this._unreferenced == '1';
};

/**
 * Provides the blocks of this FileData.
 * @return {Array.<tutao.entity.tutanota.DataBlock>} The blocks of this FileData.
 */
tutao.entity.tutanota.FileData.prototype.getBlocks = function() {
  return this._blocks;
};

/**
 * Loads a FileData from the server.
 * @param {string} id The id of the FileData.
 * @return {Promise.<tutao.entity.tutanota.FileData>} Resolves to the FileData or an exception if the loading failed.
 */
tutao.entity.tutanota.FileData.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.tutanota.FileData, tutao.entity.tutanota.FileData.PATH, id, null, {"v" : 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple FileDatas from the server.
 * @param {Array.<string>} ids The ids of the FileDatas to load.
 * @return {Promise.<Array.<tutao.entity.tutanota.FileData>>} Resolves to an array of FileData or rejects with an exception if the loading failed.
 */
tutao.entity.tutanota.FileData.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.tutanota.FileData, tutao.entity.tutanota.FileData.PATH, ids, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.tutanota.FileData.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.tutanota.FileData.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.tutanota.FileDataDataGet');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.FileDataDataGet = function(data) {
  if (data) {
    this.__format = data._format;
    this._base64 = data.base64;
    this._file = data.file;
  } else {
    this.__format = "0";
    this._base64 = null;
    this._file = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.FileDataDataGet.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.FileDataDataGet.MODEL_VERSION = '5';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.FileDataDataGet.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.FileDataDataGet.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    base64: this._base64, 
    file: this._file
  };
};

/**
 * The id of the FileDataDataGet type.
 */
tutao.entity.tutanota.FileDataDataGet.prototype.TYPE_ID = 331;

/**
 * The id of the base64 attribute.
 */
tutao.entity.tutanota.FileDataDataGet.prototype.BASE64_ATTRIBUTE_ID = 333;

/**
 * The id of the file attribute.
 */
tutao.entity.tutanota.FileDataDataGet.prototype.FILE_ATTRIBUTE_ID = 334;

/**
 * Sets the format of this FileDataDataGet.
 * @param {string} format The format of this FileDataDataGet.
 */
tutao.entity.tutanota.FileDataDataGet.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this FileDataDataGet.
 * @return {string} The format of this FileDataDataGet.
 */
tutao.entity.tutanota.FileDataDataGet.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the base64 of this FileDataDataGet.
 * @param {boolean} base64 The base64 of this FileDataDataGet.
 */
tutao.entity.tutanota.FileDataDataGet.prototype.setBase64 = function(base64) {
  this._base64 = base64 ? '1' : '0';
  return this;
};

/**
 * Provides the base64 of this FileDataDataGet.
 * @return {boolean} The base64 of this FileDataDataGet.
 */
tutao.entity.tutanota.FileDataDataGet.prototype.getBase64 = function() {
  return this._base64 == '1';
};

/**
 * Sets the file of this FileDataDataGet.
 * @param {Array.<string>} file The file of this FileDataDataGet.
 */
tutao.entity.tutanota.FileDataDataGet.prototype.setFile = function(file) {
  this._file = file;
  return this;
};

/**
 * Provides the file of this FileDataDataGet.
 * @return {Array.<string>} The file of this FileDataDataGet.
 */
tutao.entity.tutanota.FileDataDataGet.prototype.getFile = function() {
  return this._file;
};

/**
 * Loads the file of this FileDataDataGet.
 * @return {Promise.<tutao.entity.tutanota.File>} Resolves to the loaded file of this FileDataDataGet or an exception if the loading failed.
 */
tutao.entity.tutanota.FileDataDataGet.prototype.loadFile = function() {
  return tutao.entity.tutanota.File.load(this._file);
};

"use strict";

tutao.provide('tutao.entity.tutanota.FileDataDataPost');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.FileDataDataPost = function(data) {
  if (data) {
    this.__format = data._format;
    this._group = data.group;
    this._size = data.size;
  } else {
    this.__format = "0";
    this._group = null;
    this._size = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.FileDataDataPost.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.FileDataDataPost.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.FileDataDataPost.PATH = '/rest/tutanota/filedataservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.FileDataDataPost.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.FileDataDataPost.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    group: this._group, 
    size: this._size
  };
};

/**
 * The id of the FileDataDataPost type.
 */
tutao.entity.tutanota.FileDataDataPost.prototype.TYPE_ID = 335;

/**
 * The id of the group attribute.
 */
tutao.entity.tutanota.FileDataDataPost.prototype.GROUP_ATTRIBUTE_ID = 337;

/**
 * The id of the size attribute.
 */
tutao.entity.tutanota.FileDataDataPost.prototype.SIZE_ATTRIBUTE_ID = 338;

/**
 * Sets the format of this FileDataDataPost.
 * @param {string} format The format of this FileDataDataPost.
 */
tutao.entity.tutanota.FileDataDataPost.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this FileDataDataPost.
 * @return {string} The format of this FileDataDataPost.
 */
tutao.entity.tutanota.FileDataDataPost.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the group of this FileDataDataPost.
 * @param {string} group The group of this FileDataDataPost.
 */
tutao.entity.tutanota.FileDataDataPost.prototype.setGroup = function(group) {
  this._group = group;
  return this;
};

/**
 * Provides the group of this FileDataDataPost.
 * @return {string} The group of this FileDataDataPost.
 */
tutao.entity.tutanota.FileDataDataPost.prototype.getGroup = function() {
  return this._group;
};

/**
 * Sets the size of this FileDataDataPost.
 * @param {string} size The size of this FileDataDataPost.
 */
tutao.entity.tutanota.FileDataDataPost.prototype.setSize = function(size) {
  this._size = size;
  return this;
};

/**
 * Provides the size of this FileDataDataPost.
 * @return {string} The size of this FileDataDataPost.
 */
tutao.entity.tutanota.FileDataDataPost.prototype.getSize = function() {
  return this._size;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.tutanota.FileDataReturnPost=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.FileDataDataPost.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.tutanota.FileDataDataPost.PATH, this, parameters, headers, tutao.entity.tutanota.FileDataReturnPost);
};

"use strict";

tutao.provide('tutao.entity.tutanota.FileDataDataReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.FileDataDataReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._size = data.size;
  } else {
    this.__format = "0";
    this._size = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.FileDataDataReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.FileDataDataReturn.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.FileDataDataReturn.PATH = '/rest/tutanota/filedataservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.FileDataDataReturn.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.FileDataDataReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    size: this._size
  };
};

/**
 * The id of the FileDataDataReturn type.
 */
tutao.entity.tutanota.FileDataDataReturn.prototype.TYPE_ID = 339;

/**
 * The id of the size attribute.
 */
tutao.entity.tutanota.FileDataDataReturn.prototype.SIZE_ATTRIBUTE_ID = 341;

/**
 * Sets the format of this FileDataDataReturn.
 * @param {string} format The format of this FileDataDataReturn.
 */
tutao.entity.tutanota.FileDataDataReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this FileDataDataReturn.
 * @return {string} The format of this FileDataDataReturn.
 */
tutao.entity.tutanota.FileDataDataReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the size of this FileDataDataReturn.
 * @param {string} size The size of this FileDataDataReturn.
 */
tutao.entity.tutanota.FileDataDataReturn.prototype.setSize = function(size) {
  this._size = size;
  return this;
};

/**
 * Provides the size of this FileDataDataReturn.
 * @return {string} The size of this FileDataDataReturn.
 */
tutao.entity.tutanota.FileDataDataReturn.prototype.getSize = function() {
  return this._size;
};

/**
 * Updates this service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.FileDataDataReturn.prototype.update = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  return tutao.locator.entityRestClient.putService(tutao.entity.tutanota.FileDataDataReturn.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.tutanota.FileDataReturnPost');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.FileDataReturnPost = function(data) {
  if (data) {
    this.__format = data._format;
    this._fileData = data.fileData;
  } else {
    this.__format = "0";
    this._fileData = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.FileDataReturnPost.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.FileDataReturnPost.MODEL_VERSION = '5';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.FileDataReturnPost.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.FileDataReturnPost.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    fileData: this._fileData
  };
};

/**
 * The id of the FileDataReturnPost type.
 */
tutao.entity.tutanota.FileDataReturnPost.prototype.TYPE_ID = 342;

/**
 * The id of the fileData attribute.
 */
tutao.entity.tutanota.FileDataReturnPost.prototype.FILEDATA_ATTRIBUTE_ID = 344;

/**
 * Sets the format of this FileDataReturnPost.
 * @param {string} format The format of this FileDataReturnPost.
 */
tutao.entity.tutanota.FileDataReturnPost.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this FileDataReturnPost.
 * @return {string} The format of this FileDataReturnPost.
 */
tutao.entity.tutanota.FileDataReturnPost.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the fileData of this FileDataReturnPost.
 * @param {string} fileData The fileData of this FileDataReturnPost.
 */
tutao.entity.tutanota.FileDataReturnPost.prototype.setFileData = function(fileData) {
  this._fileData = fileData;
  return this;
};

/**
 * Provides the fileData of this FileDataReturnPost.
 * @return {string} The fileData of this FileDataReturnPost.
 */
tutao.entity.tutanota.FileDataReturnPost.prototype.getFileData = function() {
  return this._fileData;
};

/**
 * Loads the fileData of this FileDataReturnPost.
 * @return {Promise.<tutao.entity.tutanota.FileData>} Resolves to the loaded fileData of this FileDataReturnPost or an exception if the loading failed.
 */
tutao.entity.tutanota.FileDataReturnPost.prototype.loadFileData = function() {
  return tutao.entity.tutanota.FileData.load(this._fileData);
};

"use strict";

tutao.provide('tutao.entity.tutanota.FileSystem');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.FileSystem = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._shareBucketId = data.shareBucketId;
    this._symEncShareBucketKey = data.symEncShareBucketKey;
    this._files = data.files;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._shareBucketId = null;
    this._symEncShareBucketKey = null;
    this._files = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.FileSystem.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.FileSystem.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.FileSystem.PATH = '/rest/tutanota/filesystem';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.tutanota.FileSystem.ROOT_INSTANCE_ID = 'CHR1dGFub3RhABw';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.tutanota.FileSystem.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.FileSystem.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.FileSystem.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    shareBucketId: this._shareBucketId, 
    symEncShareBucketKey: this._symEncShareBucketKey, 
    files: this._files
  };
};

/**
 * The id of the FileSystem type.
 */
tutao.entity.tutanota.FileSystem.prototype.TYPE_ID = 28;

/**
 * The id of the shareBucketId attribute.
 */
tutao.entity.tutanota.FileSystem.prototype.SHAREBUCKETID_ATTRIBUTE_ID = 33;

/**
 * The id of the symEncShareBucketKey attribute.
 */
tutao.entity.tutanota.FileSystem.prototype.SYMENCSHAREBUCKETKEY_ATTRIBUTE_ID = 34;

/**
 * The id of the files attribute.
 */
tutao.entity.tutanota.FileSystem.prototype.FILES_ATTRIBUTE_ID = 35;

/**
 * Provides the id of this FileSystem.
 * @return {string} The id of this FileSystem.
 */
tutao.entity.tutanota.FileSystem.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this FileSystem.
 * @param {string} format The format of this FileSystem.
 */
tutao.entity.tutanota.FileSystem.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this FileSystem.
 * @return {string} The format of this FileSystem.
 */
tutao.entity.tutanota.FileSystem.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this FileSystem.
 * @param {string} permissions The permissions of this FileSystem.
 */
tutao.entity.tutanota.FileSystem.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this FileSystem.
 * @return {string} The permissions of this FileSystem.
 */
tutao.entity.tutanota.FileSystem.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the shareBucketId of this FileSystem.
 * @param {string} shareBucketId The shareBucketId of this FileSystem.
 */
tutao.entity.tutanota.FileSystem.prototype.setShareBucketId = function(shareBucketId) {
  this._shareBucketId = shareBucketId;
  return this;
};

/**
 * Provides the shareBucketId of this FileSystem.
 * @return {string} The shareBucketId of this FileSystem.
 */
tutao.entity.tutanota.FileSystem.prototype.getShareBucketId = function() {
  return this._shareBucketId;
};

/**
 * Sets the symEncShareBucketKey of this FileSystem.
 * @param {string} symEncShareBucketKey The symEncShareBucketKey of this FileSystem.
 */
tutao.entity.tutanota.FileSystem.prototype.setSymEncShareBucketKey = function(symEncShareBucketKey) {
  this._symEncShareBucketKey = symEncShareBucketKey;
  return this;
};

/**
 * Provides the symEncShareBucketKey of this FileSystem.
 * @return {string} The symEncShareBucketKey of this FileSystem.
 */
tutao.entity.tutanota.FileSystem.prototype.getSymEncShareBucketKey = function() {
  return this._symEncShareBucketKey;
};

/**
 * Sets the files of this FileSystem.
 * @param {string} files The files of this FileSystem.
 */
tutao.entity.tutanota.FileSystem.prototype.setFiles = function(files) {
  this._files = files;
  return this;
};

/**
 * Provides the files of this FileSystem.
 * @return {string} The files of this FileSystem.
 */
tutao.entity.tutanota.FileSystem.prototype.getFiles = function() {
  return this._files;
};

/**
 * Loads a FileSystem from the server.
 * @param {string} id The id of the FileSystem.
 * @return {Promise.<tutao.entity.tutanota.FileSystem>} Resolves to the FileSystem or an exception if the loading failed.
 */
tutao.entity.tutanota.FileSystem.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.tutanota.FileSystem, tutao.entity.tutanota.FileSystem.PATH, id, null, {"v" : 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity._entityHelper.loadSessionKey();
  });
};

/**
 * Loads multiple FileSystems from the server.
 * @param {Array.<string>} ids The ids of the FileSystems to load.
 * @return {Promise.<Array.<tutao.entity.tutanota.FileSystem>>} Resolves to an array of FileSystem or rejects with an exception if the loading failed.
 */
tutao.entity.tutanota.FileSystem.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.tutanota.FileSystem, tutao.entity.tutanota.FileSystem.PATH, ids, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return tutao.entity.EntityHelper.loadSessionKeys(entities);
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.tutanota.FileSystem.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.tutanota.FileSystem.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.tutanota.ImapFolder');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.ImapFolder = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._lastseenuid = data.lastseenuid;
    this._name = data.name;
    this._uidvalidity = data.uidvalidity;
    this._syncInfo = data.syncInfo;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._lastseenuid = null;
    this._name = null;
    this._uidvalidity = null;
    this._syncInfo = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.ImapFolder.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.ImapFolder.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    lastseenuid: this._lastseenuid, 
    name: this._name, 
    uidvalidity: this._uidvalidity, 
    syncInfo: this._syncInfo
  };
};

/**
 * The id of the ImapFolder type.
 */
tutao.entity.tutanota.ImapFolder.prototype.TYPE_ID = 190;

/**
 * The id of the lastseenuid attribute.
 */
tutao.entity.tutanota.ImapFolder.prototype.LASTSEENUID_ATTRIBUTE_ID = 193;

/**
 * The id of the name attribute.
 */
tutao.entity.tutanota.ImapFolder.prototype.NAME_ATTRIBUTE_ID = 192;

/**
 * The id of the uidvalidity attribute.
 */
tutao.entity.tutanota.ImapFolder.prototype.UIDVALIDITY_ATTRIBUTE_ID = 194;

/**
 * The id of the syncInfo attribute.
 */
tutao.entity.tutanota.ImapFolder.prototype.SYNCINFO_ATTRIBUTE_ID = 195;

/**
 * Sets the id of this ImapFolder.
 * @param {string} id The id of this ImapFolder.
 */
tutao.entity.tutanota.ImapFolder.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this ImapFolder.
 * @return {string} The id of this ImapFolder.
 */
tutao.entity.tutanota.ImapFolder.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the lastseenuid of this ImapFolder.
 * @param {string} lastseenuid The lastseenuid of this ImapFolder.
 */
tutao.entity.tutanota.ImapFolder.prototype.setLastseenuid = function(lastseenuid) {
  this._lastseenuid = lastseenuid;
  return this;
};

/**
 * Provides the lastseenuid of this ImapFolder.
 * @return {string} The lastseenuid of this ImapFolder.
 */
tutao.entity.tutanota.ImapFolder.prototype.getLastseenuid = function() {
  return this._lastseenuid;
};

/**
 * Sets the name of this ImapFolder.
 * @param {string} name The name of this ImapFolder.
 */
tutao.entity.tutanota.ImapFolder.prototype.setName = function(name) {
  this._name = name;
  return this;
};

/**
 * Provides the name of this ImapFolder.
 * @return {string} The name of this ImapFolder.
 */
tutao.entity.tutanota.ImapFolder.prototype.getName = function() {
  return this._name;
};

/**
 * Sets the uidvalidity of this ImapFolder.
 * @param {string} uidvalidity The uidvalidity of this ImapFolder.
 */
tutao.entity.tutanota.ImapFolder.prototype.setUidvalidity = function(uidvalidity) {
  this._uidvalidity = uidvalidity;
  return this;
};

/**
 * Provides the uidvalidity of this ImapFolder.
 * @return {string} The uidvalidity of this ImapFolder.
 */
tutao.entity.tutanota.ImapFolder.prototype.getUidvalidity = function() {
  return this._uidvalidity;
};

/**
 * Sets the syncInfo of this ImapFolder.
 * @param {string} syncInfo The syncInfo of this ImapFolder.
 */
tutao.entity.tutanota.ImapFolder.prototype.setSyncInfo = function(syncInfo) {
  this._syncInfo = syncInfo;
  return this;
};

/**
 * Provides the syncInfo of this ImapFolder.
 * @return {string} The syncInfo of this ImapFolder.
 */
tutao.entity.tutanota.ImapFolder.prototype.getSyncInfo = function() {
  return this._syncInfo;
};

"use strict";

tutao.provide('tutao.entity.tutanota.ImapSyncConfiguration');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.ImapSyncConfiguration = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._host = data.host;
    this._password = data.password;
    this._port = data.port;
    this._user = data.user;
    this._imapSyncState = data.imapSyncState;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._host = null;
    this._password = null;
    this._port = null;
    this._user = null;
    this._imapSyncState = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.ImapSyncConfiguration.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    host: this._host, 
    password: this._password, 
    port: this._port, 
    user: this._user, 
    imapSyncState: this._imapSyncState
  };
};

/**
 * The id of the ImapSyncConfiguration type.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.TYPE_ID = 209;

/**
 * The id of the host attribute.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.HOST_ATTRIBUTE_ID = 211;

/**
 * The id of the password attribute.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.PASSWORD_ATTRIBUTE_ID = 214;

/**
 * The id of the port attribute.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.PORT_ATTRIBUTE_ID = 212;

/**
 * The id of the user attribute.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.USER_ATTRIBUTE_ID = 213;

/**
 * The id of the imapSyncState attribute.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.IMAPSYNCSTATE_ATTRIBUTE_ID = 215;

/**
 * Sets the id of this ImapSyncConfiguration.
 * @param {string} id The id of this ImapSyncConfiguration.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this ImapSyncConfiguration.
 * @return {string} The id of this ImapSyncConfiguration.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the host of this ImapSyncConfiguration.
 * @param {string} host The host of this ImapSyncConfiguration.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.setHost = function(host) {
  this._host = host;
  return this;
};

/**
 * Provides the host of this ImapSyncConfiguration.
 * @return {string} The host of this ImapSyncConfiguration.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.getHost = function() {
  return this._host;
};

/**
 * Sets the password of this ImapSyncConfiguration.
 * @param {string} password The password of this ImapSyncConfiguration.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.setPassword = function(password) {
  this._password = password;
  return this;
};

/**
 * Provides the password of this ImapSyncConfiguration.
 * @return {string} The password of this ImapSyncConfiguration.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.getPassword = function() {
  return this._password;
};

/**
 * Sets the port of this ImapSyncConfiguration.
 * @param {string} port The port of this ImapSyncConfiguration.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.setPort = function(port) {
  this._port = port;
  return this;
};

/**
 * Provides the port of this ImapSyncConfiguration.
 * @return {string} The port of this ImapSyncConfiguration.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.getPort = function() {
  return this._port;
};

/**
 * Sets the user of this ImapSyncConfiguration.
 * @param {string} user The user of this ImapSyncConfiguration.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.setUser = function(user) {
  this._user = user;
  return this;
};

/**
 * Provides the user of this ImapSyncConfiguration.
 * @return {string} The user of this ImapSyncConfiguration.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.getUser = function() {
  return this._user;
};

/**
 * Sets the imapSyncState of this ImapSyncConfiguration.
 * @param {string} imapSyncState The imapSyncState of this ImapSyncConfiguration.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.setImapSyncState = function(imapSyncState) {
  this._imapSyncState = imapSyncState;
  return this;
};

/**
 * Provides the imapSyncState of this ImapSyncConfiguration.
 * @return {string} The imapSyncState of this ImapSyncConfiguration.
 */
tutao.entity.tutanota.ImapSyncConfiguration.prototype.getImapSyncState = function() {
  return this._imapSyncState;
};

"use strict";

tutao.provide('tutao.entity.tutanota.InitGroupData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.InitGroupData = function(data) {
  if (data) {
    this.__format = data._format;
    this._contactShareBucketEncContactListSessionKey = data.contactShareBucketEncContactListSessionKey;
    this._fileShareBucketEncFileSystemSessionKey = data.fileShareBucketEncFileSystemSessionKey;
    this._groupEncEntropy = data.groupEncEntropy;
    this._groupId = data.groupId;
    this._groupShareBucketEncExternalGroupInfoListKey = data.groupShareBucketEncExternalGroupInfoListKey;
    this._mailShareBucketEncMailBoxSessionKey = data.mailShareBucketEncMailBoxSessionKey;
    this._symEncContactListSessionKey = data.symEncContactListSessionKey;
    this._symEncContactShareBucketKey = data.symEncContactShareBucketKey;
    this._symEncExternalGroupInfoListKey = data.symEncExternalGroupInfoListKey;
    this._symEncFileShareBucketKey = data.symEncFileShareBucketKey;
    this._symEncFileSystemSessionKey = data.symEncFileSystemSessionKey;
    this._symEncGroupShareBucketKey = data.symEncGroupShareBucketKey;
    this._symEncMailBoxSessionKey = data.symEncMailBoxSessionKey;
    this._symEncMailShareBucketKey = data.symEncMailShareBucketKey;
  } else {
    this.__format = "0";
    this._contactShareBucketEncContactListSessionKey = null;
    this._fileShareBucketEncFileSystemSessionKey = null;
    this._groupEncEntropy = null;
    this._groupId = null;
    this._groupShareBucketEncExternalGroupInfoListKey = null;
    this._mailShareBucketEncMailBoxSessionKey = null;
    this._symEncContactListSessionKey = null;
    this._symEncContactShareBucketKey = null;
    this._symEncExternalGroupInfoListKey = null;
    this._symEncFileShareBucketKey = null;
    this._symEncFileSystemSessionKey = null;
    this._symEncGroupShareBucketKey = null;
    this._symEncMailBoxSessionKey = null;
    this._symEncMailShareBucketKey = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.InitGroupData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.InitGroupData.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.InitGroupData.PATH = '/rest/tutanota/initgroupservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.InitGroupData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.InitGroupData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    contactShareBucketEncContactListSessionKey: this._contactShareBucketEncContactListSessionKey, 
    fileShareBucketEncFileSystemSessionKey: this._fileShareBucketEncFileSystemSessionKey, 
    groupEncEntropy: this._groupEncEntropy, 
    groupId: this._groupId, 
    groupShareBucketEncExternalGroupInfoListKey: this._groupShareBucketEncExternalGroupInfoListKey, 
    mailShareBucketEncMailBoxSessionKey: this._mailShareBucketEncMailBoxSessionKey, 
    symEncContactListSessionKey: this._symEncContactListSessionKey, 
    symEncContactShareBucketKey: this._symEncContactShareBucketKey, 
    symEncExternalGroupInfoListKey: this._symEncExternalGroupInfoListKey, 
    symEncFileShareBucketKey: this._symEncFileShareBucketKey, 
    symEncFileSystemSessionKey: this._symEncFileSystemSessionKey, 
    symEncGroupShareBucketKey: this._symEncGroupShareBucketKey, 
    symEncMailBoxSessionKey: this._symEncMailBoxSessionKey, 
    symEncMailShareBucketKey: this._symEncMailShareBucketKey
  };
};

/**
 * The id of the InitGroupData type.
 */
tutao.entity.tutanota.InitGroupData.prototype.TYPE_ID = 385;

/**
 * The id of the contactShareBucketEncContactListSessionKey attribute.
 */
tutao.entity.tutanota.InitGroupData.prototype.CONTACTSHAREBUCKETENCCONTACTLISTSESSIONKEY_ATTRIBUTE_ID = 392;

/**
 * The id of the fileShareBucketEncFileSystemSessionKey attribute.
 */
tutao.entity.tutanota.InitGroupData.prototype.FILESHAREBUCKETENCFILESYSTEMSESSIONKEY_ATTRIBUTE_ID = 395;

/**
 * The id of the groupEncEntropy attribute.
 */
tutao.entity.tutanota.InitGroupData.prototype.GROUPENCENTROPY_ATTRIBUTE_ID = 411;

/**
 * The id of the groupId attribute.
 */
tutao.entity.tutanota.InitGroupData.prototype.GROUPID_ATTRIBUTE_ID = 387;

/**
 * The id of the groupShareBucketEncExternalGroupInfoListKey attribute.
 */
tutao.entity.tutanota.InitGroupData.prototype.GROUPSHAREBUCKETENCEXTERNALGROUPINFOLISTKEY_ATTRIBUTE_ID = 399;

/**
 * The id of the mailShareBucketEncMailBoxSessionKey attribute.
 */
tutao.entity.tutanota.InitGroupData.prototype.MAILSHAREBUCKETENCMAILBOXSESSIONKEY_ATTRIBUTE_ID = 389;

/**
 * The id of the symEncContactListSessionKey attribute.
 */
tutao.entity.tutanota.InitGroupData.prototype.SYMENCCONTACTLISTSESSIONKEY_ATTRIBUTE_ID = 391;

/**
 * The id of the symEncContactShareBucketKey attribute.
 */
tutao.entity.tutanota.InitGroupData.prototype.SYMENCCONTACTSHAREBUCKETKEY_ATTRIBUTE_ID = 393;

/**
 * The id of the symEncExternalGroupInfoListKey attribute.
 */
tutao.entity.tutanota.InitGroupData.prototype.SYMENCEXTERNALGROUPINFOLISTKEY_ATTRIBUTE_ID = 397;

/**
 * The id of the symEncFileShareBucketKey attribute.
 */
tutao.entity.tutanota.InitGroupData.prototype.SYMENCFILESHAREBUCKETKEY_ATTRIBUTE_ID = 396;

/**
 * The id of the symEncFileSystemSessionKey attribute.
 */
tutao.entity.tutanota.InitGroupData.prototype.SYMENCFILESYSTEMSESSIONKEY_ATTRIBUTE_ID = 394;

/**
 * The id of the symEncGroupShareBucketKey attribute.
 */
tutao.entity.tutanota.InitGroupData.prototype.SYMENCGROUPSHAREBUCKETKEY_ATTRIBUTE_ID = 398;

/**
 * The id of the symEncMailBoxSessionKey attribute.
 */
tutao.entity.tutanota.InitGroupData.prototype.SYMENCMAILBOXSESSIONKEY_ATTRIBUTE_ID = 388;

/**
 * The id of the symEncMailShareBucketKey attribute.
 */
tutao.entity.tutanota.InitGroupData.prototype.SYMENCMAILSHAREBUCKETKEY_ATTRIBUTE_ID = 390;

/**
 * Sets the format of this InitGroupData.
 * @param {string} format The format of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this InitGroupData.
 * @return {string} The format of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the contactShareBucketEncContactListSessionKey of this InitGroupData.
 * @param {string} contactShareBucketEncContactListSessionKey The contactShareBucketEncContactListSessionKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.setContactShareBucketEncContactListSessionKey = function(contactShareBucketEncContactListSessionKey) {
  this._contactShareBucketEncContactListSessionKey = contactShareBucketEncContactListSessionKey;
  return this;
};

/**
 * Provides the contactShareBucketEncContactListSessionKey of this InitGroupData.
 * @return {string} The contactShareBucketEncContactListSessionKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.getContactShareBucketEncContactListSessionKey = function() {
  return this._contactShareBucketEncContactListSessionKey;
};

/**
 * Sets the fileShareBucketEncFileSystemSessionKey of this InitGroupData.
 * @param {string} fileShareBucketEncFileSystemSessionKey The fileShareBucketEncFileSystemSessionKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.setFileShareBucketEncFileSystemSessionKey = function(fileShareBucketEncFileSystemSessionKey) {
  this._fileShareBucketEncFileSystemSessionKey = fileShareBucketEncFileSystemSessionKey;
  return this;
};

/**
 * Provides the fileShareBucketEncFileSystemSessionKey of this InitGroupData.
 * @return {string} The fileShareBucketEncFileSystemSessionKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.getFileShareBucketEncFileSystemSessionKey = function() {
  return this._fileShareBucketEncFileSystemSessionKey;
};

/**
 * Sets the groupEncEntropy of this InitGroupData.
 * @param {string} groupEncEntropy The groupEncEntropy of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.setGroupEncEntropy = function(groupEncEntropy) {
  this._groupEncEntropy = groupEncEntropy;
  return this;
};

/**
 * Provides the groupEncEntropy of this InitGroupData.
 * @return {string} The groupEncEntropy of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.getGroupEncEntropy = function() {
  return this._groupEncEntropy;
};

/**
 * Sets the groupId of this InitGroupData.
 * @param {string} groupId The groupId of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.setGroupId = function(groupId) {
  this._groupId = groupId;
  return this;
};

/**
 * Provides the groupId of this InitGroupData.
 * @return {string} The groupId of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.getGroupId = function() {
  return this._groupId;
};

/**
 * Sets the groupShareBucketEncExternalGroupInfoListKey of this InitGroupData.
 * @param {string} groupShareBucketEncExternalGroupInfoListKey The groupShareBucketEncExternalGroupInfoListKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.setGroupShareBucketEncExternalGroupInfoListKey = function(groupShareBucketEncExternalGroupInfoListKey) {
  this._groupShareBucketEncExternalGroupInfoListKey = groupShareBucketEncExternalGroupInfoListKey;
  return this;
};

/**
 * Provides the groupShareBucketEncExternalGroupInfoListKey of this InitGroupData.
 * @return {string} The groupShareBucketEncExternalGroupInfoListKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.getGroupShareBucketEncExternalGroupInfoListKey = function() {
  return this._groupShareBucketEncExternalGroupInfoListKey;
};

/**
 * Sets the mailShareBucketEncMailBoxSessionKey of this InitGroupData.
 * @param {string} mailShareBucketEncMailBoxSessionKey The mailShareBucketEncMailBoxSessionKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.setMailShareBucketEncMailBoxSessionKey = function(mailShareBucketEncMailBoxSessionKey) {
  this._mailShareBucketEncMailBoxSessionKey = mailShareBucketEncMailBoxSessionKey;
  return this;
};

/**
 * Provides the mailShareBucketEncMailBoxSessionKey of this InitGroupData.
 * @return {string} The mailShareBucketEncMailBoxSessionKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.getMailShareBucketEncMailBoxSessionKey = function() {
  return this._mailShareBucketEncMailBoxSessionKey;
};

/**
 * Sets the symEncContactListSessionKey of this InitGroupData.
 * @param {string} symEncContactListSessionKey The symEncContactListSessionKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.setSymEncContactListSessionKey = function(symEncContactListSessionKey) {
  this._symEncContactListSessionKey = symEncContactListSessionKey;
  return this;
};

/**
 * Provides the symEncContactListSessionKey of this InitGroupData.
 * @return {string} The symEncContactListSessionKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.getSymEncContactListSessionKey = function() {
  return this._symEncContactListSessionKey;
};

/**
 * Sets the symEncContactShareBucketKey of this InitGroupData.
 * @param {string} symEncContactShareBucketKey The symEncContactShareBucketKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.setSymEncContactShareBucketKey = function(symEncContactShareBucketKey) {
  this._symEncContactShareBucketKey = symEncContactShareBucketKey;
  return this;
};

/**
 * Provides the symEncContactShareBucketKey of this InitGroupData.
 * @return {string} The symEncContactShareBucketKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.getSymEncContactShareBucketKey = function() {
  return this._symEncContactShareBucketKey;
};

/**
 * Sets the symEncExternalGroupInfoListKey of this InitGroupData.
 * @param {string} symEncExternalGroupInfoListKey The symEncExternalGroupInfoListKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.setSymEncExternalGroupInfoListKey = function(symEncExternalGroupInfoListKey) {
  this._symEncExternalGroupInfoListKey = symEncExternalGroupInfoListKey;
  return this;
};

/**
 * Provides the symEncExternalGroupInfoListKey of this InitGroupData.
 * @return {string} The symEncExternalGroupInfoListKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.getSymEncExternalGroupInfoListKey = function() {
  return this._symEncExternalGroupInfoListKey;
};

/**
 * Sets the symEncFileShareBucketKey of this InitGroupData.
 * @param {string} symEncFileShareBucketKey The symEncFileShareBucketKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.setSymEncFileShareBucketKey = function(symEncFileShareBucketKey) {
  this._symEncFileShareBucketKey = symEncFileShareBucketKey;
  return this;
};

/**
 * Provides the symEncFileShareBucketKey of this InitGroupData.
 * @return {string} The symEncFileShareBucketKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.getSymEncFileShareBucketKey = function() {
  return this._symEncFileShareBucketKey;
};

/**
 * Sets the symEncFileSystemSessionKey of this InitGroupData.
 * @param {string} symEncFileSystemSessionKey The symEncFileSystemSessionKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.setSymEncFileSystemSessionKey = function(symEncFileSystemSessionKey) {
  this._symEncFileSystemSessionKey = symEncFileSystemSessionKey;
  return this;
};

/**
 * Provides the symEncFileSystemSessionKey of this InitGroupData.
 * @return {string} The symEncFileSystemSessionKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.getSymEncFileSystemSessionKey = function() {
  return this._symEncFileSystemSessionKey;
};

/**
 * Sets the symEncGroupShareBucketKey of this InitGroupData.
 * @param {string} symEncGroupShareBucketKey The symEncGroupShareBucketKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.setSymEncGroupShareBucketKey = function(symEncGroupShareBucketKey) {
  this._symEncGroupShareBucketKey = symEncGroupShareBucketKey;
  return this;
};

/**
 * Provides the symEncGroupShareBucketKey of this InitGroupData.
 * @return {string} The symEncGroupShareBucketKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.getSymEncGroupShareBucketKey = function() {
  return this._symEncGroupShareBucketKey;
};

/**
 * Sets the symEncMailBoxSessionKey of this InitGroupData.
 * @param {string} symEncMailBoxSessionKey The symEncMailBoxSessionKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.setSymEncMailBoxSessionKey = function(symEncMailBoxSessionKey) {
  this._symEncMailBoxSessionKey = symEncMailBoxSessionKey;
  return this;
};

/**
 * Provides the symEncMailBoxSessionKey of this InitGroupData.
 * @return {string} The symEncMailBoxSessionKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.getSymEncMailBoxSessionKey = function() {
  return this._symEncMailBoxSessionKey;
};

/**
 * Sets the symEncMailShareBucketKey of this InitGroupData.
 * @param {string} symEncMailShareBucketKey The symEncMailShareBucketKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.setSymEncMailShareBucketKey = function(symEncMailShareBucketKey) {
  this._symEncMailShareBucketKey = symEncMailShareBucketKey;
  return this;
};

/**
 * Provides the symEncMailShareBucketKey of this InitGroupData.
 * @return {string} The symEncMailShareBucketKey of this InitGroupData.
 */
tutao.entity.tutanota.InitGroupData.prototype.getSymEncMailShareBucketKey = function() {
  return this._symEncMailShareBucketKey;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.InitGroupData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.tutanota.InitGroupData.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.tutanota.Mail');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.Mail = function(data) {
  if (data) {
    this.__area = data._area;
    this.__format = data._format;
    this.__id = data._id;
    this.__listEncSessionKey = data._listEncSessionKey;
    this.__owner = data._owner;
    this.__permissions = data._permissions;
    this._receivedDate = data.receivedDate;
    this._sentDate = data.sentDate;
    this._state = data.state;
    this._subject = data.subject;
    this._trashed = data.trashed;
    this._unread = data.unread;
    this._attachments = data.attachments;
    this._bccRecipients = [];
    for (var i=0; i < data.bccRecipients.length; i++) {
      this._bccRecipients.push(new tutao.entity.tutanota.MailAddress(this, data.bccRecipients[i]));
    }
    this._body = data.body;
    this._ccRecipients = [];
    for (var i=0; i < data.ccRecipients.length; i++) {
      this._ccRecipients.push(new tutao.entity.tutanota.MailAddress(this, data.ccRecipients[i]));
    }
    this._conversationEntry = data.conversationEntry;
    this._sender = (data.sender) ? new tutao.entity.tutanota.MailAddress(this, data.sender) : null;
    this._toRecipients = [];
    for (var i=0; i < data.toRecipients.length; i++) {
      this._toRecipients.push(new tutao.entity.tutanota.MailAddress(this, data.toRecipients[i]));
    }
  } else {
    this.__area = null;
    this.__format = "0";
    this.__id = null;
    this.__listEncSessionKey = null;
    this.__owner = null;
    this.__permissions = null;
    this._receivedDate = null;
    this._sentDate = null;
    this._state = null;
    this._subject = null;
    this._trashed = null;
    this._unread = null;
    this._attachments = [];
    this._bccRecipients = [];
    this._body = null;
    this._ccRecipients = [];
    this._conversationEntry = null;
    this._sender = null;
    this._toRecipients = [];
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.Mail.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.Mail.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.Mail.PATH = '/rest/tutanota/mail';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.tutanota.Mail.ROOT_INSTANCE_ID = 'CHR1dGFub3RhAGE';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.tutanota.Mail.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.Mail.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.Mail.prototype.toJsonData = function() {
  return {
    _area: this.__area, 
    _format: this.__format, 
    _id: this.__id, 
    _listEncSessionKey: this.__listEncSessionKey, 
    _owner: this.__owner, 
    _permissions: this.__permissions, 
    receivedDate: this._receivedDate, 
    sentDate: this._sentDate, 
    state: this._state, 
    subject: this._subject, 
    trashed: this._trashed, 
    unread: this._unread, 
    attachments: this._attachments, 
    bccRecipients: tutao.entity.EntityHelper.aggregatesToJsonData(this._bccRecipients), 
    body: this._body, 
    ccRecipients: tutao.entity.EntityHelper.aggregatesToJsonData(this._ccRecipients), 
    conversationEntry: this._conversationEntry, 
    sender: tutao.entity.EntityHelper.aggregatesToJsonData(this._sender), 
    toRecipients: tutao.entity.EntityHelper.aggregatesToJsonData(this._toRecipients)
  };
};

/**
 * The id of the Mail type.
 */
tutao.entity.tutanota.Mail.prototype.TYPE_ID = 97;

/**
 * The id of the _area attribute.
 */
tutao.entity.tutanota.Mail.prototype._AREA_ATTRIBUTE_ID = 104;

/**
 * The id of the _owner attribute.
 */
tutao.entity.tutanota.Mail.prototype._OWNER_ATTRIBUTE_ID = 103;

/**
 * The id of the receivedDate attribute.
 */
tutao.entity.tutanota.Mail.prototype.RECEIVEDDATE_ATTRIBUTE_ID = 107;

/**
 * The id of the sentDate attribute.
 */
tutao.entity.tutanota.Mail.prototype.SENTDATE_ATTRIBUTE_ID = 106;

/**
 * The id of the state attribute.
 */
tutao.entity.tutanota.Mail.prototype.STATE_ATTRIBUTE_ID = 108;

/**
 * The id of the subject attribute.
 */
tutao.entity.tutanota.Mail.prototype.SUBJECT_ATTRIBUTE_ID = 105;

/**
 * The id of the trashed attribute.
 */
tutao.entity.tutanota.Mail.prototype.TRASHED_ATTRIBUTE_ID = 110;

/**
 * The id of the unread attribute.
 */
tutao.entity.tutanota.Mail.prototype.UNREAD_ATTRIBUTE_ID = 109;

/**
 * The id of the attachments attribute.
 */
tutao.entity.tutanota.Mail.prototype.ATTACHMENTS_ATTRIBUTE_ID = 115;

/**
 * The id of the bccRecipients attribute.
 */
tutao.entity.tutanota.Mail.prototype.BCCRECIPIENTS_ATTRIBUTE_ID = 114;

/**
 * The id of the body attribute.
 */
tutao.entity.tutanota.Mail.prototype.BODY_ATTRIBUTE_ID = 116;

/**
 * The id of the ccRecipients attribute.
 */
tutao.entity.tutanota.Mail.prototype.CCRECIPIENTS_ATTRIBUTE_ID = 113;

/**
 * The id of the conversationEntry attribute.
 */
tutao.entity.tutanota.Mail.prototype.CONVERSATIONENTRY_ATTRIBUTE_ID = 117;

/**
 * The id of the sender attribute.
 */
tutao.entity.tutanota.Mail.prototype.SENDER_ATTRIBUTE_ID = 111;

/**
 * The id of the toRecipients attribute.
 */
tutao.entity.tutanota.Mail.prototype.TORECIPIENTS_ATTRIBUTE_ID = 112;

/**
 * Provides the id of this Mail.
 * @return {Array.<string>} The id of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the area of this Mail.
 * @param {string} area The area of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.setArea = function(area) {
  this.__area = area;
  return this;
};

/**
 * Provides the area of this Mail.
 * @return {string} The area of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getArea = function() {
  return this.__area;
};

/**
 * Sets the format of this Mail.
 * @param {string} format The format of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this Mail.
 * @return {string} The format of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the listEncSessionKey of this Mail.
 * @param {string} listEncSessionKey The listEncSessionKey of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.setListEncSessionKey = function(listEncSessionKey) {
  this.__listEncSessionKey = listEncSessionKey;
  return this;
};

/**
 * Provides the listEncSessionKey of this Mail.
 * @return {string} The listEncSessionKey of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getListEncSessionKey = function() {
  return this.__listEncSessionKey;
};

/**
 * Sets the owner of this Mail.
 * @param {string} owner The owner of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.setOwner = function(owner) {
  this.__owner = owner;
  return this;
};

/**
 * Provides the owner of this Mail.
 * @return {string} The owner of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getOwner = function() {
  return this.__owner;
};

/**
 * Sets the permissions of this Mail.
 * @param {string} permissions The permissions of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this Mail.
 * @return {string} The permissions of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the receivedDate of this Mail.
 * @param {Date} receivedDate The receivedDate of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.setReceivedDate = function(receivedDate) {
  this._receivedDate = String(receivedDate.getTime());
  return this;
};

/**
 * Provides the receivedDate of this Mail.
 * @return {Date} The receivedDate of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getReceivedDate = function() {
  if (isNaN(this._receivedDate)) {
    throw new tutao.InvalidDataError('invalid time data: ' + this._receivedDate);
  }
  return new Date(Number(this._receivedDate));
};

/**
 * Sets the sentDate of this Mail.
 * @param {Date} sentDate The sentDate of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.setSentDate = function(sentDate) {
  this._sentDate = String(sentDate.getTime());
  return this;
};

/**
 * Provides the sentDate of this Mail.
 * @return {Date} The sentDate of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getSentDate = function() {
  if (isNaN(this._sentDate)) {
    throw new tutao.InvalidDataError('invalid time data: ' + this._sentDate);
  }
  return new Date(Number(this._sentDate));
};

/**
 * Sets the state of this Mail.
 * @param {string} state The state of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.setState = function(state) {
  this._state = state;
  return this;
};

/**
 * Provides the state of this Mail.
 * @return {string} The state of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getState = function() {
  return this._state;
};

/**
 * Sets the subject of this Mail.
 * @param {string} subject The subject of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.setSubject = function(subject) {
  var dataToEncrypt = subject;
  this._subject = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the subject of this Mail.
 * @return {string} The subject of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getSubject = function() {
  if (this._subject == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._subject);
  return value;
};

/**
 * Sets the trashed of this Mail.
 * @param {boolean} trashed The trashed of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.setTrashed = function(trashed) {
  this._trashed = trashed ? '1' : '0';
  return this;
};

/**
 * Provides the trashed of this Mail.
 * @return {boolean} The trashed of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getTrashed = function() {
  return this._trashed == '1';
};

/**
 * Sets the unread of this Mail.
 * @param {boolean} unread The unread of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.setUnread = function(unread) {
  this._unread = unread ? '1' : '0';
  return this;
};

/**
 * Provides the unread of this Mail.
 * @return {boolean} The unread of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getUnread = function() {
  return this._unread == '1';
};

/**
 * Provides the attachments of this Mail.
 * @return {Array.<Array.<string>>} The attachments of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getAttachments = function() {
  return this._attachments;
};

/**
 * Provides the bccRecipients of this Mail.
 * @return {Array.<tutao.entity.tutanota.MailAddress>} The bccRecipients of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getBccRecipients = function() {
  return this._bccRecipients;
};

/**
 * Sets the body of this Mail.
 * @param {string} body The body of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.setBody = function(body) {
  this._body = body;
  return this;
};

/**
 * Provides the body of this Mail.
 * @return {string} The body of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getBody = function() {
  return this._body;
};

/**
 * Loads the body of this Mail.
 * @return {Promise.<tutao.entity.tutanota.MailBody>} Resolves to the loaded body of this Mail or an exception if the loading failed.
 */
tutao.entity.tutanota.Mail.prototype.loadBody = function() {
  return tutao.entity.tutanota.MailBody.load(this._body);
};

/**
 * Provides the ccRecipients of this Mail.
 * @return {Array.<tutao.entity.tutanota.MailAddress>} The ccRecipients of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getCcRecipients = function() {
  return this._ccRecipients;
};

/**
 * Sets the conversationEntry of this Mail.
 * @param {Array.<string>} conversationEntry The conversationEntry of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.setConversationEntry = function(conversationEntry) {
  this._conversationEntry = conversationEntry;
  return this;
};

/**
 * Provides the conversationEntry of this Mail.
 * @return {Array.<string>} The conversationEntry of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getConversationEntry = function() {
  return this._conversationEntry;
};

/**
 * Loads the conversationEntry of this Mail.
 * @return {Promise.<tutao.entity.tutanota.ConversationEntry>} Resolves to the loaded conversationEntry of this Mail or an exception if the loading failed.
 */
tutao.entity.tutanota.Mail.prototype.loadConversationEntry = function() {
  return tutao.entity.tutanota.ConversationEntry.load(this._conversationEntry);
};

/**
 * Sets the sender of this Mail.
 * @param {tutao.entity.tutanota.MailAddress} sender The sender of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.setSender = function(sender) {
  this._sender = sender;
  return this;
};

/**
 * Provides the sender of this Mail.
 * @return {tutao.entity.tutanota.MailAddress} The sender of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getSender = function() {
  return this._sender;
};

/**
 * Provides the toRecipients of this Mail.
 * @return {Array.<tutao.entity.tutanota.MailAddress>} The toRecipients of this Mail.
 */
tutao.entity.tutanota.Mail.prototype.getToRecipients = function() {
  return this._toRecipients;
};

/**
 * Loads a Mail from the server.
 * @param {Array.<string>} id The id of the Mail.
 * @return {Promise.<tutao.entity.tutanota.Mail>} Resolves to the Mail or an exception if the loading failed.
 */
tutao.entity.tutanota.Mail.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.tutanota.Mail, tutao.entity.tutanota.Mail.PATH, id[1], id[0], {"v" : 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity._entityHelper.loadSessionKey();
  });
};

/**
 * Loads multiple Mails from the server.
 * @param {Array.<Array.<string>>} ids The ids of the Mails to load.
 * @return {Promise.<Array.<tutao.entity.tutanota.Mail>>} Resolves to an array of Mail or rejects with an exception if the loading failed.
 */
tutao.entity.tutanota.Mail.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.tutanota.Mail, tutao.entity.tutanota.Mail.PATH, ids, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return tutao.entity.EntityHelper.loadSessionKeys(entities);
  });
};

/**
 * Updates the listEncSessionKey on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.tutanota.Mail.prototype.updateListEncSessionKey = function() {
  var params = {};
  params[tutao.rest.ResourceConstants.UPDATE_LIST_ENC_SESSION_KEY] = "true";
  params["v"] = 5;
  return tutao.locator.entityRestClient.putElement(tutao.entity.tutanota.Mail.PATH, this, params, tutao.entity.EntityHelper.createAuthHeaders());
};

/**
 * Updates this Mail on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.tutanota.Mail.prototype.update = function() {
  var self = this;
  return tutao.locator.entityRestClient.putElement(tutao.entity.tutanota.Mail.PATH, this, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function() {
    self._entityHelper.notifyObservers(false);
  });
};

/**
 * Provides a  list of Mails loaded from the server.
 * @param {string} listId The list id.
 * @param {string} start Start id.
 * @param {number} count Max number of mails.
 * @param {boolean} reverse Reverse or not.
 * @return {Promise.<Array.<tutao.entity.tutanota.Mail>>} Resolves to an array of Mail or rejects with an exception if the loading failed.
 */
tutao.entity.tutanota.Mail.loadRange = function(listId, start, count, reverse) {
  return tutao.locator.entityRestClient.getElementRange(tutao.entity.tutanota.Mail, tutao.entity.tutanota.Mail.PATH, listId, start, count, reverse, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {;
    return tutao.entity.EntityHelper.loadSessionKeys(entities);
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.tutanota.Mail.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.tutanota.Mail.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.tutanota.MailAddress');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.MailAddress = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._address = data.address;
    this._name = data.name;
    this._contact = data.contact;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._address = null;
    this._name = null;
    this._contact = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.MailAddress.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.MailAddress.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    address: this._address, 
    name: this._name, 
    contact: this._contact
  };
};

/**
 * The id of the MailAddress type.
 */
tutao.entity.tutanota.MailAddress.prototype.TYPE_ID = 92;

/**
 * The id of the address attribute.
 */
tutao.entity.tutanota.MailAddress.prototype.ADDRESS_ATTRIBUTE_ID = 95;

/**
 * The id of the name attribute.
 */
tutao.entity.tutanota.MailAddress.prototype.NAME_ATTRIBUTE_ID = 94;

/**
 * The id of the contact attribute.
 */
tutao.entity.tutanota.MailAddress.prototype.CONTACT_ATTRIBUTE_ID = 96;

/**
 * Sets the id of this MailAddress.
 * @param {string} id The id of this MailAddress.
 */
tutao.entity.tutanota.MailAddress.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this MailAddress.
 * @return {string} The id of this MailAddress.
 */
tutao.entity.tutanota.MailAddress.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the address of this MailAddress.
 * @param {string} address The address of this MailAddress.
 */
tutao.entity.tutanota.MailAddress.prototype.setAddress = function(address) {
  this._address = address;
  return this;
};

/**
 * Provides the address of this MailAddress.
 * @return {string} The address of this MailAddress.
 */
tutao.entity.tutanota.MailAddress.prototype.getAddress = function() {
  return this._address;
};

/**
 * Sets the name of this MailAddress.
 * @param {string} name The name of this MailAddress.
 */
tutao.entity.tutanota.MailAddress.prototype.setName = function(name) {
  var dataToEncrypt = name;
  this._name = tutao.locator.aesCrypter.encryptUtf8(this._parent._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the name of this MailAddress.
 * @return {string} The name of this MailAddress.
 */
tutao.entity.tutanota.MailAddress.prototype.getName = function() {
  if (this._name == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._parent._entityHelper.getSessionKey(), this._name);
  return value;
};

/**
 * Sets the contact of this MailAddress.
 * @param {Array.<string>} contact The contact of this MailAddress.
 */
tutao.entity.tutanota.MailAddress.prototype.setContact = function(contact) {
  this._contact = contact;
  return this;
};

/**
 * Provides the contact of this MailAddress.
 * @return {Array.<string>} The contact of this MailAddress.
 */
tutao.entity.tutanota.MailAddress.prototype.getContact = function() {
  return this._contact;
};

/**
 * Loads the contact of this MailAddress.
 * @return {Promise.<tutao.entity.tutanota.Contact>} Resolves to the loaded contact of this MailAddress or an exception if the loading failed.
 */
tutao.entity.tutanota.MailAddress.prototype.loadContact = function() {
  return tutao.entity.tutanota.Contact.load(this._contact);
};

"use strict";

tutao.provide('tutao.entity.tutanota.MailBody');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.MailBody = function(data) {
  if (data) {
    this.__area = data._area;
    this.__format = data._format;
    this.__id = data._id;
    this.__owner = data._owner;
    this.__permissions = data._permissions;
    this._text = data.text;
  } else {
    this.__area = null;
    this.__format = "0";
    this.__id = null;
    this.__owner = null;
    this.__permissions = null;
    this._text = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.MailBody.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.MailBody.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.MailBody.PATH = '/rest/tutanota/mailbody';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.tutanota.MailBody.ROOT_INSTANCE_ID = 'CHR1dGFub3RhACQ';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.tutanota.MailBody.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.MailBody.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.MailBody.prototype.toJsonData = function() {
  return {
    _area: this.__area, 
    _format: this.__format, 
    _id: this.__id, 
    _owner: this.__owner, 
    _permissions: this.__permissions, 
    text: this._text
  };
};

/**
 * The id of the MailBody type.
 */
tutao.entity.tutanota.MailBody.prototype.TYPE_ID = 36;

/**
 * The id of the _area attribute.
 */
tutao.entity.tutanota.MailBody.prototype._AREA_ATTRIBUTE_ID = 42;

/**
 * The id of the _owner attribute.
 */
tutao.entity.tutanota.MailBody.prototype._OWNER_ATTRIBUTE_ID = 41;

/**
 * The id of the text attribute.
 */
tutao.entity.tutanota.MailBody.prototype.TEXT_ATTRIBUTE_ID = 43;

/**
 * Provides the id of this MailBody.
 * @return {string} The id of this MailBody.
 */
tutao.entity.tutanota.MailBody.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the area of this MailBody.
 * @param {string} area The area of this MailBody.
 */
tutao.entity.tutanota.MailBody.prototype.setArea = function(area) {
  this.__area = area;
  return this;
};

/**
 * Provides the area of this MailBody.
 * @return {string} The area of this MailBody.
 */
tutao.entity.tutanota.MailBody.prototype.getArea = function() {
  return this.__area;
};

/**
 * Sets the format of this MailBody.
 * @param {string} format The format of this MailBody.
 */
tutao.entity.tutanota.MailBody.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this MailBody.
 * @return {string} The format of this MailBody.
 */
tutao.entity.tutanota.MailBody.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the owner of this MailBody.
 * @param {string} owner The owner of this MailBody.
 */
tutao.entity.tutanota.MailBody.prototype.setOwner = function(owner) {
  this.__owner = owner;
  return this;
};

/**
 * Provides the owner of this MailBody.
 * @return {string} The owner of this MailBody.
 */
tutao.entity.tutanota.MailBody.prototype.getOwner = function() {
  return this.__owner;
};

/**
 * Sets the permissions of this MailBody.
 * @param {string} permissions The permissions of this MailBody.
 */
tutao.entity.tutanota.MailBody.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this MailBody.
 * @return {string} The permissions of this MailBody.
 */
tutao.entity.tutanota.MailBody.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the text of this MailBody.
 * @param {string} text The text of this MailBody.
 */
tutao.entity.tutanota.MailBody.prototype.setText = function(text) {
  var dataToEncrypt = text;
  this._text = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the text of this MailBody.
 * @return {string} The text of this MailBody.
 */
tutao.entity.tutanota.MailBody.prototype.getText = function() {
  if (this._text == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._text);
  return value;
};

/**
 * Loads a MailBody from the server.
 * @param {string} id The id of the MailBody.
 * @return {Promise.<tutao.entity.tutanota.MailBody>} Resolves to the MailBody or an exception if the loading failed.
 */
tutao.entity.tutanota.MailBody.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.tutanota.MailBody, tutao.entity.tutanota.MailBody.PATH, id, null, {"v" : 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity._entityHelper.loadSessionKey();
  });
};

/**
 * Loads multiple MailBodys from the server.
 * @param {Array.<string>} ids The ids of the MailBodys to load.
 * @return {Promise.<Array.<tutao.entity.tutanota.MailBody>>} Resolves to an array of MailBody or rejects with an exception if the loading failed.
 */
tutao.entity.tutanota.MailBody.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.tutanota.MailBody, tutao.entity.tutanota.MailBody.PATH, ids, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return tutao.entity.EntityHelper.loadSessionKeys(entities);
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.tutanota.MailBody.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.tutanota.MailBody.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.tutanota.MailBox');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.MailBox = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._shareBucketId = data.shareBucketId;
    this._symEncShareBucketKey = data.symEncShareBucketKey;
    this._mails = data.mails;
    this._receivedAttachments = data.receivedAttachments;
    this._sentAttachments = data.sentAttachments;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._shareBucketId = null;
    this._symEncShareBucketKey = null;
    this._mails = null;
    this._receivedAttachments = null;
    this._sentAttachments = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.MailBox.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.MailBox.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.MailBox.PATH = '/rest/tutanota/mailbox';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.tutanota.MailBox.ROOT_INSTANCE_ID = 'CHR1dGFub3RhAH0';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.tutanota.MailBox.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.MailBox.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.MailBox.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    shareBucketId: this._shareBucketId, 
    symEncShareBucketKey: this._symEncShareBucketKey, 
    mails: this._mails, 
    receivedAttachments: this._receivedAttachments, 
    sentAttachments: this._sentAttachments
  };
};

/**
 * The id of the MailBox type.
 */
tutao.entity.tutanota.MailBox.prototype.TYPE_ID = 125;

/**
 * The id of the shareBucketId attribute.
 */
tutao.entity.tutanota.MailBox.prototype.SHAREBUCKETID_ATTRIBUTE_ID = 130;

/**
 * The id of the symEncShareBucketKey attribute.
 */
tutao.entity.tutanota.MailBox.prototype.SYMENCSHAREBUCKETKEY_ATTRIBUTE_ID = 131;

/**
 * The id of the mails attribute.
 */
tutao.entity.tutanota.MailBox.prototype.MAILS_ATTRIBUTE_ID = 132;

/**
 * The id of the receivedAttachments attribute.
 */
tutao.entity.tutanota.MailBox.prototype.RECEIVEDATTACHMENTS_ATTRIBUTE_ID = 134;

/**
 * The id of the sentAttachments attribute.
 */
tutao.entity.tutanota.MailBox.prototype.SENTATTACHMENTS_ATTRIBUTE_ID = 133;

/**
 * Provides the id of this MailBox.
 * @return {string} The id of this MailBox.
 */
tutao.entity.tutanota.MailBox.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this MailBox.
 * @param {string} format The format of this MailBox.
 */
tutao.entity.tutanota.MailBox.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this MailBox.
 * @return {string} The format of this MailBox.
 */
tutao.entity.tutanota.MailBox.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this MailBox.
 * @param {string} permissions The permissions of this MailBox.
 */
tutao.entity.tutanota.MailBox.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this MailBox.
 * @return {string} The permissions of this MailBox.
 */
tutao.entity.tutanota.MailBox.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the shareBucketId of this MailBox.
 * @param {string} shareBucketId The shareBucketId of this MailBox.
 */
tutao.entity.tutanota.MailBox.prototype.setShareBucketId = function(shareBucketId) {
  this._shareBucketId = shareBucketId;
  return this;
};

/**
 * Provides the shareBucketId of this MailBox.
 * @return {string} The shareBucketId of this MailBox.
 */
tutao.entity.tutanota.MailBox.prototype.getShareBucketId = function() {
  return this._shareBucketId;
};

/**
 * Sets the symEncShareBucketKey of this MailBox.
 * @param {string} symEncShareBucketKey The symEncShareBucketKey of this MailBox.
 */
tutao.entity.tutanota.MailBox.prototype.setSymEncShareBucketKey = function(symEncShareBucketKey) {
  this._symEncShareBucketKey = symEncShareBucketKey;
  return this;
};

/**
 * Provides the symEncShareBucketKey of this MailBox.
 * @return {string} The symEncShareBucketKey of this MailBox.
 */
tutao.entity.tutanota.MailBox.prototype.getSymEncShareBucketKey = function() {
  return this._symEncShareBucketKey;
};

/**
 * Sets the mails of this MailBox.
 * @param {string} mails The mails of this MailBox.
 */
tutao.entity.tutanota.MailBox.prototype.setMails = function(mails) {
  this._mails = mails;
  return this;
};

/**
 * Provides the mails of this MailBox.
 * @return {string} The mails of this MailBox.
 */
tutao.entity.tutanota.MailBox.prototype.getMails = function() {
  return this._mails;
};

/**
 * Sets the receivedAttachments of this MailBox.
 * @param {string} receivedAttachments The receivedAttachments of this MailBox.
 */
tutao.entity.tutanota.MailBox.prototype.setReceivedAttachments = function(receivedAttachments) {
  this._receivedAttachments = receivedAttachments;
  return this;
};

/**
 * Provides the receivedAttachments of this MailBox.
 * @return {string} The receivedAttachments of this MailBox.
 */
tutao.entity.tutanota.MailBox.prototype.getReceivedAttachments = function() {
  return this._receivedAttachments;
};

/**
 * Sets the sentAttachments of this MailBox.
 * @param {string} sentAttachments The sentAttachments of this MailBox.
 */
tutao.entity.tutanota.MailBox.prototype.setSentAttachments = function(sentAttachments) {
  this._sentAttachments = sentAttachments;
  return this;
};

/**
 * Provides the sentAttachments of this MailBox.
 * @return {string} The sentAttachments of this MailBox.
 */
tutao.entity.tutanota.MailBox.prototype.getSentAttachments = function() {
  return this._sentAttachments;
};

/**
 * Loads a MailBox from the server.
 * @param {string} id The id of the MailBox.
 * @return {Promise.<tutao.entity.tutanota.MailBox>} Resolves to the MailBox or an exception if the loading failed.
 */
tutao.entity.tutanota.MailBox.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.tutanota.MailBox, tutao.entity.tutanota.MailBox.PATH, id, null, {"v" : 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity._entityHelper.loadSessionKey();
  });
};

/**
 * Loads multiple MailBoxs from the server.
 * @param {Array.<string>} ids The ids of the MailBoxs to load.
 * @return {Promise.<Array.<tutao.entity.tutanota.MailBox>>} Resolves to an array of MailBox or rejects with an exception if the loading failed.
 */
tutao.entity.tutanota.MailBox.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.tutanota.MailBox, tutao.entity.tutanota.MailBox.PATH, ids, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return tutao.entity.EntityHelper.loadSessionKeys(entities);
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.tutanota.MailBox.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.tutanota.MailBox.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.tutanota.MigrateToV2Data');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.MigrateToV2Data = function(data) {
  if (data) {
    this.__format = data._format;
    this._noop = data.noop;
  } else {
    this.__format = "0";
    this._noop = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.MigrateToV2Data.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.MigrateToV2Data.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.MigrateToV2Data.PATH = '/rest/tutanota/migratetov2service';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.MigrateToV2Data.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.MigrateToV2Data.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    noop: this._noop
  };
};

/**
 * The id of the MigrateToV2Data type.
 */
tutao.entity.tutanota.MigrateToV2Data.prototype.TYPE_ID = 413;

/**
 * The id of the noop attribute.
 */
tutao.entity.tutanota.MigrateToV2Data.prototype.NOOP_ATTRIBUTE_ID = 415;

/**
 * Sets the format of this MigrateToV2Data.
 * @param {string} format The format of this MigrateToV2Data.
 */
tutao.entity.tutanota.MigrateToV2Data.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this MigrateToV2Data.
 * @return {string} The format of this MigrateToV2Data.
 */
tutao.entity.tutanota.MigrateToV2Data.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the noop of this MigrateToV2Data.
 * @param {boolean} noop The noop of this MigrateToV2Data.
 */
tutao.entity.tutanota.MigrateToV2Data.prototype.setNoop = function(noop) {
  this._noop = noop ? '1' : '0';
  return this;
};

/**
 * Provides the noop of this MigrateToV2Data.
 * @return {boolean} The noop of this MigrateToV2Data.
 */
tutao.entity.tutanota.MigrateToV2Data.prototype.getNoop = function() {
  return this._noop == '1';
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.MigrateToV2Data.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.tutanota.MigrateToV2Data.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.tutanota.MigrateToV5Data');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.MigrateToV5Data = function(data) {
  if (data) {
    this.__format = data._format;
    this._noop = data.noop;
  } else {
    this.__format = "0";
    this._noop = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.MigrateToV5Data.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.MigrateToV5Data.MODEL_VERSION = '5';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.MigrateToV5Data.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.MigrateToV5Data.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    noop: this._noop
  };
};

/**
 * The id of the MigrateToV5Data type.
 */
tutao.entity.tutanota.MigrateToV5Data.prototype.TYPE_ID = 422;

/**
 * The id of the noop attribute.
 */
tutao.entity.tutanota.MigrateToV5Data.prototype.NOOP_ATTRIBUTE_ID = 424;

/**
 * Sets the format of this MigrateToV5Data.
 * @param {string} format The format of this MigrateToV5Data.
 */
tutao.entity.tutanota.MigrateToV5Data.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this MigrateToV5Data.
 * @return {string} The format of this MigrateToV5Data.
 */
tutao.entity.tutanota.MigrateToV5Data.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the noop of this MigrateToV5Data.
 * @param {boolean} noop The noop of this MigrateToV5Data.
 */
tutao.entity.tutanota.MigrateToV5Data.prototype.setNoop = function(noop) {
  this._noop = noop ? '1' : '0';
  return this;
};

/**
 * Provides the noop of this MigrateToV5Data.
 * @return {boolean} The noop of this MigrateToV5Data.
 */
tutao.entity.tutanota.MigrateToV5Data.prototype.getNoop = function() {
  return this._noop == '1';
};

"use strict";

tutao.provide('tutao.entity.tutanota.NotificationMail');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.NotificationMail = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._bodyText = data.bodyText;
    this._mailboxLink = data.mailboxLink;
    this._recipientMailAddress = data.recipientMailAddress;
    this._recipientName = data.recipientName;
    this._subject = data.subject;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._bodyText = null;
    this._mailboxLink = null;
    this._recipientMailAddress = null;
    this._recipientName = null;
    this._subject = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.NotificationMail.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.NotificationMail.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    bodyText: this._bodyText, 
    mailboxLink: this._mailboxLink, 
    recipientMailAddress: this._recipientMailAddress, 
    recipientName: this._recipientName, 
    subject: this._subject
  };
};

/**
 * The id of the NotificationMail type.
 */
tutao.entity.tutanota.NotificationMail.prototype.TYPE_ID = 223;

/**
 * The id of the bodyText attribute.
 */
tutao.entity.tutanota.NotificationMail.prototype.BODYTEXT_ATTRIBUTE_ID = 226;

/**
 * The id of the mailboxLink attribute.
 */
tutao.entity.tutanota.NotificationMail.prototype.MAILBOXLINK_ATTRIBUTE_ID = 417;

/**
 * The id of the recipientMailAddress attribute.
 */
tutao.entity.tutanota.NotificationMail.prototype.RECIPIENTMAILADDRESS_ATTRIBUTE_ID = 227;

/**
 * The id of the recipientName attribute.
 */
tutao.entity.tutanota.NotificationMail.prototype.RECIPIENTNAME_ATTRIBUTE_ID = 228;

/**
 * The id of the subject attribute.
 */
tutao.entity.tutanota.NotificationMail.prototype.SUBJECT_ATTRIBUTE_ID = 225;

/**
 * Sets the id of this NotificationMail.
 * @param {string} id The id of this NotificationMail.
 */
tutao.entity.tutanota.NotificationMail.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this NotificationMail.
 * @return {string} The id of this NotificationMail.
 */
tutao.entity.tutanota.NotificationMail.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the bodyText of this NotificationMail.
 * @param {string} bodyText The bodyText of this NotificationMail.
 */
tutao.entity.tutanota.NotificationMail.prototype.setBodyText = function(bodyText) {
  this._bodyText = bodyText;
  return this;
};

/**
 * Provides the bodyText of this NotificationMail.
 * @return {string} The bodyText of this NotificationMail.
 */
tutao.entity.tutanota.NotificationMail.prototype.getBodyText = function() {
  return this._bodyText;
};

/**
 * Sets the mailboxLink of this NotificationMail.
 * @param {string} mailboxLink The mailboxLink of this NotificationMail.
 */
tutao.entity.tutanota.NotificationMail.prototype.setMailboxLink = function(mailboxLink) {
  this._mailboxLink = mailboxLink;
  return this;
};

/**
 * Provides the mailboxLink of this NotificationMail.
 * @return {string} The mailboxLink of this NotificationMail.
 */
tutao.entity.tutanota.NotificationMail.prototype.getMailboxLink = function() {
  return this._mailboxLink;
};

/**
 * Sets the recipientMailAddress of this NotificationMail.
 * @param {string} recipientMailAddress The recipientMailAddress of this NotificationMail.
 */
tutao.entity.tutanota.NotificationMail.prototype.setRecipientMailAddress = function(recipientMailAddress) {
  this._recipientMailAddress = recipientMailAddress;
  return this;
};

/**
 * Provides the recipientMailAddress of this NotificationMail.
 * @return {string} The recipientMailAddress of this NotificationMail.
 */
tutao.entity.tutanota.NotificationMail.prototype.getRecipientMailAddress = function() {
  return this._recipientMailAddress;
};

/**
 * Sets the recipientName of this NotificationMail.
 * @param {string} recipientName The recipientName of this NotificationMail.
 */
tutao.entity.tutanota.NotificationMail.prototype.setRecipientName = function(recipientName) {
  this._recipientName = recipientName;
  return this;
};

/**
 * Provides the recipientName of this NotificationMail.
 * @return {string} The recipientName of this NotificationMail.
 */
tutao.entity.tutanota.NotificationMail.prototype.getRecipientName = function() {
  return this._recipientName;
};

/**
 * Sets the subject of this NotificationMail.
 * @param {string} subject The subject of this NotificationMail.
 */
tutao.entity.tutanota.NotificationMail.prototype.setSubject = function(subject) {
  this._subject = subject;
  return this;
};

/**
 * Provides the subject of this NotificationMail.
 * @return {string} The subject of this NotificationMail.
 */
tutao.entity.tutanota.NotificationMail.prototype.getSubject = function() {
  return this._subject;
};

"use strict";

tutao.provide('tutao.entity.tutanota.PasswordAutoAuthenticationReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.PasswordAutoAuthenticationReturn = function(data) {
  if (data) {
    this.__format = data._format;
  } else {
    this.__format = "0";
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.PasswordAutoAuthenticationReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.PasswordAutoAuthenticationReturn.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.PasswordAutoAuthenticationReturn.PATH = '/rest/tutanota/passwordautoauthenticationservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.PasswordAutoAuthenticationReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.PasswordAutoAuthenticationReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format
  };
};

/**
 * The id of the PasswordAutoAuthenticationReturn type.
 */
tutao.entity.tutanota.PasswordAutoAuthenticationReturn.prototype.TYPE_ID = 317;

/**
 * Sets the format of this PasswordAutoAuthenticationReturn.
 * @param {string} format The format of this PasswordAutoAuthenticationReturn.
 */
tutao.entity.tutanota.PasswordAutoAuthenticationReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this PasswordAutoAuthenticationReturn.
 * @return {string} The format of this PasswordAutoAuthenticationReturn.
 */
tutao.entity.tutanota.PasswordAutoAuthenticationReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Loads from the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.tutanota.PasswordAutoAuthenticationReturn>} Resolves to PasswordAutoAuthenticationReturn or an exception if the loading failed.
 */
tutao.entity.tutanota.PasswordAutoAuthenticationReturn.load = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  return tutao.locator.entityRestClient.getElement(tutao.entity.tutanota.PasswordAutoAuthenticationReturn, tutao.entity.tutanota.PasswordAutoAuthenticationReturn.PATH, null, null, parameters, headers);
};

"use strict";

tutao.provide('tutao.entity.tutanota.PasswordChannelPhoneNumber');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.PasswordChannelPhoneNumber = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._number = data.number;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._number = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.PasswordChannelPhoneNumber.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.PasswordChannelPhoneNumber.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    number: this._number
  };
};

/**
 * The id of the PasswordChannelPhoneNumber type.
 */
tutao.entity.tutanota.PasswordChannelPhoneNumber.prototype.TYPE_ID = 135;

/**
 * The id of the number attribute.
 */
tutao.entity.tutanota.PasswordChannelPhoneNumber.prototype.NUMBER_ATTRIBUTE_ID = 137;

/**
 * Sets the id of this PasswordChannelPhoneNumber.
 * @param {string} id The id of this PasswordChannelPhoneNumber.
 */
tutao.entity.tutanota.PasswordChannelPhoneNumber.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this PasswordChannelPhoneNumber.
 * @return {string} The id of this PasswordChannelPhoneNumber.
 */
tutao.entity.tutanota.PasswordChannelPhoneNumber.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the number of this PasswordChannelPhoneNumber.
 * @param {string} number The number of this PasswordChannelPhoneNumber.
 */
tutao.entity.tutanota.PasswordChannelPhoneNumber.prototype.setNumber = function(number) {
  this._number = number;
  return this;
};

/**
 * Provides the number of this PasswordChannelPhoneNumber.
 * @return {string} The number of this PasswordChannelPhoneNumber.
 */
tutao.entity.tutanota.PasswordChannelPhoneNumber.prototype.getNumber = function() {
  return this._number;
};

"use strict";

tutao.provide('tutao.entity.tutanota.PasswordChannelReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.PasswordChannelReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._phoneNumberChannels = [];
    for (var i=0; i < data.phoneNumberChannels.length; i++) {
      this._phoneNumberChannels.push(new tutao.entity.tutanota.PasswordChannelPhoneNumber(this, data.phoneNumberChannels[i]));
    }
  } else {
    this.__format = "0";
    this._phoneNumberChannels = [];
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.PasswordChannelReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.PasswordChannelReturn.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.PasswordChannelReturn.PATH = '/rest/tutanota/passwordchannelresource';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.PasswordChannelReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.PasswordChannelReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    phoneNumberChannels: tutao.entity.EntityHelper.aggregatesToJsonData(this._phoneNumberChannels)
  };
};

/**
 * The id of the PasswordChannelReturn type.
 */
tutao.entity.tutanota.PasswordChannelReturn.prototype.TYPE_ID = 327;

/**
 * The id of the phoneNumberChannels attribute.
 */
tutao.entity.tutanota.PasswordChannelReturn.prototype.PHONENUMBERCHANNELS_ATTRIBUTE_ID = 329;

/**
 * Sets the format of this PasswordChannelReturn.
 * @param {string} format The format of this PasswordChannelReturn.
 */
tutao.entity.tutanota.PasswordChannelReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this PasswordChannelReturn.
 * @return {string} The format of this PasswordChannelReturn.
 */
tutao.entity.tutanota.PasswordChannelReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Provides the phoneNumberChannels of this PasswordChannelReturn.
 * @return {Array.<tutao.entity.tutanota.PasswordChannelPhoneNumber>} The phoneNumberChannels of this PasswordChannelReturn.
 */
tutao.entity.tutanota.PasswordChannelReturn.prototype.getPhoneNumberChannels = function() {
  return this._phoneNumberChannels;
};

/**
 * Loads from the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.tutanota.PasswordChannelReturn>} Resolves to PasswordChannelReturn or an exception if the loading failed.
 */
tutao.entity.tutanota.PasswordChannelReturn.load = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  return tutao.locator.entityRestClient.getElement(tutao.entity.tutanota.PasswordChannelReturn, tutao.entity.tutanota.PasswordChannelReturn.PATH, null, null, parameters, headers);
};

"use strict";

tutao.provide('tutao.entity.tutanota.PasswordMessagingData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.PasswordMessagingData = function(data) {
  if (data) {
    this.__format = data._format;
    this._language = data.language;
    this._numberId = data.numberId;
    this._symKeyForPasswordTransmission = data.symKeyForPasswordTransmission;
  } else {
    this.__format = "0";
    this._language = null;
    this._numberId = null;
    this._symKeyForPasswordTransmission = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.PasswordMessagingData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.PasswordMessagingData.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.PasswordMessagingData.PATH = '/rest/tutanota/passwordmessagingservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.PasswordMessagingData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.PasswordMessagingData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    language: this._language, 
    numberId: this._numberId, 
    symKeyForPasswordTransmission: this._symKeyForPasswordTransmission
  };
};

/**
 * The id of the PasswordMessagingData type.
 */
tutao.entity.tutanota.PasswordMessagingData.prototype.TYPE_ID = 308;

/**
 * The id of the language attribute.
 */
tutao.entity.tutanota.PasswordMessagingData.prototype.LANGUAGE_ATTRIBUTE_ID = 310;

/**
 * The id of the numberId attribute.
 */
tutao.entity.tutanota.PasswordMessagingData.prototype.NUMBERID_ATTRIBUTE_ID = 311;

/**
 * The id of the symKeyForPasswordTransmission attribute.
 */
tutao.entity.tutanota.PasswordMessagingData.prototype.SYMKEYFORPASSWORDTRANSMISSION_ATTRIBUTE_ID = 312;

/**
 * Sets the format of this PasswordMessagingData.
 * @param {string} format The format of this PasswordMessagingData.
 */
tutao.entity.tutanota.PasswordMessagingData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this PasswordMessagingData.
 * @return {string} The format of this PasswordMessagingData.
 */
tutao.entity.tutanota.PasswordMessagingData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the language of this PasswordMessagingData.
 * @param {string} language The language of this PasswordMessagingData.
 */
tutao.entity.tutanota.PasswordMessagingData.prototype.setLanguage = function(language) {
  this._language = language;
  return this;
};

/**
 * Provides the language of this PasswordMessagingData.
 * @return {string} The language of this PasswordMessagingData.
 */
tutao.entity.tutanota.PasswordMessagingData.prototype.getLanguage = function() {
  return this._language;
};

/**
 * Sets the numberId of this PasswordMessagingData.
 * @param {string} numberId The numberId of this PasswordMessagingData.
 */
tutao.entity.tutanota.PasswordMessagingData.prototype.setNumberId = function(numberId) {
  this._numberId = numberId;
  return this;
};

/**
 * Provides the numberId of this PasswordMessagingData.
 * @return {string} The numberId of this PasswordMessagingData.
 */
tutao.entity.tutanota.PasswordMessagingData.prototype.getNumberId = function() {
  return this._numberId;
};

/**
 * Sets the symKeyForPasswordTransmission of this PasswordMessagingData.
 * @param {string} symKeyForPasswordTransmission The symKeyForPasswordTransmission of this PasswordMessagingData.
 */
tutao.entity.tutanota.PasswordMessagingData.prototype.setSymKeyForPasswordTransmission = function(symKeyForPasswordTransmission) {
  this._symKeyForPasswordTransmission = symKeyForPasswordTransmission;
  return this;
};

/**
 * Provides the symKeyForPasswordTransmission of this PasswordMessagingData.
 * @return {string} The symKeyForPasswordTransmission of this PasswordMessagingData.
 */
tutao.entity.tutanota.PasswordMessagingData.prototype.getSymKeyForPasswordTransmission = function() {
  return this._symKeyForPasswordTransmission;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.tutanota.PasswordMessagingReturn=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.PasswordMessagingData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.tutanota.PasswordMessagingData.PATH, this, parameters, headers, tutao.entity.tutanota.PasswordMessagingReturn);
};

"use strict";

tutao.provide('tutao.entity.tutanota.PasswordMessagingReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.PasswordMessagingReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._autoAuthenticationId = data.autoAuthenticationId;
  } else {
    this.__format = "0";
    this._autoAuthenticationId = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.PasswordMessagingReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.PasswordMessagingReturn.MODEL_VERSION = '5';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.PasswordMessagingReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.PasswordMessagingReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    autoAuthenticationId: this._autoAuthenticationId
  };
};

/**
 * The id of the PasswordMessagingReturn type.
 */
tutao.entity.tutanota.PasswordMessagingReturn.prototype.TYPE_ID = 313;

/**
 * The id of the autoAuthenticationId attribute.
 */
tutao.entity.tutanota.PasswordMessagingReturn.prototype.AUTOAUTHENTICATIONID_ATTRIBUTE_ID = 315;

/**
 * Sets the format of this PasswordMessagingReturn.
 * @param {string} format The format of this PasswordMessagingReturn.
 */
tutao.entity.tutanota.PasswordMessagingReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this PasswordMessagingReturn.
 * @return {string} The format of this PasswordMessagingReturn.
 */
tutao.entity.tutanota.PasswordMessagingReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the autoAuthenticationId of this PasswordMessagingReturn.
 * @param {string} autoAuthenticationId The autoAuthenticationId of this PasswordMessagingReturn.
 */
tutao.entity.tutanota.PasswordMessagingReturn.prototype.setAutoAuthenticationId = function(autoAuthenticationId) {
  this._autoAuthenticationId = autoAuthenticationId;
  return this;
};

/**
 * Provides the autoAuthenticationId of this PasswordMessagingReturn.
 * @return {string} The autoAuthenticationId of this PasswordMessagingReturn.
 */
tutao.entity.tutanota.PasswordMessagingReturn.prototype.getAutoAuthenticationId = function() {
  return this._autoAuthenticationId;
};

"use strict";

tutao.provide('tutao.entity.tutanota.PasswordRetrievalData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.PasswordRetrievalData = function(data) {
  if (data) {
    this.__format = data._format;
    this._autoAuthenticationId = data.autoAuthenticationId;
  } else {
    this.__format = "0";
    this._autoAuthenticationId = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.PasswordRetrievalData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.PasswordRetrievalData.MODEL_VERSION = '5';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.PasswordRetrievalData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.PasswordRetrievalData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    autoAuthenticationId: this._autoAuthenticationId
  };
};

/**
 * The id of the PasswordRetrievalData type.
 */
tutao.entity.tutanota.PasswordRetrievalData.prototype.TYPE_ID = 320;

/**
 * The id of the autoAuthenticationId attribute.
 */
tutao.entity.tutanota.PasswordRetrievalData.prototype.AUTOAUTHENTICATIONID_ATTRIBUTE_ID = 322;

/**
 * Sets the format of this PasswordRetrievalData.
 * @param {string} format The format of this PasswordRetrievalData.
 */
tutao.entity.tutanota.PasswordRetrievalData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this PasswordRetrievalData.
 * @return {string} The format of this PasswordRetrievalData.
 */
tutao.entity.tutanota.PasswordRetrievalData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the autoAuthenticationId of this PasswordRetrievalData.
 * @param {string} autoAuthenticationId The autoAuthenticationId of this PasswordRetrievalData.
 */
tutao.entity.tutanota.PasswordRetrievalData.prototype.setAutoAuthenticationId = function(autoAuthenticationId) {
  this._autoAuthenticationId = autoAuthenticationId;
  return this;
};

/**
 * Provides the autoAuthenticationId of this PasswordRetrievalData.
 * @return {string} The autoAuthenticationId of this PasswordRetrievalData.
 */
tutao.entity.tutanota.PasswordRetrievalData.prototype.getAutoAuthenticationId = function() {
  return this._autoAuthenticationId;
};

"use strict";

tutao.provide('tutao.entity.tutanota.PasswordRetrievalReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.PasswordRetrievalReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._transmissionKeyEncryptedPassword = data.transmissionKeyEncryptedPassword;
  } else {
    this.__format = "0";
    this._transmissionKeyEncryptedPassword = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.PasswordRetrievalReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.PasswordRetrievalReturn.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.PasswordRetrievalReturn.PATH = '/rest/tutanota/passwordretrievalservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.PasswordRetrievalReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.PasswordRetrievalReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    transmissionKeyEncryptedPassword: this._transmissionKeyEncryptedPassword
  };
};

/**
 * The id of the PasswordRetrievalReturn type.
 */
tutao.entity.tutanota.PasswordRetrievalReturn.prototype.TYPE_ID = 323;

/**
 * The id of the transmissionKeyEncryptedPassword attribute.
 */
tutao.entity.tutanota.PasswordRetrievalReturn.prototype.TRANSMISSIONKEYENCRYPTEDPASSWORD_ATTRIBUTE_ID = 325;

/**
 * Sets the format of this PasswordRetrievalReturn.
 * @param {string} format The format of this PasswordRetrievalReturn.
 */
tutao.entity.tutanota.PasswordRetrievalReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this PasswordRetrievalReturn.
 * @return {string} The format of this PasswordRetrievalReturn.
 */
tutao.entity.tutanota.PasswordRetrievalReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the transmissionKeyEncryptedPassword of this PasswordRetrievalReturn.
 * @param {string} transmissionKeyEncryptedPassword The transmissionKeyEncryptedPassword of this PasswordRetrievalReturn.
 */
tutao.entity.tutanota.PasswordRetrievalReturn.prototype.setTransmissionKeyEncryptedPassword = function(transmissionKeyEncryptedPassword) {
  this._transmissionKeyEncryptedPassword = transmissionKeyEncryptedPassword;
  return this;
};

/**
 * Provides the transmissionKeyEncryptedPassword of this PasswordRetrievalReturn.
 * @return {string} The transmissionKeyEncryptedPassword of this PasswordRetrievalReturn.
 */
tutao.entity.tutanota.PasswordRetrievalReturn.prototype.getTransmissionKeyEncryptedPassword = function() {
  return this._transmissionKeyEncryptedPassword;
};

/**
 * Loads from the service.
 * @param {tutao.entity.tutanota.PasswordRetrievalData} entity The entity to send to the service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.tutanota.PasswordRetrievalReturn>} Resolves to PasswordRetrievalReturn or an exception if the loading failed.
 */
tutao.entity.tutanota.PasswordRetrievalReturn.load = function(entity, parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  return tutao.locator.entityRestClient.getService(tutao.entity.tutanota.PasswordRetrievalReturn, tutao.entity.tutanota.PasswordRetrievalReturn.PATH, entity, parameters, headers);
};

"use strict";

tutao.provide('tutao.entity.tutanota.Recipient');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.Recipient = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._autoTransmitPassword = data.autoTransmitPassword;
    this._mailAddress = data.mailAddress;
    this._name = data.name;
    this._passwordVerifier = data.passwordVerifier;
    this._pubEncBucketKey = data.pubEncBucketKey;
    this._pubKeyVersion = data.pubKeyVersion;
    this._pwEncCommunicationKey = data.pwEncCommunicationKey;
    this._salt = data.salt;
    this._saltHash = data.saltHash;
    this._symEncBucketKey = data.symEncBucketKey;
    this._type = data.type;
    this._passwordChannelPhoneNumbers = [];
    for (var i=0; i < data.passwordChannelPhoneNumbers.length; i++) {
      this._passwordChannelPhoneNumbers.push(new tutao.entity.tutanota.PasswordChannelPhoneNumber(parent, data.passwordChannelPhoneNumbers[i]));
    }
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._autoTransmitPassword = null;
    this._mailAddress = null;
    this._name = null;
    this._passwordVerifier = null;
    this._pubEncBucketKey = null;
    this._pubKeyVersion = null;
    this._pwEncCommunicationKey = null;
    this._salt = null;
    this._saltHash = null;
    this._symEncBucketKey = null;
    this._type = null;
    this._passwordChannelPhoneNumbers = [];
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.Recipient.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.Recipient.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    autoTransmitPassword: this._autoTransmitPassword, 
    mailAddress: this._mailAddress, 
    name: this._name, 
    passwordVerifier: this._passwordVerifier, 
    pubEncBucketKey: this._pubEncBucketKey, 
    pubKeyVersion: this._pubKeyVersion, 
    pwEncCommunicationKey: this._pwEncCommunicationKey, 
    salt: this._salt, 
    saltHash: this._saltHash, 
    symEncBucketKey: this._symEncBucketKey, 
    type: this._type, 
    passwordChannelPhoneNumbers: tutao.entity.EntityHelper.aggregatesToJsonData(this._passwordChannelPhoneNumbers)
  };
};

/**
 * The id of the Recipient type.
 */
tutao.entity.tutanota.Recipient.prototype.TYPE_ID = 161;

/**
 * The id of the autoTransmitPassword attribute.
 */
tutao.entity.tutanota.Recipient.prototype.AUTOTRANSMITPASSWORD_ATTRIBUTE_ID = 170;

/**
 * The id of the mailAddress attribute.
 */
tutao.entity.tutanota.Recipient.prototype.MAILADDRESS_ATTRIBUTE_ID = 165;

/**
 * The id of the name attribute.
 */
tutao.entity.tutanota.Recipient.prototype.NAME_ATTRIBUTE_ID = 164;

/**
 * The id of the passwordVerifier attribute.
 */
tutao.entity.tutanota.Recipient.prototype.PASSWORDVERIFIER_ATTRIBUTE_ID = 169;

/**
 * The id of the pubEncBucketKey attribute.
 */
tutao.entity.tutanota.Recipient.prototype.PUBENCBUCKETKEY_ATTRIBUTE_ID = 166;

/**
 * The id of the pubKeyVersion attribute.
 */
tutao.entity.tutanota.Recipient.prototype.PUBKEYVERSION_ATTRIBUTE_ID = 167;

/**
 * The id of the pwEncCommunicationKey attribute.
 */
tutao.entity.tutanota.Recipient.prototype.PWENCCOMMUNICATIONKEY_ATTRIBUTE_ID = 173;

/**
 * The id of the salt attribute.
 */
tutao.entity.tutanota.Recipient.prototype.SALT_ATTRIBUTE_ID = 171;

/**
 * The id of the saltHash attribute.
 */
tutao.entity.tutanota.Recipient.prototype.SALTHASH_ATTRIBUTE_ID = 172;

/**
 * The id of the symEncBucketKey attribute.
 */
tutao.entity.tutanota.Recipient.prototype.SYMENCBUCKETKEY_ATTRIBUTE_ID = 168;

/**
 * The id of the type attribute.
 */
tutao.entity.tutanota.Recipient.prototype.TYPE_ATTRIBUTE_ID = 163;

/**
 * The id of the passwordChannelPhoneNumbers attribute.
 */
tutao.entity.tutanota.Recipient.prototype.PASSWORDCHANNELPHONENUMBERS_ATTRIBUTE_ID = 174;

/**
 * Sets the id of this Recipient.
 * @param {string} id The id of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this Recipient.
 * @return {string} The id of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the autoTransmitPassword of this Recipient.
 * @param {string} autoTransmitPassword The autoTransmitPassword of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.setAutoTransmitPassword = function(autoTransmitPassword) {
  this._autoTransmitPassword = autoTransmitPassword;
  return this;
};

/**
 * Provides the autoTransmitPassword of this Recipient.
 * @return {string} The autoTransmitPassword of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.getAutoTransmitPassword = function() {
  return this._autoTransmitPassword;
};

/**
 * Sets the mailAddress of this Recipient.
 * @param {string} mailAddress The mailAddress of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.setMailAddress = function(mailAddress) {
  this._mailAddress = mailAddress;
  return this;
};

/**
 * Provides the mailAddress of this Recipient.
 * @return {string} The mailAddress of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.getMailAddress = function() {
  return this._mailAddress;
};

/**
 * Sets the name of this Recipient.
 * @param {string} name The name of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.setName = function(name) {
  var dataToEncrypt = name;
  this._name = tutao.locator.aesCrypter.encryptUtf8(this._parent._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the name of this Recipient.
 * @return {string} The name of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.getName = function() {
  if (this._name == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._parent._entityHelper.getSessionKey(), this._name);
  return value;
};

/**
 * Sets the passwordVerifier of this Recipient.
 * @param {string} passwordVerifier The passwordVerifier of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.setPasswordVerifier = function(passwordVerifier) {
  this._passwordVerifier = passwordVerifier;
  return this;
};

/**
 * Provides the passwordVerifier of this Recipient.
 * @return {string} The passwordVerifier of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.getPasswordVerifier = function() {
  return this._passwordVerifier;
};

/**
 * Sets the pubEncBucketKey of this Recipient.
 * @param {string} pubEncBucketKey The pubEncBucketKey of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.setPubEncBucketKey = function(pubEncBucketKey) {
  this._pubEncBucketKey = pubEncBucketKey;
  return this;
};

/**
 * Provides the pubEncBucketKey of this Recipient.
 * @return {string} The pubEncBucketKey of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.getPubEncBucketKey = function() {
  return this._pubEncBucketKey;
};

/**
 * Sets the pubKeyVersion of this Recipient.
 * @param {string} pubKeyVersion The pubKeyVersion of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.setPubKeyVersion = function(pubKeyVersion) {
  this._pubKeyVersion = pubKeyVersion;
  return this;
};

/**
 * Provides the pubKeyVersion of this Recipient.
 * @return {string} The pubKeyVersion of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.getPubKeyVersion = function() {
  return this._pubKeyVersion;
};

/**
 * Sets the pwEncCommunicationKey of this Recipient.
 * @param {string} pwEncCommunicationKey The pwEncCommunicationKey of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.setPwEncCommunicationKey = function(pwEncCommunicationKey) {
  this._pwEncCommunicationKey = pwEncCommunicationKey;
  return this;
};

/**
 * Provides the pwEncCommunicationKey of this Recipient.
 * @return {string} The pwEncCommunicationKey of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.getPwEncCommunicationKey = function() {
  return this._pwEncCommunicationKey;
};

/**
 * Sets the salt of this Recipient.
 * @param {string} salt The salt of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.setSalt = function(salt) {
  this._salt = salt;
  return this;
};

/**
 * Provides the salt of this Recipient.
 * @return {string} The salt of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.getSalt = function() {
  return this._salt;
};

/**
 * Sets the saltHash of this Recipient.
 * @param {string} saltHash The saltHash of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.setSaltHash = function(saltHash) {
  this._saltHash = saltHash;
  return this;
};

/**
 * Provides the saltHash of this Recipient.
 * @return {string} The saltHash of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.getSaltHash = function() {
  return this._saltHash;
};

/**
 * Sets the symEncBucketKey of this Recipient.
 * @param {string} symEncBucketKey The symEncBucketKey of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.setSymEncBucketKey = function(symEncBucketKey) {
  this._symEncBucketKey = symEncBucketKey;
  return this;
};

/**
 * Provides the symEncBucketKey of this Recipient.
 * @return {string} The symEncBucketKey of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.getSymEncBucketKey = function() {
  return this._symEncBucketKey;
};

/**
 * Sets the type of this Recipient.
 * @param {string} type The type of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.setType = function(type) {
  this._type = type;
  return this;
};

/**
 * Provides the type of this Recipient.
 * @return {string} The type of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.getType = function() {
  return this._type;
};

/**
 * Provides the passwordChannelPhoneNumbers of this Recipient.
 * @return {Array.<tutao.entity.tutanota.PasswordChannelPhoneNumber>} The passwordChannelPhoneNumbers of this Recipient.
 */
tutao.entity.tutanota.Recipient.prototype.getPasswordChannelPhoneNumbers = function() {
  return this._passwordChannelPhoneNumbers;
};

"use strict";

tutao.provide('tutao.entity.tutanota.SendMailData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.SendMailData = function(data) {
  if (data) {
    this.__format = data._format;
    this._bodyText = data.bodyText;
    this._bucketEncSessionKey = data.bucketEncSessionKey;
    this._conversationType = data.conversationType;
    this._language = data.language;
    this._listEncSessionKey = data.listEncSessionKey;
    this._previousMessageId = data.previousMessageId;
    this._senderName = data.senderName;
    this._senderNameUnencrypted = data.senderNameUnencrypted;
    this._sharableEncSessionKey = data.sharableEncSessionKey;
    this._subject = data.subject;
    this._symEncSessionKey = data.symEncSessionKey;
    this._attachments = [];
    for (var i=0; i < data.attachments.length; i++) {
      this._attachments.push(new tutao.entity.tutanota.Attachment(this, data.attachments[i]));
    }
    this._bccRecipients = [];
    for (var i=0; i < data.bccRecipients.length; i++) {
      this._bccRecipients.push(new tutao.entity.tutanota.Recipient(this, data.bccRecipients[i]));
    }
    this._ccRecipients = [];
    for (var i=0; i < data.ccRecipients.length; i++) {
      this._ccRecipients.push(new tutao.entity.tutanota.Recipient(this, data.ccRecipients[i]));
    }
    this._toRecipients = [];
    for (var i=0; i < data.toRecipients.length; i++) {
      this._toRecipients.push(new tutao.entity.tutanota.Recipient(this, data.toRecipients[i]));
    }
  } else {
    this.__format = "0";
    this._bodyText = null;
    this._bucketEncSessionKey = null;
    this._conversationType = null;
    this._language = null;
    this._listEncSessionKey = null;
    this._previousMessageId = null;
    this._senderName = null;
    this._senderNameUnencrypted = null;
    this._sharableEncSessionKey = null;
    this._subject = null;
    this._symEncSessionKey = null;
    this._attachments = [];
    this._bccRecipients = [];
    this._ccRecipients = [];
    this._toRecipients = [];
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.SendMailData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.SendMailData.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.SendMailData.PATH = '/rest/tutanota/mailservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.SendMailData.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.SendMailData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    bodyText: this._bodyText, 
    bucketEncSessionKey: this._bucketEncSessionKey, 
    conversationType: this._conversationType, 
    language: this._language, 
    listEncSessionKey: this._listEncSessionKey, 
    previousMessageId: this._previousMessageId, 
    senderName: this._senderName, 
    senderNameUnencrypted: this._senderNameUnencrypted, 
    sharableEncSessionKey: this._sharableEncSessionKey, 
    subject: this._subject, 
    symEncSessionKey: this._symEncSessionKey, 
    attachments: tutao.entity.EntityHelper.aggregatesToJsonData(this._attachments), 
    bccRecipients: tutao.entity.EntityHelper.aggregatesToJsonData(this._bccRecipients), 
    ccRecipients: tutao.entity.EntityHelper.aggregatesToJsonData(this._ccRecipients), 
    toRecipients: tutao.entity.EntityHelper.aggregatesToJsonData(this._toRecipients)
  };
};

/**
 * The id of the SendMailData type.
 */
tutao.entity.tutanota.SendMailData.prototype.TYPE_ID = 229;

/**
 * The id of the bodyText attribute.
 */
tutao.entity.tutanota.SendMailData.prototype.BODYTEXT_ATTRIBUTE_ID = 233;

/**
 * The id of the bucketEncSessionKey attribute.
 */
tutao.entity.tutanota.SendMailData.prototype.BUCKETENCSESSIONKEY_ATTRIBUTE_ID = 241;

/**
 * The id of the conversationType attribute.
 */
tutao.entity.tutanota.SendMailData.prototype.CONVERSATIONTYPE_ATTRIBUTE_ID = 237;

/**
 * The id of the language attribute.
 */
tutao.entity.tutanota.SendMailData.prototype.LANGUAGE_ATTRIBUTE_ID = 231;

/**
 * The id of the listEncSessionKey attribute.
 */
tutao.entity.tutanota.SendMailData.prototype.LISTENCSESSIONKEY_ATTRIBUTE_ID = 238;

/**
 * The id of the previousMessageId attribute.
 */
tutao.entity.tutanota.SendMailData.prototype.PREVIOUSMESSAGEID_ATTRIBUTE_ID = 236;

/**
 * The id of the senderName attribute.
 */
tutao.entity.tutanota.SendMailData.prototype.SENDERNAME_ATTRIBUTE_ID = 234;

/**
 * The id of the senderNameUnencrypted attribute.
 */
tutao.entity.tutanota.SendMailData.prototype.SENDERNAMEUNENCRYPTED_ATTRIBUTE_ID = 235;

/**
 * The id of the sharableEncSessionKey attribute.
 */
tutao.entity.tutanota.SendMailData.prototype.SHARABLEENCSESSIONKEY_ATTRIBUTE_ID = 240;

/**
 * The id of the subject attribute.
 */
tutao.entity.tutanota.SendMailData.prototype.SUBJECT_ATTRIBUTE_ID = 232;

/**
 * The id of the symEncSessionKey attribute.
 */
tutao.entity.tutanota.SendMailData.prototype.SYMENCSESSIONKEY_ATTRIBUTE_ID = 239;

/**
 * The id of the attachments attribute.
 */
tutao.entity.tutanota.SendMailData.prototype.ATTACHMENTS_ATTRIBUTE_ID = 245;

/**
 * The id of the bccRecipients attribute.
 */
tutao.entity.tutanota.SendMailData.prototype.BCCRECIPIENTS_ATTRIBUTE_ID = 244;

/**
 * The id of the ccRecipients attribute.
 */
tutao.entity.tutanota.SendMailData.prototype.CCRECIPIENTS_ATTRIBUTE_ID = 243;

/**
 * The id of the toRecipients attribute.
 */
tutao.entity.tutanota.SendMailData.prototype.TORECIPIENTS_ATTRIBUTE_ID = 242;

/**
 * Sets the format of this SendMailData.
 * @param {string} format The format of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this SendMailData.
 * @return {string} The format of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the bodyText of this SendMailData.
 * @param {string} bodyText The bodyText of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.setBodyText = function(bodyText) {
  var dataToEncrypt = bodyText;
  this._bodyText = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the bodyText of this SendMailData.
 * @return {string} The bodyText of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getBodyText = function() {
  if (this._bodyText == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._bodyText);
  return value;
};

/**
 * Sets the bucketEncSessionKey of this SendMailData.
 * @param {string} bucketEncSessionKey The bucketEncSessionKey of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.setBucketEncSessionKey = function(bucketEncSessionKey) {
  this._bucketEncSessionKey = bucketEncSessionKey;
  return this;
};

/**
 * Provides the bucketEncSessionKey of this SendMailData.
 * @return {string} The bucketEncSessionKey of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getBucketEncSessionKey = function() {
  return this._bucketEncSessionKey;
};

/**
 * Sets the conversationType of this SendMailData.
 * @param {string} conversationType The conversationType of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.setConversationType = function(conversationType) {
  this._conversationType = conversationType;
  return this;
};

/**
 * Provides the conversationType of this SendMailData.
 * @return {string} The conversationType of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getConversationType = function() {
  return this._conversationType;
};

/**
 * Sets the language of this SendMailData.
 * @param {string} language The language of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.setLanguage = function(language) {
  this._language = language;
  return this;
};

/**
 * Provides the language of this SendMailData.
 * @return {string} The language of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getLanguage = function() {
  return this._language;
};

/**
 * Sets the listEncSessionKey of this SendMailData.
 * @param {string} listEncSessionKey The listEncSessionKey of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.setListEncSessionKey = function(listEncSessionKey) {
  this._listEncSessionKey = listEncSessionKey;
  return this;
};

/**
 * Provides the listEncSessionKey of this SendMailData.
 * @return {string} The listEncSessionKey of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getListEncSessionKey = function() {
  return this._listEncSessionKey;
};

/**
 * Sets the previousMessageId of this SendMailData.
 * @param {string} previousMessageId The previousMessageId of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.setPreviousMessageId = function(previousMessageId) {
  this._previousMessageId = previousMessageId;
  return this;
};

/**
 * Provides the previousMessageId of this SendMailData.
 * @return {string} The previousMessageId of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getPreviousMessageId = function() {
  return this._previousMessageId;
};

/**
 * Sets the senderName of this SendMailData.
 * @param {string} senderName The senderName of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.setSenderName = function(senderName) {
  var dataToEncrypt = senderName;
  this._senderName = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the senderName of this SendMailData.
 * @return {string} The senderName of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getSenderName = function() {
  if (this._senderName == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._senderName);
  return value;
};

/**
 * Sets the senderNameUnencrypted of this SendMailData.
 * @param {string} senderNameUnencrypted The senderNameUnencrypted of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.setSenderNameUnencrypted = function(senderNameUnencrypted) {
  this._senderNameUnencrypted = senderNameUnencrypted;
  return this;
};

/**
 * Provides the senderNameUnencrypted of this SendMailData.
 * @return {string} The senderNameUnencrypted of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getSenderNameUnencrypted = function() {
  return this._senderNameUnencrypted;
};

/**
 * Sets the sharableEncSessionKey of this SendMailData.
 * @param {string} sharableEncSessionKey The sharableEncSessionKey of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.setSharableEncSessionKey = function(sharableEncSessionKey) {
  this._sharableEncSessionKey = sharableEncSessionKey;
  return this;
};

/**
 * Provides the sharableEncSessionKey of this SendMailData.
 * @return {string} The sharableEncSessionKey of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getSharableEncSessionKey = function() {
  return this._sharableEncSessionKey;
};

/**
 * Sets the subject of this SendMailData.
 * @param {string} subject The subject of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.setSubject = function(subject) {
  var dataToEncrypt = subject;
  this._subject = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the subject of this SendMailData.
 * @return {string} The subject of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getSubject = function() {
  if (this._subject == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._subject);
  return value;
};

/**
 * Sets the symEncSessionKey of this SendMailData.
 * @param {string} symEncSessionKey The symEncSessionKey of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.setSymEncSessionKey = function(symEncSessionKey) {
  this._symEncSessionKey = symEncSessionKey;
  return this;
};

/**
 * Provides the symEncSessionKey of this SendMailData.
 * @return {string} The symEncSessionKey of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getSymEncSessionKey = function() {
  return this._symEncSessionKey;
};

/**
 * Provides the attachments of this SendMailData.
 * @return {Array.<tutao.entity.tutanota.Attachment>} The attachments of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getAttachments = function() {
  return this._attachments;
};

/**
 * Provides the bccRecipients of this SendMailData.
 * @return {Array.<tutao.entity.tutanota.Recipient>} The bccRecipients of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getBccRecipients = function() {
  return this._bccRecipients;
};

/**
 * Provides the ccRecipients of this SendMailData.
 * @return {Array.<tutao.entity.tutanota.Recipient>} The ccRecipients of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getCcRecipients = function() {
  return this._ccRecipients;
};

/**
 * Provides the toRecipients of this SendMailData.
 * @return {Array.<tutao.entity.tutanota.Recipient>} The toRecipients of this SendMailData.
 */
tutao.entity.tutanota.SendMailData.prototype.getToRecipients = function() {
  return this._toRecipients;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.tutanota.SendMailReturn=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.SendMailData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.tutanota.SendMailData.PATH, this, parameters, headers, tutao.entity.tutanota.SendMailReturn);
};

"use strict";

tutao.provide('tutao.entity.tutanota.SendMailFromExternalData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.SendMailFromExternalData = function(data) {
  if (data) {
    this.__format = data._format;
    this._bodyText = data.bodyText;
    this._language = data.language;
    this._previousMessageId = data.previousMessageId;
    this._recipientBucketEncSessionKey = data.recipientBucketEncSessionKey;
    this._senderBucketEncSessionKey = data.senderBucketEncSessionKey;
    this._senderName = data.senderName;
    this._senderSymEncBucketKey = data.senderSymEncBucketKey;
    this._subject = data.subject;
    this._attachments = [];
    for (var i=0; i < data.attachments.length; i++) {
      this._attachments.push(new tutao.entity.tutanota.AttachmentFromExternal(this, data.attachments[i]));
    }
    this._toRecipient = (data.toRecipient) ? new tutao.entity.tutanota.Recipient(this, data.toRecipient) : null;
  } else {
    this.__format = "0";
    this._bodyText = null;
    this._language = null;
    this._previousMessageId = null;
    this._recipientBucketEncSessionKey = null;
    this._senderBucketEncSessionKey = null;
    this._senderName = null;
    this._senderSymEncBucketKey = null;
    this._subject = null;
    this._attachments = [];
    this._toRecipient = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.SendMailFromExternalData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.SendMailFromExternalData.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.SendMailFromExternalData.PATH = '/rest/tutanota/sendmailfromexternalservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    bodyText: this._bodyText, 
    language: this._language, 
    previousMessageId: this._previousMessageId, 
    recipientBucketEncSessionKey: this._recipientBucketEncSessionKey, 
    senderBucketEncSessionKey: this._senderBucketEncSessionKey, 
    senderName: this._senderName, 
    senderSymEncBucketKey: this._senderSymEncBucketKey, 
    subject: this._subject, 
    attachments: tutao.entity.EntityHelper.aggregatesToJsonData(this._attachments), 
    toRecipient: tutao.entity.EntityHelper.aggregatesToJsonData(this._toRecipient)
  };
};

/**
 * The id of the SendMailFromExternalData type.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.TYPE_ID = 260;

/**
 * The id of the bodyText attribute.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.BODYTEXT_ATTRIBUTE_ID = 264;

/**
 * The id of the language attribute.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.LANGUAGE_ATTRIBUTE_ID = 262;

/**
 * The id of the previousMessageId attribute.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.PREVIOUSMESSAGEID_ATTRIBUTE_ID = 266;

/**
 * The id of the recipientBucketEncSessionKey attribute.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.RECIPIENTBUCKETENCSESSIONKEY_ATTRIBUTE_ID = 269;

/**
 * The id of the senderBucketEncSessionKey attribute.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.SENDERBUCKETENCSESSIONKEY_ATTRIBUTE_ID = 268;

/**
 * The id of the senderName attribute.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.SENDERNAME_ATTRIBUTE_ID = 265;

/**
 * The id of the senderSymEncBucketKey attribute.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.SENDERSYMENCBUCKETKEY_ATTRIBUTE_ID = 267;

/**
 * The id of the subject attribute.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.SUBJECT_ATTRIBUTE_ID = 263;

/**
 * The id of the attachments attribute.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.ATTACHMENTS_ATTRIBUTE_ID = 271;

/**
 * The id of the toRecipient attribute.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.TORECIPIENT_ATTRIBUTE_ID = 270;

/**
 * Sets the format of this SendMailFromExternalData.
 * @param {string} format The format of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this SendMailFromExternalData.
 * @return {string} The format of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the bodyText of this SendMailFromExternalData.
 * @param {string} bodyText The bodyText of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.setBodyText = function(bodyText) {
  var dataToEncrypt = bodyText;
  this._bodyText = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the bodyText of this SendMailFromExternalData.
 * @return {string} The bodyText of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.getBodyText = function() {
  if (this._bodyText == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._bodyText);
  return value;
};

/**
 * Sets the language of this SendMailFromExternalData.
 * @param {string} language The language of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.setLanguage = function(language) {
  this._language = language;
  return this;
};

/**
 * Provides the language of this SendMailFromExternalData.
 * @return {string} The language of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.getLanguage = function() {
  return this._language;
};

/**
 * Sets the previousMessageId of this SendMailFromExternalData.
 * @param {string} previousMessageId The previousMessageId of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.setPreviousMessageId = function(previousMessageId) {
  this._previousMessageId = previousMessageId;
  return this;
};

/**
 * Provides the previousMessageId of this SendMailFromExternalData.
 * @return {string} The previousMessageId of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.getPreviousMessageId = function() {
  return this._previousMessageId;
};

/**
 * Sets the recipientBucketEncSessionKey of this SendMailFromExternalData.
 * @param {string} recipientBucketEncSessionKey The recipientBucketEncSessionKey of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.setRecipientBucketEncSessionKey = function(recipientBucketEncSessionKey) {
  this._recipientBucketEncSessionKey = recipientBucketEncSessionKey;
  return this;
};

/**
 * Provides the recipientBucketEncSessionKey of this SendMailFromExternalData.
 * @return {string} The recipientBucketEncSessionKey of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.getRecipientBucketEncSessionKey = function() {
  return this._recipientBucketEncSessionKey;
};

/**
 * Sets the senderBucketEncSessionKey of this SendMailFromExternalData.
 * @param {string} senderBucketEncSessionKey The senderBucketEncSessionKey of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.setSenderBucketEncSessionKey = function(senderBucketEncSessionKey) {
  this._senderBucketEncSessionKey = senderBucketEncSessionKey;
  return this;
};

/**
 * Provides the senderBucketEncSessionKey of this SendMailFromExternalData.
 * @return {string} The senderBucketEncSessionKey of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.getSenderBucketEncSessionKey = function() {
  return this._senderBucketEncSessionKey;
};

/**
 * Sets the senderName of this SendMailFromExternalData.
 * @param {string} senderName The senderName of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.setSenderName = function(senderName) {
  var dataToEncrypt = senderName;
  this._senderName = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the senderName of this SendMailFromExternalData.
 * @return {string} The senderName of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.getSenderName = function() {
  if (this._senderName == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._senderName);
  return value;
};

/**
 * Sets the senderSymEncBucketKey of this SendMailFromExternalData.
 * @param {string} senderSymEncBucketKey The senderSymEncBucketKey of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.setSenderSymEncBucketKey = function(senderSymEncBucketKey) {
  this._senderSymEncBucketKey = senderSymEncBucketKey;
  return this;
};

/**
 * Provides the senderSymEncBucketKey of this SendMailFromExternalData.
 * @return {string} The senderSymEncBucketKey of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.getSenderSymEncBucketKey = function() {
  return this._senderSymEncBucketKey;
};

/**
 * Sets the subject of this SendMailFromExternalData.
 * @param {string} subject The subject of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.setSubject = function(subject) {
  var dataToEncrypt = subject;
  this._subject = tutao.locator.aesCrypter.encryptUtf8(this._entityHelper.getSessionKey(), dataToEncrypt);
  return this;
};

/**
 * Provides the subject of this SendMailFromExternalData.
 * @return {string} The subject of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.getSubject = function() {
  if (this._subject == "") {
    return "";
  }
  var value = tutao.locator.aesCrypter.decryptUtf8(this._entityHelper.getSessionKey(), this._subject);
  return value;
};

/**
 * Provides the attachments of this SendMailFromExternalData.
 * @return {Array.<tutao.entity.tutanota.AttachmentFromExternal>} The attachments of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.getAttachments = function() {
  return this._attachments;
};

/**
 * Sets the toRecipient of this SendMailFromExternalData.
 * @param {tutao.entity.tutanota.Recipient} toRecipient The toRecipient of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.setToRecipient = function(toRecipient) {
  this._toRecipient = toRecipient;
  return this;
};

/**
 * Provides the toRecipient of this SendMailFromExternalData.
 * @return {tutao.entity.tutanota.Recipient} The toRecipient of this SendMailFromExternalData.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.getToRecipient = function() {
  return this._toRecipient;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.tutanota.SendMailFromExternalReturn=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.SendMailFromExternalData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.tutanota.SendMailFromExternalData.PATH, this, parameters, headers, tutao.entity.tutanota.SendMailFromExternalReturn);
};

"use strict";

tutao.provide('tutao.entity.tutanota.SendMailFromExternalReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.SendMailFromExternalReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._senderMail = data.senderMail;
  } else {
    this.__format = "0";
    this._senderMail = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.SendMailFromExternalReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.SendMailFromExternalReturn.MODEL_VERSION = '5';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.SendMailFromExternalReturn.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.SendMailFromExternalReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    senderMail: this._senderMail
  };
};

/**
 * The id of the SendMailFromExternalReturn type.
 */
tutao.entity.tutanota.SendMailFromExternalReturn.prototype.TYPE_ID = 272;

/**
 * The id of the senderMail attribute.
 */
tutao.entity.tutanota.SendMailFromExternalReturn.prototype.SENDERMAIL_ATTRIBUTE_ID = 274;

/**
 * Sets the format of this SendMailFromExternalReturn.
 * @param {string} format The format of this SendMailFromExternalReturn.
 */
tutao.entity.tutanota.SendMailFromExternalReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this SendMailFromExternalReturn.
 * @return {string} The format of this SendMailFromExternalReturn.
 */
tutao.entity.tutanota.SendMailFromExternalReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the senderMail of this SendMailFromExternalReturn.
 * @param {Array.<string>} senderMail The senderMail of this SendMailFromExternalReturn.
 */
tutao.entity.tutanota.SendMailFromExternalReturn.prototype.setSenderMail = function(senderMail) {
  this._senderMail = senderMail;
  return this;
};

/**
 * Provides the senderMail of this SendMailFromExternalReturn.
 * @return {Array.<string>} The senderMail of this SendMailFromExternalReturn.
 */
tutao.entity.tutanota.SendMailFromExternalReturn.prototype.getSenderMail = function() {
  return this._senderMail;
};

/**
 * Loads the senderMail of this SendMailFromExternalReturn.
 * @return {Promise.<tutao.entity.tutanota.Mail>} Resolves to the loaded senderMail of this SendMailFromExternalReturn or an exception if the loading failed.
 */
tutao.entity.tutanota.SendMailFromExternalReturn.prototype.loadSenderMail = function() {
  return tutao.entity.tutanota.Mail.load(this._senderMail);
};

"use strict";

tutao.provide('tutao.entity.tutanota.SendMailReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.SendMailReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._messageId = data.messageId;
    this._sentDate = data.sentDate;
    this._notifications = [];
    for (var i=0; i < data.notifications.length; i++) {
      this._notifications.push(new tutao.entity.tutanota.NotificationMail(this, data.notifications[i]));
    }
    this._senderMail = data.senderMail;
  } else {
    this.__format = "0";
    this._messageId = null;
    this._sentDate = null;
    this._notifications = [];
    this._senderMail = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.SendMailReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.SendMailReturn.MODEL_VERSION = '5';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.SendMailReturn.prototype.ENCRYPTED = true;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.SendMailReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    messageId: this._messageId, 
    sentDate: this._sentDate, 
    notifications: tutao.entity.EntityHelper.aggregatesToJsonData(this._notifications), 
    senderMail: this._senderMail
  };
};

/**
 * The id of the SendMailReturn type.
 */
tutao.entity.tutanota.SendMailReturn.prototype.TYPE_ID = 246;

/**
 * The id of the messageId attribute.
 */
tutao.entity.tutanota.SendMailReturn.prototype.MESSAGEID_ATTRIBUTE_ID = 248;

/**
 * The id of the sentDate attribute.
 */
tutao.entity.tutanota.SendMailReturn.prototype.SENTDATE_ATTRIBUTE_ID = 249;

/**
 * The id of the notifications attribute.
 */
tutao.entity.tutanota.SendMailReturn.prototype.NOTIFICATIONS_ATTRIBUTE_ID = 250;

/**
 * The id of the senderMail attribute.
 */
tutao.entity.tutanota.SendMailReturn.prototype.SENDERMAIL_ATTRIBUTE_ID = 251;

/**
 * Sets the format of this SendMailReturn.
 * @param {string} format The format of this SendMailReturn.
 */
tutao.entity.tutanota.SendMailReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this SendMailReturn.
 * @return {string} The format of this SendMailReturn.
 */
tutao.entity.tutanota.SendMailReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the messageId of this SendMailReturn.
 * @param {string} messageId The messageId of this SendMailReturn.
 */
tutao.entity.tutanota.SendMailReturn.prototype.setMessageId = function(messageId) {
  this._messageId = messageId;
  return this;
};

/**
 * Provides the messageId of this SendMailReturn.
 * @return {string} The messageId of this SendMailReturn.
 */
tutao.entity.tutanota.SendMailReturn.prototype.getMessageId = function() {
  return this._messageId;
};

/**
 * Sets the sentDate of this SendMailReturn.
 * @param {Date} sentDate The sentDate of this SendMailReturn.
 */
tutao.entity.tutanota.SendMailReturn.prototype.setSentDate = function(sentDate) {
  this._sentDate = String(sentDate.getTime());
  return this;
};

/**
 * Provides the sentDate of this SendMailReturn.
 * @return {Date} The sentDate of this SendMailReturn.
 */
tutao.entity.tutanota.SendMailReturn.prototype.getSentDate = function() {
  if (isNaN(this._sentDate)) {
    throw new tutao.InvalidDataError('invalid time data: ' + this._sentDate);
  }
  return new Date(Number(this._sentDate));
};

/**
 * Provides the notifications of this SendMailReturn.
 * @return {Array.<tutao.entity.tutanota.NotificationMail>} The notifications of this SendMailReturn.
 */
tutao.entity.tutanota.SendMailReturn.prototype.getNotifications = function() {
  return this._notifications;
};

/**
 * Sets the senderMail of this SendMailReturn.
 * @param {Array.<string>} senderMail The senderMail of this SendMailReturn.
 */
tutao.entity.tutanota.SendMailReturn.prototype.setSenderMail = function(senderMail) {
  this._senderMail = senderMail;
  return this;
};

/**
 * Provides the senderMail of this SendMailReturn.
 * @return {Array.<string>} The senderMail of this SendMailReturn.
 */
tutao.entity.tutanota.SendMailReturn.prototype.getSenderMail = function() {
  return this._senderMail;
};

/**
 * Loads the senderMail of this SendMailReturn.
 * @return {Promise.<tutao.entity.tutanota.Mail>} Resolves to the loaded senderMail of this SendMailReturn or an exception if the loading failed.
 */
tutao.entity.tutanota.SendMailReturn.prototype.loadSenderMail = function() {
  return tutao.entity.tutanota.Mail.load(this._senderMail);
};

"use strict";

tutao.provide('tutao.entity.tutanota.SendUnsecureMailData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.SendUnsecureMailData = function(data) {
  if (data) {
    this.__format = data._format;
    this._bodyText = data.bodyText;
    this._conversationType = data.conversationType;
    this._language = data.language;
    this._listEncSessionKey = data.listEncSessionKey;
    this._mailSessionKey = data.mailSessionKey;
    this._previousMessageId = data.previousMessageId;
    this._senderName = data.senderName;
    this._sharableEncSessionKey = data.sharableEncSessionKey;
    this._subject = data.subject;
    this._symEncSessionKey = data.symEncSessionKey;
    this._attachments = [];
    for (var i=0; i < data.attachments.length; i++) {
      this._attachments.push(new tutao.entity.tutanota.UnsecureAttachment(this, data.attachments[i]));
    }
    this._bccRecipients = [];
    for (var i=0; i < data.bccRecipients.length; i++) {
      this._bccRecipients.push(new tutao.entity.tutanota.UnsecureRecipient(this, data.bccRecipients[i]));
    }
    this._ccRecipients = [];
    for (var i=0; i < data.ccRecipients.length; i++) {
      this._ccRecipients.push(new tutao.entity.tutanota.UnsecureRecipient(this, data.ccRecipients[i]));
    }
    this._toRecipients = [];
    for (var i=0; i < data.toRecipients.length; i++) {
      this._toRecipients.push(new tutao.entity.tutanota.UnsecureRecipient(this, data.toRecipients[i]));
    }
  } else {
    this.__format = "0";
    this._bodyText = null;
    this._conversationType = null;
    this._language = null;
    this._listEncSessionKey = null;
    this._mailSessionKey = null;
    this._previousMessageId = null;
    this._senderName = null;
    this._sharableEncSessionKey = null;
    this._subject = null;
    this._symEncSessionKey = null;
    this._attachments = [];
    this._bccRecipients = [];
    this._ccRecipients = [];
    this._toRecipients = [];
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.SendUnsecureMailData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.SendUnsecureMailData.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.SendUnsecureMailData.PATH = '/rest/tutanota/sendunsecuremailservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    bodyText: this._bodyText, 
    conversationType: this._conversationType, 
    language: this._language, 
    listEncSessionKey: this._listEncSessionKey, 
    mailSessionKey: this._mailSessionKey, 
    previousMessageId: this._previousMessageId, 
    senderName: this._senderName, 
    sharableEncSessionKey: this._sharableEncSessionKey, 
    subject: this._subject, 
    symEncSessionKey: this._symEncSessionKey, 
    attachments: tutao.entity.EntityHelper.aggregatesToJsonData(this._attachments), 
    bccRecipients: tutao.entity.EntityHelper.aggregatesToJsonData(this._bccRecipients), 
    ccRecipients: tutao.entity.EntityHelper.aggregatesToJsonData(this._ccRecipients), 
    toRecipients: tutao.entity.EntityHelper.aggregatesToJsonData(this._toRecipients)
  };
};

/**
 * The id of the SendUnsecureMailData type.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.TYPE_ID = 288;

/**
 * The id of the bodyText attribute.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.BODYTEXT_ATTRIBUTE_ID = 292;

/**
 * The id of the conversationType attribute.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.CONVERSATIONTYPE_ATTRIBUTE_ID = 295;

/**
 * The id of the language attribute.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.LANGUAGE_ATTRIBUTE_ID = 290;

/**
 * The id of the listEncSessionKey attribute.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.LISTENCSESSIONKEY_ATTRIBUTE_ID = 297;

/**
 * The id of the mailSessionKey attribute.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.MAILSESSIONKEY_ATTRIBUTE_ID = 296;

/**
 * The id of the previousMessageId attribute.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.PREVIOUSMESSAGEID_ATTRIBUTE_ID = 294;

/**
 * The id of the senderName attribute.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.SENDERNAME_ATTRIBUTE_ID = 293;

/**
 * The id of the sharableEncSessionKey attribute.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.SHARABLEENCSESSIONKEY_ATTRIBUTE_ID = 299;

/**
 * The id of the subject attribute.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.SUBJECT_ATTRIBUTE_ID = 291;

/**
 * The id of the symEncSessionKey attribute.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.SYMENCSESSIONKEY_ATTRIBUTE_ID = 298;

/**
 * The id of the attachments attribute.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.ATTACHMENTS_ATTRIBUTE_ID = 303;

/**
 * The id of the bccRecipients attribute.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.BCCRECIPIENTS_ATTRIBUTE_ID = 302;

/**
 * The id of the ccRecipients attribute.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.CCRECIPIENTS_ATTRIBUTE_ID = 301;

/**
 * The id of the toRecipients attribute.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.TORECIPIENTS_ATTRIBUTE_ID = 300;

/**
 * Sets the format of this SendUnsecureMailData.
 * @param {string} format The format of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this SendUnsecureMailData.
 * @return {string} The format of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the bodyText of this SendUnsecureMailData.
 * @param {string} bodyText The bodyText of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.setBodyText = function(bodyText) {
  this._bodyText = bodyText;
  return this;
};

/**
 * Provides the bodyText of this SendUnsecureMailData.
 * @return {string} The bodyText of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.getBodyText = function() {
  return this._bodyText;
};

/**
 * Sets the conversationType of this SendUnsecureMailData.
 * @param {string} conversationType The conversationType of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.setConversationType = function(conversationType) {
  this._conversationType = conversationType;
  return this;
};

/**
 * Provides the conversationType of this SendUnsecureMailData.
 * @return {string} The conversationType of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.getConversationType = function() {
  return this._conversationType;
};

/**
 * Sets the language of this SendUnsecureMailData.
 * @param {string} language The language of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.setLanguage = function(language) {
  this._language = language;
  return this;
};

/**
 * Provides the language of this SendUnsecureMailData.
 * @return {string} The language of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.getLanguage = function() {
  return this._language;
};

/**
 * Sets the listEncSessionKey of this SendUnsecureMailData.
 * @param {string} listEncSessionKey The listEncSessionKey of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.setListEncSessionKey = function(listEncSessionKey) {
  this._listEncSessionKey = listEncSessionKey;
  return this;
};

/**
 * Provides the listEncSessionKey of this SendUnsecureMailData.
 * @return {string} The listEncSessionKey of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.getListEncSessionKey = function() {
  return this._listEncSessionKey;
};

/**
 * Sets the mailSessionKey of this SendUnsecureMailData.
 * @param {string} mailSessionKey The mailSessionKey of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.setMailSessionKey = function(mailSessionKey) {
  this._mailSessionKey = mailSessionKey;
  return this;
};

/**
 * Provides the mailSessionKey of this SendUnsecureMailData.
 * @return {string} The mailSessionKey of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.getMailSessionKey = function() {
  return this._mailSessionKey;
};

/**
 * Sets the previousMessageId of this SendUnsecureMailData.
 * @param {string} previousMessageId The previousMessageId of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.setPreviousMessageId = function(previousMessageId) {
  this._previousMessageId = previousMessageId;
  return this;
};

/**
 * Provides the previousMessageId of this SendUnsecureMailData.
 * @return {string} The previousMessageId of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.getPreviousMessageId = function() {
  return this._previousMessageId;
};

/**
 * Sets the senderName of this SendUnsecureMailData.
 * @param {string} senderName The senderName of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.setSenderName = function(senderName) {
  this._senderName = senderName;
  return this;
};

/**
 * Provides the senderName of this SendUnsecureMailData.
 * @return {string} The senderName of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.getSenderName = function() {
  return this._senderName;
};

/**
 * Sets the sharableEncSessionKey of this SendUnsecureMailData.
 * @param {string} sharableEncSessionKey The sharableEncSessionKey of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.setSharableEncSessionKey = function(sharableEncSessionKey) {
  this._sharableEncSessionKey = sharableEncSessionKey;
  return this;
};

/**
 * Provides the sharableEncSessionKey of this SendUnsecureMailData.
 * @return {string} The sharableEncSessionKey of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.getSharableEncSessionKey = function() {
  return this._sharableEncSessionKey;
};

/**
 * Sets the subject of this SendUnsecureMailData.
 * @param {string} subject The subject of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.setSubject = function(subject) {
  this._subject = subject;
  return this;
};

/**
 * Provides the subject of this SendUnsecureMailData.
 * @return {string} The subject of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.getSubject = function() {
  return this._subject;
};

/**
 * Sets the symEncSessionKey of this SendUnsecureMailData.
 * @param {string} symEncSessionKey The symEncSessionKey of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.setSymEncSessionKey = function(symEncSessionKey) {
  this._symEncSessionKey = symEncSessionKey;
  return this;
};

/**
 * Provides the symEncSessionKey of this SendUnsecureMailData.
 * @return {string} The symEncSessionKey of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.getSymEncSessionKey = function() {
  return this._symEncSessionKey;
};

/**
 * Provides the attachments of this SendUnsecureMailData.
 * @return {Array.<tutao.entity.tutanota.UnsecureAttachment>} The attachments of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.getAttachments = function() {
  return this._attachments;
};

/**
 * Provides the bccRecipients of this SendUnsecureMailData.
 * @return {Array.<tutao.entity.tutanota.UnsecureRecipient>} The bccRecipients of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.getBccRecipients = function() {
  return this._bccRecipients;
};

/**
 * Provides the ccRecipients of this SendUnsecureMailData.
 * @return {Array.<tutao.entity.tutanota.UnsecureRecipient>} The ccRecipients of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.getCcRecipients = function() {
  return this._ccRecipients;
};

/**
 * Provides the toRecipients of this SendUnsecureMailData.
 * @return {Array.<tutao.entity.tutanota.UnsecureRecipient>} The toRecipients of this SendUnsecureMailData.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.getToRecipients = function() {
  return this._toRecipients;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<tutao.entity.tutanota.SendUnsecureMailReturn=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.SendUnsecureMailData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.tutanota.SendUnsecureMailData.PATH, this, parameters, headers, tutao.entity.tutanota.SendUnsecureMailReturn);
};

"use strict";

tutao.provide('tutao.entity.tutanota.SendUnsecureMailReturn');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.SendUnsecureMailReturn = function(data) {
  if (data) {
    this.__format = data._format;
    this._senderMail = data.senderMail;
  } else {
    this.__format = "0";
    this._senderMail = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.SendUnsecureMailReturn.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.SendUnsecureMailReturn.MODEL_VERSION = '5';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.SendUnsecureMailReturn.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.SendUnsecureMailReturn.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    senderMail: this._senderMail
  };
};

/**
 * The id of the SendUnsecureMailReturn type.
 */
tutao.entity.tutanota.SendUnsecureMailReturn.prototype.TYPE_ID = 304;

/**
 * The id of the senderMail attribute.
 */
tutao.entity.tutanota.SendUnsecureMailReturn.prototype.SENDERMAIL_ATTRIBUTE_ID = 306;

/**
 * Sets the format of this SendUnsecureMailReturn.
 * @param {string} format The format of this SendUnsecureMailReturn.
 */
tutao.entity.tutanota.SendUnsecureMailReturn.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this SendUnsecureMailReturn.
 * @return {string} The format of this SendUnsecureMailReturn.
 */
tutao.entity.tutanota.SendUnsecureMailReturn.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the senderMail of this SendUnsecureMailReturn.
 * @param {Array.<string>} senderMail The senderMail of this SendUnsecureMailReturn.
 */
tutao.entity.tutanota.SendUnsecureMailReturn.prototype.setSenderMail = function(senderMail) {
  this._senderMail = senderMail;
  return this;
};

/**
 * Provides the senderMail of this SendUnsecureMailReturn.
 * @return {Array.<string>} The senderMail of this SendUnsecureMailReturn.
 */
tutao.entity.tutanota.SendUnsecureMailReturn.prototype.getSenderMail = function() {
  return this._senderMail;
};

/**
 * Loads the senderMail of this SendUnsecureMailReturn.
 * @return {Promise.<tutao.entity.tutanota.Mail>} Resolves to the loaded senderMail of this SendUnsecureMailReturn or an exception if the loading failed.
 */
tutao.entity.tutanota.SendUnsecureMailReturn.prototype.loadSenderMail = function() {
  return tutao.entity.tutanota.Mail.load(this._senderMail);
};

"use strict";

tutao.provide('tutao.entity.tutanota.Subfiles');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.Subfiles = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._files = data.files;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._files = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.Subfiles.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.Subfiles.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    files: this._files
  };
};

/**
 * The id of the Subfiles type.
 */
tutao.entity.tutanota.Subfiles.prototype.TYPE_ID = 11;

/**
 * The id of the files attribute.
 */
tutao.entity.tutanota.Subfiles.prototype.FILES_ATTRIBUTE_ID = 27;

/**
 * Sets the id of this Subfiles.
 * @param {string} id The id of this Subfiles.
 */
tutao.entity.tutanota.Subfiles.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this Subfiles.
 * @return {string} The id of this Subfiles.
 */
tutao.entity.tutanota.Subfiles.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the files of this Subfiles.
 * @param {string} files The files of this Subfiles.
 */
tutao.entity.tutanota.Subfiles.prototype.setFiles = function(files) {
  this._files = files;
  return this;
};

/**
 * Provides the files of this Subfiles.
 * @return {string} The files of this Subfiles.
 */
tutao.entity.tutanota.Subfiles.prototype.getFiles = function() {
  return this._files;
};

"use strict";

tutao.provide('tutao.entity.tutanota.TutanotaProperties');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.TutanotaProperties = function(data) {
  if (data) {
    this.__format = data._format;
    this.__id = data._id;
    this.__permissions = data._permissions;
    this._groupEncEntropy = data.groupEncEntropy;
    this._notificationMailLanguage = data.notificationMailLanguage;
    this._imapSyncConfig = [];
    for (var i=0; i < data.imapSyncConfig.length; i++) {
      this._imapSyncConfig.push(new tutao.entity.tutanota.ImapSyncConfiguration(this, data.imapSyncConfig[i]));
    }
    this._lastPushedMail = data.lastPushedMail;
  } else {
    this.__format = "0";
    this.__id = null;
    this.__permissions = null;
    this._groupEncEntropy = null;
    this._notificationMailLanguage = null;
    this._imapSyncConfig = [];
    this._lastPushedMail = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.TutanotaProperties.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.TutanotaProperties.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.TutanotaProperties.PATH = '/rest/tutanota/tutanotaproperties';

/**
 * The id of the root instance reference.
 * @const
 */
tutao.entity.tutanota.TutanotaProperties.ROOT_INSTANCE_ID = 'CHR1dGFub3RhAADY';

/**
 * The generated id type flag.
 * @const
 */
tutao.entity.tutanota.TutanotaProperties.GENERATED_ID = true;

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.TutanotaProperties.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    _id: this.__id, 
    _permissions: this.__permissions, 
    groupEncEntropy: this._groupEncEntropy, 
    notificationMailLanguage: this._notificationMailLanguage, 
    imapSyncConfig: tutao.entity.EntityHelper.aggregatesToJsonData(this._imapSyncConfig), 
    lastPushedMail: this._lastPushedMail
  };
};

/**
 * The id of the TutanotaProperties type.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.TYPE_ID = 216;

/**
 * The id of the groupEncEntropy attribute.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.GROUPENCENTROPY_ATTRIBUTE_ID = 410;

/**
 * The id of the notificationMailLanguage attribute.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.NOTIFICATIONMAILLANGUAGE_ATTRIBUTE_ID = 418;

/**
 * The id of the imapSyncConfig attribute.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.IMAPSYNCCONFIG_ATTRIBUTE_ID = 222;

/**
 * The id of the lastPushedMail attribute.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.LASTPUSHEDMAIL_ATTRIBUTE_ID = 221;

/**
 * Provides the id of this TutanotaProperties.
 * @return {string} The id of this TutanotaProperties.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the format of this TutanotaProperties.
 * @param {string} format The format of this TutanotaProperties.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this TutanotaProperties.
 * @return {string} The format of this TutanotaProperties.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the permissions of this TutanotaProperties.
 * @param {string} permissions The permissions of this TutanotaProperties.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.setPermissions = function(permissions) {
  this.__permissions = permissions;
  return this;
};

/**
 * Provides the permissions of this TutanotaProperties.
 * @return {string} The permissions of this TutanotaProperties.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.getPermissions = function() {
  return this.__permissions;
};

/**
 * Sets the groupEncEntropy of this TutanotaProperties.
 * @param {string} groupEncEntropy The groupEncEntropy of this TutanotaProperties.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.setGroupEncEntropy = function(groupEncEntropy) {
  this._groupEncEntropy = groupEncEntropy;
  return this;
};

/**
 * Provides the groupEncEntropy of this TutanotaProperties.
 * @return {string} The groupEncEntropy of this TutanotaProperties.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.getGroupEncEntropy = function() {
  return this._groupEncEntropy;
};

/**
 * Sets the notificationMailLanguage of this TutanotaProperties.
 * @param {string} notificationMailLanguage The notificationMailLanguage of this TutanotaProperties.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.setNotificationMailLanguage = function(notificationMailLanguage) {
  this._notificationMailLanguage = notificationMailLanguage;
  return this;
};

/**
 * Provides the notificationMailLanguage of this TutanotaProperties.
 * @return {string} The notificationMailLanguage of this TutanotaProperties.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.getNotificationMailLanguage = function() {
  return this._notificationMailLanguage;
};

/**
 * Provides the imapSyncConfig of this TutanotaProperties.
 * @return {Array.<tutao.entity.tutanota.ImapSyncConfiguration>} The imapSyncConfig of this TutanotaProperties.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.getImapSyncConfig = function() {
  return this._imapSyncConfig;
};

/**
 * Sets the lastPushedMail of this TutanotaProperties.
 * @param {Array.<string>} lastPushedMail The lastPushedMail of this TutanotaProperties.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.setLastPushedMail = function(lastPushedMail) {
  this._lastPushedMail = lastPushedMail;
  return this;
};

/**
 * Provides the lastPushedMail of this TutanotaProperties.
 * @return {Array.<string>} The lastPushedMail of this TutanotaProperties.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.getLastPushedMail = function() {
  return this._lastPushedMail;
};

/**
 * Loads the lastPushedMail of this TutanotaProperties.
 * @return {Promise.<tutao.entity.tutanota.Mail>} Resolves to the loaded lastPushedMail of this TutanotaProperties or an exception if the loading failed.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.loadLastPushedMail = function() {
  return tutao.entity.tutanota.Mail.load(this._lastPushedMail);
};

/**
 * Loads a TutanotaProperties from the server.
 * @param {string} id The id of the TutanotaProperties.
 * @return {Promise.<tutao.entity.tutanota.TutanotaProperties>} Resolves to the TutanotaProperties or an exception if the loading failed.
 */
tutao.entity.tutanota.TutanotaProperties.load = function(id) {
  return tutao.locator.entityRestClient.getElement(tutao.entity.tutanota.TutanotaProperties, tutao.entity.tutanota.TutanotaProperties.PATH, id, null, {"v" : 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entity) {
    return entity;
  });
};

/**
 * Loads multiple TutanotaPropertiess from the server.
 * @param {Array.<string>} ids The ids of the TutanotaPropertiess to load.
 * @return {Promise.<Array.<tutao.entity.tutanota.TutanotaProperties>>} Resolves to an array of TutanotaProperties or rejects with an exception if the loading failed.
 */
tutao.entity.tutanota.TutanotaProperties.loadMultiple = function(ids) {
  return tutao.locator.entityRestClient.getElements(tutao.entity.tutanota.TutanotaProperties, tutao.entity.tutanota.TutanotaProperties.PATH, ids, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function(entities) {
    return entities;
  });
};

/**
 * Updates this TutanotaProperties on the server.
 * @return {Promise.<>} Resolves when finished, rejected if the update failed.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.update = function() {
  var self = this;
  return tutao.locator.entityRestClient.putElement(tutao.entity.tutanota.TutanotaProperties.PATH, this, {"v": 5}, tutao.entity.EntityHelper.createAuthHeaders()).then(function() {
    self._entityHelper.notifyObservers(false);
  });
};

/**
 * Register a function that is called as soon as any attribute of the entity has changed. If this listener
 * was already registered it is not registered again.
 * @param {function(Object,*=)} listener. The listener function. When called it gets the entity and the given id as arguments.
 * @param {*=} id. An optional value that is just passed-through to the listener.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.registerObserver = function(listener, id) {
  this._entityHelper.registerObserver(listener, id);
};

/**
 * Removes a registered listener function if it was registered before.
 * @param {function(Object)} listener. The listener to unregister.
 */
tutao.entity.tutanota.TutanotaProperties.prototype.unregisterObserver = function(listener) {
  this._entityHelper.unregisterObserver(listener);
};

"use strict";

tutao.provide('tutao.entity.tutanota.UnsecureAttachment');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.UnsecureAttachment = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._fileName = data.fileName;
    this._fileSessionKey = data.fileSessionKey;
    this._listEncFileSessionKey = data.listEncFileSessionKey;
    this._mimeType = data.mimeType;
    this._file = data.file;
    this._fileData = data.fileData;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._fileName = null;
    this._fileSessionKey = null;
    this._listEncFileSessionKey = null;
    this._mimeType = null;
    this._file = null;
    this._fileData = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.UnsecureAttachment.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    fileName: this._fileName, 
    fileSessionKey: this._fileSessionKey, 
    listEncFileSessionKey: this._listEncFileSessionKey, 
    mimeType: this._mimeType, 
    file: this._file, 
    fileData: this._fileData
  };
};

/**
 * The id of the UnsecureAttachment type.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.TYPE_ID = 280;

/**
 * The id of the fileName attribute.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.FILENAME_ATTRIBUTE_ID = 285;

/**
 * The id of the fileSessionKey attribute.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.FILESESSIONKEY_ATTRIBUTE_ID = 282;

/**
 * The id of the listEncFileSessionKey attribute.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.LISTENCFILESESSIONKEY_ATTRIBUTE_ID = 283;

/**
 * The id of the mimeType attribute.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.MIMETYPE_ATTRIBUTE_ID = 286;

/**
 * The id of the file attribute.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.FILE_ATTRIBUTE_ID = 284;

/**
 * The id of the fileData attribute.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.FILEDATA_ATTRIBUTE_ID = 287;

/**
 * Sets the id of this UnsecureAttachment.
 * @param {string} id The id of this UnsecureAttachment.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this UnsecureAttachment.
 * @return {string} The id of this UnsecureAttachment.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the fileName of this UnsecureAttachment.
 * @param {string} fileName The fileName of this UnsecureAttachment.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.setFileName = function(fileName) {
  this._fileName = fileName;
  return this;
};

/**
 * Provides the fileName of this UnsecureAttachment.
 * @return {string} The fileName of this UnsecureAttachment.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.getFileName = function() {
  return this._fileName;
};

/**
 * Sets the fileSessionKey of this UnsecureAttachment.
 * @param {string} fileSessionKey The fileSessionKey of this UnsecureAttachment.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.setFileSessionKey = function(fileSessionKey) {
  this._fileSessionKey = fileSessionKey;
  return this;
};

/**
 * Provides the fileSessionKey of this UnsecureAttachment.
 * @return {string} The fileSessionKey of this UnsecureAttachment.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.getFileSessionKey = function() {
  return this._fileSessionKey;
};

/**
 * Sets the listEncFileSessionKey of this UnsecureAttachment.
 * @param {string} listEncFileSessionKey The listEncFileSessionKey of this UnsecureAttachment.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.setListEncFileSessionKey = function(listEncFileSessionKey) {
  this._listEncFileSessionKey = listEncFileSessionKey;
  return this;
};

/**
 * Provides the listEncFileSessionKey of this UnsecureAttachment.
 * @return {string} The listEncFileSessionKey of this UnsecureAttachment.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.getListEncFileSessionKey = function() {
  return this._listEncFileSessionKey;
};

/**
 * Sets the mimeType of this UnsecureAttachment.
 * @param {string} mimeType The mimeType of this UnsecureAttachment.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.setMimeType = function(mimeType) {
  this._mimeType = mimeType;
  return this;
};

/**
 * Provides the mimeType of this UnsecureAttachment.
 * @return {string} The mimeType of this UnsecureAttachment.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.getMimeType = function() {
  return this._mimeType;
};

/**
 * Sets the file of this UnsecureAttachment.
 * @param {Array.<string>} file The file of this UnsecureAttachment.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.setFile = function(file) {
  this._file = file;
  return this;
};

/**
 * Provides the file of this UnsecureAttachment.
 * @return {Array.<string>} The file of this UnsecureAttachment.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.getFile = function() {
  return this._file;
};

/**
 * Loads the file of this UnsecureAttachment.
 * @return {Promise.<tutao.entity.tutanota.File>} Resolves to the loaded file of this UnsecureAttachment or an exception if the loading failed.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.loadFile = function() {
  return tutao.entity.tutanota.File.load(this._file);
};

/**
 * Sets the fileData of this UnsecureAttachment.
 * @param {string} fileData The fileData of this UnsecureAttachment.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.setFileData = function(fileData) {
  this._fileData = fileData;
  return this;
};

/**
 * Provides the fileData of this UnsecureAttachment.
 * @return {string} The fileData of this UnsecureAttachment.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.getFileData = function() {
  return this._fileData;
};

/**
 * Loads the fileData of this UnsecureAttachment.
 * @return {Promise.<tutao.entity.tutanota.FileData>} Resolves to the loaded fileData of this UnsecureAttachment or an exception if the loading failed.
 */
tutao.entity.tutanota.UnsecureAttachment.prototype.loadFileData = function() {
  return tutao.entity.tutanota.FileData.load(this._fileData);
};

"use strict";

tutao.provide('tutao.entity.tutanota.UnsecureRecipient');

/**
 * @constructor
 * @param {Object} parent The parent entity of this aggregate.
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.UnsecureRecipient = function(parent, data) {
  if (data) {
    this.__id = data._id;
    this._mailAddress = data.mailAddress;
    this._name = data.name;
  } else {
    this.__id = tutao.entity.EntityHelper.generateAggregateId();
    this._mailAddress = null;
    this._name = null;
  }
  this._parent = parent;
  this.prototype = tutao.entity.tutanota.UnsecureRecipient.prototype;
};

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.UnsecureRecipient.prototype.toJsonData = function() {
  return {
    _id: this.__id, 
    mailAddress: this._mailAddress, 
    name: this._name
  };
};

/**
 * The id of the UnsecureRecipient type.
 */
tutao.entity.tutanota.UnsecureRecipient.prototype.TYPE_ID = 276;

/**
 * The id of the mailAddress attribute.
 */
tutao.entity.tutanota.UnsecureRecipient.prototype.MAILADDRESS_ATTRIBUTE_ID = 279;

/**
 * The id of the name attribute.
 */
tutao.entity.tutanota.UnsecureRecipient.prototype.NAME_ATTRIBUTE_ID = 278;

/**
 * Sets the id of this UnsecureRecipient.
 * @param {string} id The id of this UnsecureRecipient.
 */
tutao.entity.tutanota.UnsecureRecipient.prototype.setId = function(id) {
  this.__id = id;
  return this;
};

/**
 * Provides the id of this UnsecureRecipient.
 * @return {string} The id of this UnsecureRecipient.
 */
tutao.entity.tutanota.UnsecureRecipient.prototype.getId = function() {
  return this.__id;
};

/**
 * Sets the mailAddress of this UnsecureRecipient.
 * @param {string} mailAddress The mailAddress of this UnsecureRecipient.
 */
tutao.entity.tutanota.UnsecureRecipient.prototype.setMailAddress = function(mailAddress) {
  this._mailAddress = mailAddress;
  return this;
};

/**
 * Provides the mailAddress of this UnsecureRecipient.
 * @return {string} The mailAddress of this UnsecureRecipient.
 */
tutao.entity.tutanota.UnsecureRecipient.prototype.getMailAddress = function() {
  return this._mailAddress;
};

/**
 * Sets the name of this UnsecureRecipient.
 * @param {string} name The name of this UnsecureRecipient.
 */
tutao.entity.tutanota.UnsecureRecipient.prototype.setName = function(name) {
  this._name = name;
  return this;
};

/**
 * Provides the name of this UnsecureRecipient.
 * @return {string} The name of this UnsecureRecipient.
 */
tutao.entity.tutanota.UnsecureRecipient.prototype.getName = function() {
  return this._name;
};

"use strict";

tutao.provide('tutao.entity.tutanota.UpdateFileData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.UpdateFileData = function(data) {
  if (data) {
    this.__format = data._format;
    this._file = data.file;
    this._fileData = data.fileData;
  } else {
    this.__format = "0";
    this._file = null;
    this._fileData = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.UpdateFileData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.UpdateFileData.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.UpdateFileData.PATH = '/rest/tutanota/updatefileservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.UpdateFileData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.UpdateFileData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    file: this._file, 
    fileData: this._fileData
  };
};

/**
 * The id of the UpdateFileData type.
 */
tutao.entity.tutanota.UpdateFileData.prototype.TYPE_ID = 369;

/**
 * The id of the file attribute.
 */
tutao.entity.tutanota.UpdateFileData.prototype.FILE_ATTRIBUTE_ID = 371;

/**
 * The id of the fileData attribute.
 */
tutao.entity.tutanota.UpdateFileData.prototype.FILEDATA_ATTRIBUTE_ID = 372;

/**
 * Sets the format of this UpdateFileData.
 * @param {string} format The format of this UpdateFileData.
 */
tutao.entity.tutanota.UpdateFileData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this UpdateFileData.
 * @return {string} The format of this UpdateFileData.
 */
tutao.entity.tutanota.UpdateFileData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the file of this UpdateFileData.
 * @param {Array.<string>} file The file of this UpdateFileData.
 */
tutao.entity.tutanota.UpdateFileData.prototype.setFile = function(file) {
  this._file = file;
  return this;
};

/**
 * Provides the file of this UpdateFileData.
 * @return {Array.<string>} The file of this UpdateFileData.
 */
tutao.entity.tutanota.UpdateFileData.prototype.getFile = function() {
  return this._file;
};

/**
 * Loads the file of this UpdateFileData.
 * @return {Promise.<tutao.entity.tutanota.File>} Resolves to the loaded file of this UpdateFileData or an exception if the loading failed.
 */
tutao.entity.tutanota.UpdateFileData.prototype.loadFile = function() {
  return tutao.entity.tutanota.File.load(this._file);
};

/**
 * Sets the fileData of this UpdateFileData.
 * @param {string} fileData The fileData of this UpdateFileData.
 */
tutao.entity.tutanota.UpdateFileData.prototype.setFileData = function(fileData) {
  this._fileData = fileData;
  return this;
};

/**
 * Provides the fileData of this UpdateFileData.
 * @return {string} The fileData of this UpdateFileData.
 */
tutao.entity.tutanota.UpdateFileData.prototype.getFileData = function() {
  return this._fileData;
};

/**
 * Loads the fileData of this UpdateFileData.
 * @return {Promise.<tutao.entity.tutanota.FileData>} Resolves to the loaded fileData of this UpdateFileData or an exception if the loading failed.
 */
tutao.entity.tutanota.UpdateFileData.prototype.loadFileData = function() {
  return tutao.entity.tutanota.FileData.load(this._fileData);
};

/**
 * Updates this service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.UpdateFileData.prototype.update = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  return tutao.locator.entityRestClient.putService(tutao.entity.tutanota.UpdateFileData.PATH, this, parameters, headers, null);
};

"use strict";

tutao.provide('tutao.entity.tutanota.WelcomeMailData');

/**
 * @constructor
 * @param {Object=} data The json data to store in this entity.
 */
tutao.entity.tutanota.WelcomeMailData = function(data) {
  if (data) {
    this.__format = data._format;
    this._language = data.language;
  } else {
    this.__format = "0";
    this._language = null;
  }
  this._entityHelper = new tutao.entity.EntityHelper(this);
  this.prototype = tutao.entity.tutanota.WelcomeMailData.prototype;
};

/**
 * The version of the model this type belongs to.
 * @const
 */
tutao.entity.tutanota.WelcomeMailData.MODEL_VERSION = '5';

/**
 * The url path to the resource.
 * @const
 */
tutao.entity.tutanota.WelcomeMailData.PATH = '/rest/tutanota/welcomemailservice';

/**
 * The encrypted flag.
 * @const
 */
tutao.entity.tutanota.WelcomeMailData.prototype.ENCRYPTED = false;

/**
 * Provides the data of this instances as an object that can be converted to json.
 * @return {Object} The json object.
 */
tutao.entity.tutanota.WelcomeMailData.prototype.toJsonData = function() {
  return {
    _format: this.__format, 
    language: this._language
  };
};

/**
 * The id of the WelcomeMailData type.
 */
tutao.entity.tutanota.WelcomeMailData.prototype.TYPE_ID = 401;

/**
 * The id of the language attribute.
 */
tutao.entity.tutanota.WelcomeMailData.prototype.LANGUAGE_ATTRIBUTE_ID = 403;

/**
 * Sets the format of this WelcomeMailData.
 * @param {string} format The format of this WelcomeMailData.
 */
tutao.entity.tutanota.WelcomeMailData.prototype.setFormat = function(format) {
  this.__format = format;
  return this;
};

/**
 * Provides the format of this WelcomeMailData.
 * @return {string} The format of this WelcomeMailData.
 */
tutao.entity.tutanota.WelcomeMailData.prototype.getFormat = function() {
  return this.__format;
};

/**
 * Sets the language of this WelcomeMailData.
 * @param {string} language The language of this WelcomeMailData.
 */
tutao.entity.tutanota.WelcomeMailData.prototype.setLanguage = function(language) {
  this._language = language;
  return this;
};

/**
 * Provides the language of this WelcomeMailData.
 * @return {string} The language of this WelcomeMailData.
 */
tutao.entity.tutanota.WelcomeMailData.prototype.getLanguage = function() {
  return this._language;
};

/**
 * Posts to a service.
 * @param {Object.<string, string>} parameters The parameters to send to the service.
 * @param {?Object.<string, string>} headers The headers to send to the service. If null, the default authentication data is used.
 * @return {Promise.<null=>} Resolves to the string result of the server or rejects with an exception if the post failed.
 */
tutao.entity.tutanota.WelcomeMailData.prototype.setup = function(parameters, headers) {
  if (!headers) {
    headers = tutao.entity.EntityHelper.createAuthHeaders();
  }
  parameters["v"] = 5;
  this._entityHelper.notifyObservers(false);
  return tutao.locator.entityRestClient.postService(tutao.entity.tutanota.WelcomeMailData.PATH, this, parameters, headers, null);
};
